const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./index-CrROdkG4.js","./index-BRhY6FpL.css","./userSelection-DSpF-zVD.js","./userSelection-CF-ymHZW.css"])))=>i.map(i=>d[i]);
var __defProp2 = Object.defineProperty;
var __name = (target, value3) => __defProp2(target, "name", { value: value3, configurable: true });
(/* @__PURE__ */ __name(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node3 of mutation.addedNodes) {
        if (node3.tagName === "LINK" && node3.rel === "modulepreload")
          processPreload(node3);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  __name(getFetchOpts, "getFetchOpts");
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
  __name(processPreload, "processPreload");
}, "polyfill"))();
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
__name(getDefaultExportFromCjs, "getDefaultExportFromCjs");
function getDefaultExportFromNamespaceIfPresent(n) {
  return n && Object.prototype.hasOwnProperty.call(n, "default") ? n["default"] : n;
}
__name(getDefaultExportFromNamespaceIfPresent, "getDefaultExportFromNamespaceIfPresent");
function getDefaultExportFromNamespaceIfNotNamed(n) {
  return n && Object.prototype.hasOwnProperty.call(n, "default") && Object.keys(n).length === 1 ? n["default"] : n;
}
__name(getDefaultExportFromNamespaceIfNotNamed, "getDefaultExportFromNamespaceIfNotNamed");
function getAugmentedNamespace(n) {
  if (n.__esModule) return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = /* @__PURE__ */ __name(function a2() {
      if (this instanceof a2) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    }, "a");
    a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return n[k];
      }, "get")
    });
  });
  return a;
}
__name(getAugmentedNamespace, "getAugmentedNamespace");
var _Reflect = {};
/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var Reflect$1;
(function(Reflect2) {
  (function(factory) {
    var root26 = typeof globalThis === "object" ? globalThis : typeof commonjsGlobal === "object" ? commonjsGlobal : typeof self === "object" ? self : typeof this === "object" ? this : sloppyModeThis();
    var exporter = makeExporter(Reflect2);
    if (typeof root26.Reflect !== "undefined") {
      exporter = makeExporter(root26.Reflect, exporter);
    }
    factory(exporter, root26);
    if (typeof root26.Reflect === "undefined") {
      root26.Reflect = Reflect2;
    }
    function makeExporter(target, previous) {
      return function(key, value3) {
        Object.defineProperty(target, key, { configurable: true, writable: true, value: value3 });
        if (previous)
          previous(key, value3);
      };
    }
    __name(makeExporter, "makeExporter");
    function functionThis() {
      try {
        return Function("return this;")();
      } catch (_2) {
      }
    }
    __name(functionThis, "functionThis");
    function indirectEvalThis() {
      try {
        return (void 0, eval)("(function() { return this; })()");
      } catch (_2) {
      }
    }
    __name(indirectEvalThis, "indirectEvalThis");
    function sloppyModeThis() {
      return functionThis() || indirectEvalThis();
    }
    __name(sloppyModeThis, "sloppyModeThis");
  })(function(exporter, root26) {
    var hasOwn2 = Object.prototype.hasOwnProperty;
    var supportsSymbol = typeof Symbol === "function";
    var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
    var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
    var supportsCreate = typeof Object.create === "function";
    var supportsProto = { __proto__: [] } instanceof Array;
    var downLevel = !supportsCreate && !supportsProto;
    var HashMap = {
      // create an object in dictionary mode (a.k.a. "slow" mode in v8)
      create: supportsCreate ? function() {
        return MakeDictionary(/* @__PURE__ */ Object.create(null));
      } : supportsProto ? function() {
        return MakeDictionary({ __proto__: null });
      } : function() {
        return MakeDictionary({});
      },
      has: downLevel ? function(map2, key) {
        return hasOwn2.call(map2, key);
      } : function(map2, key) {
        return key in map2;
      },
      get: downLevel ? function(map2, key) {
        return hasOwn2.call(map2, key) ? map2[key] : void 0;
      } : function(map2, key) {
        return map2[key];
      }
    };
    var functionPrototype = Object.getPrototypeOf(Function);
    var _Map = typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
    var _Set = typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
    var _WeakMap = typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
    var registrySymbol = supportsSymbol ? Symbol.for("@reflect-metadata:registry") : void 0;
    var metadataRegistry = GetOrCreateMetadataRegistry();
    var metadataProvider = CreateMetadataProvider(metadataRegistry);
    function decorate(decorators, target, propertyKey, attributes) {
      if (!IsUndefined(propertyKey)) {
        if (!IsArray(decorators))
          throw new TypeError();
        if (!IsObject(target))
          throw new TypeError();
        if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
          throw new TypeError();
        if (IsNull(attributes))
          attributes = void 0;
        propertyKey = ToPropertyKey(propertyKey);
        return DecorateProperty(decorators, target, propertyKey, attributes);
      } else {
        if (!IsArray(decorators))
          throw new TypeError();
        if (!IsConstructor(target))
          throw new TypeError();
        return DecorateConstructor(decorators, target);
      }
    }
    __name(decorate, "decorate");
    exporter("decorate", decorate);
    function metadata(metadataKey, metadataValue) {
      function decorator(target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError();
        if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
          throw new TypeError();
        OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
      }
      __name(decorator, "decorator");
      return decorator;
    }
    __name(metadata, "metadata");
    exporter("metadata", metadata);
    function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
    }
    __name(defineMetadata, "defineMetadata");
    exporter("defineMetadata", defineMetadata);
    function hasMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryHasMetadata(metadataKey, target, propertyKey);
    }
    __name(hasMetadata, "hasMetadata");
    exporter("hasMetadata", hasMetadata);
    function hasOwnMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
    }
    __name(hasOwnMetadata, "hasOwnMetadata");
    exporter("hasOwnMetadata", hasOwnMetadata);
    function getMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryGetMetadata(metadataKey, target, propertyKey);
    }
    __name(getMetadata, "getMetadata");
    exporter("getMetadata", getMetadata);
    function getOwnMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
    }
    __name(getOwnMetadata, "getOwnMetadata");
    exporter("getOwnMetadata", getOwnMetadata);
    function getMetadataKeys(target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryMetadataKeys(target, propertyKey);
    }
    __name(getMetadataKeys, "getMetadataKeys");
    exporter("getMetadataKeys", getMetadataKeys);
    function getOwnMetadataKeys(target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryOwnMetadataKeys(target, propertyKey);
    }
    __name(getOwnMetadataKeys, "getOwnMetadataKeys");
    exporter("getOwnMetadataKeys", getOwnMetadataKeys);
    function deleteMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      var provider = GetMetadataProvider(
        target,
        propertyKey,
        /*Create*/
        false
      );
      if (IsUndefined(provider))
        return false;
      return provider.OrdinaryDeleteMetadata(metadataKey, target, propertyKey);
    }
    __name(deleteMetadata, "deleteMetadata");
    exporter("deleteMetadata", deleteMetadata);
    function DecorateConstructor(decorators, target) {
      for (var i2 = decorators.length - 1; i2 >= 0; --i2) {
        var decorator = decorators[i2];
        var decorated = decorator(target);
        if (!IsUndefined(decorated) && !IsNull(decorated)) {
          if (!IsConstructor(decorated))
            throw new TypeError();
          target = decorated;
        }
      }
      return target;
    }
    __name(DecorateConstructor, "DecorateConstructor");
    function DecorateProperty(decorators, target, propertyKey, descriptor) {
      for (var i2 = decorators.length - 1; i2 >= 0; --i2) {
        var decorator = decorators[i2];
        var decorated = decorator(target, propertyKey, descriptor);
        if (!IsUndefined(decorated) && !IsNull(decorated)) {
          if (!IsObject(decorated))
            throw new TypeError();
          descriptor = decorated;
        }
      }
      return descriptor;
    }
    __name(DecorateProperty, "DecorateProperty");
    function OrdinaryHasMetadata(MetadataKey, O, P) {
      var hasOwn3 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
      if (hasOwn3)
        return true;
      var parent = OrdinaryGetPrototypeOf(O);
      if (!IsNull(parent))
        return OrdinaryHasMetadata(MetadataKey, parent, P);
      return false;
    }
    __name(OrdinaryHasMetadata, "OrdinaryHasMetadata");
    function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
      var provider = GetMetadataProvider(
        O,
        P,
        /*Create*/
        false
      );
      if (IsUndefined(provider))
        return false;
      return ToBoolean(provider.OrdinaryHasOwnMetadata(MetadataKey, O, P));
    }
    __name(OrdinaryHasOwnMetadata, "OrdinaryHasOwnMetadata");
    function OrdinaryGetMetadata(MetadataKey, O, P) {
      var hasOwn3 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
      if (hasOwn3)
        return OrdinaryGetOwnMetadata(MetadataKey, O, P);
      var parent = OrdinaryGetPrototypeOf(O);
      if (!IsNull(parent))
        return OrdinaryGetMetadata(MetadataKey, parent, P);
      return void 0;
    }
    __name(OrdinaryGetMetadata, "OrdinaryGetMetadata");
    function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
      var provider = GetMetadataProvider(
        O,
        P,
        /*Create*/
        false
      );
      if (IsUndefined(provider))
        return;
      return provider.OrdinaryGetOwnMetadata(MetadataKey, O, P);
    }
    __name(OrdinaryGetOwnMetadata, "OrdinaryGetOwnMetadata");
    function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
      var provider = GetMetadataProvider(
        O,
        P,
        /*Create*/
        true
      );
      provider.OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P);
    }
    __name(OrdinaryDefineOwnMetadata, "OrdinaryDefineOwnMetadata");
    function OrdinaryMetadataKeys(O, P) {
      var ownKeys2 = OrdinaryOwnMetadataKeys(O, P);
      var parent = OrdinaryGetPrototypeOf(O);
      if (parent === null)
        return ownKeys2;
      var parentKeys = OrdinaryMetadataKeys(parent, P);
      if (parentKeys.length <= 0)
        return ownKeys2;
      if (ownKeys2.length <= 0)
        return parentKeys;
      var set2 = new _Set();
      var keys2 = [];
      for (var _i = 0, ownKeys_1 = ownKeys2; _i < ownKeys_1.length; _i++) {
        var key = ownKeys_1[_i];
        var hasKey = set2.has(key);
        if (!hasKey) {
          set2.add(key);
          keys2.push(key);
        }
      }
      for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
        var key = parentKeys_1[_a];
        var hasKey = set2.has(key);
        if (!hasKey) {
          set2.add(key);
          keys2.push(key);
        }
      }
      return keys2;
    }
    __name(OrdinaryMetadataKeys, "OrdinaryMetadataKeys");
    function OrdinaryOwnMetadataKeys(O, P) {
      var provider = GetMetadataProvider(
        O,
        P,
        /*create*/
        false
      );
      if (!provider) {
        return [];
      }
      return provider.OrdinaryOwnMetadataKeys(O, P);
    }
    __name(OrdinaryOwnMetadataKeys, "OrdinaryOwnMetadataKeys");
    function Type2(x2) {
      if (x2 === null)
        return 1;
      switch (typeof x2) {
        case "undefined":
          return 0;
        case "boolean":
          return 2;
        case "string":
          return 3;
        case "symbol":
          return 4;
        case "number":
          return 5;
        case "object":
          return x2 === null ? 1 : 6;
        default:
          return 6;
      }
    }
    __name(Type2, "Type");
    function IsUndefined(x2) {
      return x2 === void 0;
    }
    __name(IsUndefined, "IsUndefined");
    function IsNull(x2) {
      return x2 === null;
    }
    __name(IsNull, "IsNull");
    function IsSymbol(x2) {
      return typeof x2 === "symbol";
    }
    __name(IsSymbol, "IsSymbol");
    function IsObject(x2) {
      return typeof x2 === "object" ? x2 !== null : typeof x2 === "function";
    }
    __name(IsObject, "IsObject");
    function ToPrimitive(input, PreferredType) {
      switch (Type2(input)) {
        case 0:
          return input;
        case 1:
          return input;
        case 2:
          return input;
        case 3:
          return input;
        case 4:
          return input;
        case 5:
          return input;
      }
      var hint = PreferredType === 3 ? "string" : PreferredType === 5 ? "number" : "default";
      var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
      if (exoticToPrim !== void 0) {
        var result = exoticToPrim.call(input, hint);
        if (IsObject(result))
          throw new TypeError();
        return result;
      }
      return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
    }
    __name(ToPrimitive, "ToPrimitive");
    function OrdinaryToPrimitive(O, hint) {
      if (hint === "string") {
        var toString_1 = O.toString;
        if (IsCallable(toString_1)) {
          var result = toString_1.call(O);
          if (!IsObject(result))
            return result;
        }
        var valueOf = O.valueOf;
        if (IsCallable(valueOf)) {
          var result = valueOf.call(O);
          if (!IsObject(result))
            return result;
        }
      } else {
        var valueOf = O.valueOf;
        if (IsCallable(valueOf)) {
          var result = valueOf.call(O);
          if (!IsObject(result))
            return result;
        }
        var toString_2 = O.toString;
        if (IsCallable(toString_2)) {
          var result = toString_2.call(O);
          if (!IsObject(result))
            return result;
        }
      }
      throw new TypeError();
    }
    __name(OrdinaryToPrimitive, "OrdinaryToPrimitive");
    function ToBoolean(argument) {
      return !!argument;
    }
    __name(ToBoolean, "ToBoolean");
    function ToString(argument) {
      return "" + argument;
    }
    __name(ToString, "ToString");
    function ToPropertyKey(argument) {
      var key = ToPrimitive(
        argument,
        3
        /* String */
      );
      if (IsSymbol(key))
        return key;
      return ToString(key);
    }
    __name(ToPropertyKey, "ToPropertyKey");
    function IsArray(argument) {
      return Array.isArray ? Array.isArray(argument) : argument instanceof Object ? argument instanceof Array : Object.prototype.toString.call(argument) === "[object Array]";
    }
    __name(IsArray, "IsArray");
    function IsCallable(argument) {
      return typeof argument === "function";
    }
    __name(IsCallable, "IsCallable");
    function IsConstructor(argument) {
      return typeof argument === "function";
    }
    __name(IsConstructor, "IsConstructor");
    function IsPropertyKey(argument) {
      switch (Type2(argument)) {
        case 3:
          return true;
        case 4:
          return true;
        default:
          return false;
      }
    }
    __name(IsPropertyKey, "IsPropertyKey");
    function SameValueZero(x2, y2) {
      return x2 === y2 || x2 !== x2 && y2 !== y2;
    }
    __name(SameValueZero, "SameValueZero");
    function GetMethod(V, P) {
      var func = V[P];
      if (func === void 0 || func === null)
        return void 0;
      if (!IsCallable(func))
        throw new TypeError();
      return func;
    }
    __name(GetMethod, "GetMethod");
    function GetIterator(obj) {
      var method = GetMethod(obj, iteratorSymbol);
      if (!IsCallable(method))
        throw new TypeError();
      var iterator = method.call(obj);
      if (!IsObject(iterator))
        throw new TypeError();
      return iterator;
    }
    __name(GetIterator, "GetIterator");
    function IteratorValue(iterResult) {
      return iterResult.value;
    }
    __name(IteratorValue, "IteratorValue");
    function IteratorStep(iterator) {
      var result = iterator.next();
      return result.done ? false : result;
    }
    __name(IteratorStep, "IteratorStep");
    function IteratorClose(iterator) {
      var f = iterator["return"];
      if (f)
        f.call(iterator);
    }
    __name(IteratorClose, "IteratorClose");
    function OrdinaryGetPrototypeOf(O) {
      var proto = Object.getPrototypeOf(O);
      if (typeof O !== "function" || O === functionPrototype)
        return proto;
      if (proto !== functionPrototype)
        return proto;
      var prototype2 = O.prototype;
      var prototypeProto = prototype2 && Object.getPrototypeOf(prototype2);
      if (prototypeProto == null || prototypeProto === Object.prototype)
        return proto;
      var constructor = prototypeProto.constructor;
      if (typeof constructor !== "function")
        return proto;
      if (constructor === O)
        return proto;
      return constructor;
    }
    __name(OrdinaryGetPrototypeOf, "OrdinaryGetPrototypeOf");
    function CreateMetadataRegistry() {
      var fallback;
      if (!IsUndefined(registrySymbol) && typeof root26.Reflect !== "undefined" && !(registrySymbol in root26.Reflect) && typeof root26.Reflect.defineMetadata === "function") {
        fallback = CreateFallbackProvider(root26.Reflect);
      }
      var first;
      var second;
      var rest;
      var targetProviderMap = new _WeakMap();
      var registry = {
        registerProvider,
        getProvider,
        setProvider
      };
      return registry;
      function registerProvider(provider) {
        if (!Object.isExtensible(registry)) {
          throw new Error("Cannot add provider to a frozen registry.");
        }
        switch (true) {
          case fallback === provider:
            break;
          case IsUndefined(first):
            first = provider;
            break;
          case first === provider:
            break;
          case IsUndefined(second):
            second = provider;
            break;
          case second === provider:
            break;
          default:
            if (rest === void 0)
              rest = new _Set();
            rest.add(provider);
            break;
        }
      }
      __name(registerProvider, "registerProvider");
      function getProviderNoCache(O, P) {
        if (!IsUndefined(first)) {
          if (first.isProviderFor(O, P))
            return first;
          if (!IsUndefined(second)) {
            if (second.isProviderFor(O, P))
              return first;
            if (!IsUndefined(rest)) {
              var iterator = GetIterator(rest);
              while (true) {
                var next2 = IteratorStep(iterator);
                if (!next2) {
                  return void 0;
                }
                var provider = IteratorValue(next2);
                if (provider.isProviderFor(O, P)) {
                  IteratorClose(iterator);
                  return provider;
                }
              }
            }
          }
        }
        if (!IsUndefined(fallback) && fallback.isProviderFor(O, P)) {
          return fallback;
        }
        return void 0;
      }
      __name(getProviderNoCache, "getProviderNoCache");
      function getProvider(O, P) {
        var providerMap = targetProviderMap.get(O);
        var provider;
        if (!IsUndefined(providerMap)) {
          provider = providerMap.get(P);
        }
        if (!IsUndefined(provider)) {
          return provider;
        }
        provider = getProviderNoCache(O, P);
        if (!IsUndefined(provider)) {
          if (IsUndefined(providerMap)) {
            providerMap = new _Map();
            targetProviderMap.set(O, providerMap);
          }
          providerMap.set(P, provider);
        }
        return provider;
      }
      __name(getProvider, "getProvider");
      function hasProvider(provider) {
        if (IsUndefined(provider))
          throw new TypeError();
        return first === provider || second === provider || !IsUndefined(rest) && rest.has(provider);
      }
      __name(hasProvider, "hasProvider");
      function setProvider(O, P, provider) {
        if (!hasProvider(provider)) {
          throw new Error("Metadata provider not registered.");
        }
        var existingProvider = getProvider(O, P);
        if (existingProvider !== provider) {
          if (!IsUndefined(existingProvider)) {
            return false;
          }
          var providerMap = targetProviderMap.get(O);
          if (IsUndefined(providerMap)) {
            providerMap = new _Map();
            targetProviderMap.set(O, providerMap);
          }
          providerMap.set(P, provider);
        }
        return true;
      }
      __name(setProvider, "setProvider");
    }
    __name(CreateMetadataRegistry, "CreateMetadataRegistry");
    function GetOrCreateMetadataRegistry() {
      var metadataRegistry2;
      if (!IsUndefined(registrySymbol) && IsObject(root26.Reflect) && Object.isExtensible(root26.Reflect)) {
        metadataRegistry2 = root26.Reflect[registrySymbol];
      }
      if (IsUndefined(metadataRegistry2)) {
        metadataRegistry2 = CreateMetadataRegistry();
      }
      if (!IsUndefined(registrySymbol) && IsObject(root26.Reflect) && Object.isExtensible(root26.Reflect)) {
        Object.defineProperty(root26.Reflect, registrySymbol, {
          enumerable: false,
          configurable: false,
          writable: false,
          value: metadataRegistry2
        });
      }
      return metadataRegistry2;
    }
    __name(GetOrCreateMetadataRegistry, "GetOrCreateMetadataRegistry");
    function CreateMetadataProvider(registry) {
      var metadata2 = new _WeakMap();
      var provider = {
        isProviderFor: /* @__PURE__ */ __name(function(O, P) {
          var targetMetadata = metadata2.get(O);
          if (IsUndefined(targetMetadata))
            return false;
          return targetMetadata.has(P);
        }, "isProviderFor"),
        OrdinaryDefineOwnMetadata: OrdinaryDefineOwnMetadata2,
        OrdinaryHasOwnMetadata: OrdinaryHasOwnMetadata2,
        OrdinaryGetOwnMetadata: OrdinaryGetOwnMetadata2,
        OrdinaryOwnMetadataKeys: OrdinaryOwnMetadataKeys2,
        OrdinaryDeleteMetadata
      };
      metadataRegistry.registerProvider(provider);
      return provider;
      function GetOrCreateMetadataMap(O, P, Create) {
        var targetMetadata = metadata2.get(O);
        var createdTargetMetadata = false;
        if (IsUndefined(targetMetadata)) {
          if (!Create)
            return void 0;
          targetMetadata = new _Map();
          metadata2.set(O, targetMetadata);
          createdTargetMetadata = true;
        }
        var metadataMap = targetMetadata.get(P);
        if (IsUndefined(metadataMap)) {
          if (!Create)
            return void 0;
          metadataMap = new _Map();
          targetMetadata.set(P, metadataMap);
          if (!registry.setProvider(O, P, provider)) {
            targetMetadata.delete(P);
            if (createdTargetMetadata) {
              metadata2.delete(O);
            }
            throw new Error("Wrong provider for target.");
          }
        }
        return metadataMap;
      }
      __name(GetOrCreateMetadataMap, "GetOrCreateMetadataMap");
      function OrdinaryHasOwnMetadata2(MetadataKey, O, P) {
        var metadataMap = GetOrCreateMetadataMap(
          O,
          P,
          /*Create*/
          false
        );
        if (IsUndefined(metadataMap))
          return false;
        return ToBoolean(metadataMap.has(MetadataKey));
      }
      __name(OrdinaryHasOwnMetadata2, "OrdinaryHasOwnMetadata");
      function OrdinaryGetOwnMetadata2(MetadataKey, O, P) {
        var metadataMap = GetOrCreateMetadataMap(
          O,
          P,
          /*Create*/
          false
        );
        if (IsUndefined(metadataMap))
          return void 0;
        return metadataMap.get(MetadataKey);
      }
      __name(OrdinaryGetOwnMetadata2, "OrdinaryGetOwnMetadata");
      function OrdinaryDefineOwnMetadata2(MetadataKey, MetadataValue, O, P) {
        var metadataMap = GetOrCreateMetadataMap(
          O,
          P,
          /*Create*/
          true
        );
        metadataMap.set(MetadataKey, MetadataValue);
      }
      __name(OrdinaryDefineOwnMetadata2, "OrdinaryDefineOwnMetadata");
      function OrdinaryOwnMetadataKeys2(O, P) {
        var keys2 = [];
        var metadataMap = GetOrCreateMetadataMap(
          O,
          P,
          /*Create*/
          false
        );
        if (IsUndefined(metadataMap))
          return keys2;
        var keysObj = metadataMap.keys();
        var iterator = GetIterator(keysObj);
        var k = 0;
        while (true) {
          var next2 = IteratorStep(iterator);
          if (!next2) {
            keys2.length = k;
            return keys2;
          }
          var nextValue = IteratorValue(next2);
          try {
            keys2[k] = nextValue;
          } catch (e) {
            try {
              IteratorClose(iterator);
            } finally {
              throw e;
            }
          }
          k++;
        }
      }
      __name(OrdinaryOwnMetadataKeys2, "OrdinaryOwnMetadataKeys");
      function OrdinaryDeleteMetadata(MetadataKey, O, P) {
        var metadataMap = GetOrCreateMetadataMap(
          O,
          P,
          /*Create*/
          false
        );
        if (IsUndefined(metadataMap))
          return false;
        if (!metadataMap.delete(MetadataKey))
          return false;
        if (metadataMap.size === 0) {
          var targetMetadata = metadata2.get(O);
          if (!IsUndefined(targetMetadata)) {
            targetMetadata.delete(P);
            if (targetMetadata.size === 0) {
              metadata2.delete(targetMetadata);
            }
          }
        }
        return true;
      }
      __name(OrdinaryDeleteMetadata, "OrdinaryDeleteMetadata");
    }
    __name(CreateMetadataProvider, "CreateMetadataProvider");
    function CreateFallbackProvider(reflect) {
      var defineMetadata2 = reflect.defineMetadata, hasOwnMetadata2 = reflect.hasOwnMetadata, getOwnMetadata2 = reflect.getOwnMetadata, getOwnMetadataKeys2 = reflect.getOwnMetadataKeys, deleteMetadata2 = reflect.deleteMetadata;
      var metadataOwner = new _WeakMap();
      var provider = {
        isProviderFor: /* @__PURE__ */ __name(function(O, P) {
          var metadataPropertySet = metadataOwner.get(O);
          if (!IsUndefined(metadataPropertySet) && metadataPropertySet.has(P)) {
            return true;
          }
          if (getOwnMetadataKeys2(O, P).length) {
            if (IsUndefined(metadataPropertySet)) {
              metadataPropertySet = new _Set();
              metadataOwner.set(O, metadataPropertySet);
            }
            metadataPropertySet.add(P);
            return true;
          }
          return false;
        }, "isProviderFor"),
        OrdinaryDefineOwnMetadata: defineMetadata2,
        OrdinaryHasOwnMetadata: hasOwnMetadata2,
        OrdinaryGetOwnMetadata: getOwnMetadata2,
        OrdinaryOwnMetadataKeys: getOwnMetadataKeys2,
        OrdinaryDeleteMetadata: deleteMetadata2
      };
      return provider;
    }
    __name(CreateFallbackProvider, "CreateFallbackProvider");
    function GetMetadataProvider(O, P, Create) {
      var registeredProvider = metadataRegistry.getProvider(O, P);
      if (!IsUndefined(registeredProvider)) {
        return registeredProvider;
      }
      if (Create) {
        if (metadataRegistry.setProvider(O, P, metadataProvider)) {
          return metadataProvider;
        }
        throw new Error("Illegal state.");
      }
      return void 0;
    }
    __name(GetMetadataProvider, "GetMetadataProvider");
    function CreateMapPolyfill() {
      var cacheSentinel = {};
      var arraySentinel = [];
      var MapIterator = (
        /** @class */
        function() {
          function MapIterator2(keys2, values2, selector) {
            this._index = 0;
            this._keys = keys2;
            this._values = values2;
            this._selector = selector;
          }
          __name(MapIterator2, "MapIterator");
          MapIterator2.prototype["@@iterator"] = function() {
            return this;
          };
          MapIterator2.prototype[iteratorSymbol] = function() {
            return this;
          };
          MapIterator2.prototype.next = function() {
            var index2 = this._index;
            if (index2 >= 0 && index2 < this._keys.length) {
              var result = this._selector(this._keys[index2], this._values[index2]);
              if (index2 + 1 >= this._keys.length) {
                this._index = -1;
                this._keys = arraySentinel;
                this._values = arraySentinel;
              } else {
                this._index++;
              }
              return { value: result, done: false };
            }
            return { value: void 0, done: true };
          };
          MapIterator2.prototype.throw = function(error) {
            if (this._index >= 0) {
              this._index = -1;
              this._keys = arraySentinel;
              this._values = arraySentinel;
            }
            throw error;
          };
          MapIterator2.prototype.return = function(value3) {
            if (this._index >= 0) {
              this._index = -1;
              this._keys = arraySentinel;
              this._values = arraySentinel;
            }
            return { value: value3, done: true };
          };
          return MapIterator2;
        }()
      );
      var Map2 = (
        /** @class */
        function() {
          function Map3() {
            this._keys = [];
            this._values = [];
            this._cacheKey = cacheSentinel;
            this._cacheIndex = -2;
          }
          __name(Map3, "Map");
          Object.defineProperty(Map3.prototype, "size", {
            get: /* @__PURE__ */ __name(function() {
              return this._keys.length;
            }, "get"),
            enumerable: true,
            configurable: true
          });
          Map3.prototype.has = function(key) {
            return this._find(
              key,
              /*insert*/
              false
            ) >= 0;
          };
          Map3.prototype.get = function(key) {
            var index2 = this._find(
              key,
              /*insert*/
              false
            );
            return index2 >= 0 ? this._values[index2] : void 0;
          };
          Map3.prototype.set = function(key, value3) {
            var index2 = this._find(
              key,
              /*insert*/
              true
            );
            this._values[index2] = value3;
            return this;
          };
          Map3.prototype.delete = function(key) {
            var index2 = this._find(
              key,
              /*insert*/
              false
            );
            if (index2 >= 0) {
              var size2 = this._keys.length;
              for (var i2 = index2 + 1; i2 < size2; i2++) {
                this._keys[i2 - 1] = this._keys[i2];
                this._values[i2 - 1] = this._values[i2];
              }
              this._keys.length--;
              this._values.length--;
              if (SameValueZero(key, this._cacheKey)) {
                this._cacheKey = cacheSentinel;
                this._cacheIndex = -2;
              }
              return true;
            }
            return false;
          };
          Map3.prototype.clear = function() {
            this._keys.length = 0;
            this._values.length = 0;
            this._cacheKey = cacheSentinel;
            this._cacheIndex = -2;
          };
          Map3.prototype.keys = function() {
            return new MapIterator(this._keys, this._values, getKey);
          };
          Map3.prototype.values = function() {
            return new MapIterator(this._keys, this._values, getValue2);
          };
          Map3.prototype.entries = function() {
            return new MapIterator(this._keys, this._values, getEntry);
          };
          Map3.prototype["@@iterator"] = function() {
            return this.entries();
          };
          Map3.prototype[iteratorSymbol] = function() {
            return this.entries();
          };
          Map3.prototype._find = function(key, insert2) {
            if (!SameValueZero(this._cacheKey, key)) {
              this._cacheIndex = -1;
              for (var i2 = 0; i2 < this._keys.length; i2++) {
                if (SameValueZero(this._keys[i2], key)) {
                  this._cacheIndex = i2;
                  break;
                }
              }
            }
            if (this._cacheIndex < 0 && insert2) {
              this._cacheIndex = this._keys.length;
              this._keys.push(key);
              this._values.push(void 0);
            }
            return this._cacheIndex;
          };
          return Map3;
        }()
      );
      return Map2;
      function getKey(key, _2) {
        return key;
      }
      __name(getKey, "getKey");
      function getValue2(_2, value3) {
        return value3;
      }
      __name(getValue2, "getValue");
      function getEntry(key, value3) {
        return [key, value3];
      }
      __name(getEntry, "getEntry");
    }
    __name(CreateMapPolyfill, "CreateMapPolyfill");
    function CreateSetPolyfill() {
      var Set2 = (
        /** @class */
        function() {
          function Set3() {
            this._map = new _Map();
          }
          __name(Set3, "Set");
          Object.defineProperty(Set3.prototype, "size", {
            get: /* @__PURE__ */ __name(function() {
              return this._map.size;
            }, "get"),
            enumerable: true,
            configurable: true
          });
          Set3.prototype.has = function(value3) {
            return this._map.has(value3);
          };
          Set3.prototype.add = function(value3) {
            return this._map.set(value3, value3), this;
          };
          Set3.prototype.delete = function(value3) {
            return this._map.delete(value3);
          };
          Set3.prototype.clear = function() {
            this._map.clear();
          };
          Set3.prototype.keys = function() {
            return this._map.keys();
          };
          Set3.prototype.values = function() {
            return this._map.keys();
          };
          Set3.prototype.entries = function() {
            return this._map.entries();
          };
          Set3.prototype["@@iterator"] = function() {
            return this.keys();
          };
          Set3.prototype[iteratorSymbol] = function() {
            return this.keys();
          };
          return Set3;
        }()
      );
      return Set2;
    }
    __name(CreateSetPolyfill, "CreateSetPolyfill");
    function CreateWeakMapPolyfill() {
      var UUID_SIZE = 16;
      var keys2 = HashMap.create();
      var rootKey = CreateUniqueKey();
      return (
        /** @class */
        function() {
          function WeakMap2() {
            this._key = CreateUniqueKey();
          }
          __name(WeakMap2, "WeakMap");
          WeakMap2.prototype.has = function(target) {
            var table = GetOrCreateWeakMapTable(
              target,
              /*create*/
              false
            );
            return table !== void 0 ? HashMap.has(table, this._key) : false;
          };
          WeakMap2.prototype.get = function(target) {
            var table = GetOrCreateWeakMapTable(
              target,
              /*create*/
              false
            );
            return table !== void 0 ? HashMap.get(table, this._key) : void 0;
          };
          WeakMap2.prototype.set = function(target, value3) {
            var table = GetOrCreateWeakMapTable(
              target,
              /*create*/
              true
            );
            table[this._key] = value3;
            return this;
          };
          WeakMap2.prototype.delete = function(target) {
            var table = GetOrCreateWeakMapTable(
              target,
              /*create*/
              false
            );
            return table !== void 0 ? delete table[this._key] : false;
          };
          WeakMap2.prototype.clear = function() {
            this._key = CreateUniqueKey();
          };
          return WeakMap2;
        }()
      );
      function CreateUniqueKey() {
        var key;
        do
          key = "@@WeakMap@@" + CreateUUID();
        while (HashMap.has(keys2, key));
        keys2[key] = true;
        return key;
      }
      __name(CreateUniqueKey, "CreateUniqueKey");
      function GetOrCreateWeakMapTable(target, create2) {
        if (!hasOwn2.call(target, rootKey)) {
          if (!create2)
            return void 0;
          Object.defineProperty(target, rootKey, { value: HashMap.create() });
        }
        return target[rootKey];
      }
      __name(GetOrCreateWeakMapTable, "GetOrCreateWeakMapTable");
      function FillRandomBytes(buffer2, size2) {
        for (var i2 = 0; i2 < size2; ++i2)
          buffer2[i2] = Math.random() * 255 | 0;
        return buffer2;
      }
      __name(FillRandomBytes, "FillRandomBytes");
      function GenRandomBytes(size2) {
        if (typeof Uint8Array === "function") {
          var array = new Uint8Array(size2);
          if (typeof crypto !== "undefined") {
            crypto.getRandomValues(array);
          } else if (typeof msCrypto !== "undefined") {
            msCrypto.getRandomValues(array);
          } else {
            FillRandomBytes(array, size2);
          }
          return array;
        }
        return FillRandomBytes(new Array(size2), size2);
      }
      __name(GenRandomBytes, "GenRandomBytes");
      function CreateUUID() {
        var data24 = GenRandomBytes(UUID_SIZE);
        data24[6] = data24[6] & 79 | 64;
        data24[8] = data24[8] & 191 | 128;
        var result = "";
        for (var offset = 0; offset < UUID_SIZE; ++offset) {
          var byte = data24[offset];
          if (offset === 4 || offset === 6 || offset === 8)
            result += "-";
          if (byte < 16)
            result += "0";
          result += byte.toString(16).toLowerCase();
        }
        return result;
      }
      __name(CreateUUID, "CreateUUID");
    }
    __name(CreateWeakMapPolyfill, "CreateWeakMapPolyfill");
    function MakeDictionary(obj) {
      obj.__ = void 0;
      delete obj.__;
      return obj;
    }
    __name(MakeDictionary, "MakeDictionary");
  });
})(Reflect$1 || (Reflect$1 = {}));
window["__COMFYUI_FRONTEND_VERSION__"] = "1.2.47";
console.log("ComfyUI Front-end version:", "1.2.47");
/**
* @vue/shared v3.4.31
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function makeMap(str, expectsLowerCase) {
  const set2 = new Set(str.split(","));
  return expectsLowerCase ? (val) => set2.has(val.toLowerCase()) : (val) => set2.has(val);
}
__name(makeMap, "makeMap");
const EMPTY_OBJ = false ? Object.freeze({}) : {};
const EMPTY_ARR = false ? Object.freeze([]) : [];
const NOOP = /* @__PURE__ */ __name(() => {
}, "NOOP");
const NO = /* @__PURE__ */ __name(() => false, "NO");
const isOn = /* @__PURE__ */ __name((key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
(key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97), "isOn");
const isModelListener = /* @__PURE__ */ __name((key) => key.startsWith("onUpdate:"), "isModelListener");
const extend$1 = Object.assign;
const remove$1 = /* @__PURE__ */ __name((arr, el) => {
  const i2 = arr.indexOf(el);
  if (i2 > -1) {
    arr.splice(i2, 1);
  }
}, "remove$1");
const hasOwnProperty$3 = Object.prototype.hasOwnProperty;
const hasOwn$3 = /* @__PURE__ */ __name((val, key) => hasOwnProperty$3.call(val, key), "hasOwn$3");
const isArray$4 = Array.isArray;
const isMap = /* @__PURE__ */ __name((val) => toTypeString$1(val) === "[object Map]", "isMap");
const isSet = /* @__PURE__ */ __name((val) => toTypeString$1(val) === "[object Set]", "isSet");
const isDate$3 = /* @__PURE__ */ __name((val) => toTypeString$1(val) === "[object Date]", "isDate$3");
const isRegExp$2 = /* @__PURE__ */ __name((val) => toTypeString$1(val) === "[object RegExp]", "isRegExp$2");
const isFunction$4 = /* @__PURE__ */ __name((val) => typeof val === "function", "isFunction$4");
const isString$5 = /* @__PURE__ */ __name((val) => typeof val === "string", "isString$5");
const isSymbol$1 = /* @__PURE__ */ __name((val) => typeof val === "symbol", "isSymbol$1");
const isObject$6 = /* @__PURE__ */ __name((val) => val !== null && typeof val === "object", "isObject$6");
const isPromise$2 = /* @__PURE__ */ __name((val) => {
  return (isObject$6(val) || isFunction$4(val)) && isFunction$4(val.then) && isFunction$4(val.catch);
}, "isPromise$2");
const objectToString$1 = Object.prototype.toString;
const toTypeString$1 = /* @__PURE__ */ __name((value3) => objectToString$1.call(value3), "toTypeString$1");
const toRawType = /* @__PURE__ */ __name((value3) => {
  return toTypeString$1(value3).slice(8, -1);
}, "toRawType");
const isPlainObject$3 = /* @__PURE__ */ __name((val) => toTypeString$1(val) === "[object Object]", "isPlainObject$3");
const isIntegerKey = /* @__PURE__ */ __name((key) => isString$5(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key, "isIntegerKey");
const isReservedProp = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const isBuiltInDirective = /* @__PURE__ */ makeMap(
  "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
);
const cacheStringFunction$1 = /* @__PURE__ */ __name((fn) => {
  const cache2 = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache2[str];
    return hit || (cache2[str] = fn(str));
  };
}, "cacheStringFunction$1");
const camelizeRE$1 = /-(\w)/g;
const camelize$1 = cacheStringFunction$1((str) => {
  return str.replace(camelizeRE$1, (_2, c) => c ? c.toUpperCase() : "");
});
const hyphenateRE$1 = /\B([A-Z])/g;
const hyphenate$1 = cacheStringFunction$1(
  (str) => str.replace(hyphenateRE$1, "-$1").toLowerCase()
);
const capitalize$1 = cacheStringFunction$1((str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
const toHandlerKey = cacheStringFunction$1((str) => {
  const s = str ? `on${capitalize$1(str)}` : ``;
  return s;
});
const hasChanged = /* @__PURE__ */ __name((value3, oldValue) => !Object.is(value3, oldValue), "hasChanged");
const invokeArrayFns = /* @__PURE__ */ __name((fns, ...arg) => {
  for (let i2 = 0; i2 < fns.length; i2++) {
    fns[i2](...arg);
  }
}, "invokeArrayFns");
const def = /* @__PURE__ */ __name((obj, key, value3, writable = false) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    writable,
    value: value3
  });
}, "def");
const looseToNumber = /* @__PURE__ */ __name((val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
}, "looseToNumber");
const toNumber = /* @__PURE__ */ __name((val) => {
  const n = isString$5(val) ? Number(val) : NaN;
  return isNaN(n) ? val : n;
}, "toNumber");
let _globalThis$1;
const getGlobalThis$1 = /* @__PURE__ */ __name(() => {
  return _globalThis$1 || (_globalThis$1 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
}, "getGlobalThis$1");
const identRE = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/;
function genPropsAccessExp(name) {
  return identRE.test(name) ? `__props.${name}` : `__props[${JSON.stringify(name)}]`;
}
__name(genPropsAccessExp, "genPropsAccessExp");
const PatchFlags = {
  "TEXT": 1,
  "1": "TEXT",
  "CLASS": 2,
  "2": "CLASS",
  "STYLE": 4,
  "4": "STYLE",
  "PROPS": 8,
  "8": "PROPS",
  "FULL_PROPS": 16,
  "16": "FULL_PROPS",
  "NEED_HYDRATION": 32,
  "32": "NEED_HYDRATION",
  "STABLE_FRAGMENT": 64,
  "64": "STABLE_FRAGMENT",
  "KEYED_FRAGMENT": 128,
  "128": "KEYED_FRAGMENT",
  "UNKEYED_FRAGMENT": 256,
  "256": "UNKEYED_FRAGMENT",
  "NEED_PATCH": 512,
  "512": "NEED_PATCH",
  "DYNAMIC_SLOTS": 1024,
  "1024": "DYNAMIC_SLOTS",
  "DEV_ROOT_FRAGMENT": 2048,
  "2048": "DEV_ROOT_FRAGMENT",
  "HOISTED": -1,
  "-1": "HOISTED",
  "BAIL": -2,
  "-2": "BAIL"
};
const PatchFlagNames = {
  [1]: `TEXT`,
  [2]: `CLASS`,
  [4]: `STYLE`,
  [8]: `PROPS`,
  [16]: `FULL_PROPS`,
  [32]: `NEED_HYDRATION`,
  [64]: `STABLE_FRAGMENT`,
  [128]: `KEYED_FRAGMENT`,
  [256]: `UNKEYED_FRAGMENT`,
  [512]: `NEED_PATCH`,
  [1024]: `DYNAMIC_SLOTS`,
  [2048]: `DEV_ROOT_FRAGMENT`,
  [-1]: `HOISTED`,
  [-2]: `BAIL`
};
const ShapeFlags = {
  "ELEMENT": 1,
  "1": "ELEMENT",
  "FUNCTIONAL_COMPONENT": 2,
  "2": "FUNCTIONAL_COMPONENT",
  "STATEFUL_COMPONENT": 4,
  "4": "STATEFUL_COMPONENT",
  "TEXT_CHILDREN": 8,
  "8": "TEXT_CHILDREN",
  "ARRAY_CHILDREN": 16,
  "16": "ARRAY_CHILDREN",
  "SLOTS_CHILDREN": 32,
  "32": "SLOTS_CHILDREN",
  "TELEPORT": 64,
  "64": "TELEPORT",
  "SUSPENSE": 128,
  "128": "SUSPENSE",
  "COMPONENT_SHOULD_KEEP_ALIVE": 256,
  "256": "COMPONENT_SHOULD_KEEP_ALIVE",
  "COMPONENT_KEPT_ALIVE": 512,
  "512": "COMPONENT_KEPT_ALIVE",
  "COMPONENT": 6,
  "6": "COMPONENT"
};
const SlotFlags = {
  "STABLE": 1,
  "1": "STABLE",
  "DYNAMIC": 2,
  "2": "DYNAMIC",
  "FORWARDED": 3,
  "3": "FORWARDED"
};
const slotFlagsText = {
  [1]: "STABLE",
  [2]: "DYNAMIC",
  [3]: "FORWARDED"
};
const GLOBALS_ALLOWED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error";
const isGloballyAllowed = /* @__PURE__ */ makeMap(GLOBALS_ALLOWED);
const isGloballyWhitelisted = isGloballyAllowed;
const range = 2;
function generateCodeFrame$1(source, start2 = 0, end = source.length) {
  start2 = Math.max(0, Math.min(start2, source.length));
  end = Math.max(0, Math.min(end, source.length));
  if (start2 > end) return "";
  let lines = source.split(/(\r?\n)/);
  const newlineSequences = lines.filter((_2, idx) => idx % 2 === 1);
  lines = lines.filter((_2, idx) => idx % 2 === 0);
  let count = 0;
  const res = [];
  for (let i2 = 0; i2 < lines.length; i2++) {
    count += lines[i2].length + (newlineSequences[i2] && newlineSequences[i2].length || 0);
    if (count >= start2) {
      for (let j = i2 - range; j <= i2 + range || end > count; j++) {
        if (j < 0 || j >= lines.length) continue;
        const line = j + 1;
        res.push(
          `${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`
        );
        const lineLength = lines[j].length;
        const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;
        if (j === i2) {
          const pad = start2 - (count - (lineLength + newLineSeqLength));
          const length = Math.max(
            1,
            end > count ? lineLength - pad : end - start2
          );
          res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));
        } else if (j > i2) {
          if (end > count) {
            const length = Math.max(Math.min(end - count, lineLength), 1);
            res.push(`   |  ` + "^".repeat(length));
          }
          count += lineLength + newLineSeqLength;
        }
      }
      break;
    }
  }
  return res.join("\n");
}
__name(generateCodeFrame$1, "generateCodeFrame$1");
function normalizeStyle(value3) {
  if (isArray$4(value3)) {
    const res = {};
    for (let i2 = 0; i2 < value3.length; i2++) {
      const item2 = value3[i2];
      const normalized = isString$5(item2) ? parseStringStyle(item2) : normalizeStyle(item2);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString$5(value3) || isObject$6(value3)) {
    return value3;
  }
}
__name(normalizeStyle, "normalizeStyle");
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item2) => {
    if (item2) {
      const tmp = item2.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
__name(parseStringStyle, "parseStringStyle");
function stringifyStyle(styles) {
  let ret = "";
  if (!styles || isString$5(styles)) {
    return ret;
  }
  for (const key in styles) {
    const value3 = styles[key];
    if (isString$5(value3) || typeof value3 === "number") {
      const normalizedKey = key.startsWith(`--`) ? key : hyphenate$1(key);
      ret += `${normalizedKey}:${value3};`;
    }
  }
  return ret;
}
__name(stringifyStyle, "stringifyStyle");
function normalizeClass(value3) {
  let res = "";
  if (isString$5(value3)) {
    res = value3;
  } else if (isArray$4(value3)) {
    for (let i2 = 0; i2 < value3.length; i2++) {
      const normalized = normalizeClass(value3[i2]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$6(value3)) {
    for (const name in value3) {
      if (value3[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
__name(normalizeClass, "normalizeClass");
function normalizeProps(props) {
  if (!props) return null;
  let { class: klass, style } = props;
  if (klass && !isString$5(klass)) {
    props.class = normalizeClass(klass);
  }
  if (style) {
    props.style = normalizeStyle(style);
  }
  return props;
}
__name(normalizeProps, "normalizeProps");
const HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
const SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
const MATH_TAGS = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics";
const VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
const isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
const isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
const isMathMLTag = /* @__PURE__ */ makeMap(MATH_TAGS);
const isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
const isBooleanAttr = /* @__PURE__ */ makeMap(
  specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`
);
function includeBooleanAttr(value3) {
  return !!value3 || value3 === "";
}
__name(includeBooleanAttr, "includeBooleanAttr");
const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
const attrValidationCache = {};
function isSSRSafeAttrName(name) {
  if (attrValidationCache.hasOwnProperty(name)) {
    return attrValidationCache[name];
  }
  const isUnsafe = unsafeAttrCharRE.test(name);
  if (isUnsafe) {
    console.error(`unsafe attribute name: ${name}`);
  }
  return attrValidationCache[name] = !isUnsafe;
}
__name(isSSRSafeAttrName, "isSSRSafeAttrName");
const propsToAttrMap = {
  acceptCharset: "accept-charset",
  className: "class",
  htmlFor: "for",
  httpEquiv: "http-equiv"
};
const isKnownHtmlAttr = /* @__PURE__ */ makeMap(
  `accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`
);
const isKnownSvgAttr = /* @__PURE__ */ makeMap(
  `xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`
);
function isRenderableAttrValue(value3) {
  if (value3 == null) {
    return false;
  }
  const type = typeof value3;
  return type === "string" || type === "number" || type === "boolean";
}
__name(isRenderableAttrValue, "isRenderableAttrValue");
const escapeRE = /["'&<>]/;
function escapeHtml$1(string) {
  const str = "" + string;
  const match = escapeRE.exec(str);
  if (!match) {
    return str;
  }
  let html = "";
  let escaped;
  let index2;
  let lastIndex = 0;
  for (index2 = match.index; index2 < str.length; index2++) {
    switch (str.charCodeAt(index2)) {
      case 34:
        escaped = "&quot;";
        break;
      case 38:
        escaped = "&amp;";
        break;
      case 39:
        escaped = "&#39;";
        break;
      case 60:
        escaped = "&lt;";
        break;
      case 62:
        escaped = "&gt;";
        break;
      default:
        continue;
    }
    if (lastIndex !== index2) {
      html += str.slice(lastIndex, index2);
    }
    lastIndex = index2 + 1;
    html += escaped;
  }
  return lastIndex !== index2 ? html + str.slice(lastIndex, index2) : html;
}
__name(escapeHtml$1, "escapeHtml$1");
const commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
function escapeHtmlComment(src) {
  return src.replace(commentStripRE, "");
}
__name(escapeHtmlComment, "escapeHtmlComment");
function looseCompareArrays(a, b) {
  if (a.length !== b.length) return false;
  let equal = true;
  for (let i2 = 0; equal && i2 < a.length; i2++) {
    equal = looseEqual(a[i2], b[i2]);
  }
  return equal;
}
__name(looseCompareArrays, "looseCompareArrays");
function looseEqual(a, b) {
  if (a === b) return true;
  let aValidType = isDate$3(a);
  let bValidType = isDate$3(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? a.getTime() === b.getTime() : false;
  }
  aValidType = isSymbol$1(a);
  bValidType = isSymbol$1(b);
  if (aValidType || bValidType) {
    return a === b;
  }
  aValidType = isArray$4(a);
  bValidType = isArray$4(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a, b) : false;
  }
  aValidType = isObject$6(a);
  bValidType = isObject$6(b);
  if (aValidType || bValidType) {
    if (!aValidType || !bValidType) {
      return false;
    }
    const aKeysCount = Object.keys(a).length;
    const bKeysCount = Object.keys(b).length;
    if (aKeysCount !== bKeysCount) {
      return false;
    }
    for (const key in a) {
      const aHasKey = a.hasOwnProperty(key);
      const bHasKey = b.hasOwnProperty(key);
      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
        return false;
      }
    }
  }
  return String(a) === String(b);
}
__name(looseEqual, "looseEqual");
function looseIndexOf(arr, val) {
  return arr.findIndex((item2) => looseEqual(item2, val));
}
__name(looseIndexOf, "looseIndexOf");
const isRef$1 = /* @__PURE__ */ __name((val) => {
  return !!(val && val.__v_isRef === true);
}, "isRef$1");
const toDisplayString$1 = /* @__PURE__ */ __name((val) => {
  return isString$5(val) ? val : val == null ? "" : isArray$4(val) || isObject$6(val) && (val.toString === objectToString$1 || !isFunction$4(val.toString)) ? isRef$1(val) ? toDisplayString$1(val.value) : JSON.stringify(val, replacer, 2) : String(val);
}, "toDisplayString$1");
const replacer = /* @__PURE__ */ __name((_key, val) => {
  if (isRef$1(val)) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce(
        (entries, [key, val2], i2) => {
          entries[stringifySymbol(key, i2) + " =>"] = val2;
          return entries;
        },
        {}
      )
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()].map((v2) => stringifySymbol(v2))
    };
  } else if (isSymbol$1(val)) {
    return stringifySymbol(val);
  } else if (isObject$6(val) && !isArray$4(val) && !isPlainObject$3(val)) {
    return String(val);
  }
  return val;
}, "replacer");
const stringifySymbol = /* @__PURE__ */ __name((v2, i2 = "") => {
  var _a;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    isSymbol$1(v2) ? `Symbol(${(_a = v2.description) != null ? _a : i2})` : v2
  );
}, "stringifySymbol");
/**
* @vue/reactivity v3.4.31
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function warn$3(msg, ...args) {
  console.warn(`[Vue warn] ${msg}`, ...args);
}
__name(warn$3, "warn$3");
let activeEffectScope;
class EffectScope {
  static {
    __name(this, "EffectScope");
  }
  constructor(detached = false) {
    this.detached = detached;
    this._active = true;
    this.effects = [];
    this.cleanups = [];
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
        this
      ) - 1;
    }
  }
  get active() {
    return this._active;
  }
  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    } else if (false) {
      warn$3(`cannot run an inactive effect scope.`);
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    activeEffectScope = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this._active) {
      let i2, l;
      for (i2 = 0, l = this.effects.length; i2 < l; i2++) {
        this.effects[i2].stop();
      }
      for (i2 = 0, l = this.cleanups.length; i2 < l; i2++) {
        this.cleanups[i2]();
      }
      if (this.scopes) {
        for (i2 = 0, l = this.scopes.length; i2 < l; i2++) {
          this.scopes[i2].stop(true);
        }
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
      this._active = false;
    }
  }
}
function effectScope(detached) {
  return new EffectScope(detached);
}
__name(effectScope, "effectScope");
function recordEffectScope(effect2, scope = activeEffectScope) {
  if (scope && scope.active) {
    scope.effects.push(effect2);
  }
}
__name(recordEffectScope, "recordEffectScope");
function getCurrentScope() {
  return activeEffectScope;
}
__name(getCurrentScope, "getCurrentScope");
function onScopeDispose(fn) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn);
  } else if (false) {
    warn$3(
      `onScopeDispose() is called when there is no active effect scope to be associated with.`
    );
  }
}
__name(onScopeDispose, "onScopeDispose");
let activeEffect;
class ReactiveEffect {
  static {
    __name(this, "ReactiveEffect");
  }
  constructor(fn, trigger2, scheduler, scope) {
    this.fn = fn;
    this.trigger = trigger2;
    this.scheduler = scheduler;
    this.active = true;
    this.deps = [];
    this._dirtyLevel = 4;
    this._trackId = 0;
    this._runnings = 0;
    this._shouldSchedule = false;
    this._depsLength = 0;
    recordEffectScope(this, scope);
  }
  get dirty() {
    if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {
      this._dirtyLevel = 1;
      pauseTracking();
      for (let i2 = 0; i2 < this._depsLength; i2++) {
        const dep = this.deps[i2];
        if (dep.computed) {
          triggerComputed(dep.computed);
          if (this._dirtyLevel >= 4) {
            break;
          }
        }
      }
      if (this._dirtyLevel === 1) {
        this._dirtyLevel = 0;
      }
      resetTracking();
    }
    return this._dirtyLevel >= 4;
  }
  set dirty(v2) {
    this._dirtyLevel = v2 ? 4 : 0;
  }
  run() {
    this._dirtyLevel = 0;
    if (!this.active) {
      return this.fn();
    }
    let lastShouldTrack = shouldTrack;
    let lastEffect = activeEffect;
    try {
      shouldTrack = true;
      activeEffect = this;
      this._runnings++;
      preCleanupEffect(this);
      return this.fn();
    } finally {
      postCleanupEffect(this);
      this._runnings--;
      activeEffect = lastEffect;
      shouldTrack = lastShouldTrack;
    }
  }
  stop() {
    if (this.active) {
      preCleanupEffect(this);
      postCleanupEffect(this);
      this.onStop && this.onStop();
      this.active = false;
    }
  }
}
function triggerComputed(computed2) {
  return computed2.value;
}
__name(triggerComputed, "triggerComputed");
function preCleanupEffect(effect2) {
  effect2._trackId++;
  effect2._depsLength = 0;
}
__name(preCleanupEffect, "preCleanupEffect");
function postCleanupEffect(effect2) {
  if (effect2.deps.length > effect2._depsLength) {
    for (let i2 = effect2._depsLength; i2 < effect2.deps.length; i2++) {
      cleanupDepEffect(effect2.deps[i2], effect2);
    }
    effect2.deps.length = effect2._depsLength;
  }
}
__name(postCleanupEffect, "postCleanupEffect");
function cleanupDepEffect(dep, effect2) {
  const trackId = dep.get(effect2);
  if (trackId !== void 0 && effect2._trackId !== trackId) {
    dep.delete(effect2);
    if (dep.size === 0) {
      dep.cleanup();
    }
  }
}
__name(cleanupDepEffect, "cleanupDepEffect");
function effect(fn, options3) {
  if (fn.effect instanceof ReactiveEffect) {
    fn = fn.effect.fn;
  }
  const _effect = new ReactiveEffect(fn, NOOP, () => {
    if (_effect.dirty) {
      _effect.run();
    }
  });
  if (options3) {
    extend$1(_effect, options3);
    if (options3.scope) recordEffectScope(_effect, options3.scope);
  }
  if (!options3 || !options3.lazy) {
    _effect.run();
  }
  const runner = _effect.run.bind(_effect);
  runner.effect = _effect;
  return runner;
}
__name(effect, "effect");
function stop(runner) {
  runner.effect.stop();
}
__name(stop, "stop");
let shouldTrack = true;
let pauseScheduleStack = 0;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
__name(pauseTracking, "pauseTracking");
function enableTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = true;
}
__name(enableTracking, "enableTracking");
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
__name(resetTracking, "resetTracking");
function pauseScheduling() {
  pauseScheduleStack++;
}
__name(pauseScheduling, "pauseScheduling");
function resetScheduling() {
  pauseScheduleStack--;
  while (!pauseScheduleStack && queueEffectSchedulers.length) {
    queueEffectSchedulers.shift()();
  }
}
__name(resetScheduling, "resetScheduling");
function trackEffect(effect2, dep, debuggerEventExtraInfo) {
  var _a;
  if (dep.get(effect2) !== effect2._trackId) {
    dep.set(effect2, effect2._trackId);
    const oldDep = effect2.deps[effect2._depsLength];
    if (oldDep !== dep) {
      if (oldDep) {
        cleanupDepEffect(oldDep, effect2);
      }
      effect2.deps[effect2._depsLength++] = dep;
    } else {
      effect2._depsLength++;
    }
    if (false) {
      (_a = effect2.onTrack) == null ? void 0 : _a.call(effect2, extend$1({ effect: effect2 }, debuggerEventExtraInfo));
    }
  }
}
__name(trackEffect, "trackEffect");
const queueEffectSchedulers = [];
function triggerEffects(dep, dirtyLevel, debuggerEventExtraInfo) {
  var _a;
  pauseScheduling();
  for (const effect2 of dep.keys()) {
    let tracking;
    if (effect2._dirtyLevel < dirtyLevel && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
      effect2._shouldSchedule || (effect2._shouldSchedule = effect2._dirtyLevel === 0);
      effect2._dirtyLevel = dirtyLevel;
    }
    if (effect2._shouldSchedule && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
      if (false) {
        (_a = effect2.onTrigger) == null ? void 0 : _a.call(effect2, extend$1({ effect: effect2 }, debuggerEventExtraInfo));
      }
      effect2.trigger();
      if ((!effect2._runnings || effect2.allowRecurse) && effect2._dirtyLevel !== 2) {
        effect2._shouldSchedule = false;
        if (effect2.scheduler) {
          queueEffectSchedulers.push(effect2.scheduler);
        }
      }
    }
  }
  resetScheduling();
}
__name(triggerEffects, "triggerEffects");
const createDep = /* @__PURE__ */ __name((cleanup, computed2) => {
  const dep = /* @__PURE__ */ new Map();
  dep.cleanup = cleanup;
  dep.computed = computed2;
  return dep;
}, "createDep");
const targetMap = /* @__PURE__ */ new WeakMap();
const ITERATE_KEY = Symbol(false ? "iterate" : "");
const MAP_KEY_ITERATE_KEY = Symbol(false ? "Map key iterate" : "");
function track(target, type, key) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = createDep(() => depsMap.delete(key)));
    }
    trackEffect(
      activeEffect,
      dep,
      false ? {
        target,
        type,
        key
      } : void 0
    );
  }
}
__name(track, "track");
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type === "clear") {
    deps = [...depsMap.values()];
  } else if (key === "length" && isArray$4(target)) {
    const newLength = Number(newValue);
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || !isSymbol$1(key2) && key2 >= newLength) {
        deps.push(dep);
      }
    });
  } else {
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!isArray$4(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray$4(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  pauseScheduling();
  for (const dep of deps) {
    if (dep) {
      triggerEffects(
        dep,
        4,
        false ? {
          target,
          type,
          key,
          newValue,
          oldValue,
          oldTarget
        } : void 0
      );
    }
  }
  resetScheduling();
}
__name(trigger, "trigger");
function getDepFromReactive(object, key) {
  const depsMap = targetMap.get(object);
  return depsMap && depsMap.get(key);
}
__name(getDepFromReactive, "getDepFromReactive");
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol$1)
);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i2 = 0, l = this.length; i2 < l; i2++) {
        track(arr, "get", i2 + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function(...args) {
      pauseTracking();
      pauseScheduling();
      const res = toRaw(this)[key].apply(this, args);
      resetScheduling();
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
__name(createArrayInstrumentations, "createArrayInstrumentations");
function hasOwnProperty$2(key) {
  if (!isSymbol$1(key)) key = String(key);
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
__name(hasOwnProperty$2, "hasOwnProperty$2");
class BaseReactiveHandler {
  static {
    __name(this, "BaseReactiveHandler");
  }
  constructor(_isReadonly = false, _isShallow = false) {
    this._isReadonly = _isReadonly;
    this._isShallow = _isShallow;
  }
  get(target, key, receiver) {
    const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return isShallow2;
    } else if (key === "__v_raw") {
      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
      // this means the reciever is a user proxy of the reactive proxy
      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
        return target;
      }
      return;
    }
    const targetIsArray = isArray$4(target);
    if (!isReadonly2) {
      if (targetIsArray && hasOwn$3(arrayInstrumentations, key)) {
        return Reflect.get(arrayInstrumentations, key, receiver);
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty$2;
      }
    }
    const res = Reflect.get(target, key, receiver);
    if (isSymbol$1(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (isShallow2) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject$6(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  }
}
class MutableReactiveHandler extends BaseReactiveHandler {
  static {
    __name(this, "MutableReactiveHandler");
  }
  constructor(isShallow2 = false) {
    super(false, isShallow2);
  }
  set(target, key, value3, receiver) {
    let oldValue = target[key];
    if (!this._isShallow) {
      const isOldValueReadonly = isReadonly(oldValue);
      if (!isShallow(value3) && !isReadonly(value3)) {
        oldValue = toRaw(oldValue);
        value3 = toRaw(value3);
      }
      if (!isArray$4(target) && isRef(oldValue) && !isRef(value3)) {
        if (isOldValueReadonly) {
          return false;
        } else {
          oldValue.value = value3;
          return true;
        }
      }
    }
    const hadKey = isArray$4(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn$3(target, key);
    const result = Reflect.set(target, key, value3, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value3);
      } else if (hasChanged(value3, oldValue)) {
        trigger(target, "set", key, value3, oldValue);
      }
    }
    return result;
  }
  deleteProperty(target, key) {
    const hadKey = hasOwn$3(target, key);
    const oldValue = target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0, oldValue);
    }
    return result;
  }
  has(target, key) {
    const result = Reflect.has(target, key);
    if (!isSymbol$1(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  ownKeys(target) {
    track(
      target,
      "iterate",
      isArray$4(target) ? "length" : ITERATE_KEY
    );
    return Reflect.ownKeys(target);
  }
}
class ReadonlyReactiveHandler extends BaseReactiveHandler {
  static {
    __name(this, "ReadonlyReactiveHandler");
  }
  constructor(isShallow2 = false) {
    super(true, isShallow2);
  }
  set(target, key) {
    if (false) {
      warn$3(
        `Set operation on key "${String(key)}" failed: target is readonly.`,
        target
      );
    }
    return true;
  }
  deleteProperty(target, key) {
    if (false) {
      warn$3(
        `Delete operation on key "${String(key)}" failed: target is readonly.`,
        target
      );
    }
    return true;
  }
}
const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(
  true
);
const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
const toShallow = /* @__PURE__ */ __name((value3) => value3, "toShallow");
const getProto = /* @__PURE__ */ __name((v2) => Reflect.getPrototypeOf(v2), "getProto");
function get$2(target, key, isReadonly2 = false, isShallow2 = false) {
  target = target["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (hasChanged(key, rawKey)) {
      track(rawTarget, "get", key);
    }
    track(rawTarget, "get", rawKey);
  }
  const { has: has2 } = getProto(rawTarget);
  const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive$1;
  if (has2.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
__name(get$2, "get$2");
function has(key, isReadonly2 = false) {
  const target = this["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (hasChanged(key, rawKey)) {
      track(rawTarget, "has", key);
    }
    track(rawTarget, "has", rawKey);
  }
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
__name(has, "has");
function size(target, isReadonly2 = false) {
  target = target["__v_raw"];
  !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
__name(size, "size");
function add(value3) {
  value3 = toRaw(value3);
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value3);
  if (!hadKey) {
    target.add(value3);
    trigger(target, "add", value3, value3);
  }
  return this;
}
__name(add, "add");
function set$4(key, value3) {
  value3 = toRaw(value3);
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  } else if (false) {
    checkIdentityKeys(target, has2, key);
  }
  const oldValue = get2.call(target, key);
  target.set(key, value3);
  if (!hadKey) {
    trigger(target, "add", key, value3);
  } else if (hasChanged(value3, oldValue)) {
    trigger(target, "set", key, value3, oldValue);
  }
  return this;
}
__name(set$4, "set$4");
function deleteEntry(key) {
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  } else if (false) {
    checkIdentityKeys(target, has2, key);
  }
  const oldValue = get2 ? get2.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger(target, "delete", key, void 0, oldValue);
  }
  return result;
}
__name(deleteEntry, "deleteEntry");
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const oldTarget = false ? isMap(target) ? new Map(target) : new Set(target) : void 0;
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0, oldTarget);
  }
  return result;
}
__name(clear, "clear");
function createForEach(isReadonly2, isShallow2) {
  return /* @__PURE__ */ __name(function forEach2(callback, thisArg) {
    const observed = this;
    const target = observed["__v_raw"];
    const rawTarget = toRaw(target);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive$1;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value3, key) => {
      return callback.call(thisArg, wrap(value3), wrap(key), observed);
    });
  }, "forEach");
}
__name(createForEach, "createForEach");
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive$1;
    !isReadonly2 && track(
      rawTarget,
      "iterate",
      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
    );
    return {
      // iterator protocol
      next() {
        const { value: value3, done } = innerIterator.next();
        return done ? { value: value3, done } : {
          value: isPair ? [wrap(value3[0]), wrap(value3[1])] : wrap(value3),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
__name(createIterableMethod, "createIterableMethod");
function createReadonlyMethod(type) {
  return function(...args) {
    if (false) {
      const key = args[0] ? `on key "${args[0]}" ` : ``;
      warn$3(
        `${capitalize$1(type)} operation ${key}failed: target is readonly.`,
        toRaw(this)
      );
    }
    return type === "delete" ? false : type === "clear" ? void 0 : this;
  };
}
__name(createReadonlyMethod, "createReadonlyMethod");
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get$2(this, key);
    },
    get size() {
      return size(this);
    },
    has,
    add,
    set: set$4,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get$2(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has,
    add,
    set: set$4,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get$2(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get$2(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
    shallowInstrumentations2[method] = createIterableMethod(method, false, true);
    shallowReadonlyInstrumentations2[method] = createIterableMethod(
      method,
      true,
      true
    );
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
__name(createInstrumentations, "createInstrumentations");
const [
  mutableInstrumentations,
  readonlyInstrumentations,
  shallowInstrumentations,
  shallowReadonlyInstrumentations
] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(
      hasOwn$3(instrumentations, key) && key in target ? instrumentations : target,
      key,
      receiver
    );
  };
}
__name(createInstrumentationGetter, "createInstrumentationGetter");
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};
function checkIdentityKeys(target, has2, key) {
  const rawKey = toRaw(key);
  if (rawKey !== key && has2.call(target, rawKey)) {
    const type = toRawType(target);
    warn$3(
      `Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
    );
  }
}
__name(checkIdentityKeys, "checkIdentityKeys");
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
__name(targetTypeMap, "targetTypeMap");
function getTargetType(value3) {
  return value3["__v_skip"] || !Object.isExtensible(value3) ? 0 : targetTypeMap(toRawType(value3));
}
__name(getTargetType, "getTargetType");
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  );
}
__name(reactive, "reactive");
function shallowReactive(target) {
  return createReactiveObject(
    target,
    false,
    shallowReactiveHandlers,
    shallowCollectionHandlers,
    shallowReactiveMap
  );
}
__name(shallowReactive, "shallowReactive");
function readonly(target) {
  return createReactiveObject(
    target,
    true,
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap
  );
}
__name(readonly, "readonly");
function shallowReadonly(target) {
  return createReactiveObject(
    target,
    true,
    shallowReadonlyHandlers,
    shallowReadonlyCollectionHandlers,
    shallowReadonlyMap
  );
}
__name(shallowReadonly, "shallowReadonly");
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$6(target)) {
    if (false) {
      warn$3(
        `value cannot be made ${isReadonly2 ? "readonly" : "reactive"}: ${String(
          target
        )}`
      );
    }
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(
    target,
    targetType === 2 ? collectionHandlers : baseHandlers
  );
  proxyMap.set(target, proxy);
  return proxy;
}
__name(createReactiveObject, "createReactiveObject");
function isReactive(value3) {
  if (isReadonly(value3)) {
    return isReactive(value3["__v_raw"]);
  }
  return !!(value3 && value3["__v_isReactive"]);
}
__name(isReactive, "isReactive");
function isReadonly(value3) {
  return !!(value3 && value3["__v_isReadonly"]);
}
__name(isReadonly, "isReadonly");
function isShallow(value3) {
  return !!(value3 && value3["__v_isShallow"]);
}
__name(isShallow, "isShallow");
function isProxy(value3) {
  return value3 ? !!value3["__v_raw"] : false;
}
__name(isProxy, "isProxy");
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
__name(toRaw, "toRaw");
function markRaw(value3) {
  if (Object.isExtensible(value3)) {
    def(value3, "__v_skip", true);
  }
  return value3;
}
__name(markRaw, "markRaw");
const toReactive$1 = /* @__PURE__ */ __name((value3) => isObject$6(value3) ? reactive(value3) : value3, "toReactive$1");
const toReadonly = /* @__PURE__ */ __name((value3) => isObject$6(value3) ? readonly(value3) : value3, "toReadonly");
const COMPUTED_SIDE_EFFECT_WARN = `Computed is still dirty after getter evaluation, likely because a computed is mutating its own dependency in its getter. State mutations in computed getters should be avoided.  Check the docs for more details: https://vuejs.org/guide/essentials/computed.html#getters-should-be-side-effect-free`;
class ComputedRefImpl {
  static {
    __name(this, "ComputedRefImpl");
  }
  constructor(getter, _setter, isReadonly2, isSSR) {
    this.getter = getter;
    this._setter = _setter;
    this.dep = void 0;
    this.__v_isRef = true;
    this["__v_isReadonly"] = false;
    this.effect = new ReactiveEffect(
      () => getter(this._value),
      () => triggerRefValue(
        this,
        this.effect._dirtyLevel === 2 ? 2 : 3
      )
    );
    this.effect.computed = this;
    this.effect.active = this._cacheable = !isSSR;
    this["__v_isReadonly"] = isReadonly2;
  }
  get value() {
    const self2 = toRaw(this);
    if ((!self2._cacheable || self2.effect.dirty) && hasChanged(self2._value, self2._value = self2.effect.run())) {
      triggerRefValue(self2, 4);
    }
    trackRefValue(self2);
    if (self2.effect._dirtyLevel >= 2) {
      if (false) {
        warn$3(COMPUTED_SIDE_EFFECT_WARN, `

getter: `, this.getter);
      }
      triggerRefValue(self2, 2);
    }
    return self2._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
  // #region polyfill _dirty for backward compatibility third party code for Vue <= 3.3.x
  get _dirty() {
    return this.effect.dirty;
  }
  set _dirty(v2) {
    this.effect.dirty = v2;
  }
  // #endregion
}
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  const onlyGetter = isFunction$4(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = false ? () => {
      warn$3("Write operation failed: computed value is readonly");
    } : NOOP;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
  if (false) {
    cRef.effect.onTrack = debugOptions.onTrack;
    cRef.effect.onTrigger = debugOptions.onTrigger;
  }
  return cRef;
}
__name(computed$1, "computed$1");
function trackRefValue(ref2) {
  var _a;
  if (shouldTrack && activeEffect) {
    ref2 = toRaw(ref2);
    trackEffect(
      activeEffect,
      (_a = ref2.dep) != null ? _a : ref2.dep = createDep(
        () => ref2.dep = void 0,
        ref2 instanceof ComputedRefImpl ? ref2 : void 0
      ),
      false ? {
        target: ref2,
        type: "get",
        key: "value"
      } : void 0
    );
  }
}
__name(trackRefValue, "trackRefValue");
function triggerRefValue(ref2, dirtyLevel = 4, newVal, oldVal) {
  ref2 = toRaw(ref2);
  const dep = ref2.dep;
  if (dep) {
    triggerEffects(
      dep,
      dirtyLevel,
      false ? {
        target: ref2,
        type: "set",
        key: "value",
        newValue: newVal,
        oldValue: oldVal
      } : void 0
    );
  }
}
__name(triggerRefValue, "triggerRefValue");
function isRef(r) {
  return !!(r && r.__v_isRef === true);
}
__name(isRef, "isRef");
function ref(value3) {
  return createRef(value3, false);
}
__name(ref, "ref");
function shallowRef(value3) {
  return createRef(value3, true);
}
__name(shallowRef, "shallowRef");
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
__name(createRef, "createRef");
class RefImpl {
  static {
    __name(this, "RefImpl");
  }
  constructor(value3, __v_isShallow) {
    this.__v_isShallow = __v_isShallow;
    this.dep = void 0;
    this.__v_isRef = true;
    this._rawValue = __v_isShallow ? value3 : toRaw(value3);
    this._value = __v_isShallow ? value3 : toReactive$1(value3);
  }
  get value() {
    trackRefValue(this);
    return this._value;
  }
  set value(newVal) {
    const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
    newVal = useDirectValue ? newVal : toRaw(newVal);
    if (hasChanged(newVal, this._rawValue)) {
      const oldVal = this._rawValue;
      this._rawValue = newVal;
      this._value = useDirectValue ? newVal : toReactive$1(newVal);
      triggerRefValue(this, 4, newVal, oldVal);
    }
  }
}
function triggerRef(ref2) {
  triggerRefValue(ref2, 4, false ? ref2.value : void 0);
}
__name(triggerRef, "triggerRef");
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
__name(unref, "unref");
function toValue$2(source) {
  return isFunction$4(source) ? source() : unref(source);
}
__name(toValue$2, "toValue$2");
const shallowUnwrapHandlers = {
  get: /* @__PURE__ */ __name((target, key, receiver) => unref(Reflect.get(target, key, receiver)), "get"),
  set: /* @__PURE__ */ __name((target, key, value3, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value3)) {
      oldValue.value = value3;
      return true;
    } else {
      return Reflect.set(target, key, value3, receiver);
    }
  }, "set")
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
__name(proxyRefs, "proxyRefs");
class CustomRefImpl {
  static {
    __name(this, "CustomRefImpl");
  }
  constructor(factory) {
    this.dep = void 0;
    this.__v_isRef = true;
    const { get: get2, set: set2 } = factory(
      () => trackRefValue(this),
      () => triggerRefValue(this)
    );
    this._get = get2;
    this._set = set2;
  }
  get value() {
    return this._get();
  }
  set value(newVal) {
    this._set(newVal);
  }
}
function customRef(factory) {
  return new CustomRefImpl(factory);
}
__name(customRef, "customRef");
function toRefs$1(object) {
  if (false) {
    warn$3(`toRefs() expects a reactive object but received a plain one.`);
  }
  const ret = isArray$4(object) ? new Array(object.length) : {};
  for (const key in object) {
    ret[key] = propertyToRef(object, key);
  }
  return ret;
}
__name(toRefs$1, "toRefs$1");
class ObjectRefImpl {
  static {
    __name(this, "ObjectRefImpl");
  }
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this.__v_isRef = true;
  }
  get value() {
    const val = this._object[this._key];
    return val === void 0 ? this._defaultValue : val;
  }
  set value(newVal) {
    this._object[this._key] = newVal;
  }
  get dep() {
    return getDepFromReactive(toRaw(this._object), this._key);
  }
}
class GetterRefImpl {
  static {
    __name(this, "GetterRefImpl");
  }
  constructor(_getter) {
    this._getter = _getter;
    this.__v_isRef = true;
    this.__v_isReadonly = true;
  }
  get value() {
    return this._getter();
  }
}
function toRef$1(source, key, defaultValue) {
  if (isRef(source)) {
    return source;
  } else if (isFunction$4(source)) {
    return new GetterRefImpl(source);
  } else if (isObject$6(source) && arguments.length > 1) {
    return propertyToRef(source, key, defaultValue);
  } else {
    return ref(source);
  }
}
__name(toRef$1, "toRef$1");
function propertyToRef(source, key, defaultValue) {
  const val = source[key];
  return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
}
__name(propertyToRef, "propertyToRef");
const deferredComputed = computed$1;
const TrackOpTypes = {
  "GET": "get",
  "HAS": "has",
  "ITERATE": "iterate"
};
const TriggerOpTypes = {
  "SET": "set",
  "ADD": "add",
  "DELETE": "delete",
  "CLEAR": "clear"
};
const ReactiveFlags = {
  "SKIP": "__v_skip",
  "IS_REACTIVE": "__v_isReactive",
  "IS_READONLY": "__v_isReadonly",
  "IS_SHALLOW": "__v_isShallow",
  "RAW": "__v_raw"
};
/**
* @vue/runtime-core v3.4.31
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const stack = [];
function pushWarningContext(vnode) {
  stack.push(vnode);
}
__name(pushWarningContext, "pushWarningContext");
function popWarningContext() {
  stack.pop();
}
__name(popWarningContext, "popWarningContext");
function warn$1(msg, ...args) {
  pauseTracking();
  const instance = stack.length ? stack[stack.length - 1].component : null;
  const appWarnHandler = instance && instance.appContext.config.warnHandler;
  const trace = getComponentTrace();
  if (appWarnHandler) {
    callWithErrorHandling(
      appWarnHandler,
      instance,
      11,
      [
        // eslint-disable-next-line no-restricted-syntax
        msg + args.map((a) => {
          var _a, _b;
          return (_b = (_a = a.toString) == null ? void 0 : _a.call(a)) != null ? _b : JSON.stringify(a);
        }).join(""),
        instance && instance.proxy,
        trace.map(
          ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
        ).join("\n"),
        trace
      ]
    );
  } else {
    const warnArgs = [`[Vue warn]: ${msg}`, ...args];
    if (trace.length && // avoid spamming console during tests
    true) {
      warnArgs.push(`
`, ...formatTrace(trace));
    }
    console.warn(...warnArgs);
  }
  resetTracking();
}
__name(warn$1, "warn$1");
function getComponentTrace() {
  let currentVNode = stack[stack.length - 1];
  if (!currentVNode) {
    return [];
  }
  const normalizedStack = [];
  while (currentVNode) {
    const last = normalizedStack[0];
    if (last && last.vnode === currentVNode) {
      last.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }
    const parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }
  return normalizedStack;
}
__name(getComponentTrace, "getComponentTrace");
function formatTrace(trace) {
  const logs = [];
  trace.forEach((entry, i2) => {
    logs.push(...i2 === 0 ? [] : [`
`], ...formatTraceEntry(entry));
  });
  return logs;
}
__name(formatTrace, "formatTrace");
function formatTraceEntry({ vnode, recurseCount }) {
  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode.component ? vnode.component.parent == null : false;
  const open2 = ` at <${formatComponentName(
    vnode.component,
    vnode.type,
    isRoot
  )}`;
  const close4 = `>` + postfix;
  return vnode.props ? [open2, ...formatProps(vnode.props), close4] : [open2 + close4];
}
__name(formatTraceEntry, "formatTraceEntry");
function formatProps(props) {
  const res = [];
  const keys2 = Object.keys(props);
  keys2.slice(0, 3).forEach((key) => {
    res.push(...formatProp(key, props[key]));
  });
  if (keys2.length > 3) {
    res.push(` ...`);
  }
  return res;
}
__name(formatProps, "formatProps");
function formatProp(key, value3, raw) {
  if (isString$5(value3)) {
    value3 = JSON.stringify(value3);
    return raw ? value3 : [`${key}=${value3}`];
  } else if (typeof value3 === "number" || typeof value3 === "boolean" || value3 == null) {
    return raw ? value3 : [`${key}=${value3}`];
  } else if (isRef(value3)) {
    value3 = formatProp(key, toRaw(value3.value), true);
    return raw ? value3 : [`${key}=Ref<`, value3, `>`];
  } else if (isFunction$4(value3)) {
    return [`${key}=fn${value3.name ? `<${value3.name}>` : ``}`];
  } else {
    value3 = toRaw(value3);
    return raw ? value3 : [`${key}=`, value3];
  }
}
__name(formatProp, "formatProp");
function assertNumber(val, type) {
  if (true) return;
  if (val === void 0) {
    return;
  } else if (typeof val !== "number") {
    warn$1(`${type} is not a valid number - got ${JSON.stringify(val)}.`);
  } else if (isNaN(val)) {
    warn$1(`${type} is NaN - the duration expression might be incorrect.`);
  }
}
__name(assertNumber, "assertNumber");
const ErrorCodes = {
  "SETUP_FUNCTION": 0,
  "0": "SETUP_FUNCTION",
  "RENDER_FUNCTION": 1,
  "1": "RENDER_FUNCTION",
  "WATCH_GETTER": 2,
  "2": "WATCH_GETTER",
  "WATCH_CALLBACK": 3,
  "3": "WATCH_CALLBACK",
  "WATCH_CLEANUP": 4,
  "4": "WATCH_CLEANUP",
  "NATIVE_EVENT_HANDLER": 5,
  "5": "NATIVE_EVENT_HANDLER",
  "COMPONENT_EVENT_HANDLER": 6,
  "6": "COMPONENT_EVENT_HANDLER",
  "VNODE_HOOK": 7,
  "7": "VNODE_HOOK",
  "DIRECTIVE_HOOK": 8,
  "8": "DIRECTIVE_HOOK",
  "TRANSITION_HOOK": 9,
  "9": "TRANSITION_HOOK",
  "APP_ERROR_HANDLER": 10,
  "10": "APP_ERROR_HANDLER",
  "APP_WARN_HANDLER": 11,
  "11": "APP_WARN_HANDLER",
  "FUNCTION_REF": 12,
  "12": "FUNCTION_REF",
  "ASYNC_COMPONENT_LOADER": 13,
  "13": "ASYNC_COMPONENT_LOADER",
  "SCHEDULER": 14,
  "14": "SCHEDULER"
};
const ErrorTypeStrings$1 = {
  ["sp"]: "serverPrefetch hook",
  ["bc"]: "beforeCreate hook",
  ["c"]: "created hook",
  ["bm"]: "beforeMount hook",
  ["m"]: "mounted hook",
  ["bu"]: "beforeUpdate hook",
  ["u"]: "updated",
  ["bum"]: "beforeUnmount hook",
  ["um"]: "unmounted hook",
  ["a"]: "activated hook",
  ["da"]: "deactivated hook",
  ["ec"]: "errorCaptured hook",
  ["rtc"]: "renderTracked hook",
  ["rtg"]: "renderTriggered hook",
  [0]: "setup function",
  [1]: "render function",
  [2]: "watcher getter",
  [3]: "watcher callback",
  [4]: "watcher cleanup function",
  [5]: "native event handler",
  [6]: "component event handler",
  [7]: "vnode hook",
  [8]: "directive hook",
  [9]: "transition hook",
  [10]: "app errorHandler",
  [11]: "app warnHandler",
  [12]: "ref function",
  [13]: "async component loader",
  [14]: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://github.com/vuejs/core ."
};
function callWithErrorHandling(fn, instance, type, args) {
  try {
    return args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
}
__name(callWithErrorHandling, "callWithErrorHandling");
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if (isFunction$4(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && isPromise$2(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  if (isArray$4(fn)) {
    const values2 = [];
    for (let i2 = 0; i2 < fn.length; i2++) {
      values2.push(callWithAsyncErrorHandling(fn[i2], instance, type, args));
    }
    return values2;
  } else if (false) {
    warn$1(
      `Invalid value type passed to callWithAsyncErrorHandling(): ${typeof fn}`
    );
  }
}
__name(callWithAsyncErrorHandling, "callWithAsyncErrorHandling");
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = false ? ErrorTypeStrings$1[type] : `https://vuejs.org/error-reference/#runtime-${type}`;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i2 = 0; i2 < errorCapturedHooks.length; i2++) {
          if (errorCapturedHooks[i2](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance.appContext.config.errorHandler;
    if (appErrorHandler) {
      pauseTracking();
      callWithErrorHandling(
        appErrorHandler,
        null,
        10,
        [err, exposedInstance, errorInfo]
      );
      resetTracking();
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev);
}
__name(handleError, "handleError");
function logError(err, type, contextVNode, throwInDev = true) {
  if (false) {
    const info = ErrorTypeStrings$1[type];
    if (contextVNode) {
      pushWarningContext(contextVNode);
    }
    warn$1(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
    if (contextVNode) {
      popWarningContext();
    }
    if (throwInDev) {
      throw err;
    } else {
      console.error(err);
    }
  } else {
    console.error(err);
  }
}
__name(logError, "logError");
let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
const RECURSION_LIMIT = 100;
function nextTick(fn) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
}
__name(nextTick, "nextTick");
function findInsertionIndex(id2) {
  let start2 = flushIndex + 1;
  let end = queue.length;
  while (start2 < end) {
    const middle = start2 + end >>> 1;
    const middleJob = queue[middle];
    const middleJobId = getId(middleJob);
    if (middleJobId < id2 || middleJobId === id2 && middleJob.pre) {
      start2 = middle + 1;
    } else {
      end = middle;
    }
  }
  return start2;
}
__name(findInsertionIndex, "findInsertionIndex");
function queueJob(job) {
  if (!queue.length || !queue.includes(
    job,
    isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
  )) {
    if (job.id == null) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(job.id), 0, job);
    }
    queueFlush();
  }
}
__name(queueJob, "queueJob");
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
__name(queueFlush, "queueFlush");
function invalidateJob(job) {
  const i2 = queue.indexOf(job);
  if (i2 > flushIndex) {
    queue.splice(i2, 1);
  }
}
__name(invalidateJob, "invalidateJob");
function queuePostFlushCb(cb) {
  if (!isArray$4(cb)) {
    if (!activePostFlushCbs || !activePostFlushCbs.includes(
      cb,
      cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex
    )) {
      pendingPostFlushCbs.push(cb);
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
__name(queuePostFlushCb, "queuePostFlushCb");
function flushPreFlushCbs(instance, seen2, i2 = isFlushing ? flushIndex + 1 : 0) {
  if (false) {
    seen2 = seen2 || /* @__PURE__ */ new Map();
  }
  for (; i2 < queue.length; i2++) {
    const cb = queue[i2];
    if (cb && cb.pre) {
      if (instance && cb.id !== instance.uid) {
        continue;
      }
      if (false) {
        continue;
      }
      queue.splice(i2, 1);
      i2--;
      cb();
    }
  }
}
__name(flushPreFlushCbs, "flushPreFlushCbs");
function flushPostFlushCbs(seen2) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)].sort(
      (a, b) => getId(a) - getId(b)
    );
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    if (false) {
      seen2 = seen2 || /* @__PURE__ */ new Map();
    }
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      const cb = activePostFlushCbs[postFlushIndex];
      if (false) {
        continue;
      }
      if (cb.active !== false) cb();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
__name(flushPostFlushCbs, "flushPostFlushCbs");
const getId = /* @__PURE__ */ __name((job) => job.id == null ? Infinity : job.id, "getId");
const comparator = /* @__PURE__ */ __name((a, b) => {
  const diff = getId(a) - getId(b);
  if (diff === 0) {
    if (a.pre && !b.pre) return -1;
    if (b.pre && !a.pre) return 1;
  }
  return diff;
}, "comparator");
function flushJobs(seen2) {
  isFlushPending = false;
  isFlushing = true;
  if (false) {
    seen2 = seen2 || /* @__PURE__ */ new Map();
  }
  queue.sort(comparator);
  const check = false ? (job) => checkRecursiveUpdates(seen2, job) : NOOP;
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && job.active !== false) {
        if (false) {
          continue;
        }
        callWithErrorHandling(job, null, 14);
      }
    }
  } finally {
    flushIndex = 0;
    queue.length = 0;
    flushPostFlushCbs(seen2);
    isFlushing = false;
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs(seen2);
    }
  }
}
__name(flushJobs, "flushJobs");
function checkRecursiveUpdates(seen2, fn) {
  if (!seen2.has(fn)) {
    seen2.set(fn, 1);
  } else {
    const count = seen2.get(fn);
    if (count > RECURSION_LIMIT) {
      const instance = fn.ownerInstance;
      const componentName = instance && getComponentName(instance.type);
      handleError(
        `Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,
        null,
        10
      );
      return true;
    } else {
      seen2.set(fn, count + 1);
    }
  }
}
__name(checkRecursiveUpdates, "checkRecursiveUpdates");
let isHmrUpdating = false;
const hmrDirtyComponents = /* @__PURE__ */ new Set();
if (false) {
  getGlobalThis$1().__VUE_HMR_RUNTIME__ = {
    createRecord: tryWrap(createRecord),
    rerender: tryWrap(rerender),
    reload: tryWrap(reload)
  };
}
const map = /* @__PURE__ */ new Map();
function registerHMR(instance) {
  const id2 = instance.type.__hmrId;
  let record = map.get(id2);
  if (!record) {
    createRecord(id2, instance.type);
    record = map.get(id2);
  }
  record.instances.add(instance);
}
__name(registerHMR, "registerHMR");
function unregisterHMR(instance) {
  map.get(instance.type.__hmrId).instances.delete(instance);
}
__name(unregisterHMR, "unregisterHMR");
function createRecord(id2, initialDef) {
  if (map.has(id2)) {
    return false;
  }
  map.set(id2, {
    initialDef: normalizeClassComponent(initialDef),
    instances: /* @__PURE__ */ new Set()
  });
  return true;
}
__name(createRecord, "createRecord");
function normalizeClassComponent(component) {
  return isClassComponent(component) ? component.__vccOpts : component;
}
__name(normalizeClassComponent, "normalizeClassComponent");
function rerender(id2, newRender) {
  const record = map.get(id2);
  if (!record) {
    return;
  }
  record.initialDef.render = newRender;
  [...record.instances].forEach((instance) => {
    if (newRender) {
      instance.render = newRender;
      normalizeClassComponent(instance.type).render = newRender;
    }
    instance.renderCache = [];
    isHmrUpdating = true;
    instance.effect.dirty = true;
    instance.update();
    isHmrUpdating = false;
  });
}
__name(rerender, "rerender");
function reload(id2, newComp) {
  const record = map.get(id2);
  if (!record) return;
  newComp = normalizeClassComponent(newComp);
  updateComponentDef(record.initialDef, newComp);
  const instances = [...record.instances];
  for (const instance of instances) {
    const oldComp = normalizeClassComponent(instance.type);
    if (!hmrDirtyComponents.has(oldComp)) {
      if (oldComp !== record.initialDef) {
        updateComponentDef(oldComp, newComp);
      }
      hmrDirtyComponents.add(oldComp);
    }
    instance.appContext.propsCache.delete(instance.type);
    instance.appContext.emitsCache.delete(instance.type);
    instance.appContext.optionsCache.delete(instance.type);
    if (instance.ceReload) {
      hmrDirtyComponents.add(oldComp);
      instance.ceReload(newComp.styles);
      hmrDirtyComponents.delete(oldComp);
    } else if (instance.parent) {
      instance.parent.effect.dirty = true;
      queueJob(() => {
        instance.parent.update();
        hmrDirtyComponents.delete(oldComp);
      });
    } else if (instance.appContext.reload) {
      instance.appContext.reload();
    } else if (typeof window !== "undefined") {
      window.location.reload();
    } else {
      console.warn(
        "[HMR] Root or manually mounted instance modified. Full reload required."
      );
    }
  }
  queuePostFlushCb(() => {
    for (const instance of instances) {
      hmrDirtyComponents.delete(
        normalizeClassComponent(instance.type)
      );
    }
  });
}
__name(reload, "reload");
function updateComponentDef(oldComp, newComp) {
  extend$1(oldComp, newComp);
  for (const key in oldComp) {
    if (key !== "__file" && !(key in newComp)) {
      delete oldComp[key];
    }
  }
}
__name(updateComponentDef, "updateComponentDef");
function tryWrap(fn) {
  return (id2, arg) => {
    try {
      return fn(id2, arg);
    } catch (e) {
      console.error(e);
      console.warn(
        `[HMR] Something went wrong during Vue component hot-reload. Full reload required.`
      );
    }
  };
}
__name(tryWrap, "tryWrap");
let devtools$1;
let buffer = [];
let devtoolsNotInstalled = false;
function emit$1(event2, ...args) {
  if (devtools$1) {
    devtools$1.emit(event2, ...args);
  } else if (!devtoolsNotInstalled) {
    buffer.push({ event: event2, args });
  }
}
__name(emit$1, "emit$1");
function setDevtoolsHook$1(hook, target) {
  var _a, _b;
  devtools$1 = hook;
  if (devtools$1) {
    devtools$1.enabled = true;
    buffer.forEach(({ event: event2, args }) => devtools$1.emit(event2, ...args));
    buffer = [];
  } else if (
    // handle late devtools injection - only do this if we are in an actual
    // browser environment to avoid the timer handle stalling test runner exit
    // (#4815)
    typeof window !== "undefined" && // some envs mock window but not fully
    window.HTMLElement && // also exclude jsdom
    // eslint-disable-next-line no-restricted-syntax
    !((_b = (_a = window.navigator) == null ? void 0 : _a.userAgent) == null ? void 0 : _b.includes("jsdom"))
  ) {
    const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
    replay.push((newHook) => {
      setDevtoolsHook$1(newHook, target);
    });
    setTimeout(() => {
      if (!devtools$1) {
        target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
        devtoolsNotInstalled = true;
        buffer = [];
      }
    }, 3e3);
  } else {
    devtoolsNotInstalled = true;
    buffer = [];
  }
}
__name(setDevtoolsHook$1, "setDevtoolsHook$1");
function devtoolsInitApp(app2, version2) {
  emit$1("app:init", app2, version2, {
    Fragment,
    Text,
    Comment,
    Static
  });
}
__name(devtoolsInitApp, "devtoolsInitApp");
function devtoolsUnmountApp(app2) {
  emit$1("app:unmount", app2);
}
__name(devtoolsUnmountApp, "devtoolsUnmountApp");
const devtoolsComponentAdded = /* @__PURE__ */ createDevtoolsComponentHook(
  "component:added"
  /* COMPONENT_ADDED */
);
const devtoolsComponentUpdated = /* @__PURE__ */ createDevtoolsComponentHook(
  "component:updated"
  /* COMPONENT_UPDATED */
);
const _devtoolsComponentRemoved = /* @__PURE__ */ createDevtoolsComponentHook(
  "component:removed"
  /* COMPONENT_REMOVED */
);
const devtoolsComponentRemoved = /* @__PURE__ */ __name((component) => {
  if (devtools$1 && typeof devtools$1.cleanupBuffer === "function" && // remove the component if it wasn't buffered
  !devtools$1.cleanupBuffer(component)) {
    _devtoolsComponentRemoved(component);
  }
}, "devtoolsComponentRemoved");
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function createDevtoolsComponentHook(hook) {
  return (component) => {
    emit$1(
      hook,
      component.appContext.app,
      component.uid,
      component.parent ? component.parent.uid : void 0,
      component
    );
  };
}
__name(createDevtoolsComponentHook, "createDevtoolsComponentHook");
const devtoolsPerfStart = /* @__PURE__ */ createDevtoolsPerformanceHook(
  "perf:start"
  /* PERFORMANCE_START */
);
const devtoolsPerfEnd = /* @__PURE__ */ createDevtoolsPerformanceHook(
  "perf:end"
  /* PERFORMANCE_END */
);
function createDevtoolsPerformanceHook(hook) {
  return (component, type, time) => {
    emit$1(hook, component.appContext.app, component.uid, component, type, time);
  };
}
__name(createDevtoolsPerformanceHook, "createDevtoolsPerformanceHook");
function devtoolsComponentEmit(component, event2, params) {
  emit$1(
    "component:emit",
    component.appContext.app,
    component,
    event2,
    params
  );
}
__name(devtoolsComponentEmit, "devtoolsComponentEmit");
function emit(instance, event2, ...rawArgs) {
  if (instance.isUnmounted) return;
  const props = instance.vnode.props || EMPTY_OBJ;
  if (false) {
    const {
      emitsOptions,
      propsOptions: [propsOptions]
    } = instance;
    if (emitsOptions) {
      if (!(event2 in emitsOptions) && true) {
        if (!propsOptions || !(toHandlerKey(event2) in propsOptions)) {
          warn$1(
            `Component emitted event "${event2}" but it is neither declared in the emits option nor as an "${toHandlerKey(event2)}" prop.`
          );
        }
      } else {
        const validator3 = emitsOptions[event2];
        if (isFunction$4(validator3)) {
          const isValid2 = validator3(...rawArgs);
          if (!isValid2) {
            warn$1(
              `Invalid event arguments: event validation failed for event "${event2}".`
            );
          }
        }
      }
    }
  }
  let args = rawArgs;
  const isModelListener2 = event2.startsWith("update:");
  const modelArg = isModelListener2 && event2.slice(7);
  if (modelArg && modelArg in props) {
    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
    const { number: number2, trim: trim2 } = props[modifiersKey] || EMPTY_OBJ;
    if (trim2) {
      args = rawArgs.map((a) => isString$5(a) ? a.trim() : a);
    }
    if (number2) {
      args = rawArgs.map(looseToNumber);
    }
  }
  if (false) {
    devtoolsComponentEmit(instance, event2, args);
  }
  if (false) {
    const lowerCaseEvent = event2.toLowerCase();
    if (lowerCaseEvent !== event2 && props[toHandlerKey(lowerCaseEvent)]) {
      warn$1(
        `Event "${lowerCaseEvent}" is emitted in component ${formatComponentName(
          instance,
          instance.type
        )} but the handler is registered for "${event2}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${hyphenate$1(
          event2
        )}" instead of "${event2}".`
      );
    }
  }
  let handlerName;
  let handler6 = props[handlerName = toHandlerKey(event2)] || // also try camelCase event handler (#2249)
  props[handlerName = toHandlerKey(camelize$1(event2))];
  if (!handler6 && isModelListener2) {
    handler6 = props[handlerName = toHandlerKey(hyphenate$1(event2))];
  }
  if (handler6) {
    callWithAsyncErrorHandling(
      handler6,
      instance,
      6,
      args
    );
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(
      onceHandler,
      instance,
      6,
      args
    );
  }
}
__name(emit, "emit");
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache2 = appContext.emitsCache;
  const cached = cache2.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction$4(comp)) {
    const extendEmits = /* @__PURE__ */ __name((raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend$1(normalized, normalizedFromExtend);
      }
    }, "extendEmits");
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$6(comp)) {
      cache2.set(comp, null);
    }
    return null;
  }
  if (isArray$4(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend$1(normalized, raw);
  }
  if (isObject$6(comp)) {
    cache2.set(comp, normalized);
  }
  return normalized;
}
__name(normalizeEmitsOptions, "normalizeEmitsOptions");
function isEmitListener(options3, key) {
  if (!options3 || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn$3(options3, key[0].toLowerCase() + key.slice(1)) || hasOwn$3(options3, hyphenate$1(key)) || hasOwn$3(options3, key);
}
__name(isEmitListener, "isEmitListener");
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev2 = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev2;
}
__name(setCurrentRenderingInstance, "setCurrentRenderingInstance");
function pushScopeId(id2) {
  currentScopeId = id2;
}
__name(pushScopeId, "pushScopeId");
function popScopeId() {
  currentScopeId = null;
}
__name(popScopeId, "popScopeId");
const withScopeId = /* @__PURE__ */ __name((_id2) => withCtx, "withScopeId");
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx) return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = /* @__PURE__ */ __name((...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    if (false) {
      devtoolsComponentUpdated(ctx);
    }
    return res;
  }, "renderFnWithContext");
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
__name(withCtx, "withCtx");
let accessedAttrs = false;
function markAttrsAccessed() {
  accessedAttrs = true;
}
__name(markAttrsAccessed, "markAttrsAccessed");
function renderComponentRoot(instance) {
  const {
    type: Component,
    vnode,
    proxy,
    withProxy,
    propsOptions: [propsOptions],
    slots,
    attrs: attrs3,
    emit: emit2,
    render: render2,
    renderCache,
    props,
    data: data24,
    setupState,
    ctx,
    inheritAttrs
  } = instance;
  const prev2 = setCurrentRenderingInstance(instance);
  let result;
  let fallthroughAttrs;
  if (false) {
    accessedAttrs = false;
  }
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      const thisProxy = false ? new Proxy(proxyToUse, {
        get(target, key, receiver) {
          warn$1(
            `Property '${String(
              key
            )}' was accessed via 'this'. Avoid using 'this' in templates.`
          );
          return Reflect.get(target, key, receiver);
        }
      }) : proxyToUse;
      result = normalizeVNode(
        render2.call(
          thisProxy,
          proxyToUse,
          renderCache,
          false ? shallowReadonly(props) : props,
          setupState,
          data24,
          ctx
        )
      );
      fallthroughAttrs = attrs3;
    } else {
      const render22 = Component;
      if (false) {
        markAttrsAccessed();
      }
      result = normalizeVNode(
        render22.length > 1 ? render22(
          false ? shallowReadonly(props) : props,
          false ? {
            get attrs() {
              markAttrsAccessed();
              return shallowReadonly(attrs3);
            },
            slots,
            emit: emit2
          } : { attrs: attrs3, slots, emit: emit2 }
        ) : render22(
          false ? shallowReadonly(props) : props,
          null
        )
      );
      fallthroughAttrs = Component.props ? attrs3 : getFunctionalFallthrough(attrs3);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root26 = result;
  let setRoot = void 0;
  if (false) {
    [root26, setRoot] = getChildRoot(result);
  }
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys2 = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root26;
    if (keys2.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys2.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(
            fallthroughAttrs,
            propsOptions
          );
        }
        root26 = cloneVNode(root26, fallthroughAttrs, false, true);
      } else if (false) {
        const allAttrs = Object.keys(attrs3);
        const eventAttrs = [];
        const extraAttrs = [];
        for (let i2 = 0, l = allAttrs.length; i2 < l; i2++) {
          const key = allAttrs[i2];
          if (isOn(key)) {
            if (!isModelListener(key)) {
              eventAttrs.push(key[2].toLowerCase() + key.slice(3));
            }
          } else {
            extraAttrs.push(key);
          }
        }
        if (extraAttrs.length) {
          warn$1(
            `Extraneous non-props attributes (${extraAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`
          );
        }
        if (eventAttrs.length) {
          warn$1(
            `Extraneous non-emits event listeners (${eventAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`
          );
        }
      }
    }
  }
  if (vnode.dirs) {
    if (false) {
      warn$1(
        `Runtime directive used on component with non-element root node. The directives will not function as intended.`
      );
    }
    root26 = cloneVNode(root26, null, false, true);
    root26.dirs = root26.dirs ? root26.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    if (false) {
      warn$1(
        `Component inside <Transition> renders non-element root node that cannot be animated.`
      );
    }
    root26.transition = vnode.transition;
  }
  if (false) {
    setRoot(root26);
  } else {
    result = root26;
  }
  setCurrentRenderingInstance(prev2);
  return result;
}
__name(renderComponentRoot, "renderComponentRoot");
const getChildRoot = /* @__PURE__ */ __name((vnode) => {
  const rawChildren = vnode.children;
  const dynamicChildren = vnode.dynamicChildren;
  const childRoot = filterSingleRoot(rawChildren, false);
  if (!childRoot) {
    return [vnode, void 0];
  } else if (false) {
    return getChildRoot(childRoot);
  }
  const index2 = rawChildren.indexOf(childRoot);
  const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
  const setRoot = /* @__PURE__ */ __name((updatedRoot) => {
    rawChildren[index2] = updatedRoot;
    if (dynamicChildren) {
      if (dynamicIndex > -1) {
        dynamicChildren[dynamicIndex] = updatedRoot;
      } else if (updatedRoot.patchFlag > 0) {
        vnode.dynamicChildren = [...dynamicChildren, updatedRoot];
      }
    }
  }, "setRoot");
  return [normalizeVNode(childRoot), setRoot];
}, "getChildRoot");
function filterSingleRoot(children, recurse = true) {
  let singleRoot;
  for (let i2 = 0; i2 < children.length; i2++) {
    const child = children[i2];
    if (isVNode$1(child)) {
      if (child.type !== Comment || child.children === "v-if") {
        if (singleRoot) {
          return;
        } else {
          singleRoot = child;
          if (false) {
            return filterSingleRoot(singleRoot.children);
          }
        }
      }
    } else {
      return;
    }
  }
  return singleRoot;
}
__name(filterSingleRoot, "filterSingleRoot");
const getFunctionalFallthrough = /* @__PURE__ */ __name((attrs3) => {
  let res;
  for (const key in attrs3) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs3[key];
    }
  }
  return res;
}, "getFunctionalFallthrough");
const filterModelListeners = /* @__PURE__ */ __name((attrs3, props) => {
  const res = {};
  for (const key in attrs3) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs3[key];
    }
  }
  return res;
}, "filterModelListeners");
const isElementRoot = /* @__PURE__ */ __name((vnode) => {
  return vnode.shapeFlag & (6 | 1) || vnode.type === Comment;
}, "isElementRoot");
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (false) {
    return true;
  }
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i2 = 0; i2 < dynamicProps.length; i2++) {
        const key = dynamicProps[i2];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
__name(shouldUpdateComponent, "shouldUpdateComponent");
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i2 = 0; i2 < nextKeys.length; i2++) {
    const key = nextKeys[i2];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
__name(hasPropsChanged, "hasPropsChanged");
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent) {
    const root26 = parent.subTree;
    if (root26.suspense && root26.suspense.activeBranch === vnode) {
      root26.el = vnode.el;
    }
    if (root26 === vnode) {
      (vnode = parent.vnode).el = el;
      parent = parent.parent;
    } else {
      break;
    }
  }
}
__name(updateHOCHostEl, "updateHOCHostEl");
const COMPONENTS = "components";
const DIRECTIVES = "directives";
function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
__name(resolveComponent, "resolveComponent");
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function resolveDynamicComponent(component) {
  if (isString$5(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
__name(resolveDynamicComponent, "resolveDynamicComponent");
function resolveDirective(name) {
  return resolveAsset(DIRECTIVES, name);
}
__name(resolveDirective, "resolveDirective");
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    if (type === COMPONENTS) {
      const selfName = getComponentName(
        Component,
        false
      );
      if (selfName && (selfName === name || selfName === camelize$1(name) || selfName === capitalize$1(camelize$1(name)))) {
        return Component;
      }
    }
    const res = (
      // local registration
      // check instance[type] first which is resolved for options API
      resolve$1(instance[type] || Component[type], name) || // global registration
      resolve$1(instance.appContext[type], name)
    );
    if (!res && maybeSelfReference) {
      return Component;
    }
    if (false) {
      const extra = type === COMPONENTS ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : ``;
      warn$1(`Failed to resolve ${type.slice(0, -1)}: ${name}${extra}`);
    }
    return res;
  } else if (false) {
    warn$1(
      `resolve${capitalize$1(type.slice(0, -1))} can only be used in render() or setup().`
    );
  }
}
__name(resolveAsset, "resolveAsset");
function resolve$1(registry, name) {
  return registry && (registry[name] || registry[camelize$1(name)] || registry[capitalize$1(camelize$1(name))]);
}
__name(resolve$1, "resolve$1");
const isSuspense = /* @__PURE__ */ __name((type) => type.__isSuspense, "isSuspense");
let suspenseId = 0;
const SuspenseImpl = {
  name: "Suspense",
  // In order to make Suspense tree-shakable, we need to avoid importing it
  // directly in the renderer. The renderer checks for the __isSuspense flag
  // on a vnode's type and calls the `process` method, passing in renderer
  // internals.
  __isSuspense: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {
    if (n1 == null) {
      mountSuspense(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized,
        rendererInternals
      );
    } else {
      if (parentSuspense && parentSuspense.deps > 0 && !n1.suspense.isInFallback) {
        n2.suspense = n1.suspense;
        n2.suspense.vnode = n2;
        n2.el = n1.el;
        return;
      }
      patchSuspense(
        n1,
        n2,
        container,
        anchor,
        parentComponent,
        namespace,
        slotScopeIds,
        optimized,
        rendererInternals
      );
    }
  },
  hydrate: hydrateSuspense,
  normalize: normalizeSuspenseChildren
};
const Suspense = SuspenseImpl;
function triggerEvent(vnode, name) {
  const eventListener = vnode.props && vnode.props[name];
  if (isFunction$4(eventListener)) {
    eventListener();
  }
}
__name(triggerEvent, "triggerEvent");
function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {
  const {
    p: patch,
    o: { createElement: createElement2 }
  } = rendererInternals;
  const hiddenContainer = createElement2("div");
  const suspense = vnode.suspense = createSuspenseBoundary(
    vnode,
    parentSuspense,
    parentComponent,
    container,
    hiddenContainer,
    anchor,
    namespace,
    slotScopeIds,
    optimized,
    rendererInternals
  );
  patch(
    null,
    suspense.pendingBranch = vnode.ssContent,
    hiddenContainer,
    null,
    parentComponent,
    suspense,
    namespace,
    slotScopeIds
  );
  if (suspense.deps > 0) {
    triggerEvent(vnode, "onPending");
    triggerEvent(vnode, "onFallback");
    patch(
      null,
      vnode.ssFallback,
      container,
      anchor,
      parentComponent,
      null,
      // fallback tree will not have suspense context
      namespace,
      slotScopeIds
    );
    setActiveBranch(suspense, vnode.ssFallback);
  } else {
    suspense.resolve(false, true);
  }
}
__name(mountSuspense, "mountSuspense");
function patchSuspense(n1, n2, container, anchor, parentComponent, namespace, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement: createElement2 } }) {
  const suspense = n2.suspense = n1.suspense;
  suspense.vnode = n2;
  n2.el = n1.el;
  const newBranch = n2.ssContent;
  const newFallback = n2.ssFallback;
  const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
  if (pendingBranch) {
    suspense.pendingBranch = newBranch;
    if (isSameVNodeType(newBranch, pendingBranch)) {
      patch(
        pendingBranch,
        newBranch,
        suspense.hiddenContainer,
        null,
        parentComponent,
        suspense,
        namespace,
        slotScopeIds,
        optimized
      );
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else if (isInFallback) {
        if (!isHydrating) {
          patch(
            activeBranch,
            newFallback,
            container,
            anchor,
            parentComponent,
            null,
            // fallback tree will not have suspense context
            namespace,
            slotScopeIds,
            optimized
          );
          setActiveBranch(suspense, newFallback);
        }
      }
    } else {
      suspense.pendingId = suspenseId++;
      if (isHydrating) {
        suspense.isHydrating = false;
        suspense.activeBranch = pendingBranch;
      } else {
        unmount(pendingBranch, parentComponent, suspense);
      }
      suspense.deps = 0;
      suspense.effects.length = 0;
      suspense.hiddenContainer = createElement2("div");
      if (isInFallback) {
        patch(
          null,
          newBranch,
          suspense.hiddenContainer,
          null,
          parentComponent,
          suspense,
          namespace,
          slotScopeIds,
          optimized
        );
        if (suspense.deps <= 0) {
          suspense.resolve();
        } else {
          patch(
            activeBranch,
            newFallback,
            container,
            anchor,
            parentComponent,
            null,
            // fallback tree will not have suspense context
            namespace,
            slotScopeIds,
            optimized
          );
          setActiveBranch(suspense, newFallback);
        }
      } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
        patch(
          activeBranch,
          newBranch,
          container,
          anchor,
          parentComponent,
          suspense,
          namespace,
          slotScopeIds,
          optimized
        );
        suspense.resolve(true);
      } else {
        patch(
          null,
          newBranch,
          suspense.hiddenContainer,
          null,
          parentComponent,
          suspense,
          namespace,
          slotScopeIds,
          optimized
        );
        if (suspense.deps <= 0) {
          suspense.resolve();
        }
      }
    }
  } else {
    if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
      patch(
        activeBranch,
        newBranch,
        container,
        anchor,
        parentComponent,
        suspense,
        namespace,
        slotScopeIds,
        optimized
      );
      setActiveBranch(suspense, newBranch);
    } else {
      triggerEvent(n2, "onPending");
      suspense.pendingBranch = newBranch;
      if (newBranch.shapeFlag & 512) {
        suspense.pendingId = newBranch.component.suspenseId;
      } else {
        suspense.pendingId = suspenseId++;
      }
      patch(
        null,
        newBranch,
        suspense.hiddenContainer,
        null,
        parentComponent,
        suspense,
        namespace,
        slotScopeIds,
        optimized
      );
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else {
        const { timeout, pendingId } = suspense;
        if (timeout > 0) {
          setTimeout(() => {
            if (suspense.pendingId === pendingId) {
              suspense.fallback(newFallback);
            }
          }, timeout);
        } else if (timeout === 0) {
          suspense.fallback(newFallback);
        }
      }
    }
  }
}
__name(patchSuspense, "patchSuspense");
let hasWarned$1 = false;
function createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, namespace, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
  if (false) {
    hasWarned$1 = true;
    console[console.info ? "info" : "log"](
      `<Suspense> is an experimental feature and its API will likely change.`
    );
  }
  const {
    p: patch,
    m: move,
    um: unmount,
    n: next2,
    o: { parentNode, remove: remove22 }
  } = rendererInternals;
  let parentSuspenseId;
  const isSuspensible = isVNodeSuspensible(vnode);
  if (isSuspensible) {
    if (parentSuspense && parentSuspense.pendingBranch) {
      parentSuspenseId = parentSuspense.pendingId;
      parentSuspense.deps++;
    }
  }
  const timeout = vnode.props ? toNumber(vnode.props.timeout) : void 0;
  if (false) {
    assertNumber(timeout, `Suspense timeout`);
  }
  const initialAnchor = anchor;
  const suspense = {
    vnode,
    parent: parentSuspense,
    parentComponent,
    namespace,
    container,
    hiddenContainer,
    deps: 0,
    pendingId: suspenseId++,
    timeout: typeof timeout === "number" ? timeout : -1,
    activeBranch: null,
    pendingBranch: null,
    isInFallback: !isHydrating,
    isHydrating,
    isUnmounted: false,
    effects: [],
    resolve(resume = false, sync = false) {
      if (false) {
        if (!resume && !suspense.pendingBranch) {
          throw new Error(
            `suspense.resolve() is called without a pending branch.`
          );
        }
        if (suspense.isUnmounted) {
          throw new Error(
            `suspense.resolve() is called on an already unmounted suspense boundary.`
          );
        }
      }
      const {
        vnode: vnode2,
        activeBranch,
        pendingBranch,
        pendingId,
        effects,
        parentComponent: parentComponent2,
        container: container2
      } = suspense;
      let delayEnter = false;
      if (suspense.isHydrating) {
        suspense.isHydrating = false;
      } else if (!resume) {
        delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";
        if (delayEnter) {
          activeBranch.transition.afterLeave = () => {
            if (pendingId === suspense.pendingId) {
              move(
                pendingBranch,
                container2,
                anchor === initialAnchor ? next2(activeBranch) : anchor,
                0
              );
              queuePostFlushCb(effects);
            }
          };
        }
        if (activeBranch) {
          if (parentNode(activeBranch.el) !== suspense.hiddenContainer) {
            anchor = next2(activeBranch);
          }
          unmount(activeBranch, parentComponent2, suspense, true);
        }
        if (!delayEnter) {
          move(pendingBranch, container2, anchor, 0);
        }
      }
      setActiveBranch(suspense, pendingBranch);
      suspense.pendingBranch = null;
      suspense.isInFallback = false;
      let parent = suspense.parent;
      let hasUnresolvedAncestor = false;
      while (parent) {
        if (parent.pendingBranch) {
          parent.effects.push(...effects);
          hasUnresolvedAncestor = true;
          break;
        }
        parent = parent.parent;
      }
      if (!hasUnresolvedAncestor && !delayEnter) {
        queuePostFlushCb(effects);
      }
      suspense.effects = [];
      if (isSuspensible) {
        if (parentSuspense && parentSuspense.pendingBranch && parentSuspenseId === parentSuspense.pendingId) {
          parentSuspense.deps--;
          if (parentSuspense.deps === 0 && !sync) {
            parentSuspense.resolve();
          }
        }
      }
      triggerEvent(vnode2, "onResolve");
    },
    fallback(fallbackVNode) {
      if (!suspense.pendingBranch) {
        return;
      }
      const { vnode: vnode2, activeBranch, parentComponent: parentComponent2, container: container2, namespace: namespace2 } = suspense;
      triggerEvent(vnode2, "onFallback");
      const anchor2 = next2(activeBranch);
      const mountFallback = /* @__PURE__ */ __name(() => {
        if (!suspense.isInFallback) {
          return;
        }
        patch(
          null,
          fallbackVNode,
          container2,
          anchor2,
          parentComponent2,
          null,
          // fallback tree will not have suspense context
          namespace2,
          slotScopeIds,
          optimized
        );
        setActiveBranch(suspense, fallbackVNode);
      }, "mountFallback");
      const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
      if (delayEnter) {
        activeBranch.transition.afterLeave = mountFallback;
      }
      suspense.isInFallback = true;
      unmount(
        activeBranch,
        parentComponent2,
        null,
        // no suspense so unmount hooks fire now
        true
        // shouldRemove
      );
      if (!delayEnter) {
        mountFallback();
      }
    },
    move(container2, anchor2, type) {
      suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type);
      suspense.container = container2;
    },
    next() {
      return suspense.activeBranch && next2(suspense.activeBranch);
    },
    registerDep(instance, setupRenderEffect, optimized2) {
      const isInPendingSuspense = !!suspense.pendingBranch;
      if (isInPendingSuspense) {
        suspense.deps++;
      }
      const hydratedEl = instance.vnode.el;
      instance.asyncDep.catch((err) => {
        handleError(err, instance, 0);
      }).then((asyncSetupResult) => {
        if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {
          return;
        }
        instance.asyncResolved = true;
        const { vnode: vnode2 } = instance;
        if (false) {
          pushWarningContext(vnode2);
        }
        handleSetupResult(instance, asyncSetupResult, false);
        if (hydratedEl) {
          vnode2.el = hydratedEl;
        }
        const placeholder = !hydratedEl && instance.subTree.el;
        setupRenderEffect(
          instance,
          vnode2,
          // component may have been moved before resolve.
          // if this is not a hydration, instance.subTree will be the comment
          // placeholder.
          parentNode(hydratedEl || instance.subTree.el),
          // anchor will not be used if this is hydration, so only need to
          // consider the comment placeholder case.
          hydratedEl ? null : next2(instance.subTree),
          suspense,
          namespace,
          optimized2
        );
        if (placeholder) {
          remove22(placeholder);
        }
        updateHOCHostEl(instance, vnode2.el);
        if (false) {
          popWarningContext();
        }
        if (isInPendingSuspense && --suspense.deps === 0) {
          suspense.resolve();
        }
      });
    },
    unmount(parentSuspense2, doRemove) {
      suspense.isUnmounted = true;
      if (suspense.activeBranch) {
        unmount(
          suspense.activeBranch,
          parentComponent,
          parentSuspense2,
          doRemove
        );
      }
      if (suspense.pendingBranch) {
        unmount(
          suspense.pendingBranch,
          parentComponent,
          parentSuspense2,
          doRemove
        );
      }
    }
  };
  return suspense;
}
__name(createSuspenseBoundary, "createSuspenseBoundary");
function hydrateSuspense(node3, vnode, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals, hydrateNode) {
  const suspense = vnode.suspense = createSuspenseBoundary(
    vnode,
    parentSuspense,
    parentComponent,
    node3.parentNode,
    // eslint-disable-next-line no-restricted-globals
    document.createElement("div"),
    null,
    namespace,
    slotScopeIds,
    optimized,
    rendererInternals,
    true
  );
  const result = hydrateNode(
    node3,
    suspense.pendingBranch = vnode.ssContent,
    parentComponent,
    suspense,
    slotScopeIds,
    optimized
  );
  if (suspense.deps === 0) {
    suspense.resolve(false, true);
  }
  return result;
}
__name(hydrateSuspense, "hydrateSuspense");
function normalizeSuspenseChildren(vnode) {
  const { shapeFlag, children } = vnode;
  const isSlotChildren = shapeFlag & 32;
  vnode.ssContent = normalizeSuspenseSlot(
    isSlotChildren ? children.default : children
  );
  vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
}
__name(normalizeSuspenseChildren, "normalizeSuspenseChildren");
function normalizeSuspenseSlot(s) {
  let block2;
  if (isFunction$4(s)) {
    const trackBlock = isBlockTreeEnabled && s._c;
    if (trackBlock) {
      s._d = false;
      openBlock();
    }
    s = s();
    if (trackBlock) {
      s._d = true;
      block2 = currentBlock;
      closeBlock();
    }
  }
  if (isArray$4(s)) {
    const singleChild = filterSingleRoot(s);
    if (false) {
      warn$1(`<Suspense> slots expect a single root node.`);
    }
    s = singleChild;
  }
  s = normalizeVNode(s);
  if (block2 && !s.dynamicChildren) {
    s.dynamicChildren = block2.filter((c) => c !== s);
  }
  return s;
}
__name(normalizeSuspenseSlot, "normalizeSuspenseSlot");
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray$4(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
__name(queueEffectWithSuspense, "queueEffectWithSuspense");
function setActiveBranch(suspense, branch) {
  suspense.activeBranch = branch;
  const { vnode, parentComponent } = suspense;
  let el = branch.el;
  while (!el && branch.component) {
    branch = branch.component.subTree;
    el = branch.el;
  }
  vnode.el = el;
  if (parentComponent && parentComponent.subTree === vnode) {
    parentComponent.vnode.el = el;
    updateHOCHostEl(parentComponent, el);
  }
}
__name(setActiveBranch, "setActiveBranch");
function isVNodeSuspensible(vnode) {
  const suspensible = vnode.props && vnode.props.suspensible;
  return suspensible != null && suspensible !== false;
}
__name(isVNodeSuspensible, "isVNodeSuspensible");
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      pauseTracking();
      const reset = setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      reset();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  } else if (false) {
    const apiName = toHandlerKey(ErrorTypeStrings$1[type].replace(/ hook$/, ""));
    warn$1(
      `${apiName} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`
    );
  }
}
__name(injectHook, "injectHook");
const createHook = /* @__PURE__ */ __name((lifecycle2) => (hook, target = currentInstance) => {
  if (!isInSSRComponentSetup || lifecycle2 === "sp") {
    injectHook(lifecycle2, (...args) => hook(...args), target);
  }
}, "createHook");
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook("bu");
const onUpdated = createHook("u");
const onBeforeUnmount = createHook("bum");
const onUnmounted = createHook("um");
const onServerPrefetch = createHook("sp");
const onRenderTriggered = createHook(
  "rtg"
);
const onRenderTracked = createHook(
  "rtc"
);
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
__name(onErrorCaptured, "onErrorCaptured");
function validateDirectiveName(name) {
  if (isBuiltInDirective(name)) {
    warn$1("Do not use built-in directive ids as custom directive id: " + name);
  }
}
__name(validateDirectiveName, "validateDirectiveName");
function withDirectives(vnode, directives) {
  if (currentRenderingInstance === null) {
    return vnode;
  }
  const instance = getComponentPublicInstance(currentRenderingInstance);
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i2 = 0; i2 < directives.length; i2++) {
    let [dir, value3, arg, modifiers = EMPTY_OBJ] = directives[i2];
    if (dir) {
      if (isFunction$4(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        traverse(value3);
      }
      bindings.push({
        dir,
        instance,
        value: value3,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
  }
  return vnode;
}
__name(withDirectives, "withDirectives");
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i2 = 0; i2 < bindings.length; i2++) {
    const binding = bindings[i2];
    if (oldBindings) {
      binding.oldValue = oldBindings[i2].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
__name(invokeDirectiveHook, "invokeDirectiveHook");
function renderList(source, renderItem, cache2, index2) {
  let ret;
  const cached = cache2 && cache2[index2];
  if (isArray$4(source) || isString$5(source)) {
    ret = new Array(source.length);
    for (let i2 = 0, l = source.length; i2 < l; i2++) {
      ret[i2] = renderItem(source[i2], i2, void 0, cached && cached[i2]);
    }
  } else if (typeof source === "number") {
    if (false) {
      warn$1(`The v-for range expect an integer value but got ${source}.`);
    }
    ret = new Array(source);
    for (let i2 = 0; i2 < source; i2++) {
      ret[i2] = renderItem(i2 + 1, i2, void 0, cached && cached[i2]);
    }
  } else if (isObject$6(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(
        source,
        (item2, i2) => renderItem(item2, i2, void 0, cached && cached[i2])
      );
    } else {
      const keys2 = Object.keys(source);
      ret = new Array(keys2.length);
      for (let i2 = 0, l = keys2.length; i2 < l; i2++) {
        const key = keys2[i2];
        ret[i2] = renderItem(source[key], key, i2, cached && cached[i2]);
      }
    }
  } else {
    ret = [];
  }
  if (cache2) {
    cache2[index2] = ret;
  }
  return ret;
}
__name(renderList, "renderList");
function createSlots(slots, dynamicSlots) {
  for (let i2 = 0; i2 < dynamicSlots.length; i2++) {
    const slot = dynamicSlots[i2];
    if (isArray$4(slot)) {
      for (let j = 0; j < slot.length; j++) {
        slots[slot[j].name] = slot[j].fn;
      }
    } else if (slot) {
      slots[slot.name] = slot.key ? (...args) => {
        const res = slot.fn(...args);
        if (res) res.key = slot.key;
        return res;
      } : slot.fn;
    }
  }
  return slots;
}
__name(createSlots, "createSlots");
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineComponent(options3, extraOptions) {
  return isFunction$4(options3) ? (
    // #8326: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (() => extend$1({ name: options3.name }, extraOptions, { setup: options3 }))()
  ) : options3;
}
__name(defineComponent, "defineComponent");
const isAsyncWrapper = /* @__PURE__ */ __name((i2) => !!i2.type.__asyncLoader, "isAsyncWrapper");
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineAsyncComponent(source) {
  if (isFunction$4(source)) {
    source = { loader: source };
  }
  const {
    loader,
    loadingComponent,
    errorComponent,
    delay = 200,
    timeout,
    // undefined = never times out
    suspensible = true,
    onError: userOnError
  } = source;
  let pendingRequest = null;
  let resolvedComp;
  let retries = 0;
  const retry = /* @__PURE__ */ __name(() => {
    retries++;
    pendingRequest = null;
    return load2();
  }, "retry");
  const load2 = /* @__PURE__ */ __name(() => {
    let thisRequest;
    return pendingRequest || (thisRequest = pendingRequest = loader().catch((err) => {
      err = err instanceof Error ? err : new Error(String(err));
      if (userOnError) {
        return new Promise((resolve22, reject2) => {
          const userRetry = /* @__PURE__ */ __name(() => resolve22(retry()), "userRetry");
          const userFail = /* @__PURE__ */ __name(() => reject2(err), "userFail");
          userOnError(err, userRetry, userFail, retries + 1);
        });
      } else {
        throw err;
      }
    }).then((comp) => {
      if (thisRequest !== pendingRequest && pendingRequest) {
        return pendingRequest;
      }
      if (false) {
        warn$1(
          `Async component loader resolved to undefined. If you are using retry(), make sure to return its return value.`
        );
      }
      if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) {
        comp = comp.default;
      }
      if (false) {
        throw new Error(`Invalid async component load result: ${comp}`);
      }
      resolvedComp = comp;
      return comp;
    }));
  }, "load");
  return /* @__PURE__ */ defineComponent({
    name: "AsyncComponentWrapper",
    __asyncLoader: load2,
    get __asyncResolved() {
      return resolvedComp;
    },
    setup() {
      const instance = currentInstance;
      if (resolvedComp) {
        return () => createInnerComp(resolvedComp, instance);
      }
      const onError = /* @__PURE__ */ __name((err) => {
        pendingRequest = null;
        handleError(
          err,
          instance,
          13,
          !errorComponent
        );
      }, "onError");
      if (suspensible && instance.suspense || isInSSRComponentSetup) {
        return load2().then((comp) => {
          return () => createInnerComp(comp, instance);
        }).catch((err) => {
          onError(err);
          return () => errorComponent ? createVNode(errorComponent, {
            error: err
          }) : null;
        });
      }
      const loaded = ref(false);
      const error = ref();
      const delayed = ref(!!delay);
      if (delay) {
        setTimeout(() => {
          delayed.value = false;
        }, delay);
      }
      if (timeout != null) {
        setTimeout(() => {
          if (!loaded.value && !error.value) {
            const err = new Error(
              `Async component timed out after ${timeout}ms.`
            );
            onError(err);
            error.value = err;
          }
        }, timeout);
      }
      load2().then(() => {
        loaded.value = true;
        if (instance.parent && isKeepAlive(instance.parent.vnode)) {
          instance.parent.effect.dirty = true;
          queueJob(instance.parent.update);
        }
      }).catch((err) => {
        onError(err);
        error.value = err;
      });
      return () => {
        if (loaded.value && resolvedComp) {
          return createInnerComp(resolvedComp, instance);
        } else if (error.value && errorComponent) {
          return createVNode(errorComponent, {
            error: error.value
          });
        } else if (loadingComponent && !delayed.value) {
          return createVNode(loadingComponent);
        }
      };
    }
  });
}
__name(defineAsyncComponent, "defineAsyncComponent");
function createInnerComp(comp, parent) {
  const { ref: ref22, props, children, ce } = parent.vnode;
  const vnode = createVNode(comp, props, children);
  vnode.ref = ref22;
  vnode.ce = ce;
  delete parent.vnode.ce;
  return vnode;
}
__name(createInnerComp, "createInnerComp");
function renderSlot(slots, name, props = {}, fallback, noSlotted) {
  if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
    if (name !== "default") props.name = name;
    return createVNode("slot", props, fallback && fallback());
  }
  let slot = slots[name];
  if (false) {
    warn$1(
      `SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template.`
    );
    slot = /* @__PURE__ */ __name(() => [], "slot");
  }
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props));
  const rendered = createBlock(
    Fragment,
    {
      key: props.key || // slot content array of a dynamic conditional slot may have a branch
      // key attached in the `createSlots` helper, respect that
      validSlotContent && validSlotContent.key || `_${name}`
    },
    validSlotContent || (fallback ? fallback() : []),
    validSlotContent && slots._ === 1 ? 64 : -2
  );
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
__name(renderSlot, "renderSlot");
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode$1(child)) return true;
    if (child.type === Comment) return false;
    if (child.type === Fragment && !ensureValidVNode(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}
__name(ensureValidVNode, "ensureValidVNode");
function toHandlers(obj, preserveCaseIfNecessary) {
  const ret = {};
  if (false) {
    warn$1(`v-on with no argument expects an object value.`);
    return ret;
  }
  for (const key in obj) {
    ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? `on:${key}` : toHandlerKey(key)] = obj[key];
  }
  return ret;
}
__name(toHandlers, "toHandlers");
const getPublicInstance = /* @__PURE__ */ __name((i2) => {
  if (!i2) return null;
  if (isStatefulComponent(i2)) return getComponentPublicInstance(i2);
  return getPublicInstance(i2.parent);
}, "getPublicInstance");
const publicPropertiesMap = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ extend$1(/* @__PURE__ */ Object.create(null), {
    $: /* @__PURE__ */ __name((i2) => i2, "$"),
    $el: /* @__PURE__ */ __name((i2) => i2.vnode.el, "$el"),
    $data: /* @__PURE__ */ __name((i2) => i2.data, "$data"),
    $props: /* @__PURE__ */ __name((i2) => false ? shallowReadonly(i2.props) : i2.props, "$props"),
    $attrs: /* @__PURE__ */ __name((i2) => false ? shallowReadonly(i2.attrs) : i2.attrs, "$attrs"),
    $slots: /* @__PURE__ */ __name((i2) => false ? shallowReadonly(i2.slots) : i2.slots, "$slots"),
    $refs: /* @__PURE__ */ __name((i2) => false ? shallowReadonly(i2.refs) : i2.refs, "$refs"),
    $parent: /* @__PURE__ */ __name((i2) => getPublicInstance(i2.parent), "$parent"),
    $root: /* @__PURE__ */ __name((i2) => getPublicInstance(i2.root), "$root"),
    $emit: /* @__PURE__ */ __name((i2) => i2.emit, "$emit"),
    $options: /* @__PURE__ */ __name((i2) => true ? resolveMergedOptions(i2) : i2.type, "$options"),
    $forceUpdate: /* @__PURE__ */ __name((i2) => i2.f || (i2.f = () => {
      i2.effect.dirty = true;
      queueJob(i2.update);
    }), "$forceUpdate"),
    $nextTick: /* @__PURE__ */ __name((i2) => i2.n || (i2.n = nextTick.bind(i2.proxy)), "$nextTick"),
    $watch: /* @__PURE__ */ __name((i2) => true ? instanceWatch.bind(i2) : NOOP, "$watch")
  })
);
const isReservedPrefix = /* @__PURE__ */ __name((key) => key === "_" || key === "$", "isReservedPrefix");
const hasSetupBinding = /* @__PURE__ */ __name((state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn$3(state, key), "hasSetupBinding");
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    if (key === "__v_skip") {
      return true;
    }
    const { ctx, setupState, data: data24, props, accessCache, type, appContext } = instance;
    if (false) {
      return true;
    }
    let normalizedProps;
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 1:
            return setupState[key];
          case 2:
            return data24[key];
          case 4:
            return ctx[key];
          case 3:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data24 !== EMPTY_OBJ && hasOwn$3(data24, key)) {
        accessCache[key] = 2;
        return data24[key];
      } else if (
        // only cache other properties when instance has declared (thus stable)
        // props
        (normalizedProps = instance.propsOptions[0]) && hasOwn$3(normalizedProps, key)
      ) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn$3(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance.attrs, "get", "");
      } else if (false) {
        track(instance, "get", key);
      }
      return publicGetter(instance);
    } else if (
      // css module (injected by vue-loader)
      (cssModule = type.__cssModules) && (cssModule = cssModule[key])
    ) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn$3(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (
      // global properties
      globalProperties = appContext.config.globalProperties, hasOwn$3(globalProperties, key)
    ) {
      {
        return globalProperties[key];
      }
    } else if (false) {
      if (data24 !== EMPTY_OBJ && isReservedPrefix(key[0]) && hasOwn$3(data24, key)) {
        warn$1(
          `Property ${JSON.stringify(
            key
          )} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`
        );
      } else if (instance === currentRenderingInstance) {
        warn$1(
          `Property ${JSON.stringify(key)} was accessed during render but is not defined on instance.`
        );
      }
    }
  },
  set({ _: instance }, key, value3) {
    const { data: data24, setupState, ctx } = instance;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value3;
      return true;
    } else if (false) {
      warn$1(`Cannot mutate <script setup> binding "${key}" from Options API.`);
      return false;
    } else if (data24 !== EMPTY_OBJ && hasOwn$3(data24, key)) {
      data24[key] = value3;
      return true;
    } else if (hasOwn$3(instance.props, key)) {
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      return false;
    } else {
      if (false) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          value: value3
        });
      } else {
        ctx[key] = value3;
      }
    }
    return true;
  },
  has({
    _: { data: data24, setupState, accessCache, ctx, appContext, propsOptions }
  }, key) {
    let normalizedProps;
    return !!accessCache[key] || data24 !== EMPTY_OBJ && hasOwn$3(data24, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn$3(normalizedProps, key) || hasOwn$3(ctx, key) || hasOwn$3(publicPropertiesMap, key) || hasOwn$3(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn$3(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
if (false) {
  PublicInstanceProxyHandlers.ownKeys = (target) => {
    warn$1(
      `Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.`
    );
    return Reflect.ownKeys(target);
  };
}
const RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */ extend$1(
  {},
  PublicInstanceProxyHandlers,
  {
    get(target, key) {
      if (key === Symbol.unscopables) {
        return;
      }
      return PublicInstanceProxyHandlers.get(target, key, target);
    },
    has(_2, key) {
      const has2 = key[0] !== "_" && !isGloballyAllowed(key);
      if (false) {
        warn$1(
          `Property ${JSON.stringify(
            key
          )} should not start with _ which is a reserved prefix for Vue internals.`
        );
      }
      return has2;
    }
  }
);
function createDevRenderContext(instance) {
  const target = {};
  Object.defineProperty(target, `_`, {
    configurable: true,
    enumerable: false,
    get: /* @__PURE__ */ __name(() => instance, "get")
  });
  Object.keys(publicPropertiesMap).forEach((key) => {
    Object.defineProperty(target, key, {
      configurable: true,
      enumerable: false,
      get: /* @__PURE__ */ __name(() => publicPropertiesMap[key](instance), "get"),
      // intercepted by the proxy so no need for implementation,
      // but needed to prevent set errors
      set: NOOP
    });
  });
  return target;
}
__name(createDevRenderContext, "createDevRenderContext");
function exposePropsOnRenderContext(instance) {
  const {
    ctx,
    propsOptions: [propsOptions]
  } = instance;
  if (propsOptions) {
    Object.keys(propsOptions).forEach((key) => {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: /* @__PURE__ */ __name(() => instance.props[key], "get"),
        set: NOOP
      });
    });
  }
}
__name(exposePropsOnRenderContext, "exposePropsOnRenderContext");
function exposeSetupStateOnRenderContext(instance) {
  const { ctx, setupState } = instance;
  Object.keys(toRaw(setupState)).forEach((key) => {
    if (!setupState.__isScriptSetup) {
      if (isReservedPrefix(key[0])) {
        warn$1(
          `setup() return property ${JSON.stringify(
            key
          )} should not start with "$" or "_" which are reserved prefixes for Vue internals.`
        );
        return;
      }
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: /* @__PURE__ */ __name(() => setupState[key], "get"),
        set: NOOP
      });
    }
  });
}
__name(exposeSetupStateOnRenderContext, "exposeSetupStateOnRenderContext");
const warnRuntimeUsage = /* @__PURE__ */ __name((method) => warn$1(
  `${method}() is a compiler-hint helper that is only usable inside <script setup> of a single file component. Its arguments should be compiled away and passing it at runtime has no effect.`
), "warnRuntimeUsage");
function defineProps() {
  if (false) {
    warnRuntimeUsage(`defineProps`);
  }
  return null;
}
__name(defineProps, "defineProps");
function defineEmits() {
  if (false) {
    warnRuntimeUsage(`defineEmits`);
  }
  return null;
}
__name(defineEmits, "defineEmits");
function defineExpose(exposed) {
  if (false) {
    warnRuntimeUsage(`defineExpose`);
  }
}
__name(defineExpose, "defineExpose");
function defineOptions(options3) {
  if (false) {
    warnRuntimeUsage(`defineOptions`);
  }
}
__name(defineOptions, "defineOptions");
function defineSlots() {
  if (false) {
    warnRuntimeUsage(`defineSlots`);
  }
  return null;
}
__name(defineSlots, "defineSlots");
function defineModel() {
  if (false) {
    warnRuntimeUsage("defineModel");
  }
}
__name(defineModel, "defineModel");
function withDefaults(props, defaults2) {
  if (false) {
    warnRuntimeUsage(`withDefaults`);
  }
  return null;
}
__name(withDefaults, "withDefaults");
function useSlots() {
  return getContext().slots;
}
__name(useSlots, "useSlots");
function useAttrs() {
  return getContext().attrs;
}
__name(useAttrs, "useAttrs");
function getContext() {
  const i2 = getCurrentInstance();
  if (false) {
    warn$1(`useContext() called without active instance.`);
  }
  return i2.setupContext || (i2.setupContext = createSetupContext(i2));
}
__name(getContext, "getContext");
function normalizePropsOrEmits(props) {
  return isArray$4(props) ? props.reduce(
    (normalized, p2) => (normalized[p2] = null, normalized),
    {}
  ) : props;
}
__name(normalizePropsOrEmits, "normalizePropsOrEmits");
function mergeDefaults(raw, defaults2) {
  const props = normalizePropsOrEmits(raw);
  for (const key in defaults2) {
    if (key.startsWith("__skip")) continue;
    let opt = props[key];
    if (opt) {
      if (isArray$4(opt) || isFunction$4(opt)) {
        opt = props[key] = { type: opt, default: defaults2[key] };
      } else {
        opt.default = defaults2[key];
      }
    } else if (opt === null) {
      opt = props[key] = { default: defaults2[key] };
    } else if (false) {
      warn$1(`props default key "${key}" has no corresponding declaration.`);
    }
    if (opt && defaults2[`__skip_${key}`]) {
      opt.skipFactory = true;
    }
  }
  return props;
}
__name(mergeDefaults, "mergeDefaults");
function mergeModels(a, b) {
  if (!a || !b) return a || b;
  if (isArray$4(a) && isArray$4(b)) return a.concat(b);
  return extend$1({}, normalizePropsOrEmits(a), normalizePropsOrEmits(b));
}
__name(mergeModels, "mergeModels");
function createPropsRestProxy(props, excludedKeys) {
  const ret = {};
  for (const key in props) {
    if (!excludedKeys.includes(key)) {
      Object.defineProperty(ret, key, {
        enumerable: true,
        get: /* @__PURE__ */ __name(() => props[key], "get")
      });
    }
  }
  return ret;
}
__name(createPropsRestProxy, "createPropsRestProxy");
function withAsyncContext(getAwaitable) {
  const ctx = getCurrentInstance();
  if (false) {
    warn$1(
      `withAsyncContext called without active current instance. This is likely a bug.`
    );
  }
  let awaitable = getAwaitable();
  unsetCurrentInstance();
  if (isPromise$2(awaitable)) {
    awaitable = awaitable.catch((e) => {
      setCurrentInstance(ctx);
      throw e;
    });
  }
  return [awaitable, () => setCurrentInstance(ctx)];
}
__name(withAsyncContext, "withAsyncContext");
function createDuplicateChecker() {
  const cache2 = /* @__PURE__ */ Object.create(null);
  return (type, key) => {
    if (cache2[key]) {
      warn$1(`${type} property "${key}" is already defined in ${cache2[key]}.`);
    } else {
      cache2[key] = type;
    }
  };
}
__name(createDuplicateChecker, "createDuplicateChecker");
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options3 = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options3.beforeCreate) {
    callHook$1(options3.beforeCreate, instance, "bc");
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created: created3,
    beforeMount: beforeMount4,
    mounted: mounted23,
    beforeUpdate: beforeUpdate2,
    updated: updated12,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount: beforeUnmount17,
    destroyed,
    unmounted: unmounted6,
    render: render2,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components,
    directives,
    filters
  } = options3;
  const checkDuplicateProperties = false ? createDuplicateChecker() : null;
  if (false) {
    const [propsOptions] = instance.propsOptions;
    if (propsOptions) {
      for (const key in propsOptions) {
        checkDuplicateProperties("Props", key);
      }
    }
  }
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction$4(methodHandler)) {
        if (false) {
          Object.defineProperty(ctx, key, {
            value: methodHandler.bind(publicThis),
            configurable: true,
            enumerable: true,
            writable: true
          });
        } else {
          ctx[key] = methodHandler.bind(publicThis);
        }
        if (false) {
          checkDuplicateProperties("Methods", key);
        }
      } else if (false) {
        warn$1(
          `Method "${key}" has type "${typeof methodHandler}" in the component definition. Did you reference the function correctly?`
        );
      }
    }
  }
  if (dataOptions) {
    if (false) {
      warn$1(
        `The data option must be a function. Plain object usage is no longer supported.`
      );
    }
    const data24 = dataOptions.call(publicThis, publicThis);
    if (false) {
      warn$1(
        `data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.`
      );
    }
    if (!isObject$6(data24)) {
    } else {
      instance.data = reactive(data24);
      if (false) {
        for (const key in data24) {
          checkDuplicateProperties("Data", key);
          if (!isReservedPrefix(key[0])) {
            Object.defineProperty(ctx, key, {
              configurable: true,
              enumerable: true,
              get: /* @__PURE__ */ __name(() => data24[key], "get"),
              set: NOOP
            });
          }
        }
      }
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get2 = isFunction$4(opt) ? opt.bind(publicThis, publicThis) : isFunction$4(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      if (false) {
        warn$1(`Computed property "${key}" has no getter.`);
      }
      const set2 = !isFunction$4(opt) && isFunction$4(opt.set) ? opt.set.bind(publicThis) : false ? () => {
        warn$1(
          `Write operation failed: computed property "${key}" is readonly.`
        );
      } : NOOP;
      const c = computed({
        get: get2,
        set: set2
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: /* @__PURE__ */ __name(() => c.value, "get"),
        set: /* @__PURE__ */ __name((v2) => c.value = v2, "set")
      });
      if (false) {
        checkDuplicateProperties("Computed", key);
      }
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction$4(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created3) {
    callHook$1(created3, instance, "c");
  }
  function registerLifecycleHook(register3, hook) {
    if (isArray$4(hook)) {
      hook.forEach((_hook3) => register3(_hook3.bind(publicThis)));
    } else if (hook) {
      register3(hook.bind(publicThis));
    }
  }
  __name(registerLifecycleHook, "registerLifecycleHook");
  registerLifecycleHook(onBeforeMount, beforeMount4);
  registerLifecycleHook(onMounted, mounted23);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate2);
  registerLifecycleHook(onUpdated, updated12);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount17);
  registerLifecycleHook(onUnmounted, unmounted6);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray$4(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: /* @__PURE__ */ __name(() => publicThis[key], "get"),
          set: /* @__PURE__ */ __name((val) => publicThis[key] = val, "set")
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render2 && instance.render === NOOP) {
    instance.render = render2;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components) instance.components = components;
  if (directives) instance.directives = directives;
}
__name(applyOptions, "applyOptions");
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
  if (isArray$4(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject$6(opt)) {
      if ("default" in opt) {
        injected = inject(
          opt.from || key,
          opt.default,
          true
        );
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: /* @__PURE__ */ __name(() => injected.value, "get"),
        set: /* @__PURE__ */ __name((v2) => injected.value = v2, "set")
      });
    } else {
      ctx[key] = injected;
    }
    if (false) {
      checkDuplicateProperties("Inject", key);
    }
  }
}
__name(resolveInjections, "resolveInjections");
function callHook$1(hook, instance, type) {
  callWithAsyncErrorHandling(
    isArray$4(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
    instance,
    type
  );
}
__name(callHook$1, "callHook$1");
function createWatcher(raw, ctx, publicThis, key) {
  const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString$5(raw)) {
    const handler6 = ctx[raw];
    if (isFunction$4(handler6)) {
      watch(getter, handler6);
    } else if (false) {
      warn$1(`Invalid watch handler specified by key "${raw}"`, handler6);
    }
  } else if (isFunction$4(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if (isObject$6(raw)) {
    if (isArray$4(raw)) {
      raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
    } else {
      const handler6 = isFunction$4(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction$4(handler6)) {
        watch(getter, handler6, raw);
      } else if (false) {
        warn$1(`Invalid watch handler specified by key "${raw.handler}"`, handler6);
      }
    }
  } else if (false) {
    warn$1(`Invalid watch option: "${key}"`, raw);
  }
}
__name(createWatcher, "createWatcher");
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const {
    mixins: globalMixins,
    optionsCache: cache2,
    config: { optionMergeStrategies }
  } = instance.appContext;
  const cached = cache2.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach(
        (m) => mergeOptions(resolved, m, optionMergeStrategies, true)
      );
    }
    mergeOptions(resolved, base, optionMergeStrategies);
  }
  if (isObject$6(base)) {
    cache2.set(base, resolved);
  }
  return resolved;
}
__name(resolveMergedOptions, "resolveMergedOptions");
function mergeOptions(to, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach(
      (m) => mergeOptions(to, m, strats, true)
    );
  }
  for (const key in from) {
    if (asMixin && key === "expose") {
    } else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }
  return to;
}
__name(mergeOptions, "mergeOptions");
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeEmitsOrPropsOptions,
  emits: mergeEmitsOrPropsOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return /* @__PURE__ */ __name(function mergedDataFn() {
    return extend$1(
      isFunction$4(to) ? to.call(this, this) : to,
      isFunction$4(from) ? from.call(this, this) : from
    );
  }, "mergedDataFn");
}
__name(mergeDataFn, "mergeDataFn");
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
__name(mergeInject, "mergeInject");
function normalizeInject(raw) {
  if (isArray$4(raw)) {
    const res = {};
    for (let i2 = 0; i2 < raw.length; i2++) {
      res[raw[i2]] = raw[i2];
    }
    return res;
  }
  return raw;
}
__name(normalizeInject, "normalizeInject");
function mergeAsArray(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
__name(mergeAsArray, "mergeAsArray");
function mergeObjectOptions(to, from) {
  return to ? extend$1(/* @__PURE__ */ Object.create(null), to, from) : from;
}
__name(mergeObjectOptions, "mergeObjectOptions");
function mergeEmitsOrPropsOptions(to, from) {
  if (to) {
    if (isArray$4(to) && isArray$4(from)) {
      return [.../* @__PURE__ */ new Set([...to, ...from])];
    }
    return extend$1(
      /* @__PURE__ */ Object.create(null),
      normalizePropsOrEmits(to),
      normalizePropsOrEmits(from != null ? from : {})
    );
  } else {
    return from;
  }
}
__name(mergeEmitsOrPropsOptions, "mergeEmitsOrPropsOptions");
function mergeWatchOptions(to, from) {
  if (!to) return from;
  if (!from) return to;
  const merged = extend$1(/* @__PURE__ */ Object.create(null), to);
  for (const key in from) {
    merged[key] = mergeAsArray(to[key], from[key]);
  }
  return merged;
}
__name(mergeWatchOptions, "mergeWatchOptions");
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
__name(createAppContext, "createAppContext");
let uid$1 = 0;
function createAppAPI(render2, hydrate2) {
  return /* @__PURE__ */ __name(function createApp2(rootComponent, rootProps = null) {
    if (!isFunction$4(rootComponent)) {
      rootComponent = extend$1({}, rootComponent);
    }
    if (rootProps != null && !isObject$6(rootProps)) {
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new WeakSet();
    let isMounted = false;
    const app2 = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version,
      get config() {
        return context.config;
      },
      set config(v2) {
        if (false) {
          warn$1(
            `app.config cannot be replaced. Modify individual options instead.`
          );
        }
      },
      use(plugin, ...options3) {
        if (installedPlugins.has(plugin)) {
        } else if (plugin && isFunction$4(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app2, ...options3);
        } else if (isFunction$4(plugin)) {
          installedPlugins.add(plugin);
          plugin(app2, ...options3);
        } else if (false) {
          warn$1(
            `A plugin must either be a function or an object with an "install" function.`
          );
        }
        return app2;
      },
      mixin(mixin) {
        if (true) {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          } else if (false) {
            warn$1(
              "Mixin has already been applied to target app" + (mixin.name ? `: ${mixin.name}` : "")
            );
          }
        } else if (false) {
          warn$1("Mixins are only available in builds supporting Options API");
        }
        return app2;
      },
      component(name, component) {
        if (false) {
          validateComponentName(name, context.config);
        }
        if (!component) {
          return context.components[name];
        }
        if (false) {
          warn$1(`Component "${name}" has already been registered in target app.`);
        }
        context.components[name] = component;
        return app2;
      },
      directive(name, directive) {
        if (false) {
          validateDirectiveName(name);
        }
        if (!directive) {
          return context.directives[name];
        }
        if (false) {
          warn$1(`Directive "${name}" has already been registered in target app.`);
        }
        context.directives[name] = directive;
        return app2;
      },
      mount(rootContainer, isHydrate, namespace) {
        if (!isMounted) {
          if (false) {
            warn$1(
              `There is already an app instance mounted on the host container.
 If you want to mount another app on the same host container, you need to unmount the previous app by calling \`app.unmount()\` first.`
            );
          }
          const vnode = createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (namespace === true) {
            namespace = "svg";
          } else if (namespace === false) {
            namespace = void 0;
          }
          if (false) {
            context.reload = () => {
              render2(
                cloneVNode(vnode),
                rootContainer,
                namespace
              );
            };
          }
          if (isHydrate && hydrate2) {
            hydrate2(vnode, rootContainer);
          } else {
            render2(vnode, rootContainer, namespace);
          }
          isMounted = true;
          app2._container = rootContainer;
          rootContainer.__vue_app__ = app2;
          if (false) {
            app2._instance = vnode.component;
            devtoolsInitApp(app2, version);
          }
          return getComponentPublicInstance(vnode.component);
        } else if (false) {
          warn$1(
            `App has already been mounted.
If you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. \`const createMyApp = () => createApp(App)\``
          );
        }
      },
      unmount() {
        if (isMounted) {
          render2(null, app2._container);
          if (false) {
            app2._instance = null;
            devtoolsUnmountApp(app2);
          }
          delete app2._container.__vue_app__;
        } else if (false) {
          warn$1(`Cannot unmount an app that is not mounted.`);
        }
      },
      provide(key, value3) {
        if (false) {
          warn$1(
            `App already provides property with key "${String(key)}". It will be overwritten with the new value.`
          );
        }
        context.provides[key] = value3;
        return app2;
      },
      runWithContext(fn) {
        const lastApp = currentApp;
        currentApp = app2;
        try {
          return fn();
        } finally {
          currentApp = lastApp;
        }
      }
    };
    return app2;
  }, "createApp");
}
__name(createAppAPI, "createAppAPI");
let currentApp = null;
function provide(key, value3) {
  if (!currentInstance) {
    if (false) {
      warn$1(`provide() can only be used inside setup().`);
    }
  } else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value3;
  }
}
__name(provide, "provide");
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance || currentApp) {
    const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction$4(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
    } else if (false) {
      warn$1(`injection "${String(key)}" not found.`);
    }
  } else if (false) {
    warn$1(`inject() can only be used inside setup() or functional components.`);
  }
}
__name(inject, "inject");
function hasInjectionContext() {
  return !!(currentInstance || currentRenderingInstance || currentApp);
}
__name(hasInjectionContext, "hasInjectionContext");
const internalObjectProto = {};
const createInternalObject = /* @__PURE__ */ __name(() => Object.create(internalObjectProto), "createInternalObject");
const isInternalObject = /* @__PURE__ */ __name((obj) => Object.getPrototypeOf(obj) === internalObjectProto, "isInternalObject");
function initProps(instance, rawProps, isStateful2, isSSR = false) {
  const props = {};
  const attrs3 = createInternalObject();
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs3);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (false) {
    validateProps(rawProps || {}, props, instance);
  }
  if (isStateful2) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs3;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs3;
}
__name(initProps, "initProps");
function isInHmrContext(instance) {
  while (instance) {
    if (instance.type.__hmrId) return true;
    instance = instance.parent;
  }
}
__name(isInHmrContext, "isInHmrContext");
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const {
    props,
    attrs: attrs3,
    vnode: { patchFlag }
  } = instance;
  const rawCurrentProps = toRaw(props);
  const [options3] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (optimized || patchFlag > 0) && !(patchFlag & 16)
  ) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
        let key = propsToUpdate[i2];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value3 = rawProps[key];
        if (options3) {
          if (hasOwn$3(attrs3, key)) {
            if (value3 !== attrs3[key]) {
              attrs3[key] = value3;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize$1(key);
            props[camelizedKey] = resolvePropValue(
              options3,
              rawCurrentProps,
              camelizedKey,
              value3,
              instance,
              false
            );
          }
        } else {
          if (value3 !== attrs3[key]) {
            attrs3[key] = value3;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs3)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !hasOwn$3(rawProps, key) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((kebabKey = hyphenate$1(key)) === key || !hasOwn$3(rawProps, kebabKey))) {
        if (options3) {
          if (rawPrevProps && // for camelCase
          (rawPrevProps[key] !== void 0 || // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(
              options3,
              rawCurrentProps,
              key,
              void 0,
              instance,
              true
            );
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs3 !== rawCurrentProps) {
      for (const key in attrs3) {
        if (!rawProps || !hasOwn$3(rawProps, key) && true) {
          delete attrs3[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance.attrs, "set", "");
  }
  if (false) {
    validateProps(rawProps || {}, props, instance);
  }
}
__name(updateProps, "updateProps");
function setFullProps(instance, rawProps, props, attrs3) {
  const [options3, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value3 = rawProps[key];
      let camelKey;
      if (options3 && hasOwn$3(options3, camelKey = camelize$1(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value3;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value3;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs3) || value3 !== attrs3[key]) {
          attrs3[key] = value3;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i2 = 0; i2 < needCastKeys.length; i2++) {
      const key = needCastKeys[i2];
      props[key] = resolvePropValue(
        options3,
        rawCurrentProps,
        key,
        castValues[key],
        instance,
        !hasOwn$3(castValues, key)
      );
    }
  }
  return hasAttrsChanged;
}
__name(setFullProps, "setFullProps");
function resolvePropValue(options3, props, key, value3, instance, isAbsent) {
  const opt = options3[key];
  if (opt != null) {
    const hasDefault = hasOwn$3(opt, "default");
    if (hasDefault && value3 === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && !opt.skipFactory && isFunction$4(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value3 = propsDefaults[key];
        } else {
          const reset = setCurrentInstance(instance);
          value3 = propsDefaults[key] = defaultValue.call(
            null,
            props
          );
          reset();
        }
      } else {
        value3 = defaultValue;
      }
    }
    if (opt[
      0
      /* shouldCast */
    ]) {
      if (isAbsent && !hasDefault) {
        value3 = false;
      } else if (opt[
        1
        /* shouldCastTrue */
      ] && (value3 === "" || value3 === hyphenate$1(key))) {
        value3 = true;
      }
    }
  }
  return value3;
}
__name(resolvePropValue, "resolvePropValue");
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache2 = appContext.propsCache;
  const cached = cache2.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction$4(comp)) {
    const extendProps = /* @__PURE__ */ __name((raw2) => {
      hasExtends = true;
      const [props, keys2] = normalizePropsOptions(raw2, appContext, true);
      extend$1(normalized, props);
      if (keys2) needCastKeys.push(...keys2);
    }, "extendProps");
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$6(comp)) {
      cache2.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray$4(raw)) {
    for (let i2 = 0; i2 < raw.length; i2++) {
      if (false) {
        warn$1(`props must be strings when using array syntax.`, raw[i2]);
      }
      const normalizedKey = camelize$1(raw[i2]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    if (false) {
      warn$1(`invalid props options`, raw);
    }
    for (const key in raw) {
      const normalizedKey = camelize$1(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop2 = normalized[normalizedKey] = isArray$4(opt) || isFunction$4(opt) ? { type: opt } : extend$1({}, opt);
        if (prop2) {
          const booleanIndex = getTypeIndex(Boolean, prop2.type);
          const stringIndex = getTypeIndex(String, prop2.type);
          prop2[
            0
            /* shouldCast */
          ] = booleanIndex > -1;
          prop2[
            1
            /* shouldCastTrue */
          ] = stringIndex < 0 || booleanIndex < stringIndex;
          if (booleanIndex > -1 || hasOwn$3(prop2, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject$6(comp)) {
    cache2.set(comp, res);
  }
  return res;
}
__name(normalizePropsOptions, "normalizePropsOptions");
function validatePropName(key) {
  if (key[0] !== "$" && !isReservedProp(key)) {
    return true;
  } else if (false) {
    warn$1(`Invalid prop name: "${key}" is a reserved property.`);
  }
  return false;
}
__name(validatePropName, "validatePropName");
function getType(ctor) {
  if (ctor === null) {
    return "null";
  }
  if (typeof ctor === "function") {
    return ctor.name || "";
  } else if (typeof ctor === "object") {
    const name = ctor.constructor && ctor.constructor.name;
    return name || "";
  }
  return "";
}
__name(getType, "getType");
function isSameType(a, b) {
  return getType(a) === getType(b);
}
__name(isSameType, "isSameType");
function getTypeIndex(type, expectedTypes) {
  if (isArray$4(expectedTypes)) {
    return expectedTypes.findIndex((t) => isSameType(t, type));
  } else if (isFunction$4(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }
  return -1;
}
__name(getTypeIndex, "getTypeIndex");
function validateProps(rawProps, props, instance) {
  const resolvedValues = toRaw(props);
  const options3 = instance.propsOptions[0];
  for (const key in options3) {
    let opt = options3[key];
    if (opt == null) continue;
    validateProp(
      key,
      resolvedValues[key],
      opt,
      false ? shallowReadonly(resolvedValues) : resolvedValues,
      !hasOwn$3(rawProps, key) && !hasOwn$3(rawProps, hyphenate$1(key))
    );
  }
}
__name(validateProps, "validateProps");
function validateProp(name, value3, prop2, props, isAbsent) {
  const { type, required, validator: validator3, skipCheck } = prop2;
  if (required && isAbsent) {
    warn$1('Missing required prop: "' + name + '"');
    return;
  }
  if (value3 == null && !required) {
    return;
  }
  if (type != null && type !== true && !skipCheck) {
    let isValid2 = false;
    const types = isArray$4(type) ? type : [type];
    const expectedTypes = [];
    for (let i2 = 0; i2 < types.length && !isValid2; i2++) {
      const { valid, expectedType } = assertType(value3, types[i2]);
      expectedTypes.push(expectedType || "");
      isValid2 = valid;
    }
    if (!isValid2) {
      warn$1(getInvalidTypeMessage(name, value3, expectedTypes));
      return;
    }
  }
  if (validator3 && !validator3(value3, props)) {
    warn$1('Invalid prop: custom validator check failed for prop "' + name + '".');
  }
}
__name(validateProp, "validateProp");
const isSimpleType = /* @__PURE__ */ makeMap(
  "String,Number,Boolean,Function,Symbol,BigInt"
);
function assertType(value3, type) {
  let valid;
  const expectedType = getType(type);
  if (isSimpleType(expectedType)) {
    const t = typeof value3;
    valid = t === expectedType.toLowerCase();
    if (!valid && t === "object") {
      valid = value3 instanceof type;
    }
  } else if (expectedType === "Object") {
    valid = isObject$6(value3);
  } else if (expectedType === "Array") {
    valid = isArray$4(value3);
  } else if (expectedType === "null") {
    valid = value3 === null;
  } else {
    valid = value3 instanceof type;
  }
  return {
    valid,
    expectedType
  };
}
__name(assertType, "assertType");
function getInvalidTypeMessage(name, value3, expectedTypes) {
  if (expectedTypes.length === 0) {
    return `Prop type [] for prop "${name}" won't match anything. Did you mean to use type Array instead?`;
  }
  let message3 = `Invalid prop: type check failed for prop "${name}". Expected ${expectedTypes.map(capitalize$1).join(" | ")}`;
  const expectedType = expectedTypes[0];
  const receivedType = toRawType(value3);
  const expectedValue = styleValue(value3, expectedType);
  const receivedValue = styleValue(value3, receivedType);
  if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean$3(expectedType, receivedType)) {
    message3 += ` with value ${expectedValue}`;
  }
  message3 += `, got ${receivedType} `;
  if (isExplicable(receivedType)) {
    message3 += `with value ${receivedValue}.`;
  }
  return message3;
}
__name(getInvalidTypeMessage, "getInvalidTypeMessage");
function styleValue(value3, type) {
  if (type === "String") {
    return `"${value3}"`;
  } else if (type === "Number") {
    return `${Number(value3)}`;
  } else {
    return `${value3}`;
  }
}
__name(styleValue, "styleValue");
function isExplicable(type) {
  const explicitTypes = ["string", "number", "boolean"];
  return explicitTypes.some((elem) => type.toLowerCase() === elem);
}
__name(isExplicable, "isExplicable");
function isBoolean$3(...args) {
  return args.some((elem) => elem.toLowerCase() === "boolean");
}
__name(isBoolean$3, "isBoolean$3");
const isInternalKey = /* @__PURE__ */ __name((key) => key[0] === "_" || key === "$stable", "isInternalKey");
const normalizeSlotValue = /* @__PURE__ */ __name((value3) => isArray$4(value3) ? value3.map(normalizeVNode) : [normalizeVNode(value3)], "normalizeSlotValue");
const normalizeSlot = /* @__PURE__ */ __name((key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (false) {
      warn$1(
        `Slot "${key}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`
      );
    }
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
}, "normalizeSlot");
const normalizeObjectSlots = /* @__PURE__ */ __name((rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key)) continue;
    const value3 = rawSlots[key];
    if (isFunction$4(value3)) {
      slots[key] = normalizeSlot(key, value3, ctx);
    } else if (value3 != null) {
      if (false) {
        warn$1(
          `Non-function value encountered for slot "${key}". Prefer function slots for better performance.`
        );
      }
      const normalized = normalizeSlotValue(value3);
      slots[key] = () => normalized;
    }
  }
}, "normalizeObjectSlots");
const normalizeVNodeSlots = /* @__PURE__ */ __name((instance, children) => {
  if (false) {
    warn$1(
      `Non-function value encountered for default slot. Prefer function slots for better performance.`
    );
  }
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
}, "normalizeVNodeSlots");
const initSlots = /* @__PURE__ */ __name((instance, children) => {
  const slots = instance.slots = createInternalObject();
  if (instance.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      extend$1(slots, children);
      def(slots, "_", type, true);
    } else {
      normalizeObjectSlots(children, slots);
    }
  } else if (children) {
    normalizeVNodeSlots(instance, children);
  }
}, "initSlots");
const updateSlots = /* @__PURE__ */ __name((instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (false) {
        extend$1(slots, children);
        trigger(instance, "set", "$slots");
      } else if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        extend$1(slots, children);
        if (!optimized && type === 1) {
          delete slots._;
        }
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
        delete slots[key];
      }
    }
  }
}, "updateSlots");
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray$4(rawRef)) {
    rawRef.forEach(
      (r, i2) => setRef(
        r,
        oldRawRef && (isArray$4(oldRawRef) ? oldRawRef[i2] : oldRawRef),
        parentSuspense,
        vnode,
        isUnmount
      )
    );
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
  const value3 = isUnmount ? null : refValue;
  const { i: owner, r: ref3 } = rawRef;
  if (false) {
    warn$1(
      `Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.`
    );
    return;
  }
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  if (oldRef != null && oldRef !== ref3) {
    if (isString$5(oldRef)) {
      refs[oldRef] = null;
      if (hasOwn$3(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction$4(ref3)) {
    callWithErrorHandling(ref3, owner, 12, [value3, refs]);
  } else {
    const _isString = isString$5(ref3);
    const _isRef = isRef(ref3);
    if (_isString || _isRef) {
      const doSet = /* @__PURE__ */ __name(() => {
        if (rawRef.f) {
          const existing = _isString ? hasOwn$3(setupState, ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
          if (isUnmount) {
            isArray$4(existing) && remove$1(existing, refValue);
          } else {
            if (!isArray$4(existing)) {
              if (_isString) {
                refs[ref3] = [refValue];
                if (hasOwn$3(setupState, ref3)) {
                  setupState[ref3] = refs[ref3];
                }
              } else {
                ref3.value = [refValue];
                if (rawRef.k) refs[rawRef.k] = ref3.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref3] = value3;
          if (hasOwn$3(setupState, ref3)) {
            setupState[ref3] = value3;
          }
        } else if (_isRef) {
          ref3.value = value3;
          if (rawRef.k) refs[rawRef.k] = value3;
        } else if (false) {
          warn$1("Invalid template ref type:", ref3, `(${typeof ref3})`);
        }
      }, "doSet");
      if (value3) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    } else if (false) {
      warn$1("Invalid template ref type:", ref3, `(${typeof ref3})`);
    }
  }
}
__name(setRef, "setRef");
let hasLoggedMismatchError = false;
const logMismatchError = /* @__PURE__ */ __name(() => {
  if (hasLoggedMismatchError) {
    return;
  }
  console.error("Hydration completed but contains mismatches.");
  hasLoggedMismatchError = true;
}, "logMismatchError");
const isSVGContainer = /* @__PURE__ */ __name((container) => container.namespaceURI.includes("svg") && container.tagName !== "foreignObject", "isSVGContainer");
const isMathMLContainer = /* @__PURE__ */ __name((container) => container.namespaceURI.includes("MathML"), "isMathMLContainer");
const getContainerType = /* @__PURE__ */ __name((container) => {
  if (isSVGContainer(container)) return "svg";
  if (isMathMLContainer(container)) return "mathml";
  return void 0;
}, "getContainerType");
const isComment = /* @__PURE__ */ __name((node3) => node3.nodeType === 8, "isComment");
function createHydrationFunctions(rendererInternals) {
  const {
    mt: mountComponent,
    p: patch,
    o: {
      patchProp: patchProp2,
      createText,
      nextSibling,
      parentNode,
      remove: remove22,
      insert: insert2,
      createComment
    }
  } = rendererInternals;
  const hydrate2 = /* @__PURE__ */ __name((vnode, container) => {
    if (!container.hasChildNodes()) {
      patch(null, vnode, container);
      flushPostFlushCbs();
      container._vnode = vnode;
      return;
    }
    hydrateNode(container.firstChild, vnode, null, null, null);
    flushPostFlushCbs();
    container._vnode = vnode;
  }, "hydrate");
  const hydrateNode = /* @__PURE__ */ __name((node3, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {
    optimized = optimized || !!vnode.dynamicChildren;
    const isFragmentStart = isComment(node3) && node3.data === "[";
    const onMismatch = /* @__PURE__ */ __name(() => handleMismatch(
      node3,
      vnode,
      parentComponent,
      parentSuspense,
      slotScopeIds,
      isFragmentStart
    ), "onMismatch");
    const { type, ref: ref3, shapeFlag, patchFlag } = vnode;
    let domType = node3.nodeType;
    vnode.el = node3;
    if (false) {
      def(node3, "__vnode", vnode, true);
      def(node3, "__vueParentComponent", parentComponent, true);
    }
    if (patchFlag === -2) {
      optimized = false;
      vnode.dynamicChildren = null;
    }
    let nextNode = null;
    switch (type) {
      case Text:
        if (domType !== 3) {
          if (vnode.children === "") {
            insert2(vnode.el = createText(""), parentNode(node3), node3);
            nextNode = node3;
          } else {
            nextNode = onMismatch();
          }
        } else {
          if (node3.data !== vnode.children) {
            logMismatchError();
            node3.data = vnode.children;
          }
          nextNode = nextSibling(node3);
        }
        break;
      case Comment:
        if (isTemplateNode(node3)) {
          nextNode = nextSibling(node3);
          replaceNode(
            vnode.el = node3.content.firstChild,
            node3,
            parentComponent
          );
        } else if (domType !== 8 || isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = nextSibling(node3);
        }
        break;
      case Static:
        if (isFragmentStart) {
          node3 = nextSibling(node3);
          domType = node3.nodeType;
        }
        if (domType === 1 || domType === 3) {
          nextNode = node3;
          const needToAdoptContent = !vnode.children.length;
          for (let i2 = 0; i2 < vnode.staticCount; i2++) {
            if (needToAdoptContent)
              vnode.children += nextNode.nodeType === 1 ? nextNode.outerHTML : nextNode.data;
            if (i2 === vnode.staticCount - 1) {
              vnode.anchor = nextNode;
            }
            nextNode = nextSibling(nextNode);
          }
          return isFragmentStart ? nextSibling(nextNode) : nextNode;
        } else {
          onMismatch();
        }
        break;
      case Fragment:
        if (!isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = hydrateFragment(
            node3,
            vnode,
            parentComponent,
            parentSuspense,
            slotScopeIds,
            optimized
          );
        }
        break;
      default:
        if (shapeFlag & 1) {
          if ((domType !== 1 || vnode.type.toLowerCase() !== node3.tagName.toLowerCase()) && !isTemplateNode(node3)) {
            nextNode = onMismatch();
          } else {
            nextNode = hydrateElement(
              node3,
              vnode,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
          }
        } else if (shapeFlag & 6) {
          vnode.slotScopeIds = slotScopeIds;
          const container = parentNode(node3);
          if (isFragmentStart) {
            nextNode = locateClosingAnchor(node3);
          } else if (isComment(node3) && node3.data === "teleport start") {
            nextNode = locateClosingAnchor(node3, node3.data, "teleport end");
          } else {
            nextNode = nextSibling(node3);
          }
          mountComponent(
            vnode,
            container,
            null,
            parentComponent,
            parentSuspense,
            getContainerType(container),
            optimized
          );
          if (isAsyncWrapper(vnode)) {
            let subTree;
            if (isFragmentStart) {
              subTree = createVNode(Fragment);
              subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;
            } else {
              subTree = node3.nodeType === 3 ? createTextVNode("") : createVNode("div");
            }
            subTree.el = node3;
            vnode.component.subTree = subTree;
          }
        } else if (shapeFlag & 64) {
          if (domType !== 8) {
            nextNode = onMismatch();
          } else {
            nextNode = vnode.type.hydrate(
              node3,
              vnode,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized,
              rendererInternals,
              hydrateChildren
            );
          }
        } else if (shapeFlag & 128) {
          nextNode = vnode.type.hydrate(
            node3,
            vnode,
            parentComponent,
            parentSuspense,
            getContainerType(parentNode(node3)),
            slotScopeIds,
            optimized,
            rendererInternals,
            hydrateNode
          );
        } else if (false) {
          warn$1("Invalid HostVNode type:", type, `(${typeof type})`);
        }
    }
    if (ref3 != null) {
      setRef(ref3, null, parentSuspense, vnode);
    }
    return nextNode;
  }, "hydrateNode");
  const hydrateElement = /* @__PURE__ */ __name((el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!vnode.dynamicChildren;
    const { type, props, patchFlag, shapeFlag, dirs, transition } = vnode;
    const forcePatch = type === "input" || type === "option";
    if (forcePatch || patchFlag !== -1) {
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      let needCallTransitionHooks = false;
      if (isTemplateNode(el)) {
        needCallTransitionHooks = needTransition(parentSuspense, transition) && parentComponent && parentComponent.vnode.props && parentComponent.vnode.props.appear;
        const content = el.content.firstChild;
        if (needCallTransitionHooks) {
          transition.beforeEnter(content);
        }
        replaceNode(content, el, parentComponent);
        vnode.el = el = content;
      }
      if (shapeFlag & 16 && // skip if element has innerHTML / textContent
      !(props && (props.innerHTML || props.textContent))) {
        let next2 = hydrateChildren(
          el.firstChild,
          vnode,
          el,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
        let hasWarned2 = false;
        while (next2) {
          if (false) {
            warn$1(
              `Hydration children mismatch on`,
              el,
              `
Server rendered element contains more child nodes than client vdom.`
            );
            hasWarned2 = true;
          }
          logMismatchError();
          const cur = next2;
          next2 = next2.nextSibling;
          remove22(cur);
        }
      } else if (shapeFlag & 8) {
        if (el.textContent !== vnode.children) {
          logMismatchError();
          el.textContent = vnode.children;
        }
      }
      if (props) {
        if (forcePatch || !optimized || patchFlag & (16 | 32)) {
          for (const key in props) {
            if (false) {
              logMismatchError();
            }
            if (forcePatch && (key.endsWith("value") || key === "indeterminate") || isOn(key) && !isReservedProp(key) || // force hydrate v-bind with .prop modifiers
            key[0] === ".") {
              patchProp2(
                el,
                key,
                null,
                props[key],
                void 0,
                void 0,
                parentComponent
              );
            }
          }
        } else if (props.onClick) {
          patchProp2(
            el,
            "onClick",
            null,
            props.onClick,
            void 0,
            void 0,
            parentComponent
          );
        }
      }
      let vnodeHooks;
      if (vnodeHooks = props && props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHooks, parentComponent, vnode);
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
      }
      if ((vnodeHooks = props && props.onVnodeMounted) || dirs || needCallTransitionHooks) {
        queueEffectWithSuspense(() => {
          vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
          needCallTransitionHooks && transition.enter(el);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
      }
    }
    return el.nextSibling;
  }, "hydrateElement");
  const hydrateChildren = /* @__PURE__ */ __name((node3, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!parentVNode.dynamicChildren;
    const children = parentVNode.children;
    const l = children.length;
    let hasWarned2 = false;
    for (let i2 = 0; i2 < l; i2++) {
      const vnode = optimized ? children[i2] : children[i2] = normalizeVNode(children[i2]);
      if (node3) {
        node3 = hydrateNode(
          node3,
          vnode,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
      } else if (vnode.type === Text && !vnode.children) {
        insert2(vnode.el = createText(""), container);
      } else {
        if (false) {
          warn$1(
            `Hydration children mismatch on`,
            container,
            `
Server rendered element contains fewer child nodes than client vdom.`
          );
          hasWarned2 = true;
        }
        logMismatchError();
        patch(
          null,
          vnode,
          container,
          null,
          parentComponent,
          parentSuspense,
          getContainerType(container),
          slotScopeIds
        );
      }
    }
    return node3;
  }, "hydrateChildren");
  const hydrateFragment = /* @__PURE__ */ __name((node3, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    const { slotScopeIds: fragmentSlotScopeIds } = vnode;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    const container = parentNode(node3);
    const next2 = hydrateChildren(
      nextSibling(node3),
      vnode,
      container,
      parentComponent,
      parentSuspense,
      slotScopeIds,
      optimized
    );
    if (next2 && isComment(next2) && next2.data === "]") {
      return nextSibling(vnode.anchor = next2);
    } else {
      logMismatchError();
      insert2(vnode.anchor = createComment(`]`), container, next2);
      return next2;
    }
  }, "hydrateFragment");
  const handleMismatch = /* @__PURE__ */ __name((node3, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {
    logMismatchError();
    vnode.el = null;
    if (isFragment) {
      const end = locateClosingAnchor(node3);
      while (true) {
        const next22 = nextSibling(node3);
        if (next22 && next22 !== end) {
          remove22(next22);
        } else {
          break;
        }
      }
    }
    const next2 = nextSibling(node3);
    const container = parentNode(node3);
    remove22(node3);
    patch(
      null,
      vnode,
      container,
      next2,
      parentComponent,
      parentSuspense,
      getContainerType(container),
      slotScopeIds
    );
    return next2;
  }, "handleMismatch");
  const locateClosingAnchor = /* @__PURE__ */ __name((node3, open2 = "[", close4 = "]") => {
    let match = 0;
    while (node3) {
      node3 = nextSibling(node3);
      if (node3 && isComment(node3)) {
        if (node3.data === open2) match++;
        if (node3.data === close4) {
          if (match === 0) {
            return nextSibling(node3);
          } else {
            match--;
          }
        }
      }
    }
    return node3;
  }, "locateClosingAnchor");
  const replaceNode = /* @__PURE__ */ __name((newNode, oldNode, parentComponent) => {
    const parentNode2 = oldNode.parentNode;
    if (parentNode2) {
      parentNode2.replaceChild(newNode, oldNode);
    }
    let parent = parentComponent;
    while (parent) {
      if (parent.vnode.el === oldNode) {
        parent.vnode.el = parent.subTree.el = newNode;
      }
      parent = parent.parent;
    }
  }, "replaceNode");
  const isTemplateNode = /* @__PURE__ */ __name((node3) => {
    return node3.nodeType === 1 && node3.tagName.toLowerCase() === "template";
  }, "isTemplateNode");
  return [hydrate2, hydrateNode];
}
__name(createHydrationFunctions, "createHydrationFunctions");
function propHasMismatch(el, key, clientValue, vnode, instance) {
  let mismatchType;
  let mismatchKey;
  let actual;
  let expected;
  if (key === "class") {
    actual = el.getAttribute("class");
    expected = normalizeClass(clientValue);
    if (!isSetEqual(toClassSet(actual || ""), toClassSet(expected))) {
      mismatchType = mismatchKey = `class`;
    }
  } else if (key === "style") {
    actual = el.getAttribute("style") || "";
    expected = isString$5(clientValue) ? clientValue : stringifyStyle(normalizeStyle(clientValue));
    const actualMap = toStyleMap(actual);
    const expectedMap = toStyleMap(expected);
    if (vnode.dirs) {
      for (const { dir, value: value3 } of vnode.dirs) {
        if (dir.name === "show" && !value3) {
          expectedMap.set("display", "none");
        }
      }
    }
    if (instance) {
      resolveCssVars(instance, vnode, expectedMap);
    }
    if (!isMapEqual(actualMap, expectedMap)) {
      mismatchType = mismatchKey = "style";
    }
  } else if (el instanceof SVGElement && isKnownSvgAttr(key) || el instanceof HTMLElement && (isBooleanAttr(key) || isKnownHtmlAttr(key))) {
    if (isBooleanAttr(key)) {
      actual = el.hasAttribute(key);
      expected = includeBooleanAttr(clientValue);
    } else if (clientValue == null) {
      actual = el.hasAttribute(key);
      expected = false;
    } else {
      if (el.hasAttribute(key)) {
        actual = el.getAttribute(key);
      } else if (key === "value" && el.tagName === "TEXTAREA") {
        actual = el.value;
      } else {
        actual = false;
      }
      expected = isRenderableAttrValue(clientValue) ? String(clientValue) : false;
    }
    if (actual !== expected) {
      mismatchType = `attribute`;
      mismatchKey = key;
    }
  }
  if (mismatchType) {
    const format2 = /* @__PURE__ */ __name((v2) => v2 === false ? `(not rendered)` : `${mismatchKey}="${v2}"`, "format");
    const preSegment = `Hydration ${mismatchType} mismatch on`;
    const postSegment = `
  - rendered on server: ${format2(actual)}
  - expected on client: ${format2(expected)}
  Note: this mismatch is check-only. The DOM will not be rectified in production due to performance overhead.
  You should fix the source of the mismatch.`;
    {
      warn$1(preSegment, el, postSegment);
    }
    return true;
  }
  return false;
}
__name(propHasMismatch, "propHasMismatch");
function toClassSet(str) {
  return new Set(str.trim().split(/\s+/));
}
__name(toClassSet, "toClassSet");
function isSetEqual(a, b) {
  if (a.size !== b.size) {
    return false;
  }
  for (const s of a) {
    if (!b.has(s)) {
      return false;
    }
  }
  return true;
}
__name(isSetEqual, "isSetEqual");
function toStyleMap(str) {
  const styleMap = /* @__PURE__ */ new Map();
  for (const item2 of str.split(";")) {
    let [key, value3] = item2.split(":");
    key = key.trim();
    value3 = value3 && value3.trim();
    if (key && value3) {
      styleMap.set(key, value3);
    }
  }
  return styleMap;
}
__name(toStyleMap, "toStyleMap");
function isMapEqual(a, b) {
  if (a.size !== b.size) {
    return false;
  }
  for (const [key, value3] of a) {
    if (value3 !== b.get(key)) {
      return false;
    }
  }
  return true;
}
__name(isMapEqual, "isMapEqual");
function resolveCssVars(instance, vnode, expectedMap) {
  const root26 = instance.subTree;
  if (instance.getCssVars && (vnode === root26 || root26 && root26.type === Fragment && root26.children.includes(vnode))) {
    const cssVars = instance.getCssVars();
    for (const key in cssVars) {
      expectedMap.set(`--${key}`, String(cssVars[key]));
    }
  }
  if (vnode === root26 && instance.parent) {
    resolveCssVars(instance.parent, instance.vnode, expectedMap);
  }
}
__name(resolveCssVars, "resolveCssVars");
let supported$1;
let perf$1;
function startMeasure(instance, type) {
  if (instance.appContext.config.performance && isSupported()) {
    perf$1.mark(`vue-${type}-${instance.uid}`);
  }
  if (false) {
    devtoolsPerfStart(instance, type, isSupported() ? perf$1.now() : Date.now());
  }
}
__name(startMeasure, "startMeasure");
function endMeasure(instance, type) {
  if (instance.appContext.config.performance && isSupported()) {
    const startTag = `vue-${type}-${instance.uid}`;
    const endTag = startTag + `:end`;
    perf$1.mark(endTag);
    perf$1.measure(
      `<${formatComponentName(instance, instance.type)}> ${type}`,
      startTag,
      endTag
    );
    perf$1.clearMarks(startTag);
    perf$1.clearMarks(endTag);
  }
  if (false) {
    devtoolsPerfEnd(instance, type, isSupported() ? perf$1.now() : Date.now());
  }
}
__name(endMeasure, "endMeasure");
function isSupported() {
  if (supported$1 !== void 0) {
    return supported$1;
  }
  if (typeof window !== "undefined" && window.performance) {
    supported$1 = true;
    perf$1 = window.performance;
  } else {
    supported$1 = false;
  }
  return supported$1;
}
__name(isSupported, "isSupported");
function initFeatureFlags$2() {
  const needWarn = [];
  if (false) {
    getGlobalThis$1().__VUE_OPTIONS_API__ = true;
  }
  if (false) {
    getGlobalThis$1().__VUE_PROD_DEVTOOLS__ = false;
  }
  if (false) {
    getGlobalThis$1().__VUE_PROD_HYDRATION_MISMATCH_DETAILS__ = false;
  }
  if (false) {
    const multi = needWarn.length > 1;
    console.warn(
      `Feature flag${multi ? `s` : ``} ${needWarn.join(", ")} ${multi ? `are` : `is`} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`
    );
  }
}
__name(initFeatureFlags$2, "initFeatureFlags$2");
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options3) {
  return baseCreateRenderer(options3);
}
__name(createRenderer, "createRenderer");
function createHydrationRenderer(options3) {
  return baseCreateRenderer(options3, createHydrationFunctions);
}
__name(createHydrationRenderer, "createHydrationRenderer");
function baseCreateRenderer(options3, createHydrationFns) {
  {
    initFeatureFlags$2();
  }
  const target = getGlobalThis$1();
  target.__VUE__ = true;
  if (false) {
    setDevtoolsHook$1(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
  }
  const {
    insert: hostInsert,
    remove: hostRemove,
    patchProp: hostPatchProp,
    createElement: hostCreateElement,
    createText: hostCreateText,
    createComment: hostCreateComment,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling,
    setScopeId: hostSetScopeId = NOOP,
    insertStaticContent: hostInsertStaticContent
  } = options3;
  const patch = /* @__PURE__ */ __name((n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = false ? false : !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref: ref3, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, namespace);
        } else if (false) {
          patchStaticNode(n1, n2, container, namespace);
        }
        break;
      case Fragment:
        processFragment(
          n1,
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        break;
      default:
        if (shapeFlag & 1) {
          processElement(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 6) {
          processComponent(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 64) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (shapeFlag & 128) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (false) {
          warn$1("Invalid VNode type:", type, `(${typeof type})`);
        }
    }
    if (ref3 != null && parentComponent) {
      setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  }, "patch");
  const processText = /* @__PURE__ */ __name((n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateText(n2.children),
        container,
        anchor
      );
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  }, "processText");
  const processCommentNode = /* @__PURE__ */ __name((n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateComment(n2.children || ""),
        container,
        anchor
      );
    } else {
      n2.el = n1.el;
    }
  }, "processCommentNode");
  const mountStaticNode = /* @__PURE__ */ __name((n2, container, anchor, namespace) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(
      n2.children,
      container,
      anchor,
      namespace,
      n2.el,
      n2.anchor
    );
  }, "mountStaticNode");
  const patchStaticNode = /* @__PURE__ */ __name((n1, n2, container, namespace) => {
    if (n2.children !== n1.children) {
      const anchor = hostNextSibling(n1.anchor);
      removeStaticNode(n1);
      [n2.el, n2.anchor] = hostInsertStaticContent(
        n2.children,
        container,
        anchor,
        namespace
      );
    } else {
      n2.el = n1.el;
      n2.anchor = n1.anchor;
    }
  }, "patchStaticNode");
  const moveStaticNode = /* @__PURE__ */ __name(({ el, anchor }, container, nextSibling) => {
    let next2;
    while (el && el !== anchor) {
      next2 = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next2;
    }
    hostInsert(anchor, container, nextSibling);
  }, "moveStaticNode");
  const removeStaticNode = /* @__PURE__ */ __name(({ el, anchor }) => {
    let next2;
    while (el && el !== anchor) {
      next2 = hostNextSibling(el);
      hostRemove(el);
      el = next2;
    }
    hostRemove(anchor);
  }, "removeStaticNode");
  const processElement = /* @__PURE__ */ __name((n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    if (n2.type === "svg") {
      namespace = "svg";
    } else if (n2.type === "math") {
      namespace = "mathml";
    }
    if (n1 == null) {
      mountElement(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      patchElement(
        n1,
        n2,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
  }, "processElement");
  const mountElement = /* @__PURE__ */ __name((vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { props, shapeFlag, transition, dirs } = vnode;
    el = vnode.el = hostCreateElement(
      vnode.type,
      namespace,
      props && props.is,
      props
    );
    if (shapeFlag & 8) {
      hostSetElementText(el, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(
        vnode.children,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(vnode, namespace),
        slotScopeIds,
        optimized
      );
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (props) {
      for (const key in props) {
        if (key !== "value" && !isReservedProp(key)) {
          hostPatchProp(
            el,
            key,
            null,
            props[key],
            namespace,
            vnode.children,
            parentComponent,
            parentSuspense,
            unmountChildren
          );
        }
      }
      if ("value" in props) {
        hostPatchProp(el, "value", null, props.value, namespace);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    if (false) {
      def(el, "__vnode", vnode, true);
      def(el, "__vueParentComponent", parentComponent, true);
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = needTransition(parentSuspense, transition);
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  }, "mountElement");
  const setScopeId = /* @__PURE__ */ __name((el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i2 = 0; i2 < slotScopeIds.length; i2++) {
        hostSetScopeId(el, slotScopeIds[i2]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (false) {
        subTree = filterSingleRoot(subTree.children) || subTree;
      }
      if (vnode === subTree) {
        const parentVNode = parentComponent.vnode;
        setScopeId(
          el,
          parentVNode,
          parentVNode.scopeId,
          parentVNode.slotScopeIds,
          parentComponent.parent
        );
      }
    }
  }, "setScopeId");
  const mountChildren = /* @__PURE__ */ __name((children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start2 = 0) => {
    for (let i2 = start2; i2 < children.length; i2++) {
      const child = children[i2] = optimized ? cloneIfMounted(children[i2]) : normalizeVNode(children[i2]);
      patch(
        null,
        child,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
  }, "mountChildren");
  const patchElement = /* @__PURE__ */ __name((n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    if (false) {
      el.__vnode = n2;
    }
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    if (false) {
      patchFlag = 0;
      optimized = false;
      dynamicChildren = null;
    }
    if (dynamicChildren) {
      patchBlockChildren(
        n1.dynamicChildren,
        dynamicChildren,
        el,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds
      );
      if (false) {
        traverseStaticChildren(n1, n2);
      }
    } else if (!optimized) {
      patchChildren(
        n1,
        n2,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds,
        false
      );
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(
          el,
          n2,
          oldProps,
          newProps,
          parentComponent,
          parentSuspense,
          namespace
        );
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, namespace);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
            const key = propsToUpdate[i2];
            const prev2 = oldProps[key];
            const next2 = newProps[key];
            if (next2 !== prev2 || key === "value") {
              hostPatchProp(
                el,
                key,
                prev2,
                next2,
                namespace,
                n1.children,
                parentComponent,
                parentSuspense,
                unmountChildren
              );
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(
        el,
        n2,
        oldProps,
        newProps,
        parentComponent,
        parentSuspense,
        namespace
      );
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  }, "patchElement");
  const patchBlockChildren = /* @__PURE__ */ __name((oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
    for (let i2 = 0; i2 < newChildren.length; i2++) {
      const oldVNode = oldChildren[i2];
      const newVNode = newChildren[i2];
      const container = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
        oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          fallbackContainer
        )
      );
      patch(
        oldVNode,
        newVNode,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        true
      );
    }
  }, "patchBlockChildren");
  const patchProps = /* @__PURE__ */ __name((el, vnode, oldProps, newProps, parentComponent, parentSuspense, namespace) => {
    if (oldProps !== newProps) {
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(
              el,
              key,
              oldProps[key],
              null,
              namespace,
              vnode.children,
              parentComponent,
              parentSuspense,
              unmountChildren
            );
          }
        }
      }
      for (const key in newProps) {
        if (isReservedProp(key)) continue;
        const next2 = newProps[key];
        const prev2 = oldProps[key];
        if (next2 !== prev2 && key !== "value") {
          hostPatchProp(
            el,
            key,
            prev2,
            next2,
            namespace,
            vnode.children,
            parentComponent,
            parentSuspense,
            unmountChildren
          );
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
      }
    }
  }, "patchProps");
  const processFragment = /* @__PURE__ */ __name((n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (false) {
      patchFlag = 0;
      optimized = false;
      dynamicChildren = null;
    }
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(
        // #10007
        // such fragment like `<></>` will be compiled into
        // a fragment which doesn't have a children.
        // In this case fallback to an empty array
        n2.children || [],
        container,
        fragmentEndAnchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n1.dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          container,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds
        );
        if (false) {
          traverseStaticChildren(n1, n2);
        } else if (
          // #2080 if the stable fragment has a key, it's a <template v-for> that may
          //  get moved around. Make sure all root level vnodes inherit el.
          // #2134 or if it's a component root, it may also get moved around
          // as the component is being moved.
          n2.key != null || parentComponent && n2 === parentComponent.subTree
        ) {
          traverseStaticChildren(
            n1,
            n2,
            true
            /* shallow */
          );
        }
      } else {
        patchChildren(
          n1,
          n2,
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    }
  }, "processFragment");
  const processComponent = /* @__PURE__ */ __name((n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(
          n2,
          container,
          anchor,
          namespace,
          optimized
        );
      } else {
        mountComponent(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          optimized
        );
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  }, "processComponent");
  const mountComponent = /* @__PURE__ */ __name((initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
    const instance = initialVNode.component = createComponentInstance(
      initialVNode,
      parentComponent,
      parentSuspense
    );
    if (false) {
      registerHMR(instance);
    }
    if (false) {
      pushWarningContext(initialVNode);
      startMeasure(instance, `mount`);
    }
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      if (false) {
        startMeasure(instance, `init`);
      }
      setupComponent(instance);
      if (false) {
        endMeasure(instance, `init`);
      }
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
    } else {
      setupRenderEffect(
        instance,
        initialVNode,
        container,
        anchor,
        parentSuspense,
        namespace,
        optimized
      );
    }
    if (false) {
      popWarningContext();
      endMeasure(instance, `mount`);
    }
  }, "mountComponent");
  const updateComponent = /* @__PURE__ */ __name((n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        if (false) {
          pushWarningContext(n2);
        }
        updateComponentPreRender(instance, n2, optimized);
        if (false) {
          popWarningContext();
        }
        return;
      } else {
        instance.next = n2;
        invalidateJob(instance.update);
        instance.effect.dirty = true;
        instance.update();
      }
    } else {
      n2.el = n1.el;
      instance.vnode = n2;
    }
  }, "updateComponent");
  const setupRenderEffect = /* @__PURE__ */ __name((instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
    const componentUpdateFn = /* @__PURE__ */ __name(() => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el, props } = initialVNode;
        const { bm, m, parent } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el && hydrateNode) {
          const hydrateSubTree = /* @__PURE__ */ __name(() => {
            if (false) {
              startMeasure(instance, `render`);
            }
            instance.subTree = renderComponentRoot(instance);
            if (false) {
              endMeasure(instance, `render`);
            }
            if (false) {
              startMeasure(instance, `hydrate`);
            }
            hydrateNode(
              el,
              instance.subTree,
              instance,
              parentSuspense,
              null
            );
            if (false) {
              endMeasure(instance, `hydrate`);
            }
          }, "hydrateSubTree");
          if (isAsyncWrapperVNode) {
            initialVNode.type.__asyncLoader().then(
              // note: we are moving the render call into an async callback,
              // which means it won't track dependencies - but it's ok because
              // a server-rendered async wrapper is already in resolved state
              // and it will never need to change.
              () => !instance.isUnmounted && hydrateSubTree()
            );
          } else {
            hydrateSubTree();
          }
        } else {
          if (false) {
            startMeasure(instance, `render`);
          }
          const subTree = instance.subTree = renderComponentRoot(instance);
          if (false) {
            endMeasure(instance, `render`);
          }
          if (false) {
            startMeasure(instance, `patch`);
          }
          patch(
            null,
            subTree,
            container,
            anchor,
            instance,
            parentSuspense,
            namespace
          );
          if (false) {
            endMeasure(instance, `patch`);
          }
          initialVNode.el = subTree.el;
        }
        if (m) {
          queuePostRenderEffect(m, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
            parentSuspense
          );
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        if (false) {
          devtoolsComponentAdded(instance);
        }
        initialVNode = container = anchor = null;
      } else {
        let { next: next2, bu, u, parent, vnode } = instance;
        {
          const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
          if (nonHydratedAsyncRoot) {
            if (next2) {
              next2.el = vnode.el;
              updateComponentPreRender(instance, next2, optimized);
            }
            nonHydratedAsyncRoot.asyncDep.then(() => {
              if (!instance.isUnmounted) {
                componentUpdateFn();
              }
            });
            return;
          }
        }
        let originNext = next2;
        let vnodeHook;
        if (false) {
          pushWarningContext(next2 || instance.vnode);
        }
        toggleRecurse(instance, false);
        if (next2) {
          next2.el = vnode.el;
          updateComponentPreRender(instance, next2, optimized);
        } else {
          next2 = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next2.props && next2.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next2, vnode);
        }
        toggleRecurse(instance, true);
        if (false) {
          startMeasure(instance, `render`);
        }
        const nextTree = renderComponentRoot(instance);
        if (false) {
          endMeasure(instance, `render`);
        }
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        if (false) {
          startMeasure(instance, `patch`);
        }
        patch(
          prevTree,
          nextTree,
          // parent may have changed if it's in a teleport
          hostParentNode(prevTree.el),
          // anchor may have changed if it's in a fragment
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          namespace
        );
        if (false) {
          endMeasure(instance, `patch`);
        }
        next2.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        }
        if (vnodeHook = next2.props && next2.props.onVnodeUpdated) {
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, next2, vnode),
            parentSuspense
          );
        }
        if (false) {
          devtoolsComponentUpdated(instance);
        }
        if (false) {
          popWarningContext();
        }
      }
    }, "componentUpdateFn");
    const effect2 = instance.effect = new ReactiveEffect(
      componentUpdateFn,
      NOOP,
      () => queueJob(update2),
      instance.scope
      // track it in component's effect scope
    );
    const update2 = instance.update = () => {
      if (effect2.dirty) {
        effect2.run();
      }
    };
    update2.id = instance.uid;
    toggleRecurse(instance, true);
    if (false) {
      effect2.onTrack = instance.rtc ? (e) => invokeArrayFns(instance.rtc, e) : void 0;
      effect2.onTrigger = instance.rtg ? (e) => invokeArrayFns(instance.rtg, e) : void 0;
      update2.ownerInstance = instance;
    }
    update2();
  }, "setupRenderEffect");
  const updateComponentPreRender = /* @__PURE__ */ __name((instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs(instance);
    resetTracking();
  }, "updateComponentPreRender");
  const patchChildren = /* @__PURE__ */ __name((n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      }
    }
  }, "patchChildren");
  const patchUnkeyedChildren = /* @__PURE__ */ __name((c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i2;
    for (i2 = 0; i2 < commonLength; i2++) {
      const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
      patch(
        c1[i2],
        nextChild,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
    if (oldLength > newLength) {
      unmountChildren(
        c1,
        parentComponent,
        parentSuspense,
        true,
        false,
        commonLength
      );
    } else {
      mountChildren(
        c2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized,
        commonLength
      );
    }
  }, "patchUnkeyedChildren");
  const patchKeyedChildren = /* @__PURE__ */ __name((c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let i2 = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i2 <= e1 && i2 <= e2) {
      const n1 = c1[i2];
      const n2 = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      i2++;
    }
    while (i2 <= e1 && i2 <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i2 > e1) {
      if (i2 <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i2 <= e2) {
          patch(
            null,
            c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]),
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          i2++;
        }
      }
    } else if (i2 > e2) {
      while (i2 <= e1) {
        unmount(c1[i2], parentComponent, parentSuspense, true);
        i2++;
      }
    } else {
      const s1 = i2;
      const s2 = i2;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i2 = s2; i2 <= e2; i2++) {
        const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
        if (nextChild.key != null) {
          if (false) {
            warn$1(
              `Duplicate keys found during update:`,
              JSON.stringify(nextChild.key),
              `Make sure keys are unique.`
            );
          }
          keyToNewIndexMap.set(nextChild.key, i2);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i2 = 0; i2 < toBePatched; i2++) newIndexToOldIndexMap[i2] = 0;
      for (i2 = s1; i2 <= e1; i2++) {
        const prevChild = c1[i2];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s2; j <= e2; j++) {
            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
              newIndex = j;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i2 + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(
            prevChild,
            c2[newIndex],
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1;
      for (i2 = toBePatched - 1; i2 >= 0; i2--) {
        const nextIndex = s2 + i2;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i2] === 0) {
          patch(
            null,
            nextChild,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (moved) {
          if (j < 0 || i2 !== increasingNewIndexSequence[j]) {
            move(nextChild, container, anchor, 2);
          } else {
            j--;
          }
        }
      }
    }
  }, "patchKeyedChildren");
  const move = /* @__PURE__ */ __name((vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el, container, anchor);
      for (let i2 = 0; i2 < children.length; i2++) {
        move(children[i2], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition2) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove222 = /* @__PURE__ */ __name(() => hostInsert(el, container, anchor), "remove22");
        const performLeave = /* @__PURE__ */ __name(() => {
          leave(el, () => {
            remove222();
            afterLeave && afterLeave();
          });
        }, "performLeave");
        if (delayLeave) {
          delayLeave(el, remove222, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  }, "move");
  const unmount = /* @__PURE__ */ __name((vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const {
      type,
      props,
      ref: ref3,
      children,
      dynamicChildren,
      shapeFlag,
      patchFlag,
      dirs,
      memoIndex
    } = vnode;
    if (patchFlag === -2) {
      optimized = false;
    }
    if (ref3 != null) {
      setRef(ref3, null, parentSuspense, vnode, true);
    }
    if (memoIndex != null) {
      parentComponent.renderCache[memoIndex] = void 0;
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(
          vnode,
          parentComponent,
          parentSuspense,
          internals,
          doRemove
        );
      } else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(
          dynamicChildren,
          parentComponent,
          parentSuspense,
          false,
          true
        );
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove22(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  }, "unmount");
  const remove22 = /* @__PURE__ */ __name((vnode) => {
    const { type, el, anchor, transition } = vnode;
    if (type === Fragment) {
      if (false) {
        vnode.children.forEach((child) => {
          if (child.type === Comment) {
            hostRemove(child.el);
          } else {
            remove22(child);
          }
        });
      } else {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = /* @__PURE__ */ __name(() => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    }, "performRemove");
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = /* @__PURE__ */ __name(() => leave(el, performRemove), "performLeave");
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  }, "remove2");
  const removeFragment = /* @__PURE__ */ __name((cur, end) => {
    let next2;
    while (cur !== end) {
      next2 = hostNextSibling(cur);
      hostRemove(cur);
      cur = next2;
    }
    hostRemove(end);
  }, "removeFragment");
  const unmountComponent = /* @__PURE__ */ __name((instance, parentSuspense, doRemove) => {
    if (false) {
      unregisterHMR(instance);
    }
    const { bum, scope, update: update2, subTree, um, m, a } = instance;
    invalidateMount(m);
    invalidateMount(a);
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (update2) {
      update2.active = false;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
    if (false) {
      devtoolsComponentRemoved(instance);
    }
  }, "unmountComponent");
  const unmountChildren = /* @__PURE__ */ __name((children, parentComponent, parentSuspense, doRemove = false, optimized = false, start2 = 0) => {
    for (let i2 = start2; i2 < children.length; i2++) {
      unmount(children[i2], parentComponent, parentSuspense, doRemove, optimized);
    }
  }, "unmountChildren");
  const getNextHostNode = /* @__PURE__ */ __name((vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    return hostNextSibling(vnode.anchor || vnode.el);
  }, "getNextHostNode");
  let isFlushing2 = false;
  const render2 = /* @__PURE__ */ __name((vnode, container, namespace) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(
        container._vnode || null,
        vnode,
        container,
        null,
        null,
        null,
        namespace
      );
    }
    if (!isFlushing2) {
      isFlushing2 = true;
      flushPreFlushCbs();
      flushPostFlushCbs();
      isFlushing2 = false;
    }
    container._vnode = vnode;
  }, "render");
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove22,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options3
  };
  let hydrate2;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate2, hydrateNode] = createHydrationFns(
      internals
    );
  }
  return {
    render: render2,
    hydrate: hydrate2,
    createApp: createAppAPI(render2, hydrate2)
  };
}
__name(baseCreateRenderer, "baseCreateRenderer");
function resolveChildrenNamespace({ type, props }, currentNamespace) {
  return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
}
__name(resolveChildrenNamespace, "resolveChildrenNamespace");
function toggleRecurse({ effect: effect2, update: update2 }, allowed) {
  effect2.allowRecurse = update2.allowRecurse = allowed;
}
__name(toggleRecurse, "toggleRecurse");
function needTransition(parentSuspense, transition) {
  return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
}
__name(needTransition, "needTransition");
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray$4(ch1) && isArray$4(ch2)) {
    for (let i2 = 0; i2 < ch1.length; i2++) {
      const c1 = ch1[i2];
      let c2 = ch2[i2];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i2] = cloneIfMounted(ch2[i2]);
          c2.el = c1.el;
        }
        if (!shallow && c2.patchFlag !== -2)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Text) {
        c2.el = c1.el;
      }
      if (false) {
        c2.el = c1.el;
      }
    }
  }
}
__name(traverseStaticChildren, "traverseStaticChildren");
function getSequence(arr) {
  const p2 = arr.slice();
  const result = [0];
  let i2, j, u, v2, c;
  const len = arr.length;
  for (i2 = 0; i2 < len; i2++) {
    const arrI = arr[i2];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p2[i2] = j;
        result.push(i2);
        continue;
      }
      u = 0;
      v2 = result.length - 1;
      while (u < v2) {
        c = u + v2 >> 1;
        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v2 = c;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p2[i2] = result[u - 1];
        }
        result[u] = i2;
      }
    }
  }
  u = result.length;
  v2 = result[u - 1];
  while (u-- > 0) {
    result[u] = v2;
    v2 = p2[v2];
  }
  return result;
}
__name(getSequence, "getSequence");
function locateNonHydratedAsyncRoot(instance) {
  const subComponent = instance.subTree.component;
  if (subComponent) {
    if (subComponent.asyncDep && !subComponent.asyncResolved) {
      return subComponent;
    } else {
      return locateNonHydratedAsyncRoot(subComponent);
    }
  }
}
__name(locateNonHydratedAsyncRoot, "locateNonHydratedAsyncRoot");
function invalidateMount(hooks) {
  if (hooks) {
    for (let i2 = 0; i2 < hooks.length; i2++) hooks[i2].active = false;
  }
}
__name(invalidateMount, "invalidateMount");
const ssrContextKey = Symbol.for("v-scx");
const useSSRContext = /* @__PURE__ */ __name(() => {
  {
    const ctx = inject(ssrContextKey);
    if (!ctx) {
    }
    return ctx;
  }
}, "useSSRContext");
function watchEffect(effect2, options3) {
  return doWatch(effect2, null, options3);
}
__name(watchEffect, "watchEffect");
function watchPostEffect(effect2, options3) {
  return doWatch(
    effect2,
    null,
    false ? extend$1({}, options3, { flush: "post" }) : { flush: "post" }
  );
}
__name(watchPostEffect, "watchPostEffect");
function watchSyncEffect(effect2, options3) {
  return doWatch(
    effect2,
    null,
    false ? extend$1({}, options3, { flush: "sync" }) : { flush: "sync" }
  );
}
__name(watchSyncEffect, "watchSyncEffect");
const INITIAL_WATCHER_VALUE = {};
function watch(source, cb, options3) {
  if (false) {
    warn$1(
      `\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature.`
    );
  }
  return doWatch(source, cb, options3);
}
__name(watch, "watch");
function doWatch(source, cb, {
  immediate,
  deep,
  flush,
  once: once2,
  onTrack,
  onTrigger
} = EMPTY_OBJ) {
  if (cb && once2) {
    const _cb = cb;
    cb = /* @__PURE__ */ __name((...args) => {
      _cb(...args);
      unwatch();
    }, "cb");
  }
  if (false) {
    warn$1(
      `watch() "deep" option with number value will be used as watch depth in future versions. Please use a boolean instead to avoid potential breakage.`
    );
  }
  if (false) {
    if (immediate !== void 0) {
      warn$1(
        `watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.`
      );
    }
    if (deep !== void 0) {
      warn$1(
        `watch() "deep" option is only respected when using the watch(source, callback, options?) signature.`
      );
    }
    if (once2 !== void 0) {
      warn$1(
        `watch() "once" option is only respected when using the watch(source, callback, options?) signature.`
      );
    }
  }
  const warnInvalidSource = /* @__PURE__ */ __name((s) => {
    warn$1(
      `Invalid watch source: `,
      s,
      `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`
    );
  }, "warnInvalidSource");
  const instance = currentInstance;
  const reactiveGetter = /* @__PURE__ */ __name((source2) => deep === true ? source2 : (
    // for deep: false, only traverse root-level properties
    traverse(source2, deep === false ? 1 : void 0)
  ), "reactiveGetter");
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = /* @__PURE__ */ __name(() => source.value, "getter");
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = /* @__PURE__ */ __name(() => reactiveGetter(source), "getter");
    forceTrigger = true;
  } else if (isArray$4(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
    getter = /* @__PURE__ */ __name(() => source.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return reactiveGetter(s);
      } else if (isFunction$4(s)) {
        return callWithErrorHandling(s, instance, 2);
      } else {
      }
    }), "getter");
  } else if (isFunction$4(source)) {
    if (cb) {
      getter = /* @__PURE__ */ __name(() => callWithErrorHandling(source, instance, 2), "getter");
    } else {
      getter = /* @__PURE__ */ __name(() => {
        if (cleanup) {
          cleanup();
        }
        return callWithAsyncErrorHandling(
          source,
          instance,
          3,
          [onCleanup]
        );
      }, "getter");
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = /* @__PURE__ */ __name(() => traverse(baseGetter()), "getter");
  }
  let cleanup;
  let onCleanup = /* @__PURE__ */ __name((fn) => {
    cleanup = effect2.onStop = () => {
      callWithErrorHandling(fn, instance, 4);
      cleanup = effect2.onStop = void 0;
    };
  }, "onCleanup");
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    onCleanup = NOOP;
    if (!cb) {
      getter();
    } else if (immediate) {
      callWithAsyncErrorHandling(cb, instance, 3, [
        getter(),
        isMultiSource ? [] : void 0,
        onCleanup
      ]);
    }
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else {
      return NOOP;
    }
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = /* @__PURE__ */ __name(() => {
    if (!effect2.active || !effect2.dirty) {
      return;
    }
    if (cb) {
      const newValue = effect2.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v2, i2) => hasChanged(v2, oldValue[i2])) : hasChanged(newValue, oldValue)) || false) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling(cb, instance, 3, [
          newValue,
          // pass undefined as the old value when it's changed for the first time
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
          onCleanup
        ]);
        oldValue = newValue;
      }
    } else {
      effect2.run();
    }
  }, "job");
  job.allowRecurse = !!cb;
  let scheduler;
  if (flush === "sync") {
    scheduler = job;
  } else if (flush === "post") {
    scheduler = /* @__PURE__ */ __name(() => queuePostRenderEffect(job, instance && instance.suspense), "scheduler");
  } else {
    job.pre = true;
    if (instance) job.id = instance.uid;
    scheduler = /* @__PURE__ */ __name(() => queueJob(job), "scheduler");
  }
  const effect2 = new ReactiveEffect(getter, NOOP, scheduler);
  const scope = getCurrentScope();
  const unwatch = /* @__PURE__ */ __name(() => {
    effect2.stop();
    if (scope) {
      remove$1(scope.effects, effect2);
    }
  }, "unwatch");
  if (false) {
    effect2.onTrack = onTrack;
    effect2.onTrigger = onTrigger;
  }
  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = effect2.run();
    }
  } else if (flush === "post") {
    queuePostRenderEffect(
      effect2.run.bind(effect2),
      instance && instance.suspense
    );
  } else {
    effect2.run();
  }
  if (ssrCleanup) ssrCleanup.push(unwatch);
  return unwatch;
}
__name(doWatch, "doWatch");
function instanceWatch(source, value3, options3) {
  const publicThis = this.proxy;
  const getter = isString$5(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction$4(value3)) {
    cb = value3;
  } else {
    cb = value3.handler;
    options3 = value3;
  }
  const reset = setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options3);
  reset();
  return res;
}
__name(instanceWatch, "instanceWatch");
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i2 = 0; i2 < segments.length && cur; i2++) {
      cur = cur[segments[i2]];
    }
    return cur;
  };
}
__name(createPathGetter, "createPathGetter");
function traverse(value3, depth = Infinity, seen2) {
  if (depth <= 0 || !isObject$6(value3) || value3["__v_skip"]) {
    return value3;
  }
  seen2 = seen2 || /* @__PURE__ */ new Set();
  if (seen2.has(value3)) {
    return value3;
  }
  seen2.add(value3);
  depth--;
  if (isRef(value3)) {
    traverse(value3.value, depth, seen2);
  } else if (isArray$4(value3)) {
    for (let i2 = 0; i2 < value3.length; i2++) {
      traverse(value3[i2], depth, seen2);
    }
  } else if (isSet(value3) || isMap(value3)) {
    value3.forEach((v2) => {
      traverse(v2, depth, seen2);
    });
  } else if (isPlainObject$3(value3)) {
    for (const key in value3) {
      traverse(value3[key], depth, seen2);
    }
    for (const key of Object.getOwnPropertySymbols(value3)) {
      if (Object.prototype.propertyIsEnumerable.call(value3, key)) {
        traverse(value3[key], depth, seen2);
      }
    }
  }
  return value3;
}
__name(traverse, "traverse");
const isKeepAlive = /* @__PURE__ */ __name((vnode) => vnode.type.__isKeepAlive, "isKeepAlive");
const KeepAliveImpl = {
  name: `KeepAlive`,
  // Marker for special handling inside the renderer. We are not using a ===
  // check directly on KeepAlive in the renderer, because importing it directly
  // would prevent it from being tree-shaken.
  __isKeepAlive: true,
  props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
  },
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const sharedContext = instance.ctx;
    if (!sharedContext.renderer) {
      return () => {
        const children = slots.default && slots.default();
        return children && children.length === 1 ? children[0] : children;
      };
    }
    const cache2 = /* @__PURE__ */ new Map();
    const keys2 = /* @__PURE__ */ new Set();
    let current = null;
    if (false) {
      instance.__v_cache = cache2;
    }
    const parentSuspense = instance.suspense;
    const {
      renderer: {
        p: patch,
        m: move,
        um: _unmount,
        o: { createElement: createElement2 }
      }
    } = sharedContext;
    const storageContainer = createElement2("div");
    sharedContext.activate = (vnode, container, anchor, namespace, optimized) => {
      const instance2 = vnode.component;
      move(vnode, container, anchor, 0, parentSuspense);
      patch(
        instance2.vnode,
        vnode,
        container,
        anchor,
        instance2,
        parentSuspense,
        namespace,
        vnode.slotScopeIds,
        optimized
      );
      queuePostRenderEffect(() => {
        instance2.isDeactivated = false;
        if (instance2.a) {
          invokeArrayFns(instance2.a);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
      }, parentSuspense);
      if (false) {
        devtoolsComponentAdded(instance2);
      }
    };
    sharedContext.deactivate = (vnode) => {
      const instance2 = vnode.component;
      invalidateMount(instance2.m);
      invalidateMount(instance2.a);
      move(vnode, storageContainer, null, 1, parentSuspense);
      queuePostRenderEffect(() => {
        if (instance2.da) {
          invokeArrayFns(instance2.da);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
        instance2.isDeactivated = true;
      }, parentSuspense);
      if (false) {
        devtoolsComponentAdded(instance2);
      }
    };
    function unmount(vnode) {
      resetShapeFlag(vnode);
      _unmount(vnode, instance, parentSuspense, true);
    }
    __name(unmount, "unmount");
    function pruneCache(filter4) {
      cache2.forEach((vnode, key) => {
        const name = getComponentName(vnode.type);
        if (name && (!filter4 || !filter4(name))) {
          pruneCacheEntry(key);
        }
      });
    }
    __name(pruneCache, "pruneCache");
    function pruneCacheEntry(key) {
      const cached = cache2.get(key);
      if (!current || !isSameVNodeType(cached, current)) {
        unmount(cached);
      } else if (current) {
        resetShapeFlag(current);
      }
      cache2.delete(key);
      keys2.delete(key);
    }
    __name(pruneCacheEntry, "pruneCacheEntry");
    watch(
      () => [props.include, props.exclude],
      ([include, exclude]) => {
        include && pruneCache((name) => matches(include, name));
        exclude && pruneCache((name) => !matches(exclude, name));
      },
      // prune post-render after `current` has been updated
      { flush: "post", deep: true }
    );
    let pendingCacheKey = null;
    const cacheSubtree = /* @__PURE__ */ __name(() => {
      if (pendingCacheKey != null) {
        if (isSuspense(instance.subTree.type)) {
          queuePostRenderEffect(() => {
            cache2.set(pendingCacheKey, getInnerChild(instance.subTree));
          }, instance.subTree.suspense);
        } else {
          cache2.set(pendingCacheKey, getInnerChild(instance.subTree));
        }
      }
    }, "cacheSubtree");
    onMounted(cacheSubtree);
    onUpdated(cacheSubtree);
    onBeforeUnmount(() => {
      cache2.forEach((cached) => {
        const { subTree, suspense } = instance;
        const vnode = getInnerChild(subTree);
        if (cached.type === vnode.type && cached.key === vnode.key) {
          resetShapeFlag(vnode);
          const da = vnode.component.da;
          da && queuePostRenderEffect(da, suspense);
          return;
        }
        unmount(cached);
      });
    });
    return () => {
      pendingCacheKey = null;
      if (!slots.default) {
        return null;
      }
      const children = slots.default();
      const rawVNode = children[0];
      if (children.length > 1) {
        if (false) {
          warn$1(`KeepAlive should contain exactly one component child.`);
        }
        current = null;
        return children;
      } else if (!isVNode$1(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {
        current = null;
        return rawVNode;
      }
      let vnode = getInnerChild(rawVNode);
      const comp = vnode.type;
      const name = getComponentName(
        isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp
      );
      const { include, exclude, max } = props;
      if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {
        current = vnode;
        return rawVNode;
      }
      const key = vnode.key == null ? comp : vnode.key;
      const cachedVNode = cache2.get(key);
      if (vnode.el) {
        vnode = cloneVNode(vnode);
        if (rawVNode.shapeFlag & 128) {
          rawVNode.ssContent = vnode;
        }
      }
      pendingCacheKey = key;
      if (cachedVNode) {
        vnode.el = cachedVNode.el;
        vnode.component = cachedVNode.component;
        if (vnode.transition) {
          setTransitionHooks(vnode, vnode.transition);
        }
        vnode.shapeFlag |= 512;
        keys2.delete(key);
        keys2.add(key);
      } else {
        keys2.add(key);
        if (max && keys2.size > parseInt(max, 10)) {
          pruneCacheEntry(keys2.values().next().value);
        }
      }
      vnode.shapeFlag |= 256;
      current = vnode;
      return isSuspense(rawVNode.type) ? rawVNode : vnode;
    };
  }
};
const KeepAlive = KeepAliveImpl;
function matches(pattern, name) {
  if (isArray$4(pattern)) {
    return pattern.some((p2) => matches(p2, name));
  } else if (isString$5(pattern)) {
    return pattern.split(",").includes(name);
  } else if (isRegExp$2(pattern)) {
    return pattern.test(name);
  }
  return false;
}
__name(matches, "matches");
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
__name(onActivated, "onActivated");
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
__name(onDeactivated, "onDeactivated");
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
__name(registerKeepAliveHook, "registerKeepAliveHook");
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(
    type,
    hook,
    keepAliveRoot,
    true
    /* prepend */
  );
  onUnmounted(() => {
    remove$1(keepAliveRoot[type], injected);
  }, target);
}
__name(injectToKeepAliveRoot, "injectToKeepAliveRoot");
function resetShapeFlag(vnode) {
  vnode.shapeFlag &= ~256;
  vnode.shapeFlag &= ~512;
}
__name(resetShapeFlag, "resetShapeFlag");
function getInnerChild(vnode) {
  return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;
}
__name(getInnerChild, "getInnerChild");
const leaveCbKey = Symbol("_leaveCb");
const enterCbKey$1 = Symbol("_enterCb");
function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}
__name(useTransitionState, "useTransitionState");
const TransitionHookValidator = [Function, Array];
const BaseTransitionPropsValidators = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: TransitionHookValidator,
  onEnter: TransitionHookValidator,
  onAfterEnter: TransitionHookValidator,
  onEnterCancelled: TransitionHookValidator,
  // leave
  onBeforeLeave: TransitionHookValidator,
  onLeave: TransitionHookValidator,
  onAfterLeave: TransitionHookValidator,
  onLeaveCancelled: TransitionHookValidator,
  // appear
  onBeforeAppear: TransitionHookValidator,
  onAppear: TransitionHookValidator,
  onAfterAppear: TransitionHookValidator,
  onAppearCancelled: TransitionHookValidator
};
const recursiveGetSubtree = /* @__PURE__ */ __name((instance) => {
  const subTree = instance.subTree;
  return subTree.component ? recursiveGetSubtree(subTree.component) : subTree;
}, "recursiveGetSubtree");
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: BaseTransitionPropsValidators,
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      let child = children[0];
      if (children.length > 1) {
        let hasFound = false;
        for (const c of children) {
          if (c.type !== Comment) {
            if (false) {
              warn$1(
                "<transition> can only be used on a single element or component. Use <transition-group> for lists."
              );
              break;
            }
            child = c;
            hasFound = true;
            if (true) break;
          }
        }
      }
      const rawProps = toRaw(props);
      const { mode: mode2 } = rawProps;
      if (false) {
        warn$1(`invalid <transition> mode: ${mode2}`);
      }
      if (state.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getKeepAliveChild(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      let enterHooks = resolveTransitionHooks(
        innerChild,
        rawProps,
        state,
        instance,
        // #11061, ensure enterHooks is fresh after clone
        (hooks) => enterHooks = hooks
      );
      setTransitionHooks(innerChild, enterHooks);
      const oldChild = instance.subTree;
      const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
      if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(innerChild, oldInnerChild) && recursiveGetSubtree(instance).type !== Comment) {
        const leavingHooks = resolveTransitionHooks(
          oldInnerChild,
          rawProps,
          state,
          instance
        );
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode2 === "out-in" && innerChild.type !== Comment) {
          state.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state.isLeaving = false;
            if (instance.update.active !== false) {
              instance.effect.dirty = true;
              instance.update();
            }
          };
          return emptyPlaceholder(child);
        } else if (mode2 === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(
              state,
              oldInnerChild
            );
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el[leaveCbKey] = () => {
              earlyRemove();
              el[leaveCbKey] = void 0;
              delete enterHooks.delayedLeave;
            };
            enterHooks.delayedLeave = delayedLeave;
          };
        }
      }
      return child;
    };
  }
};
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
  const { leavingVNodes } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
__name(getLeavingNodesForType, "getLeavingNodesForType");
function resolveTransitionHooks(vnode, props, state, instance, postClone) {
  const {
    appear,
    mode: mode2,
    persisted = false,
    onBeforeEnter: onBeforeEnter3,
    onEnter: onEnter8,
    onAfterEnter: onAfterEnter3,
    onEnterCancelled,
    onBeforeLeave: onBeforeLeave3,
    onLeave: onLeave6,
    onAfterLeave: onAfterLeave6,
    onLeaveCancelled,
    onBeforeAppear,
    onAppear,
    onAfterAppear,
    onAppearCancelled
  } = props;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode);
  const callHook2 = /* @__PURE__ */ __name((hook, args) => {
    hook && callWithAsyncErrorHandling(
      hook,
      instance,
      9,
      args
    );
  }, "callHook2");
  const callAsyncHook = /* @__PURE__ */ __name((hook, args) => {
    const done = args[1];
    callHook2(hook, args);
    if (isArray$4(hook)) {
      if (hook.every((hook2) => hook2.length <= 1)) done();
    } else if (hook.length <= 1) {
      done();
    }
  }, "callAsyncHook");
  const hooks = {
    mode: mode2,
    persisted,
    beforeEnter(el) {
      let hook = onBeforeEnter3;
      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter3;
        } else {
          return;
        }
      }
      if (el[leaveCbKey]) {
        el[leaveCbKey](
          true
          /* cancelled */
        );
      }
      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
        leavingVNode.el[leaveCbKey]();
      }
      callHook2(hook, [el]);
    },
    enter(el) {
      let hook = onEnter8;
      let afterHook = onAfterEnter3;
      let cancelHook = onEnterCancelled;
      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter8;
          afterHook = onAfterAppear || onAfterEnter3;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el[enterCbKey$1] = (cancelled) => {
        if (called) return;
        called = true;
        if (cancelled) {
          callHook2(cancelHook, [el]);
        } else {
          callHook2(afterHook, [el]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el[enterCbKey$1] = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el, done]);
      } else {
        done();
      }
    },
    leave(el, remove22) {
      const key2 = String(vnode.key);
      if (el[enterCbKey$1]) {
        el[enterCbKey$1](
          true
          /* cancelled */
        );
      }
      if (state.isUnmounting) {
        return remove22();
      }
      callHook2(onBeforeLeave3, [el]);
      let called = false;
      const done = el[leaveCbKey] = (cancelled) => {
        if (called) return;
        called = true;
        remove22();
        if (cancelled) {
          callHook2(onLeaveCancelled, [el]);
        } else {
          callHook2(onAfterLeave6, [el]);
        }
        el[leaveCbKey] = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave6) {
        callAsyncHook(onLeave6, [el, done]);
      } else {
        done();
      }
    },
    clone(vnode2) {
      const hooks2 = resolveTransitionHooks(
        vnode2,
        props,
        state,
        instance,
        postClone
      );
      if (postClone) postClone(hooks2);
      return hooks2;
    }
  };
  return hooks;
}
__name(resolveTransitionHooks, "resolveTransitionHooks");
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
__name(emptyPlaceholder, "emptyPlaceholder");
function getKeepAliveChild(vnode) {
  if (!isKeepAlive(vnode)) {
    return vnode;
  }
  if (false) {
    return vnode.component.subTree;
  }
  const { shapeFlag, children } = vnode;
  if (children) {
    if (shapeFlag & 16) {
      return children[0];
    }
    if (shapeFlag & 32 && isFunction$4(children.default)) {
      return children.default();
    }
  }
}
__name(getKeepAliveChild, "getKeepAliveChild");
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
__name(setTransitionHooks, "setTransitionHooks");
function getTransitionRawChildren(children, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i2 = 0; i2 < children.length; i2++) {
    let child = children[i2];
    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i2);
    if (child.type === Fragment) {
      if (child.patchFlag & 128) keyedFragmentCount++;
      ret = ret.concat(
        getTransitionRawChildren(child.children, keepComment, key)
      );
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, { key }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i2 = 0; i2 < ret.length; i2++) {
      ret[i2].patchFlag = -2;
    }
  }
  return ret;
}
__name(getTransitionRawChildren, "getTransitionRawChildren");
const isTeleport = /* @__PURE__ */ __name((type) => type.__isTeleport, "isTeleport");
const isTeleportDisabled = /* @__PURE__ */ __name((props) => props && (props.disabled || props.disabled === ""), "isTeleportDisabled");
const isTargetSVG = /* @__PURE__ */ __name((target) => typeof SVGElement !== "undefined" && target instanceof SVGElement, "isTargetSVG");
const isTargetMathML = /* @__PURE__ */ __name((target) => typeof MathMLElement === "function" && target instanceof MathMLElement, "isTargetMathML");
const resolveTarget = /* @__PURE__ */ __name((props, select) => {
  const targetSelector = props && props.to;
  if (isString$5(targetSelector)) {
    if (!select) {
      return null;
    } else {
      const target = select(targetSelector);
      if (false) {
        warn$1(
          `Failed to locate Teleport target with selector "${targetSelector}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`
        );
      }
      return target;
    }
  } else {
    if (false) {
      warn$1(`Invalid Teleport target: ${targetSelector}`);
    }
    return targetSelector;
  }
}, "resolveTarget");
const TeleportImpl = {
  name: "Teleport",
  __isTeleport: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {
    const {
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      o: { insert: insert2, querySelector, createText, createComment }
    } = internals;
    const disabled2 = isTeleportDisabled(n2.props);
    let { shapeFlag, children, dynamicChildren } = n2;
    if (false) {
      optimized = false;
      dynamicChildren = null;
    }
    if (n1 == null) {
      const placeholder = n2.el = false ? createComment("teleport start") : createText("");
      const mainAnchor = n2.anchor = false ? createComment("teleport end") : createText("");
      insert2(placeholder, container, anchor);
      insert2(mainAnchor, container, anchor);
      const target = n2.target = resolveTarget(n2.props, querySelector);
      const targetAnchor = n2.targetAnchor = createText("");
      if (target) {
        insert2(targetAnchor, target);
        if (namespace === "svg" || isTargetSVG(target)) {
          namespace = "svg";
        } else if (namespace === "mathml" || isTargetMathML(target)) {
          namespace = "mathml";
        }
      } else if (false) {
        warn$1("Invalid Teleport target on mount:", target, `(${typeof target})`);
      }
      const mount2 = /* @__PURE__ */ __name((container2, anchor2) => {
        if (shapeFlag & 16) {
          mountChildren(
            children,
            container2,
            anchor2,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      }, "mount");
      if (disabled2) {
        mount2(container, mainAnchor);
      } else if (target) {
        mount2(target, targetAnchor);
      }
    } else {
      n2.el = n1.el;
      const mainAnchor = n2.anchor = n1.anchor;
      const target = n2.target = n1.target;
      const targetAnchor = n2.targetAnchor = n1.targetAnchor;
      const wasDisabled = isTeleportDisabled(n1.props);
      const currentContainer = wasDisabled ? container : target;
      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
      if (namespace === "svg" || isTargetSVG(target)) {
        namespace = "svg";
      } else if (namespace === "mathml" || isTargetMathML(target)) {
        namespace = "mathml";
      }
      if (dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          currentContainer,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds
        );
        traverseStaticChildren(n1, n2, true);
      } else if (!optimized) {
        patchChildren(
          n1,
          n2,
          currentContainer,
          currentAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          false
        );
      }
      if (disabled2) {
        if (!wasDisabled) {
          moveTeleport(
            n2,
            container,
            mainAnchor,
            internals,
            1
          );
        } else {
          if (n2.props && n1.props && n2.props.to !== n1.props.to) {
            n2.props.to = n1.props.to;
          }
        }
      } else {
        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
          const nextTarget = n2.target = resolveTarget(
            n2.props,
            querySelector
          );
          if (nextTarget) {
            moveTeleport(
              n2,
              nextTarget,
              null,
              internals,
              0
            );
          } else if (false) {
            warn$1(
              "Invalid Teleport target on update:",
              target,
              `(${typeof target})`
            );
          }
        } else if (wasDisabled) {
          moveTeleport(
            n2,
            target,
            targetAnchor,
            internals,
            1
          );
        }
      }
    }
    updateCssVars(n2);
  },
  remove(vnode, parentComponent, parentSuspense, { um: unmount, o: { remove: hostRemove } }, doRemove) {
    const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
    if (target) {
      hostRemove(targetAnchor);
    }
    doRemove && hostRemove(anchor);
    if (shapeFlag & 16) {
      const shouldRemove = doRemove || !isTeleportDisabled(props);
      for (let i2 = 0; i2 < children.length; i2++) {
        const child = children[i2];
        unmount(
          child,
          parentComponent,
          parentSuspense,
          shouldRemove,
          !!child.dynamicChildren
        );
      }
    }
  },
  move: moveTeleport,
  hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert: insert2 }, m: move }, moveType = 2) {
  if (moveType === 0) {
    insert2(vnode.targetAnchor, container, parentAnchor);
  }
  const { el, anchor, shapeFlag, children, props } = vnode;
  const isReorder = moveType === 2;
  if (isReorder) {
    insert2(el, container, parentAnchor);
  }
  if (!isReorder || isTeleportDisabled(props)) {
    if (shapeFlag & 16) {
      for (let i2 = 0; i2 < children.length; i2++) {
        move(
          children[i2],
          container,
          parentAnchor,
          2
        );
      }
    }
  }
  if (isReorder) {
    insert2(anchor, container, parentAnchor);
  }
}
__name(moveTeleport, "moveTeleport");
function hydrateTeleport(node3, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
  o: { nextSibling, parentNode, querySelector }
}, hydrateChildren) {
  const target = vnode.target = resolveTarget(
    vnode.props,
    querySelector
  );
  if (target) {
    const targetNode = target._lpa || target.firstChild;
    if (vnode.shapeFlag & 16) {
      if (isTeleportDisabled(vnode.props)) {
        vnode.anchor = hydrateChildren(
          nextSibling(node3),
          vnode,
          parentNode(node3),
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
        vnode.targetAnchor = targetNode;
      } else {
        vnode.anchor = nextSibling(node3);
        let targetAnchor = targetNode;
        while (targetAnchor) {
          targetAnchor = nextSibling(targetAnchor);
          if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
            vnode.targetAnchor = targetAnchor;
            target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
            break;
          }
        }
        hydrateChildren(
          targetNode,
          vnode,
          target,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
      }
    }
    updateCssVars(vnode);
  }
  return vnode.anchor && nextSibling(vnode.anchor);
}
__name(hydrateTeleport, "hydrateTeleport");
const Teleport = TeleportImpl;
function updateCssVars(vnode) {
  const ctx = vnode.ctx;
  if (ctx && ctx.ut) {
    let node3 = vnode.children[0].el;
    while (node3 && node3 !== vnode.targetAnchor) {
      if (node3.nodeType === 1) node3.setAttribute("data-v-owner", ctx.uid);
      node3 = node3.nextSibling;
    }
    ctx.ut();
  }
}
__name(updateCssVars, "updateCssVars");
const Fragment = Symbol.for("v-fgt");
const Text = Symbol.for("v-txt");
const Comment = Symbol.for("v-cmt");
const Static = Symbol.for("v-stc");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
__name(openBlock, "openBlock");
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
__name(closeBlock, "closeBlock");
let isBlockTreeEnabled = 1;
function setBlockTracking(value3) {
  isBlockTreeEnabled += value3;
}
__name(setBlockTracking, "setBlockTracking");
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
__name(setupBlock, "setupBlock");
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(
    createBaseVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      true
    )
  );
}
__name(createElementBlock, "createElementBlock");
function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(
    createVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      true
    )
  );
}
__name(createBlock, "createBlock");
function isVNode$1(value3) {
  return value3 ? value3.__v_isVNode === true : false;
}
__name(isVNode$1, "isVNode$1");
function isSameVNodeType(n1, n2) {
  if (false) {
    n1.shapeFlag &= ~256;
    n2.shapeFlag &= ~512;
    return false;
  }
  return n1.type === n2.type && n1.key === n2.key;
}
__name(isSameVNodeType, "isSameVNodeType");
let vnodeArgsTransformer;
function transformVNodeArgs(transformer) {
  vnodeArgsTransformer = transformer;
}
__name(transformVNodeArgs, "transformVNodeArgs");
const createVNodeWithArgsTransform = /* @__PURE__ */ __name((...args) => {
  return _createVNode(
    ...vnodeArgsTransformer ? vnodeArgsTransformer(args, currentRenderingInstance) : args
  );
}, "createVNodeWithArgsTransform");
const normalizeKey = /* @__PURE__ */ __name(({ key }) => key != null ? key : null, "normalizeKey");
const normalizeRef = /* @__PURE__ */ __name(({
  ref: ref3,
  ref_key,
  ref_for
}) => {
  if (typeof ref3 === "number") {
    ref3 = "" + ref3;
  }
  return ref3 != null ? isString$5(ref3) || isRef(ref3) || isFunction$4(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
}, "normalizeRef");
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString$5(children) ? 8 : 16;
  }
  if (false) {
    warn$1(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
  }
  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
__name(createBaseVNode, "createBaseVNode");
const createVNode = false ? createVNodeWithArgsTransform : _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    if (false) {
      warn$1(`Invalid vnode type when creating vnode: ${type}.`);
    }
    type = Comment;
  }
  if (isVNode$1(type)) {
    const cloned = cloneVNode(
      type,
      props,
      true
      /* mergeRef: true */
    );
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag = -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style } = props;
    if (klass && !isString$5(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject$6(style)) {
      if (isProxy(style) && !isArray$4(style)) {
        style = extend$1({}, style);
      }
      props.style = normalizeStyle(style);
    }
  }
  const shapeFlag = isString$5(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$6(type) ? 4 : isFunction$4(type) ? 2 : 0;
  if (false) {
    type = toRaw(type);
    warn$1(
      `Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with \`markRaw\` or using \`shallowRef\` instead of \`ref\`.`,
      `
Component that was made reactive: `,
      type
    );
  }
  return createBaseVNode(
    type,
    props,
    children,
    patchFlag,
    dynamicProps,
    shapeFlag,
    isBlockNode,
    true
  );
}
__name(_createVNode, "_createVNode");
function guardReactiveProps(props) {
  if (!props) return null;
  return isProxy(props) || isInternalObject(props) ? extend$1({}, props) : props;
}
__name(guardReactiveProps, "guardReactiveProps");
function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
  const { props, ref: ref3, patchFlag, children, transition } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      mergeRef && ref3 ? isArray$4(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
    ) : ref3,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children: false ? children.map(deepCloneVNode) : children,
    target: vnode.target,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  if (transition && cloneTransition) {
    setTransitionHooks(
      cloned,
      transition.clone(cloned)
    );
  }
  return cloned;
}
__name(cloneVNode, "cloneVNode");
function deepCloneVNode(vnode) {
  const cloned = cloneVNode(vnode);
  if (isArray$4(vnode.children)) {
    cloned.children = vnode.children.map(deepCloneVNode);
  }
  return cloned;
}
__name(deepCloneVNode, "deepCloneVNode");
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
__name(createTextVNode, "createTextVNode");
function createStaticVNode(content, numberOfNodes) {
  const vnode = createVNode(Static, null, content);
  vnode.staticCount = numberOfNodes;
  return vnode;
}
__name(createStaticVNode, "createStaticVNode");
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
__name(createCommentVNode, "createCommentVNode");
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray$4(child)) {
    return createVNode(
      Fragment,
      null,
      // #3666, avoid reference pollution when reusing vnode
      child.slice()
    );
  } else if (typeof child === "object") {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
__name(normalizeVNode, "normalizeVNode");
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
__name(cloneIfMounted, "cloneIfMounted");
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray$4(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !isInternalObject(children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction$4(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
__name(normalizeChildren, "normalizeChildren");
function mergeProps(...args) {
  const ret = {};
  for (let i2 = 0; i2 < args.length; i2++) {
    const toMerge = args[i2];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray$4(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
__name(mergeProps, "mergeProps");
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
__name(invokeVNodeHook, "invokeVNodeHook");
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    scope: new EffectScope(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    attrsProxy: null,
    slotsProxy: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  if (false) {
    instance.ctx = createDevRenderContext(instance);
  } else {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
__name(createComponentInstance, "createComponentInstance");
let currentInstance = null;
const getCurrentInstance = /* @__PURE__ */ __name(() => currentInstance || currentRenderingInstance, "getCurrentInstance");
let internalSetCurrentInstance;
let setInSSRSetupState;
{
  const g = getGlobalThis$1();
  const registerGlobalSetter = /* @__PURE__ */ __name((key, setter) => {
    let setters;
    if (!(setters = g[key])) setters = g[key] = [];
    setters.push(setter);
    return (v2) => {
      if (setters.length > 1) setters.forEach((set2) => set2(v2));
      else setters[0](v2);
    };
  }, "registerGlobalSetter");
  internalSetCurrentInstance = registerGlobalSetter(
    `__VUE_INSTANCE_SETTERS__`,
    (v2) => currentInstance = v2
  );
  setInSSRSetupState = registerGlobalSetter(
    `__VUE_SSR_SETTERS__`,
    (v2) => isInSSRComponentSetup = v2
  );
}
const setCurrentInstance = /* @__PURE__ */ __name((instance) => {
  const prev2 = currentInstance;
  internalSetCurrentInstance(instance);
  instance.scope.on();
  return () => {
    instance.scope.off();
    internalSetCurrentInstance(prev2);
  };
}, "setCurrentInstance");
const unsetCurrentInstance = /* @__PURE__ */ __name(() => {
  currentInstance && currentInstance.scope.off();
  internalSetCurrentInstance(null);
}, "unsetCurrentInstance");
const isBuiltInTag = /* @__PURE__ */ makeMap("slot,component");
function validateComponentName(name, { isNativeTag }) {
  if (isBuiltInTag(name) || isNativeTag(name)) {
    warn$1(
      "Do not use built-in or reserved HTML elements as component id: " + name
    );
  }
}
__name(validateComponentName, "validateComponentName");
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
__name(isStatefulComponent, "isStatefulComponent");
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
  isSSR && setInSSRSetupState(isSSR);
  const { props, children } = instance.vnode;
  const isStateful2 = isStatefulComponent(instance);
  initProps(instance, props, isStateful2, isSSR);
  initSlots(instance, children);
  const setupResult = isStateful2 ? setupStatefulComponent(instance, isSSR) : void 0;
  isSSR && setInSSRSetupState(false);
  return setupResult;
}
__name(setupComponent, "setupComponent");
function setupStatefulComponent(instance, isSSR) {
  var _a;
  const Component = instance.type;
  if (false) {
    if (Component.name) {
      validateComponentName(Component.name, instance.appContext.config);
    }
    if (Component.components) {
      const names = Object.keys(Component.components);
      for (let i2 = 0; i2 < names.length; i2++) {
        validateComponentName(names[i2], instance.appContext.config);
      }
    }
    if (Component.directives) {
      const names = Object.keys(Component.directives);
      for (let i2 = 0; i2 < names.length; i2++) {
        validateDirectiveName(names[i2]);
      }
    }
    if (Component.compilerOptions && isRuntimeOnly()) {
      warn$1(
        `"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.`
      );
    }
  }
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
  if (false) {
    exposePropsOnRenderContext(instance);
  }
  const { setup: setup2 } = Component;
  if (setup2) {
    const setupContext = instance.setupContext = setup2.length > 1 ? createSetupContext(instance) : null;
    const reset = setCurrentInstance(instance);
    pauseTracking();
    const setupResult = callWithErrorHandling(
      setup2,
      instance,
      0,
      [
        false ? shallowReadonly(instance.props) : instance.props,
        setupContext
      ]
    );
    resetTracking();
    reset();
    if (isPromise$2(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e) => {
          handleError(e, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
        if (false) {
          const name = (_a = Component.name) != null ? _a : "Anonymous";
          warn$1(
            `Component <${name}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`
          );
        }
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
__name(setupStatefulComponent, "setupStatefulComponent");
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction$4(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject$6(setupResult)) {
    if (false) {
      warn$1(
        `setup() should not return VNodes directly - return a render function instead.`
      );
    }
    if (false) {
      instance.devtoolsRawSetupState = setupResult;
    }
    instance.setupState = proxyRefs(setupResult);
    if (false) {
      exposeSetupStateOnRenderContext(instance);
    }
  } else if (false) {
    warn$1(
      `setup() should return an object. Received: ${setupResult === null ? "null" : typeof setupResult}`
    );
  }
  finishComponentSetup(instance, isSSR);
}
__name(handleSetupResult, "handleSetupResult");
let compile$2;
let installWithProxy;
function registerRuntimeCompiler(_compile) {
  compile$2 = _compile;
  installWithProxy = /* @__PURE__ */ __name((i2) => {
    if (i2.render._rc) {
      i2.withProxy = new Proxy(i2.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
    }
  }, "installWithProxy");
}
__name(registerRuntimeCompiler, "registerRuntimeCompiler");
const isRuntimeOnly = /* @__PURE__ */ __name(() => !compile$2, "isRuntimeOnly");
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile$2 && !Component.render) {
      const template = Component.template || resolveMergedOptions(instance).template;
      if (template) {
        if (false) {
          startMeasure(instance, `compile`);
        }
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = extend$1(
          extend$1(
            {
              isCustomElement,
              delimiters
            },
            compilerOptions
          ),
          componentCompilerOptions
        );
        Component.render = compile$2(template, finalCompilerOptions);
        if (false) {
          endMeasure(instance, `compile`);
        }
      }
    }
    instance.render = Component.render || NOOP;
    if (installWithProxy) {
      installWithProxy(instance);
    }
  }
  if (true) {
    const reset = setCurrentInstance(instance);
    pauseTracking();
    try {
      applyOptions(instance);
    } finally {
      resetTracking();
      reset();
    }
  }
  if (false) {
    if (!compile$2 && Component.template) {
      warn$1(
        `Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`
      );
    } else {
      warn$1(`Component is missing template or render function: `, Component);
    }
  }
}
__name(finishComponentSetup, "finishComponentSetup");
const attrsProxyHandlers = false ? {
  get(target, key) {
    markAttrsAccessed();
    track(target, "get", "");
    return target[key];
  },
  set() {
    warn$1(`setupContext.attrs is readonly.`);
    return false;
  },
  deleteProperty() {
    warn$1(`setupContext.attrs is readonly.`);
    return false;
  }
} : {
  get(target, key) {
    track(target, "get", "");
    return target[key];
  }
};
function getSlotsProxy(instance) {
  return instance.slotsProxy || (instance.slotsProxy = new Proxy(instance.slots, {
    get(target, key) {
      track(instance, "get", "$slots");
      return target[key];
    }
  }));
}
__name(getSlotsProxy, "getSlotsProxy");
function createSetupContext(instance) {
  const expose = /* @__PURE__ */ __name((exposed) => {
    if (false) {
      if (instance.exposed) {
        warn$1(`expose() should be called only once per setup().`);
      }
      if (exposed != null) {
        let exposedType = typeof exposed;
        if (exposedType === "object") {
          if (isArray$4(exposed)) {
            exposedType = "array";
          } else if (isRef(exposed)) {
            exposedType = "ref";
          }
        }
        if (exposedType !== "object") {
          warn$1(
            `expose() should be passed a plain object, received ${exposedType}.`
          );
        }
      }
    }
    instance.exposed = exposed || {};
  }, "expose");
  if (false) {
    let attrsProxy;
    return Object.freeze({
      get attrs() {
        return attrsProxy || (attrsProxy = new Proxy(instance.attrs, attrsProxyHandlers));
      },
      get slots() {
        return getSlotsProxy(instance);
      },
      get emit() {
        return (event2, ...args) => instance.emit(event2, ...args);
      },
      expose
    });
  } else {
    return {
      attrs: new Proxy(instance.attrs, attrsProxyHandlers),
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
__name(createSetupContext, "createSetupContext");
function getComponentPublicInstance(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  } else {
    return instance.proxy;
  }
}
__name(getComponentPublicInstance, "getComponentPublicInstance");
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = /* @__PURE__ */ __name((str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, ""), "classify");
function getComponentName(Component, includeInferred = true) {
  return isFunction$4(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
__name(getComponentName, "getComponentName");
function formatComponentName(instance, Component, isRoot = false) {
  let name = getComponentName(Component);
  if (!name && Component.__file) {
    const match = Component.__file.match(/([^/\\]+)\.\w+$/);
    if (match) {
      name = match[1];
    }
  }
  if (!name && instance && instance.parent) {
    const inferFromRegistry = /* @__PURE__ */ __name((registry) => {
      for (const key in registry) {
        if (registry[key] === Component) {
          return key;
        }
      }
    }, "inferFromRegistry");
    name = inferFromRegistry(
      instance.components || instance.parent.type.components
    ) || inferFromRegistry(instance.appContext.components);
  }
  return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
__name(formatComponentName, "formatComponentName");
function isClassComponent(value3) {
  return isFunction$4(value3) && "__vccOpts" in value3;
}
__name(isClassComponent, "isClassComponent");
const computed = /* @__PURE__ */ __name((getterOrOptions, debugOptions) => {
  const c = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
  if (false) {
    const i2 = getCurrentInstance();
    if (i2 && i2.appContext.config.warnRecursiveComputed) {
      c._warnRecursive = true;
    }
  }
  return c;
}, "computed");
function useModel(props, name, options3 = EMPTY_OBJ) {
  const i2 = getCurrentInstance();
  if (false) {
    warn$1(`useModel() called without active instance.`);
    return ref();
  }
  if (false) {
    warn$1(`useModel() called with prop "${name}" which is not declared.`);
    return ref();
  }
  const camelizedName = camelize$1(name);
  const hyphenatedName = hyphenate$1(name);
  const res = customRef((track2, trigger2) => {
    let localValue;
    watchSyncEffect(() => {
      const propValue = props[name];
      if (hasChanged(localValue, propValue)) {
        localValue = propValue;
        trigger2();
      }
    });
    return {
      get() {
        track2();
        return options3.get ? options3.get(localValue) : localValue;
      },
      set(value3) {
        const rawProps = i2.vnode.props;
        if (!(rawProps && // check if parent has passed v-model
        (name in rawProps || camelizedName in rawProps || hyphenatedName in rawProps) && (`onUpdate:${name}` in rawProps || `onUpdate:${camelizedName}` in rawProps || `onUpdate:${hyphenatedName}` in rawProps)) && hasChanged(value3, localValue)) {
          localValue = value3;
          trigger2();
        }
        i2.emit(`update:${name}`, options3.set ? options3.set(value3) : value3);
      }
    };
  });
  const modifierKey = name === "modelValue" ? "modelModifiers" : `${name}Modifiers`;
  res[Symbol.iterator] = () => {
    let i22 = 0;
    return {
      next() {
        if (i22 < 2) {
          return { value: i22++ ? props[modifierKey] || {} : res, done: false };
        } else {
          return { done: true };
        }
      }
    };
  };
  return res;
}
__name(useModel, "useModel");
function h(type, propsOrChildren, children) {
  const l = arguments.length;
  if (l === 2) {
    if (isObject$6(propsOrChildren) && !isArray$4(propsOrChildren)) {
      if (isVNode$1(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      }
      return createVNode(type, propsOrChildren);
    } else {
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l === 3 && isVNode$1(children)) {
      children = [children];
    }
    return createVNode(type, propsOrChildren, children);
  }
}
__name(h, "h");
function initCustomFormatter() {
  if (true) {
    return;
  }
  const vueStyle = { style: "color:#3ba776" };
  const numberStyle = { style: "color:#1677ff" };
  const stringStyle = { style: "color:#f5222d" };
  const keywordStyle = { style: "color:#eb2f96" };
  const formatter = {
    header(obj) {
      if (!isObject$6(obj)) {
        return null;
      }
      if (obj.__isVue) {
        return ["div", vueStyle, `VueInstance`];
      } else if (isRef(obj)) {
        return [
          "div",
          {},
          ["span", vueStyle, genRefFlag(obj)],
          "<",
          formatValue2(obj.value),
          `>`
        ];
      } else if (isReactive(obj)) {
        return [
          "div",
          {},
          ["span", vueStyle, isShallow(obj) ? "ShallowReactive" : "Reactive"],
          "<",
          formatValue2(obj),
          `>${isReadonly(obj) ? ` (readonly)` : ``}`
        ];
      } else if (isReadonly(obj)) {
        return [
          "div",
          {},
          ["span", vueStyle, isShallow(obj) ? "ShallowReadonly" : "Readonly"],
          "<",
          formatValue2(obj),
          ">"
        ];
      }
      return null;
    },
    hasBody(obj) {
      return obj && obj.__isVue;
    },
    body(obj) {
      if (obj && obj.__isVue) {
        return [
          "div",
          {},
          ...formatInstance(obj.$)
        ];
      }
    }
  };
  function formatInstance(instance) {
    const blocks = [];
    if (instance.type.props && instance.props) {
      blocks.push(createInstanceBlock("props", toRaw(instance.props)));
    }
    if (instance.setupState !== EMPTY_OBJ) {
      blocks.push(createInstanceBlock("setup", instance.setupState));
    }
    if (instance.data !== EMPTY_OBJ) {
      blocks.push(createInstanceBlock("data", toRaw(instance.data)));
    }
    const computed2 = extractKeys(instance, "computed");
    if (computed2) {
      blocks.push(createInstanceBlock("computed", computed2));
    }
    const injected = extractKeys(instance, "inject");
    if (injected) {
      blocks.push(createInstanceBlock("injected", injected));
    }
    blocks.push([
      "div",
      {},
      [
        "span",
        {
          style: keywordStyle.style + ";opacity:0.66"
        },
        "$ (internal): "
      ],
      ["object", { object: instance }]
    ]);
    return blocks;
  }
  __name(formatInstance, "formatInstance");
  function createInstanceBlock(type, target) {
    target = extend$1({}, target);
    if (!Object.keys(target).length) {
      return ["span", {}];
    }
    return [
      "div",
      { style: "line-height:1.25em;margin-bottom:0.6em" },
      [
        "div",
        {
          style: "color:#476582"
        },
        type
      ],
      [
        "div",
        {
          style: "padding-left:1.25em"
        },
        ...Object.keys(target).map((key) => {
          return [
            "div",
            {},
            ["span", keywordStyle, key + ": "],
            formatValue2(target[key], false)
          ];
        })
      ]
    ];
  }
  __name(createInstanceBlock, "createInstanceBlock");
  function formatValue2(v2, asRaw = true) {
    if (typeof v2 === "number") {
      return ["span", numberStyle, v2];
    } else if (typeof v2 === "string") {
      return ["span", stringStyle, JSON.stringify(v2)];
    } else if (typeof v2 === "boolean") {
      return ["span", keywordStyle, v2];
    } else if (isObject$6(v2)) {
      return ["object", { object: asRaw ? toRaw(v2) : v2 }];
    } else {
      return ["span", stringStyle, String(v2)];
    }
  }
  __name(formatValue2, "formatValue");
  function extractKeys(instance, type) {
    const Comp = instance.type;
    if (isFunction$4(Comp)) {
      return;
    }
    const extracted = {};
    for (const key in instance.ctx) {
      if (isKeyOfType(Comp, key, type)) {
        extracted[key] = instance.ctx[key];
      }
    }
    return extracted;
  }
  __name(extractKeys, "extractKeys");
  function isKeyOfType(Comp, key, type) {
    const opts = Comp[type];
    if (isArray$4(opts) && opts.includes(key) || isObject$6(opts) && key in opts) {
      return true;
    }
    if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {
      return true;
    }
    if (Comp.mixins && Comp.mixins.some((m) => isKeyOfType(m, key, type))) {
      return true;
    }
  }
  __name(isKeyOfType, "isKeyOfType");
  function genRefFlag(v2) {
    if (isShallow(v2)) {
      return `ShallowRef`;
    }
    if (v2.effect) {
      return `ComputedRef`;
    }
    return `Ref`;
  }
  __name(genRefFlag, "genRefFlag");
  if (window.devtoolsFormatters) {
    window.devtoolsFormatters.push(formatter);
  } else {
    window.devtoolsFormatters = [formatter];
  }
}
__name(initCustomFormatter, "initCustomFormatter");
function withMemo(memo, render2, cache2, index2) {
  const cached = cache2[index2];
  if (cached && isMemoSame(cached, memo)) {
    return cached;
  }
  const ret = render2();
  ret.memo = memo.slice();
  ret.memoIndex = index2;
  return cache2[index2] = ret;
}
__name(withMemo, "withMemo");
function isMemoSame(cached, memo) {
  const prev2 = cached.memo;
  if (prev2.length != memo.length) {
    return false;
  }
  for (let i2 = 0; i2 < prev2.length; i2++) {
    if (hasChanged(prev2[i2], memo[i2])) {
      return false;
    }
  }
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(cached);
  }
  return true;
}
__name(isMemoSame, "isMemoSame");
const version = "3.4.31";
const warn$2 = false ? warn$1 : NOOP;
const ErrorTypeStrings = ErrorTypeStrings$1;
const devtools$2 = true ? devtools$1 : void 0;
const setDevtoolsHook = true ? setDevtoolsHook$1 : NOOP;
const _ssrUtils = {
  createComponentInstance,
  setupComponent,
  renderComponentRoot,
  setCurrentRenderingInstance,
  isVNode: isVNode$1,
  normalizeVNode,
  getComponentPublicInstance
};
const ssrUtils = _ssrUtils;
const resolveFilter = null;
const compatUtils = null;
const DeprecationTypes = null;
/**
* @vue/runtime-dom v3.4.31
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const svgNS = "http://www.w3.org/2000/svg";
const mathmlNS = "http://www.w3.org/1998/Math/MathML";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: /* @__PURE__ */ __name((child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  }, "insert"),
  remove: /* @__PURE__ */ __name((child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  }, "remove"),
  createElement: /* @__PURE__ */ __name((tag, namespace, is, props) => {
    const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : is ? doc.createElement(tag, { is }) : doc.createElement(tag);
    if (tag === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  }, "createElement"),
  createText: /* @__PURE__ */ __name((text) => doc.createTextNode(text), "createText"),
  createComment: /* @__PURE__ */ __name((text) => doc.createComment(text), "createComment"),
  setText: /* @__PURE__ */ __name((node3, text) => {
    node3.nodeValue = text;
  }, "setText"),
  setElementText: /* @__PURE__ */ __name((el, text) => {
    el.textContent = text;
  }, "setElementText"),
  parentNode: /* @__PURE__ */ __name((node3) => node3.parentNode, "parentNode"),
  nextSibling: /* @__PURE__ */ __name((node3) => node3.nextSibling, "nextSibling"),
  querySelector: /* @__PURE__ */ __name((selector) => doc.querySelector(selector), "querySelector"),
  setScopeId(el, id2) {
    el.setAttribute(id2, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(content, parent, anchor, namespace, start2, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start2 && (start2 === end || start2.nextSibling)) {
      while (true) {
        parent.insertBefore(start2.cloneNode(true), anchor);
        if (start2 === end || !(start2 = start2.nextSibling)) break;
      }
    } else {
      templateContainer.innerHTML = namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content;
      const template = templateContainer.content;
      if (namespace === "svg" || namespace === "mathml") {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      // first
      before ? before.nextSibling : parent.firstChild,
      // last
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
const TRANSITION = "transition";
const ANIMATION = "animation";
const vtcKey = Symbol("_vtc");
const Transition = /* @__PURE__ */ __name((props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots), "Transition");
Transition.displayName = "Transition";
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
const TransitionPropsValidators = Transition.props = /* @__PURE__ */ extend$1(
  {},
  BaseTransitionPropsValidators,
  DOMTransitionPropsValidators
);
const callHook = /* @__PURE__ */ __name((hook, args = []) => {
  if (isArray$4(hook)) {
    hook.forEach((h2) => h2(...args));
  } else if (hook) {
    hook(...args);
  }
}, "callHook");
const hasExplicitCallback = /* @__PURE__ */ __name((hook) => {
  return hook ? isArray$4(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
}, "hasExplicitCallback");
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const {
    name = "v",
    type,
    duration,
    enterFromClass = `${name}-enter-from`,
    enterActiveClass = `${name}-enter-active`,
    enterToClass = `${name}-enter-to`,
    appearFromClass = enterFromClass,
    appearActiveClass = enterActiveClass,
    appearToClass = enterToClass,
    leaveFromClass = `${name}-leave-from`,
    leaveActiveClass = `${name}-leave-active`,
    leaveToClass = `${name}-leave-to`
  } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const {
    onBeforeEnter: onBeforeEnter3,
    onEnter: onEnter8,
    onEnterCancelled,
    onLeave: onLeave6,
    onLeaveCancelled,
    onBeforeAppear = onBeforeEnter3,
    onAppear = onEnter8,
    onAppearCancelled = onEnterCancelled
  } = baseProps;
  const finishEnter = /* @__PURE__ */ __name((el, isAppear, done) => {
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  }, "finishEnter");
  const finishLeave = /* @__PURE__ */ __name((el, done) => {
    el._isLeaving = false;
    removeTransitionClass(el, leaveFromClass);
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done && done();
  }, "finishLeave");
  const makeEnterHook = /* @__PURE__ */ __name((isAppear) => {
    return (el, done) => {
      const hook = isAppear ? onAppear : onEnter8;
      const resolve8 = /* @__PURE__ */ __name(() => finishEnter(el, isAppear, done), "resolve");
      callHook(hook, [el, resolve8]);
      nextFrame(() => {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type, enterDuration, resolve8);
        }
      });
    };
  }, "makeEnterHook");
  return extend$1(baseProps, {
    onBeforeEnter(el) {
      callHook(onBeforeEnter3, [el]);
      addTransitionClass(el, enterFromClass);
      addTransitionClass(el, enterActiveClass);
    },
    onBeforeAppear(el) {
      callHook(onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      addTransitionClass(el, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el, done) {
      el._isLeaving = true;
      const resolve8 = /* @__PURE__ */ __name(() => finishLeave(el, done), "resolve");
      addTransitionClass(el, leaveFromClass);
      addTransitionClass(el, leaveActiveClass);
      forceReflow();
      nextFrame(() => {
        if (!el._isLeaving) {
          return;
        }
        removeTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveToClass);
        if (!hasExplicitCallback(onLeave6)) {
          whenTransitionEnds(el, type, leaveDuration, resolve8);
        }
      });
      callHook(onLeave6, [el, resolve8]);
    },
    onEnterCancelled(el) {
      finishEnter(el, false);
      callHook(onEnterCancelled, [el]);
    },
    onAppearCancelled(el) {
      finishEnter(el, true);
      callHook(onAppearCancelled, [el]);
    },
    onLeaveCancelled(el) {
      finishLeave(el);
      callHook(onLeaveCancelled, [el]);
    }
  });
}
__name(resolveTransitionProps, "resolveTransitionProps");
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if (isObject$6(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n = NumberOf(duration);
    return [n, n];
  }
}
__name(normalizeDuration, "normalizeDuration");
function NumberOf(val) {
  const res = toNumber(val);
  if (false) {
    assertNumber(res, "<transition> explicit duration");
  }
  return res;
}
__name(NumberOf, "NumberOf");
function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
  (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
}
__name(addTransitionClass, "addTransitionClass");
function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
  const _vtc = el[vtcKey];
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el[vtcKey] = void 0;
    }
  }
}
__name(removeTransitionClass, "removeTransitionClass");
function nextFrame(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
__name(nextFrame, "nextFrame");
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve8) {
  const id2 = el._endId = ++endId;
  const resolveIfNotStale = /* @__PURE__ */ __name(() => {
    if (id2 === el._endId) {
      resolve8();
    }
  }, "resolveIfNotStale");
  if (explicitTimeout) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
  if (!type) {
    return resolve8();
  }
  const endEvent = type + "end";
  let ended = 0;
  const end = /* @__PURE__ */ __name(() => {
    el.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  }, "end");
  const onEnd = /* @__PURE__ */ __name((e) => {
    if (e.target === el && ++ended >= propCount) {
      end();
    }
  }, "onEnd");
  setTimeout(() => {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(endEvent, onEnd);
}
__name(whenTransitionEnds, "whenTransitionEnds");
function getTransitionInfo(el, expectedType) {
  const styles = window.getComputedStyle(el);
  const getStyleProperties = /* @__PURE__ */ __name((key) => (styles[key] || "").split(", "), "getStyleProperties");
  const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
  const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type = null;
  let timeout = 0;
  let propCount = 0;
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(
    getStyleProperties(`${TRANSITION}Property`).toString()
  );
  return {
    type,
    timeout,
    propCount,
    hasTransform
  };
}
__name(getTransitionInfo, "getTransitionInfo");
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d, i2) => toMs(d) + toMs(delays[i2])));
}
__name(getTimeout, "getTimeout");
function toMs(s) {
  if (s === "auto") return 0;
  return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
}
__name(toMs, "toMs");
function forceReflow() {
  return document.body.offsetHeight;
}
__name(forceReflow, "forceReflow");
function patchClass(el, value3, isSVG) {
  const transitionClasses = el[vtcKey];
  if (transitionClasses) {
    value3 = (value3 ? [value3, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value3 == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value3);
  } else {
    el.className = value3;
  }
}
__name(patchClass, "patchClass");
const vShowOriginalDisplay = Symbol("_vod");
const vShowHidden = Symbol("_vsh");
const vShow = {
  beforeMount(el, { value: value3 }, { transition }) {
    el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
    if (transition && value3) {
      transition.beforeEnter(el);
    } else {
      setDisplay(el, value3);
    }
  },
  mounted(el, { value: value3 }, { transition }) {
    if (transition && value3) {
      transition.enter(el);
    }
  },
  updated(el, { value: value3, oldValue }, { transition }) {
    if (!value3 === !oldValue) return;
    if (transition) {
      if (value3) {
        transition.beforeEnter(el);
        setDisplay(el, true);
        transition.enter(el);
      } else {
        transition.leave(el, () => {
          setDisplay(el, false);
        });
      }
    } else {
      setDisplay(el, value3);
    }
  },
  beforeUnmount(el, { value: value3 }) {
    setDisplay(el, value3);
  }
};
if (false) {
  vShow.name = "show";
}
function setDisplay(el, value3) {
  el.style.display = value3 ? el[vShowOriginalDisplay] : "none";
  el[vShowHidden] = !value3;
}
__name(setDisplay, "setDisplay");
function initVShowForSSR() {
  vShow.getSSRProps = ({ value: value3 }) => {
    if (!value3) {
      return { style: { display: "none" } };
    }
  };
}
__name(initVShowForSSR, "initVShowForSSR");
const CSS_VAR_TEXT = Symbol(false ? "CSS_VAR_TEXT" : "");
function useCssVars(getter) {
  const instance = getCurrentInstance();
  if (!instance) {
    return;
  }
  const updateTeleports = instance.ut = (vars = getter(instance.proxy)) => {
    Array.from(
      document.querySelectorAll(`[data-v-owner="${instance.uid}"]`)
    ).forEach((node3) => setVarsOnNode(node3, vars));
  };
  if (false) {
    instance.getCssVars = () => getter(instance.proxy);
  }
  const setVars = /* @__PURE__ */ __name(() => {
    const vars = getter(instance.proxy);
    setVarsOnVNode(instance.subTree, vars);
    updateTeleports(vars);
  }, "setVars");
  onMounted(() => {
    watchPostEffect(setVars);
    const ob = new MutationObserver(setVars);
    ob.observe(instance.subTree.el.parentNode, { childList: true });
    onUnmounted(() => ob.disconnect());
  });
}
__name(useCssVars, "useCssVars");
function setVarsOnVNode(vnode, vars) {
  if (vnode.shapeFlag & 128) {
    const suspense = vnode.suspense;
    vnode = suspense.activeBranch;
    if (suspense.pendingBranch && !suspense.isHydrating) {
      suspense.effects.push(() => {
        setVarsOnVNode(suspense.activeBranch, vars);
      });
    }
  }
  while (vnode.component) {
    vnode = vnode.component.subTree;
  }
  if (vnode.shapeFlag & 1 && vnode.el) {
    setVarsOnNode(vnode.el, vars);
  } else if (vnode.type === Fragment) {
    vnode.children.forEach((c) => setVarsOnVNode(c, vars));
  } else if (vnode.type === Static) {
    let { el, anchor } = vnode;
    while (el) {
      setVarsOnNode(el, vars);
      if (el === anchor) break;
      el = el.nextSibling;
    }
  }
}
__name(setVarsOnVNode, "setVarsOnVNode");
function setVarsOnNode(el, vars) {
  if (el.nodeType === 1) {
    const style = el.style;
    let cssText = "";
    for (const key in vars) {
      style.setProperty(`--${key}`, vars[key]);
      cssText += `--${key}: ${vars[key]};`;
    }
    style[CSS_VAR_TEXT] = cssText;
  }
}
__name(setVarsOnNode, "setVarsOnNode");
const displayRE = /(^|;)\s*display\s*:/;
function patchStyle(el, prev2, next2) {
  const style = el.style;
  const isCssString = isString$5(next2);
  let hasControlledDisplay = false;
  if (next2 && !isCssString) {
    if (prev2) {
      if (!isString$5(prev2)) {
        for (const key in prev2) {
          if (next2[key] == null) {
            setStyle(style, key, "");
          }
        }
      } else {
        for (const prevStyle of prev2.split(";")) {
          const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
          if (next2[key] == null) {
            setStyle(style, key, "");
          }
        }
      }
    }
    for (const key in next2) {
      if (key === "display") {
        hasControlledDisplay = true;
      }
      setStyle(style, key, next2[key]);
    }
  } else {
    if (isCssString) {
      if (prev2 !== next2) {
        const cssVarText = style[CSS_VAR_TEXT];
        if (cssVarText) {
          next2 += ";" + cssVarText;
        }
        style.cssText = next2;
        hasControlledDisplay = displayRE.test(next2);
      }
    } else if (prev2) {
      el.removeAttribute("style");
    }
  }
  if (vShowOriginalDisplay in el) {
    el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
    if (el[vShowHidden]) {
      style.display = "none";
    }
  }
}
__name(patchStyle, "patchStyle");
const semicolonRE = /[^\\];\s*$/;
const importantRE = /\s*!important$/;
function setStyle(style, name, val) {
  if (isArray$4(val)) {
    val.forEach((v2) => setStyle(style, name, v2));
  } else {
    if (val == null) val = "";
    if (false) {
      if (semicolonRE.test(val)) {
        warn$2(
          `Unexpected semicolon at the end of '${name}' style value: '${val}'`
        );
      }
    }
    if (name.startsWith("--")) {
      style.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style, name);
      if (importantRE.test(val)) {
        style.setProperty(
          hyphenate$1(prefixed),
          val.replace(importantRE, ""),
          "important"
        );
      } else {
        style[prefixed] = val;
      }
    }
  }
}
__name(setStyle, "setStyle");
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize$1(rawName);
  if (name !== "filter" && name in style) {
    return prefixCache[rawName] = name;
  }
  name = capitalize$1(name);
  for (let i2 = 0; i2 < prefixes.length; i2++) {
    const prefixed = prefixes[i2] + name;
    if (prefixed in style) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
__name(autoPrefix, "autoPrefix");
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value3, isSVG, instance, isBoolean2 = isSpecialBooleanAttr(key)) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value3 == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value3);
    }
  } else {
    if (value3 == null || isBoolean2 && !includeBooleanAttr(value3)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(
        key,
        isBoolean2 ? "" : isSymbol$1(value3) ? String(value3) : value3
      );
    }
  }
}
__name(patchAttr, "patchAttr");
function patchDOMProp(el, key, value3, prevChildren, parentComponent, parentSuspense, unmountChildren) {
  if (key === "innerHTML" || key === "textContent") {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }
    el[key] = value3 == null ? "" : value3;
    return;
  }
  const tag = el.tagName;
  if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
  !tag.includes("-")) {
    const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
    const newValue = value3 == null ? "" : String(value3);
    if (oldValue !== newValue || !("_value" in el)) {
      el.value = newValue;
    }
    if (value3 == null) {
      el.removeAttribute(key);
    }
    el._value = value3;
    return;
  }
  let needRemove = false;
  if (value3 === "" || value3 == null) {
    const type = typeof el[key];
    if (type === "boolean") {
      value3 = includeBooleanAttr(value3);
    } else if (value3 == null && type === "string") {
      value3 = "";
      needRemove = true;
    } else if (type === "number") {
      value3 = 0;
      needRemove = true;
    }
  }
  try {
    el[key] = value3;
  } catch (e) {
    if (false) {
      warn$2(
        `Failed setting prop "${key}" on <${tag.toLowerCase()}>: value ${value3} is invalid.`,
        e
      );
    }
  }
  needRemove && el.removeAttribute(key);
}
__name(patchDOMProp, "patchDOMProp");
function addEventListener(el, event2, handler6, options3) {
  el.addEventListener(event2, handler6, options3);
}
__name(addEventListener, "addEventListener");
function removeEventListener(el, event2, handler6, options3) {
  el.removeEventListener(event2, handler6, options3);
}
__name(removeEventListener, "removeEventListener");
const veiKey = Symbol("_vei");
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el[veiKey] || (el[veiKey] = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = false ? sanitizeEventValue(nextValue, rawName) : nextValue;
  } else {
    const [name, options3] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(
        false ? sanitizeEventValue(nextValue, rawName) : nextValue,
        instance
      );
      addEventListener(el, name, invoker, options3);
    } else if (existingInvoker) {
      removeEventListener(el, name, existingInvoker, options3);
      invokers[rawName] = void 0;
    }
  }
}
__name(patchEvent, "patchEvent");
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options3;
  if (optionsModifierRE.test(name)) {
    options3 = {};
    let m;
    while (m = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m[0].length);
      options3[m[0].toLowerCase()] = true;
    }
  }
  const event2 = name[2] === ":" ? name.slice(3) : hyphenate$1(name.slice(2));
  return [event2, options3];
}
__name(parseName, "parseName");
let cachedNow = 0;
const p = /* @__PURE__ */ Promise.resolve();
const getNow = /* @__PURE__ */ __name(() => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now()), "getNow");
function createInvoker(initialValue, instance) {
  const invoker = /* @__PURE__ */ __name((e) => {
    if (!e._vts) {
      e._vts = Date.now();
    } else if (e._vts <= invoker.attached) {
      return;
    }
    callWithAsyncErrorHandling(
      patchStopImmediatePropagation(e, invoker.value),
      instance,
      5,
      [e]
    );
  }, "invoker");
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
__name(createInvoker, "createInvoker");
function sanitizeEventValue(value3, propName) {
  if (isFunction$4(value3) || isArray$4(value3)) {
    return value3;
  }
  warn$2(
    `Wrong type passed as event handler to ${propName} - did you forget @ or : in front of your prop?
Expected function or array of functions, received type ${typeof value3}.`
  );
  return NOOP;
}
__name(sanitizeEventValue, "sanitizeEventValue");
function patchStopImmediatePropagation(e, value3) {
  if (isArray$4(value3)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value3.map(
      (fn) => (e2) => !e2._stopped && fn && fn(e2)
    );
  } else {
    return value3;
  }
}
__name(patchStopImmediatePropagation, "patchStopImmediatePropagation");
const isNativeOn = /* @__PURE__ */ __name((key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123, "isNativeOn");
const patchProp = /* @__PURE__ */ __name((el, key, prevValue, nextValue, namespace, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
  const isSVG = namespace === "svg";
  if (key === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
    patchDOMProp(
      el,
      key,
      nextValue,
      prevChildren,
      parentComponent,
      parentSuspense,
      unmountChildren
    );
    if (!el.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
      patchAttr(el, key, nextValue, isSVG, parentComponent, key !== "value");
    }
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG);
  }
}, "patchProp");
function shouldSetAsProp(el, key, value3, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && isNativeOn(key) && isFunction$4(value3)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (key === "width" || key === "height") {
    const tag = el.tagName;
    if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
      return false;
    }
  }
  if (isNativeOn(key) && isString$5(value3)) {
    return false;
  }
  return key in el;
}
__name(shouldSetAsProp, "shouldSetAsProp");
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineCustomElement(options3, extraOptions, hydrate2) {
  const Comp = /* @__PURE__ */ defineComponent(options3, extraOptions);
  class VueCustomElement extends VueElement {
    static {
      __name(this, "VueCustomElement");
    }
    constructor(initialProps) {
      super(Comp, initialProps, hydrate2);
    }
  }
  VueCustomElement.def = Comp;
  return VueCustomElement;
}
__name(defineCustomElement, "defineCustomElement");
/*! #__NO_SIDE_EFFECTS__ */
const defineSSRCustomElement = /* @__PURE__ */ __name(/* @__NO_SIDE_EFFECTS__ */ (options3, extraOptions) => {
  return /* @__PURE__ */ defineCustomElement(options3, extraOptions, hydrate);
}, "defineSSRCustomElement");
const BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {
};
class VueElement extends BaseClass {
  static {
    __name(this, "VueElement");
  }
  constructor(_def, _props = {}, hydrate2) {
    super();
    this._def = _def;
    this._props = _props;
    this._instance = null;
    this._connected = false;
    this._resolved = false;
    this._numberProps = null;
    this._ob = null;
    if (this.shadowRoot && hydrate2) {
      hydrate2(this._createVNode(), this.shadowRoot);
    } else {
      if (false) {
        warn$2(
          `Custom element has pre-rendered declarative shadow root but is not defined as hydratable. Use \`defineSSRCustomElement\`.`
        );
      }
      this.attachShadow({ mode: "open" });
      if (!this._def.__asyncLoader) {
        this._resolveProps(this._def);
      }
    }
  }
  connectedCallback() {
    this._connected = true;
    if (!this._instance) {
      if (this._resolved) {
        this._update();
      } else {
        this._resolveDef();
      }
    }
  }
  disconnectedCallback() {
    this._connected = false;
    nextTick(() => {
      if (!this._connected) {
        if (this._ob) {
          this._ob.disconnect();
          this._ob = null;
        }
        render$V(null, this.shadowRoot);
        this._instance = null;
      }
    });
  }
  /**
   * resolve inner component definition (handle possible async component)
   */
  _resolveDef() {
    this._resolved = true;
    for (let i2 = 0; i2 < this.attributes.length; i2++) {
      this._setAttr(this.attributes[i2].name);
    }
    this._ob = new MutationObserver((mutations) => {
      for (const m of mutations) {
        this._setAttr(m.attributeName);
      }
    });
    this._ob.observe(this, { attributes: true });
    const resolve8 = /* @__PURE__ */ __name((def2, isAsync2 = false) => {
      const { props, styles } = def2;
      let numberProps;
      if (props && !isArray$4(props)) {
        for (const key in props) {
          const opt = props[key];
          if (opt === Number || opt && opt.type === Number) {
            if (key in this._props) {
              this._props[key] = toNumber(this._props[key]);
            }
            (numberProps || (numberProps = /* @__PURE__ */ Object.create(null)))[camelize$1(key)] = true;
          }
        }
      }
      this._numberProps = numberProps;
      if (isAsync2) {
        this._resolveProps(def2);
      }
      this._applyStyles(styles);
      this._update();
    }, "resolve");
    const asyncDef = this._def.__asyncLoader;
    if (asyncDef) {
      asyncDef().then((def2) => resolve8(def2, true));
    } else {
      resolve8(this._def);
    }
  }
  _resolveProps(def2) {
    const { props } = def2;
    const declaredPropKeys = isArray$4(props) ? props : Object.keys(props || {});
    for (const key of Object.keys(this)) {
      if (key[0] !== "_" && declaredPropKeys.includes(key)) {
        this._setProp(key, this[key], true, false);
      }
    }
    for (const key of declaredPropKeys.map(camelize$1)) {
      Object.defineProperty(this, key, {
        get() {
          return this._getProp(key);
        },
        set(val) {
          this._setProp(key, val);
        }
      });
    }
  }
  _setAttr(key) {
    let value3 = this.hasAttribute(key) ? this.getAttribute(key) : void 0;
    const camelKey = camelize$1(key);
    if (this._numberProps && this._numberProps[camelKey]) {
      value3 = toNumber(value3);
    }
    this._setProp(camelKey, value3, false);
  }
  /**
   * @internal
   */
  _getProp(key) {
    return this._props[key];
  }
  /**
   * @internal
   */
  _setProp(key, val, shouldReflect = true, shouldUpdate = true) {
    if (val !== this._props[key]) {
      this._props[key] = val;
      if (shouldUpdate && this._instance) {
        this._update();
      }
      if (shouldReflect) {
        if (val === true) {
          this.setAttribute(hyphenate$1(key), "");
        } else if (typeof val === "string" || typeof val === "number") {
          this.setAttribute(hyphenate$1(key), val + "");
        } else if (!val) {
          this.removeAttribute(hyphenate$1(key));
        }
      }
    }
  }
  _update() {
    render$V(this._createVNode(), this.shadowRoot);
  }
  _createVNode() {
    const vnode = createVNode(this._def, extend$1({}, this._props));
    if (!this._instance) {
      vnode.ce = (instance) => {
        this._instance = instance;
        instance.isCE = true;
        if (false) {
          instance.ceReload = (newStyles) => {
            if (this._styles) {
              this._styles.forEach((s) => this.shadowRoot.removeChild(s));
              this._styles.length = 0;
            }
            this._applyStyles(newStyles);
            this._instance = null;
            this._update();
          };
        }
        const dispatch = /* @__PURE__ */ __name((event2, args) => {
          this.dispatchEvent(
            new CustomEvent(event2, {
              detail: args
            })
          );
        }, "dispatch");
        instance.emit = (event2, ...args) => {
          dispatch(event2, args);
          if (hyphenate$1(event2) !== event2) {
            dispatch(hyphenate$1(event2), args);
          }
        };
        let parent = this;
        while (parent = parent && (parent.parentNode || parent.host)) {
          if (parent instanceof VueElement) {
            instance.parent = parent._instance;
            instance.provides = parent._instance.provides;
            break;
          }
        }
      };
    }
    return vnode;
  }
  _applyStyles(styles) {
    if (styles) {
      styles.forEach((css4) => {
        const s = document.createElement("style");
        s.textContent = css4;
        this.shadowRoot.appendChild(s);
        if (false) {
          (this._styles || (this._styles = [])).push(s);
        }
      });
    }
  }
}
function useCssModule(name = "$style") {
  {
    const instance = getCurrentInstance();
    if (!instance) {
      return EMPTY_OBJ;
    }
    const modules = instance.type.__cssModules;
    if (!modules) {
      return EMPTY_OBJ;
    }
    const mod = modules[name];
    if (!mod) {
      return EMPTY_OBJ;
    }
    return mod;
  }
}
__name(useCssModule, "useCssModule");
const positionMap = /* @__PURE__ */ new WeakMap();
const newPositionMap = /* @__PURE__ */ new WeakMap();
const moveCbKey = Symbol("_moveCb");
const enterCbKey = Symbol("_enterCb");
const TransitionGroupImpl = {
  name: "TransitionGroup",
  props: /* @__PURE__ */ extend$1({}, TransitionPropsValidators, {
    tag: String,
    moveClass: String
  }),
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    let prevChildren;
    let children;
    onUpdated(() => {
      if (!prevChildren.length) {
        return;
      }
      const moveClass = props.moveClass || `${props.name || "v"}-move`;
      if (!hasCSSTransform(
        prevChildren[0].el,
        instance.vnode.el,
        moveClass
      )) {
        return;
      }
      prevChildren.forEach(callPendingCbs);
      prevChildren.forEach(recordPosition);
      const movedChildren = prevChildren.filter(applyTranslation);
      forceReflow();
      movedChildren.forEach((c) => {
        const el = c.el;
        const style = el.style;
        addTransitionClass(el, moveClass);
        style.transform = style.webkitTransform = style.transitionDuration = "";
        const cb = el[moveCbKey] = (e) => {
          if (e && e.target !== el) {
            return;
          }
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener("transitionend", cb);
            el[moveCbKey] = null;
            removeTransitionClass(el, moveClass);
          }
        };
        el.addEventListener("transitionend", cb);
      });
    });
    return () => {
      const rawProps = toRaw(props);
      const cssTransitionProps = resolveTransitionProps(rawProps);
      let tag = rawProps.tag || Fragment;
      prevChildren = [];
      if (children) {
        for (let i2 = 0; i2 < children.length; i2++) {
          const child = children[i2];
          if (child.el && child.el instanceof Element) {
            prevChildren.push(child);
            setTransitionHooks(
              child,
              resolveTransitionHooks(
                child,
                cssTransitionProps,
                state,
                instance
              )
            );
            positionMap.set(
              child,
              child.el.getBoundingClientRect()
            );
          }
        }
      }
      children = slots.default ? getTransitionRawChildren(slots.default()) : [];
      for (let i2 = 0; i2 < children.length; i2++) {
        const child = children[i2];
        if (child.key != null) {
          setTransitionHooks(
            child,
            resolveTransitionHooks(child, cssTransitionProps, state, instance)
          );
        } else if (false) {
          warn$2(`<TransitionGroup> children must be keyed.`);
        }
      }
      return createVNode(tag, null, children);
    };
  }
};
const removeMode = /* @__PURE__ */ __name((props) => delete props.mode, "removeMode");
/* @__PURE__ */ removeMode(TransitionGroupImpl.props);
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c) {
  const el = c.el;
  if (el[moveCbKey]) {
    el[moveCbKey]();
  }
  if (el[enterCbKey]) {
    el[enterCbKey]();
  }
}
__name(callPendingCbs, "callPendingCbs");
function recordPosition(c) {
  newPositionMap.set(c, c.el.getBoundingClientRect());
}
__name(recordPosition, "recordPosition");
function applyTranslation(c) {
  const oldPos = positionMap.get(c);
  const newPos = newPositionMap.get(c);
  const dx = oldPos.left - newPos.left;
  const dy = oldPos.top - newPos.top;
  if (dx || dy) {
    const s = c.el.style;
    s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
    s.transitionDuration = "0s";
    return c;
  }
}
__name(applyTranslation, "applyTranslation");
function hasCSSTransform(el, root26, moveClass) {
  const clone2 = el.cloneNode();
  const _vtc = el[vtcKey];
  if (_vtc) {
    _vtc.forEach((cls) => {
      cls.split(/\s+/).forEach((c) => c && clone2.classList.remove(c));
    });
  }
  moveClass.split(/\s+/).forEach((c) => c && clone2.classList.add(c));
  clone2.style.display = "none";
  const container = root26.nodeType === 1 ? root26 : root26.parentNode;
  container.appendChild(clone2);
  const { hasTransform } = getTransitionInfo(clone2);
  container.removeChild(clone2);
  return hasTransform;
}
__name(hasCSSTransform, "hasCSSTransform");
const getModelAssigner = /* @__PURE__ */ __name((vnode) => {
  const fn = vnode.props["onUpdate:modelValue"] || false;
  return isArray$4(fn) ? (value3) => invokeArrayFns(fn, value3) : fn;
}, "getModelAssigner");
function onCompositionStart(e) {
  e.target.composing = true;
}
__name(onCompositionStart, "onCompositionStart");
function onCompositionEnd(e) {
  const target = e.target;
  if (target.composing) {
    target.composing = false;
    target.dispatchEvent(new Event("input"));
  }
}
__name(onCompositionEnd, "onCompositionEnd");
const assignKey = Symbol("_assign");
const vModelText = {
  created(el, { modifiers: { lazy, trim: trim2, number: number2 } }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    const castToNumber = number2 || vnode.props && vnode.props.type === "number";
    addEventListener(el, lazy ? "change" : "input", (e) => {
      if (e.target.composing) return;
      let domValue = el.value;
      if (trim2) {
        domValue = domValue.trim();
      }
      if (castToNumber) {
        domValue = looseToNumber(domValue);
      }
      el[assignKey](domValue);
    });
    if (trim2) {
      addEventListener(el, "change", () => {
        el.value = el.value.trim();
      });
    }
    if (!lazy) {
      addEventListener(el, "compositionstart", onCompositionStart);
      addEventListener(el, "compositionend", onCompositionEnd);
      addEventListener(el, "change", onCompositionEnd);
    }
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(el, { value: value3 }) {
    el.value = value3 == null ? "" : value3;
  },
  beforeUpdate(el, { value: value3, oldValue, modifiers: { lazy, trim: trim2, number: number2 } }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    if (el.composing) return;
    const elValue = (number2 || el.type === "number") && !/^0\d/.test(el.value) ? looseToNumber(el.value) : el.value;
    const newValue = value3 == null ? "" : value3;
    if (elValue === newValue) {
      return;
    }
    if (document.activeElement === el && el.type !== "range") {
      if (lazy && value3 === oldValue) {
        return;
      }
      if (trim2 && el.value.trim() === newValue) {
        return;
      }
    }
    el.value = newValue;
  }
};
const vModelCheckbox = {
  // #4096 array checkboxes need to be deep traversed
  deep: true,
  created(el, _2, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    addEventListener(el, "change", () => {
      const modelValue3 = el._modelValue;
      const elementValue = getValue$1(el);
      const checked4 = el.checked;
      const assign2 = el[assignKey];
      if (isArray$4(modelValue3)) {
        const index2 = looseIndexOf(modelValue3, elementValue);
        const found = index2 !== -1;
        if (checked4 && !found) {
          assign2(modelValue3.concat(elementValue));
        } else if (!checked4 && found) {
          const filtered = [...modelValue3];
          filtered.splice(index2, 1);
          assign2(filtered);
        }
      } else if (isSet(modelValue3)) {
        const cloned = new Set(modelValue3);
        if (checked4) {
          cloned.add(elementValue);
        } else {
          cloned.delete(elementValue);
        }
        assign2(cloned);
      } else {
        assign2(getCheckboxValue(el, checked4));
      }
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: setChecked,
  beforeUpdate(el, binding, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    setChecked(el, binding, vnode);
  }
};
function setChecked(el, { value: value3, oldValue }, vnode) {
  el._modelValue = value3;
  if (isArray$4(value3)) {
    el.checked = looseIndexOf(value3, vnode.props.value) > -1;
  } else if (isSet(value3)) {
    el.checked = value3.has(vnode.props.value);
  } else if (value3 !== oldValue) {
    el.checked = looseEqual(value3, getCheckboxValue(el, true));
  }
}
__name(setChecked, "setChecked");
const vModelRadio = {
  created(el, { value: value3 }, vnode) {
    el.checked = looseEqual(value3, vnode.props.value);
    el[assignKey] = getModelAssigner(vnode);
    addEventListener(el, "change", () => {
      el[assignKey](getValue$1(el));
    });
  },
  beforeUpdate(el, { value: value3, oldValue }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    if (value3 !== oldValue) {
      el.checked = looseEqual(value3, vnode.props.value);
    }
  }
};
const vModelSelect = {
  // <select multiple> value need to be deep traversed
  deep: true,
  created(el, { value: value3, modifiers: { number: number2 } }, vnode) {
    const isSetModel = isSet(value3);
    addEventListener(el, "change", () => {
      const selectedVal = Array.prototype.filter.call(el.options, (o) => o.selected).map(
        (o) => number2 ? looseToNumber(getValue$1(o)) : getValue$1(o)
      );
      el[assignKey](
        el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]
      );
      el._assigning = true;
      nextTick(() => {
        el._assigning = false;
      });
    });
    el[assignKey] = getModelAssigner(vnode);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(el, { value: value3, modifiers: { number: number2 } }) {
    setSelected(el, value3);
  },
  beforeUpdate(el, _binding, vnode) {
    el[assignKey] = getModelAssigner(vnode);
  },
  updated(el, { value: value3, modifiers: { number: number2 } }) {
    if (!el._assigning) {
      setSelected(el, value3);
    }
  }
};
function setSelected(el, value3, number2) {
  const isMultiple = el.multiple;
  const isArrayValue = isArray$4(value3);
  if (isMultiple && !isArrayValue && !isSet(value3)) {
    return;
  }
  for (let i2 = 0, l = el.options.length; i2 < l; i2++) {
    const option4 = el.options[i2];
    const optionValue = getValue$1(option4);
    if (isMultiple) {
      if (isArrayValue) {
        const optionType = typeof optionValue;
        if (optionType === "string" || optionType === "number") {
          option4.selected = value3.some((v2) => String(v2) === String(optionValue));
        } else {
          option4.selected = looseIndexOf(value3, optionValue) > -1;
        }
      } else {
        option4.selected = value3.has(optionValue);
      }
    } else if (looseEqual(getValue$1(option4), value3)) {
      if (el.selectedIndex !== i2) el.selectedIndex = i2;
      return;
    }
  }
  if (!isMultiple && el.selectedIndex !== -1) {
    el.selectedIndex = -1;
  }
}
__name(setSelected, "setSelected");
function getValue$1(el) {
  return "_value" in el ? el._value : el.value;
}
__name(getValue$1, "getValue$1");
function getCheckboxValue(el, checked4) {
  const key = checked4 ? "_trueValue" : "_falseValue";
  return key in el ? el[key] : checked4;
}
__name(getCheckboxValue, "getCheckboxValue");
const vModelDynamic = {
  created(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, "created");
  },
  mounted(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, "mounted");
  },
  beforeUpdate(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, "beforeUpdate");
  },
  updated(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, "updated");
  }
};
function resolveDynamicModel(tagName, type) {
  switch (tagName) {
    case "SELECT":
      return vModelSelect;
    case "TEXTAREA":
      return vModelText;
    default:
      switch (type) {
        case "checkbox":
          return vModelCheckbox;
        case "radio":
          return vModelRadio;
        default:
          return vModelText;
      }
  }
}
__name(resolveDynamicModel, "resolveDynamicModel");
function callModelHook(el, binding, vnode, prevVNode, hook) {
  const modelToUse = resolveDynamicModel(
    el.tagName,
    vnode.props && vnode.props.type
  );
  const fn = modelToUse[hook];
  fn && fn(el, binding, vnode, prevVNode);
}
__name(callModelHook, "callModelHook");
function initVModelForSSR() {
  vModelText.getSSRProps = ({ value: value3 }) => ({ value: value3 });
  vModelRadio.getSSRProps = ({ value: value3 }, vnode) => {
    if (vnode.props && looseEqual(vnode.props.value, value3)) {
      return { checked: true };
    }
  };
  vModelCheckbox.getSSRProps = ({ value: value3 }, vnode) => {
    if (isArray$4(value3)) {
      if (vnode.props && looseIndexOf(value3, vnode.props.value) > -1) {
        return { checked: true };
      }
    } else if (isSet(value3)) {
      if (vnode.props && value3.has(vnode.props.value)) {
        return { checked: true };
      }
    } else if (value3) {
      return { checked: true };
    }
  };
  vModelDynamic.getSSRProps = (binding, vnode) => {
    if (typeof vnode.type !== "string") {
      return;
    }
    const modelToUse = resolveDynamicModel(
      // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase
      vnode.type.toUpperCase(),
      vnode.props && vnode.props.type
    );
    if (modelToUse.getSSRProps) {
      return modelToUse.getSSRProps(binding, vnode);
    }
  };
}
__name(initVModelForSSR, "initVModelForSSR");
const systemModifiers = ["ctrl", "shift", "alt", "meta"];
const modifierGuards = {
  stop: /* @__PURE__ */ __name((e) => e.stopPropagation(), "stop"),
  prevent: /* @__PURE__ */ __name((e) => e.preventDefault(), "prevent"),
  self: /* @__PURE__ */ __name((e) => e.target !== e.currentTarget, "self"),
  ctrl: /* @__PURE__ */ __name((e) => !e.ctrlKey, "ctrl"),
  shift: /* @__PURE__ */ __name((e) => !e.shiftKey, "shift"),
  alt: /* @__PURE__ */ __name((e) => !e.altKey, "alt"),
  meta: /* @__PURE__ */ __name((e) => !e.metaKey, "meta"),
  left: /* @__PURE__ */ __name((e) => "button" in e && e.button !== 0, "left"),
  middle: /* @__PURE__ */ __name((e) => "button" in e && e.button !== 1, "middle"),
  right: /* @__PURE__ */ __name((e) => "button" in e && e.button !== 2, "right"),
  exact: /* @__PURE__ */ __name((e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m)), "exact")
};
const withModifiers = /* @__PURE__ */ __name((fn, modifiers) => {
  const cache2 = fn._withMods || (fn._withMods = {});
  const cacheKey = modifiers.join(".");
  return cache2[cacheKey] || (cache2[cacheKey] = (event2, ...args) => {
    for (let i2 = 0; i2 < modifiers.length; i2++) {
      const guard = modifierGuards[modifiers[i2]];
      if (guard && guard(event2, modifiers)) return;
    }
    return fn(event2, ...args);
  });
}, "withModifiers");
const keyNames = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
};
const withKeys = /* @__PURE__ */ __name((fn, modifiers) => {
  const cache2 = fn._withKeys || (fn._withKeys = {});
  const cacheKey = modifiers.join(".");
  return cache2[cacheKey] || (cache2[cacheKey] = (event2) => {
    if (!("key" in event2)) {
      return;
    }
    const eventKey = hyphenate$1(event2.key);
    if (modifiers.some((k) => k === eventKey || keyNames[k] === eventKey)) {
      return fn(event2);
    }
  });
}, "withKeys");
const rendererOptions = /* @__PURE__ */ extend$1({ patchProp }, nodeOps);
let renderer;
let enabledHydration = false;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
__name(ensureRenderer, "ensureRenderer");
function ensureHydrationRenderer() {
  renderer = enabledHydration ? renderer : createHydrationRenderer(rendererOptions);
  enabledHydration = true;
  return renderer;
}
__name(ensureHydrationRenderer, "ensureHydrationRenderer");
const render$V = /* @__PURE__ */ __name((...args) => {
  ensureRenderer().render(...args);
}, "render$V");
const hydrate = /* @__PURE__ */ __name((...args) => {
  ensureHydrationRenderer().hydrate(...args);
}, "hydrate");
const createApp = /* @__PURE__ */ __name((...args) => {
  const app2 = ensureRenderer().createApp(...args);
  if (false) {
    injectNativeTagCheck(app2);
    injectCompilerOptionsCheck(app2);
  }
  const { mount: mount2 } = app2;
  app2.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container) return;
    const component = app2._component;
    if (!isFunction$4(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    container.innerHTML = "";
    const proxy = mount2(container, false, resolveRootNamespace(container));
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app2;
}, "createApp");
const createSSRApp = /* @__PURE__ */ __name((...args) => {
  const app2 = ensureHydrationRenderer().createApp(...args);
  if (false) {
    injectNativeTagCheck(app2);
    injectCompilerOptionsCheck(app2);
  }
  const { mount: mount2 } = app2;
  app2.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (container) {
      return mount2(container, true, resolveRootNamespace(container));
    }
  };
  return app2;
}, "createSSRApp");
function resolveRootNamespace(container) {
  if (container instanceof SVGElement) {
    return "svg";
  }
  if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
    return "mathml";
  }
}
__name(resolveRootNamespace, "resolveRootNamespace");
function injectNativeTagCheck(app2) {
  Object.defineProperty(app2.config, "isNativeTag", {
    value: /* @__PURE__ */ __name((tag) => isHTMLTag(tag) || isSVGTag(tag) || isMathMLTag(tag), "value"),
    writable: false
  });
}
__name(injectNativeTagCheck, "injectNativeTagCheck");
function injectCompilerOptionsCheck(app2) {
  if (isRuntimeOnly()) {
    const isCustomElement = app2.config.isCustomElement;
    Object.defineProperty(app2.config, "isCustomElement", {
      get() {
        return isCustomElement;
      },
      set() {
        warn$2(
          `The \`isCustomElement\` config option is deprecated. Use \`compilerOptions.isCustomElement\` instead.`
        );
      }
    });
    const compilerOptions = app2.config.compilerOptions;
    const msg = `The \`compilerOptions\` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, \`compilerOptions\` must be passed to \`@vue/compiler-dom\` in the build setup instead.
- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.
- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader
- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc`;
    Object.defineProperty(app2.config, "compilerOptions", {
      get() {
        warn$2(msg);
        return compilerOptions;
      },
      set() {
        warn$2(msg);
      }
    });
  }
}
__name(injectCompilerOptionsCheck, "injectCompilerOptionsCheck");
function normalizeContainer(container) {
  if (isString$5(container)) {
    const res = document.querySelector(container);
    if (false) {
      warn$2(
        `Failed to mount app: mount target selector "${container}" returned null.`
      );
    }
    return res;
  }
  if (false) {
    warn$2(
      `mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`
    );
  }
  return container;
}
__name(normalizeContainer, "normalizeContainer");
let ssrDirectiveInitialized = false;
const initDirectivesForSSR = /* @__PURE__ */ __name(() => {
  if (!ssrDirectiveInitialized) {
    ssrDirectiveInitialized = true;
    initVModelForSSR();
    initVShowForSSR();
  }
}, "initDirectivesForSSR");
/**
* vue v3.4.31
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function initDev() {
  {
    initCustomFormatter();
  }
}
__name(initDev, "initDev");
if (false) {
  initDev();
}
const compile$1 = /* @__PURE__ */ __name(() => {
  if (false) {
    warn$2(
      `Runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`
    );
  }
}, "compile$1");
const vue_runtime_esmBundler = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BaseTransition,
  BaseTransitionPropsValidators,
  Comment,
  DeprecationTypes,
  EffectScope,
  ErrorCodes,
  ErrorTypeStrings,
  Fragment,
  KeepAlive,
  ReactiveEffect,
  Static,
  Suspense,
  Teleport,
  Text,
  TrackOpTypes,
  Transition,
  TransitionGroup,
  TriggerOpTypes,
  VueElement,
  assertNumber,
  callWithAsyncErrorHandling,
  callWithErrorHandling,
  camelize: camelize$1,
  capitalize: capitalize$1,
  cloneVNode,
  compatUtils,
  compile: compile$1,
  computed,
  createApp,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createElementVNode: createBaseVNode,
  createHydrationRenderer,
  createPropsRestProxy,
  createRenderer,
  createSSRApp,
  createSlots,
  createStaticVNode,
  createTextVNode,
  createVNode,
  customRef,
  defineAsyncComponent,
  defineComponent,
  defineCustomElement,
  defineEmits,
  defineExpose,
  defineModel,
  defineOptions,
  defineProps,
  defineSSRCustomElement,
  defineSlots,
  devtools: devtools$2,
  effect,
  effectScope,
  getCurrentInstance,
  getCurrentScope,
  getTransitionRawChildren,
  guardReactiveProps,
  h,
  handleError,
  hasInjectionContext,
  hydrate,
  initCustomFormatter,
  initDirectivesForSSR,
  inject,
  isMemoSame,
  isProxy,
  isReactive,
  isReadonly,
  isRef,
  isRuntimeOnly,
  isShallow,
  isVNode: isVNode$1,
  markRaw,
  mergeDefaults,
  mergeModels,
  mergeProps,
  nextTick,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  onActivated,
  onBeforeMount,
  onBeforeUnmount,
  onBeforeUpdate,
  onDeactivated,
  onErrorCaptured,
  onMounted,
  onRenderTracked,
  onRenderTriggered,
  onScopeDispose,
  onServerPrefetch,
  onUnmounted,
  onUpdated,
  openBlock,
  popScopeId,
  provide,
  proxyRefs,
  pushScopeId,
  queuePostFlushCb,
  reactive,
  readonly,
  ref,
  registerRuntimeCompiler,
  render: render$V,
  renderList,
  renderSlot,
  resolveComponent,
  resolveDirective,
  resolveDynamicComponent,
  resolveFilter,
  resolveTransitionHooks,
  setBlockTracking,
  setDevtoolsHook,
  setTransitionHooks,
  shallowReactive,
  shallowReadonly,
  shallowRef,
  ssrContextKey,
  ssrUtils,
  stop,
  toDisplayString: toDisplayString$1,
  toHandlerKey,
  toHandlers,
  toRaw,
  toRef: toRef$1,
  toRefs: toRefs$1,
  toValue: toValue$2,
  transformVNodeArgs,
  triggerRef,
  unref,
  useAttrs,
  useCssModule,
  useCssVars,
  useModel,
  useSSRContext,
  useSlots,
  useTransitionState,
  vModelCheckbox,
  vModelDynamic,
  vModelRadio,
  vModelSelect,
  vModelText,
  vShow,
  version,
  warn: warn$2,
  watch,
  watchEffect,
  watchPostEffect,
  watchSyncEffect,
  withAsyncContext,
  withCtx,
  withDefaults,
  withDirectives,
  withKeys,
  withMemo,
  withModifiers,
  withScopeId
}, Symbol.toStringTag, { value: "Module" }));
var __defProp$3 = Object.defineProperty;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2 = /* @__PURE__ */ __name((obj, key, value3) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value: value3 }) : obj[key] = value3, "__defNormalProp$2");
var __spreadValues$1 = /* @__PURE__ */ __name((a, b) => {
  for (var prop2 in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop2))
      __defNormalProp$2(a, prop2, b[prop2]);
  if (__getOwnPropSymbols$1)
    for (var prop2 of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop2))
        __defNormalProp$2(a, prop2, b[prop2]);
    }
  return a;
}, "__spreadValues$1");
function isEmpty(value3) {
  return value3 === null || value3 === void 0 || value3 === "" || Array.isArray(value3) && value3.length === 0 || !(value3 instanceof Date) && typeof value3 === "object" && Object.keys(value3).length === 0;
}
__name(isEmpty, "isEmpty");
function compare(value1, value22, comparator2, order = 1) {
  let result = -1;
  const emptyValue1 = isEmpty(value1);
  const emptyValue2 = isEmpty(value22);
  if (emptyValue1 && emptyValue2) result = 0;
  else if (emptyValue1) result = order;
  else if (emptyValue2) result = -order;
  else if (typeof value1 === "string" && typeof value22 === "string") result = comparator2(value1, value22);
  else result = value1 < value22 ? -1 : value1 > value22 ? 1 : 0;
  return result;
}
__name(compare, "compare");
function deepEquals(obj1, obj2) {
  if (obj1 === obj2) return true;
  if (obj1 && obj2 && typeof obj1 == "object" && typeof obj2 == "object") {
    var arrObj1 = Array.isArray(obj1), arrObj2 = Array.isArray(obj2), i2, length, key;
    if (arrObj1 && arrObj2) {
      length = obj1.length;
      if (length != obj2.length) return false;
      for (i2 = length; i2-- !== 0; ) if (!deepEquals(obj1[i2], obj2[i2])) return false;
      return true;
    }
    if (arrObj1 != arrObj2) return false;
    var dateObj1 = obj1 instanceof Date, dateObj2 = obj2 instanceof Date;
    if (dateObj1 != dateObj2) return false;
    if (dateObj1 && dateObj2) return obj1.getTime() == obj2.getTime();
    var regexpObj1 = obj1 instanceof RegExp, regexpObj2 = obj2 instanceof RegExp;
    if (regexpObj1 != regexpObj2) return false;
    if (regexpObj1 && regexpObj2) return obj1.toString() == obj2.toString();
    var keys2 = Object.keys(obj1);
    length = keys2.length;
    if (length !== Object.keys(obj2).length) return false;
    for (i2 = length; i2-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(obj2, keys2[i2])) return false;
    for (i2 = length; i2-- !== 0; ) {
      key = keys2[i2];
      if (!deepEquals(obj1[key], obj2[key])) return false;
    }
    return true;
  }
  return obj1 !== obj1 && obj2 !== obj2;
}
__name(deepEquals, "deepEquals");
function isFunction$3(value3) {
  return !!(value3 && value3.constructor && value3.call && value3.apply);
}
__name(isFunction$3, "isFunction$3");
function isNotEmpty(value3) {
  return !isEmpty(value3);
}
__name(isNotEmpty, "isNotEmpty");
function resolveFieldData(data24, field) {
  if (!data24 || !field) {
    return null;
  }
  try {
    const value3 = data24[field];
    if (isNotEmpty(value3)) return value3;
  } catch (e) {
  }
  if (Object.keys(data24).length) {
    if (isFunction$3(field)) {
      return field(data24);
    } else if (field.indexOf(".") === -1) {
      return data24[field];
    } else {
      let fields = field.split(".");
      let value3 = data24;
      for (let i2 = 0, len = fields.length; i2 < len; ++i2) {
        if (value3 == null) {
          return null;
        }
        value3 = value3[fields[i2]];
      }
      return value3;
    }
  }
  return null;
}
__name(resolveFieldData, "resolveFieldData");
function equals(obj1, obj2, field) {
  if (field) return resolveFieldData(obj1, field) === resolveFieldData(obj2, field);
  else return deepEquals(obj1, obj2);
}
__name(equals, "equals");
function contains(value3, list) {
  if (value3 != null && list && list.length) {
    for (let val of list) {
      if (equals(value3, val)) return true;
    }
  }
  return false;
}
__name(contains, "contains");
function filter(value3, fields, filterValue) {
  let filteredItems = [];
  if (value3) {
    for (let item2 of value3) {
      for (let field of fields) {
        if (String(resolveFieldData(item2, field)).toLowerCase().indexOf(filterValue.toLowerCase()) > -1) {
          filteredItems.push(item2);
          break;
        }
      }
    }
  }
  return filteredItems;
}
__name(filter, "filter");
function findIndexInList(value3, list) {
  let index2 = -1;
  if (list) {
    for (let i2 = 0; i2 < list.length; i2++) {
      if (list[i2] === value3) {
        index2 = i2;
        break;
      }
    }
  }
  return index2;
}
__name(findIndexInList, "findIndexInList");
function findLast$1(arr, callback) {
  let item2;
  if (isNotEmpty(arr)) {
    try {
      item2 = arr.findLast(callback);
    } catch (e) {
      item2 = [...arr].reverse().find(callback);
    }
  }
  return item2;
}
__name(findLast$1, "findLast$1");
function findLastIndex(arr, callback) {
  let index2 = -1;
  if (isNotEmpty(arr)) {
    try {
      index2 = arr.findLastIndex(callback);
    } catch (e) {
      index2 = arr.lastIndexOf([...arr].reverse().find(callback));
    }
  }
  return index2;
}
__name(findLastIndex, "findLastIndex");
function isObject$5(value3, empty = true) {
  return value3 instanceof Object && value3.constructor === Object && (empty || Object.keys(value3).length !== 0);
}
__name(isObject$5, "isObject$5");
function resolve(obj, ...params) {
  return isFunction$3(obj) ? obj(...params) : obj;
}
__name(resolve, "resolve");
function isString$4(value3, empty = true) {
  return typeof value3 === "string" && (empty || value3 !== "");
}
__name(isString$4, "isString$4");
function toFlatCase(str) {
  return isString$4(str) ? str.replace(/(-|_)/g, "").toLowerCase() : str;
}
__name(toFlatCase, "toFlatCase");
function getKeyValue(obj, key = "", params = {}) {
  const fKeys = toFlatCase(key).split(".");
  const fKey = fKeys.shift();
  return fKey ? isObject$5(obj) ? getKeyValue(resolve(obj[Object.keys(obj).find((k) => toFlatCase(k) === fKey) || ""], params), fKeys.join("."), params) : void 0 : resolve(obj, params);
}
__name(getKeyValue, "getKeyValue");
function insertIntoOrderedArray(item2, index2, arr, sourceArr) {
  if (arr.length > 0) {
    let injected = false;
    for (let i2 = 0; i2 < arr.length; i2++) {
      let currentItemIndex = findIndexInList(arr[i2], sourceArr);
      if (currentItemIndex > index2) {
        arr.splice(i2, 0, item2);
        injected = true;
        break;
      }
    }
    if (!injected) {
      arr.push(item2);
    }
  } else {
    arr.push(item2);
  }
}
__name(insertIntoOrderedArray, "insertIntoOrderedArray");
function isArray$3(value3, empty = true) {
  return Array.isArray(value3) && (empty || value3.length !== 0);
}
__name(isArray$3, "isArray$3");
function isDate$2(value3) {
  return value3 instanceof Date && value3.constructor === Date;
}
__name(isDate$2, "isDate$2");
function isNumber$3(value3) {
  return isNotEmpty(value3) && !isNaN(value3);
}
__name(isNumber$3, "isNumber$3");
function isPrintableCharacter(char = "") {
  return isNotEmpty(char) && char.length === 1 && !!char.match(/\S| /);
}
__name(isPrintableCharacter, "isPrintableCharacter");
function localeComparator() {
  return new Intl.Collator(void 0, { numeric: true }).compare;
}
__name(localeComparator, "localeComparator");
function matchRegex(str, regex) {
  if (regex) {
    const match = regex.test(str);
    regex.lastIndex = 0;
    return match;
  }
  return false;
}
__name(matchRegex, "matchRegex");
function mergeKeys(...args) {
  const _mergeKeys = /* @__PURE__ */ __name((target = {}, source = {}) => {
    const mergedObj = __spreadValues$1({}, target);
    Object.keys(source).forEach((key) => {
      if (isObject$5(source[key]) && key in target && isObject$5(target[key])) {
        mergedObj[key] = _mergeKeys(target[key], source[key]);
      } else {
        mergedObj[key] = source[key];
      }
    });
    return mergedObj;
  }, "_mergeKeys");
  return args.reduce((acc, obj, i2) => i2 === 0 ? obj : _mergeKeys(acc, obj), {});
}
__name(mergeKeys, "mergeKeys");
function minifyCSS(css4) {
  return css4 ? css4.replace(/\/\*(?:(?!\*\/)[\s\S])*\*\/|[\r\n\t]+/g, "").replace(/ {2,}/g, " ").replace(/ ([{:}]) /g, "$1").replace(/([;,]) /g, "$1").replace(/ !/g, "!").replace(/: /g, ":") : css4;
}
__name(minifyCSS, "minifyCSS");
function nestedKeys(obj = {}, parentKey = "") {
  return Object.entries(obj).reduce((o, [key, value3]) => {
    const currentKey = parentKey ? `${parentKey}.${key}` : key;
    isObject$5(value3) ? o = o.concat(nestedKeys(value3, currentKey)) : o.push(currentKey);
    return o;
  }, []);
}
__name(nestedKeys, "nestedKeys");
function removeAccents(str) {
  if (str && str.search(/[\xC0-\xFF]/g) > -1) {
    str = str.replace(/[\xC0-\xC5]/g, "A").replace(/[\xC6]/g, "AE").replace(/[\xC7]/g, "C").replace(/[\xC8-\xCB]/g, "E").replace(/[\xCC-\xCF]/g, "I").replace(/[\xD0]/g, "D").replace(/[\xD1]/g, "N").replace(/[\xD2-\xD6\xD8]/g, "O").replace(/[\xD9-\xDC]/g, "U").replace(/[\xDD]/g, "Y").replace(/[\xDE]/g, "P").replace(/[\xE0-\xE5]/g, "a").replace(/[\xE6]/g, "ae").replace(/[\xE7]/g, "c").replace(/[\xE8-\xEB]/g, "e").replace(/[\xEC-\xEF]/g, "i").replace(/[\xF1]/g, "n").replace(/[\xF2-\xF6\xF8]/g, "o").replace(/[\xF9-\xFC]/g, "u").replace(/[\xFE]/g, "p").replace(/[\xFD\xFF]/g, "y");
  }
  return str;
}
__name(removeAccents, "removeAccents");
function reorderArray(value3, from, to) {
  if (value3 && from !== to) {
    if (to >= value3.length) {
      to %= value3.length;
      from %= value3.length;
    }
    value3.splice(to, 0, value3.splice(from, 1)[0]);
  }
}
__name(reorderArray, "reorderArray");
function sort(value1, value22, order = 1, comparator2, nullSortOrder = 1) {
  const result = compare(value1, value22, comparator2, order);
  let finalSortOrder = order;
  if (isEmpty(value1) || isEmpty(value22)) {
    finalSortOrder = nullSortOrder === 1 ? order : nullSortOrder;
  }
  return finalSortOrder * result;
}
__name(sort, "sort");
function stringify$1(value3, indent = 2, currentIndent = 0) {
  const currentIndentStr = " ".repeat(currentIndent);
  const nextIndentStr = " ".repeat(currentIndent + indent);
  if (isArray$3(value3)) {
    return "[" + value3.map((v2) => stringify$1(v2, indent, currentIndent + indent)).join(", ") + "]";
  } else if (isDate$2(value3)) {
    return value3.toISOString();
  } else if (isFunction$3(value3)) {
    return value3.toString();
  } else if (isObject$5(value3)) {
    return "{\n" + Object.entries(value3).map(([k, v2]) => `${nextIndentStr}${k}: ${stringify$1(v2, indent, currentIndent + indent)}`).join(",\n") + `
${currentIndentStr}}`;
  } else {
    return JSON.stringify(value3);
  }
}
__name(stringify$1, "stringify$1");
function toCapitalCase(str) {
  return isString$4(str, false) ? str[0].toUpperCase() + str.slice(1) : str;
}
__name(toCapitalCase, "toCapitalCase");
function toKebabCase(str) {
  return isString$4(str) ? str.replace(/(_)/g, "-").replace(/[A-Z]/g, (c, i2) => i2 === 0 ? c : "-" + c.toLowerCase()).toLowerCase() : str;
}
__name(toKebabCase, "toKebabCase");
function toTokenKey$1(str) {
  return isString$4(str) ? str.replace(/[A-Z]/g, (c, i2) => i2 === 0 ? c : "." + c.toLowerCase()).toLowerCase() : str;
}
__name(toTokenKey$1, "toTokenKey$1");
function EventBus() {
  const allHandlers = /* @__PURE__ */ new Map();
  return {
    on(type, handler6) {
      let handlers2 = allHandlers.get(type);
      if (!handlers2) handlers2 = [handler6];
      else handlers2.push(handler6);
      allHandlers.set(type, handlers2);
      return this;
    },
    off(type, handler6) {
      let handlers2 = allHandlers.get(type);
      if (handlers2) {
        handlers2.splice(handlers2.indexOf(handler6) >>> 0, 1);
      }
      return this;
    },
    emit(type, evt) {
      let handlers2 = allHandlers.get(type);
      if (handlers2) {
        handlers2.slice().map((handler6) => {
          handler6(evt);
        });
      }
    },
    clear() {
      allHandlers.clear();
    }
  };
}
__name(EventBus, "EventBus");
var __defProp$2 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = /* @__PURE__ */ __name((obj, key, value3) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value: value3 }) : obj[key] = value3, "__defNormalProp$1");
var __spreadValues = /* @__PURE__ */ __name((a, b) => {
  for (var prop2 in b || (b = {}))
    if (__hasOwnProp.call(b, prop2))
      __defNormalProp$1(a, prop2, b[prop2]);
  if (__getOwnPropSymbols)
    for (var prop2 of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop2))
        __defNormalProp$1(a, prop2, b[prop2]);
    }
  return a;
}, "__spreadValues");
var __spreadProps = /* @__PURE__ */ __name((a, b) => __defProps(a, __getOwnPropDescs(b)), "__spreadProps");
var __objRest = /* @__PURE__ */ __name((source, exclude) => {
  var target = {};
  for (var prop2 in source)
    if (__hasOwnProp.call(source, prop2) && exclude.indexOf(prop2) < 0)
      target[prop2] = source[prop2];
  if (source != null && __getOwnPropSymbols)
    for (var prop2 of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop2) < 0 && __propIsEnum.call(source, prop2))
        target[prop2] = source[prop2];
    }
  return target;
}, "__objRest");
function definePreset$1(...presets) {
  return mergeKeys(...presets);
}
__name(definePreset$1, "definePreset$1");
var ThemeService$1 = EventBus();
var service_default = ThemeService$1;
function toTokenKey(str) {
  return isString$4(str) ? str.replace(/[A-Z]/g, (c, i2) => i2 === 0 ? c : "." + c.toLowerCase()).toLowerCase() : str;
}
__name(toTokenKey, "toTokenKey");
function merge$1(value1, value22) {
  if (isArray$3(value1)) {
    value1.push(...value22 || []);
  } else if (isObject$5(value1)) {
    Object.assign(value1, value22);
  }
}
__name(merge$1, "merge$1");
function toValue$1(value3) {
  return isObject$5(value3) && value3.hasOwnProperty("value") && value3.hasOwnProperty("type") ? value3.value : value3;
}
__name(toValue$1, "toValue$1");
function toUnit(value3, variable = "") {
  const excludedProperties = ["opacity", "z-index", "line-height", "font-weight", "flex", "flex-grow", "flex-shrink", "order"];
  if (!excludedProperties.some((property) => variable.endsWith(property))) {
    const val = `${value3}`.trim();
    const valArr = val.split(" ");
    return valArr.map((v2) => isNumber$3(v2) ? `${v2}px` : v2).join(" ");
  }
  return value3;
}
__name(toUnit, "toUnit");
function toNormalizePrefix(prefix2) {
  return prefix2.replaceAll(/ /g, "").replace(/[^\w]/g, "-");
}
__name(toNormalizePrefix, "toNormalizePrefix");
function toNormalizeVariable(prefix2 = "", variable = "") {
  return toNormalizePrefix(`${isString$4(prefix2, false) && isString$4(variable, false) ? `${prefix2}-` : prefix2}${variable}`);
}
__name(toNormalizeVariable, "toNormalizeVariable");
function getVariableName(prefix2 = "", variable = "") {
  return `--${toNormalizeVariable(prefix2, variable)}`;
}
__name(getVariableName, "getVariableName");
function getVariableValue(value3, variable = "", prefix2 = "", excludedKeyRegexes = [], fallback) {
  if (isString$4(value3)) {
    const regex = /{([^}]*)}/g;
    const val = value3.trim();
    if (matchRegex(val, regex)) {
      const _val = val.replaceAll(regex, (v2) => {
        const path = v2.replace(/{|}/g, "");
        const keys2 = path.split(".").filter((_v) => !excludedKeyRegexes.some((_r) => matchRegex(_v, _r)));
        return `var(${getVariableName(prefix2, toKebabCase(keys2.join("-")))}${isNotEmpty(fallback) ? `, ${fallback}` : ""})`;
      });
      const calculationRegex = /(\d+\s+[\+\-\*\/]\s+\d+)/g;
      const cleanedVarRegex = /var\([^)]+\)/g;
      return matchRegex(_val.replace(cleanedVarRegex, "0"), calculationRegex) ? `calc(${_val})` : _val;
    }
    return toUnit(val, variable);
  } else if (isNumber$3(value3)) {
    return toUnit(value3, variable);
  }
  return void 0;
}
__name(getVariableValue, "getVariableValue");
function getComputedValue(obj = {}, value3) {
  if (isString$4(value3)) {
    const regex = /{([^}]*)}/g;
    const val = value3.trim();
    return matchRegex(val, regex) ? val.replaceAll(regex, (v2) => getKeyValue(obj, v2.replace(/{|}/g, ""))) : val;
  } else if (isNumber$3(value3)) {
    return value3;
  }
  return void 0;
}
__name(getComputedValue, "getComputedValue");
function setProperty(properties, key, value3) {
  if (isString$4(key, false)) {
    properties.push(`${key}:${value3};`);
  }
}
__name(setProperty, "setProperty");
function getRule(selector, properties) {
  if (selector) {
    return `${selector}{${properties}}`;
  }
  return "";
}
__name(getRule, "getRule");
function normalizeColor$1(color) {
  if (color.length === 4) {
    return `#${color[1]}${color[1]}${color[2]}${color[2]}${color[3]}${color[3]}`;
  }
  return color;
}
__name(normalizeColor$1, "normalizeColor$1");
function hexToRgb$2(hex) {
  var bigint = parseInt(hex.substring(1), 16);
  var r = bigint >> 16 & 255;
  var g = bigint >> 8 & 255;
  var b = bigint & 255;
  return { r, g, b };
}
__name(hexToRgb$2, "hexToRgb$2");
function rgbToHex$2(r, g, b) {
  return `#${r.toString(16).padStart(2, "0")}${g.toString(16).padStart(2, "0")}${b.toString(16).padStart(2, "0")}`;
}
__name(rgbToHex$2, "rgbToHex$2");
var mix_default = /* @__PURE__ */ __name((color1, color2, weight) => {
  color1 = normalizeColor$1(color1);
  color2 = normalizeColor$1(color2);
  var p2 = weight / 100;
  var w2 = p2 * 2 - 1;
  var w1 = (w2 + 1) / 2;
  var w22 = 1 - w1;
  var rgb1 = hexToRgb$2(color1);
  var rgb2 = hexToRgb$2(color2);
  var r = Math.round(rgb1.r * w1 + rgb2.r * w22);
  var g = Math.round(rgb1.g * w1 + rgb2.g * w22);
  var b = Math.round(rgb1.b * w1 + rgb2.b * w22);
  return rgbToHex$2(r, g, b);
}, "mix_default");
var shade_default = /* @__PURE__ */ __name((color, percent) => mix_default("#000000", color, percent), "shade_default");
var tint_default = /* @__PURE__ */ __name((color, percent) => mix_default("#ffffff", color, percent), "tint_default");
var scales$1 = [50, 100, 200, 300, 400, 500, 600, 700, 800, 900, 950];
var palette_default = /* @__PURE__ */ __name((color) => {
  if (/{([^}]*)}/g.test(color)) {
    const token = color.replace(/{|}/g, "");
    return scales$1.reduce((acc, scale) => (acc[scale] = `{${token}.${scale}}`, acc), {});
  }
  return typeof color === "string" ? scales$1.reduce((acc, scale, i2) => (acc[scale] = i2 <= 5 ? tint_default(color, (5 - i2) * 19) : shade_default(color, (i2 - 5) * 15), acc), {}) : color;
}, "palette_default");
var $dt$1 = /* @__PURE__ */ __name((tokenPath) => {
  var _a;
  const theme38 = config_default.getTheme();
  const variable = dtwt$1(theme38, tokenPath, void 0, "variable");
  const name = (_a = variable.match(/--[\w-]+/g)) == null ? void 0 : _a[0];
  const value3 = dtwt$1(theme38, tokenPath, void 0, "value");
  return {
    name,
    variable,
    value: value3
  };
}, "$dt$1");
var dt$1 = /* @__PURE__ */ __name((...args) => {
  return dtwt$1(config_default.getTheme(), ...args);
}, "dt$1");
var dtwt$1 = /* @__PURE__ */ __name((theme38 = {}, tokenPath, fallback, type = "variable") => {
  if (tokenPath) {
    const { variable: VARIABLE, options: OPTIONS } = config_default.defaults || {};
    const { prefix: prefix2, transform: transform2 } = (theme38 == null ? void 0 : theme38.options) || OPTIONS || {};
    const regex = /{([^}]*)}/g;
    const token = matchRegex(tokenPath, regex) ? tokenPath : `{${tokenPath}}`;
    const isStrictTransform = type === "value" || transform2 === "strict";
    return isStrictTransform ? config_default.getTokenValue(tokenPath) : getVariableValue(token, void 0, prefix2, [VARIABLE.excludedKeyRegex], fallback);
  }
  return "";
}, "dtwt$1");
function css$3(style) {
  return resolve(style, { dt: dt$1 });
}
__name(css$3, "css$3");
var $t$1 = /* @__PURE__ */ __name((theme38 = {}) => {
  let { preset: _preset, options: _options } = theme38;
  return {
    preset(value3) {
      _preset = _preset ? mergeKeys(_preset, value3) : value3;
      return this;
    },
    options(value3) {
      _options = _options ? __spreadValues(__spreadValues({}, _options), value3) : value3;
      return this;
    },
    // features
    primaryPalette(primary) {
      const { semantic } = _preset || {};
      _preset = __spreadProps(__spreadValues({}, _preset), { semantic: __spreadProps(__spreadValues({}, semantic), { primary }) });
      return this;
    },
    surfacePalette(surface) {
      var _a, _b;
      const { semantic } = _preset || {};
      const lightSurface = (surface == null ? void 0 : surface.hasOwnProperty("light")) ? surface == null ? void 0 : surface.light : surface;
      const darkSurface = (surface == null ? void 0 : surface.hasOwnProperty("dark")) ? surface == null ? void 0 : surface.dark : surface;
      const newColorScheme = {
        colorScheme: {
          light: __spreadValues(__spreadValues({}, (_a = semantic == null ? void 0 : semantic.colorScheme) == null ? void 0 : _a.light), !!lightSurface && { surface: lightSurface }),
          dark: __spreadValues(__spreadValues({}, (_b = semantic == null ? void 0 : semantic.colorScheme) == null ? void 0 : _b.dark), !!darkSurface && { surface: darkSurface })
        }
      };
      _preset = __spreadProps(__spreadValues({}, _preset), { semantic: __spreadValues(__spreadValues({}, semantic), newColorScheme) });
      return this;
    },
    // actions
    define({ useDefaultPreset = false, useDefaultOptions = false } = {}) {
      return {
        preset: useDefaultPreset ? config_default.getPreset() : _preset,
        options: useDefaultOptions ? config_default.getOptions() : _options
      };
    },
    update({ mergePresets = true, mergeOptions: mergeOptions2 = true } = {}) {
      const newTheme = {
        preset: mergePresets ? mergeKeys(config_default.getPreset(), _preset) : _preset,
        options: mergeOptions2 ? __spreadValues(__spreadValues({}, config_default.getOptions()), _options) : _options
      };
      config_default.setTheme(newTheme);
      return newTheme;
    },
    use(options3) {
      const newTheme = this.define(options3);
      config_default.setTheme(newTheme);
      return newTheme;
    }
  };
}, "$t$1");
function toVariables_default(theme38, options3 = {}) {
  const VARIABLE = config_default.defaults.variable;
  const { prefix: prefix2 = VARIABLE.prefix, selector = VARIABLE.selector, excludedKeyRegex = VARIABLE.excludedKeyRegex } = options3;
  const _toVariables2 = /* @__PURE__ */ __name((_theme, _prefix = "") => {
    return Object.entries(_theme).reduce(
      (acc, [key, value3]) => {
        const px = matchRegex(key, excludedKeyRegex) ? toNormalizeVariable(_prefix) : toNormalizeVariable(_prefix, toKebabCase(key));
        const v2 = toValue$1(value3);
        if (isObject$5(v2)) {
          const { variables: variables2, tokens: tokens2 } = _toVariables2(v2, px);
          merge$1(acc["tokens"], tokens2);
          merge$1(acc["variables"], variables2);
        } else {
          acc["tokens"].push((prefix2 ? px.replace(`${prefix2}-`, "") : px).replaceAll("-", "."));
          setProperty(acc["variables"], getVariableName(px), getVariableValue(v2, px, prefix2, [excludedKeyRegex]));
        }
        return acc;
      },
      { variables: [], tokens: [] }
    );
  }, "_toVariables");
  const { variables, tokens } = _toVariables2(theme38, prefix2);
  return {
    value: variables,
    tokens,
    declarations: variables.join(""),
    css: getRule(selector, variables.join(""))
  };
}
__name(toVariables_default, "toVariables_default");
var themeUtils_default = {
  regex: {
    rules: {
      class: {
        pattern: /^\.([a-zA-Z][\w-]*)$/,
        resolve(value3) {
          return { type: "class", selector: value3, matched: this.pattern.test(value3.trim()) };
        }
      },
      attr: {
        pattern: /^\[(.*)\]$/,
        resolve(value3) {
          return { type: "attr", selector: `:root${value3}`, matched: this.pattern.test(value3.trim()) };
        }
      },
      media: {
        pattern: /^@media (.*)$/,
        resolve(value3) {
          return { type: "media", selector: `${value3}{:root{[CSS]}}`, matched: this.pattern.test(value3.trim()) };
        }
      },
      system: {
        pattern: /^system$/,
        resolve(value3) {
          return { type: "system", selector: "@media (prefers-color-scheme: dark){:root{[CSS]}}", matched: this.pattern.test(value3.trim()) };
        }
      },
      custom: {
        resolve(value3) {
          return { type: "custom", selector: value3, matched: true };
        }
      }
    },
    resolve(value3) {
      const rules = Object.keys(this.rules).filter((k) => k !== "custom").map((r) => this.rules[r]);
      return [value3].flat().map((v2) => {
        var _a;
        return (_a = rules.map((r) => r.resolve(v2)).find((rr) => rr.matched)) != null ? _a : this.rules.custom.resolve(v2);
      });
    }
  },
  _toVariables(theme38, options3) {
    return toVariables_default(theme38, { prefix: options3 == null ? void 0 : options3.prefix });
  },
  getCommon({ name = "", theme: theme38 = {}, params, set: set2, defaults: defaults2 }) {
    var _c, _d, _e, _f;
    const { preset, options: options3 } = theme38;
    let primitive_css, primitive_tokens, semantic_css, semantic_tokens;
    if (isNotEmpty(preset)) {
      const { primitive, semantic } = preset;
      const _a = semantic || {}, { colorScheme } = _a, sRest = __objRest(_a, ["colorScheme"]);
      const _b = colorScheme || {}, { dark } = _b, csRest = __objRest(_b, ["dark"]);
      const prim_var = isNotEmpty(primitive) ? this._toVariables({ primitive }, options3) : {};
      const sRest_var = isNotEmpty(sRest) ? this._toVariables({ semantic: sRest }, options3) : {};
      const csRest_var = isNotEmpty(csRest) ? this._toVariables({ light: csRest }, options3) : {};
      const dark_var = isNotEmpty(dark) ? this._toVariables({ dark }, options3) : {};
      const [prim_css, prim_tokens] = [(_c = prim_var.declarations) != null ? _c : "", prim_var.tokens];
      const [sRest_css, sRest_tokens] = [(_d = sRest_var.declarations) != null ? _d : "", sRest_var.tokens || []];
      const [csRest_css, csRest_tokens] = [(_e = csRest_var.declarations) != null ? _e : "", csRest_var.tokens || []];
      const [dark_css, dark_tokens] = [(_f = dark_var.declarations) != null ? _f : "", dark_var.tokens || []];
      primitive_css = this.transformCSS(name, prim_css, "light", "variable", options3, set2, defaults2);
      primitive_tokens = prim_tokens;
      const semantic_light_css = this.transformCSS(name, `${sRest_css}${csRest_css}color-scheme:light`, "light", "variable", options3, set2, defaults2);
      const semantic_dark_css = this.transformCSS(name, `${dark_css}color-scheme:dark`, "dark", "variable", options3, set2, defaults2);
      semantic_css = `${semantic_light_css}${semantic_dark_css}`;
      semantic_tokens = [.../* @__PURE__ */ new Set([...sRest_tokens, ...csRest_tokens, ...dark_tokens])];
    }
    return {
      primitive: {
        css: primitive_css,
        tokens: primitive_tokens
      },
      semantic: {
        css: semantic_css,
        tokens: semantic_tokens
      }
    };
  },
  getPreset({ name = "", preset = {}, options: options3, params, set: set2, defaults: defaults2, selector }) {
    var _c, _d, _e;
    const _name = name.replace("-directive", "");
    const _a = preset, { colorScheme } = _a, vRest = __objRest(_a, ["colorScheme"]);
    const _b = colorScheme || {}, { dark } = _b, csRest = __objRest(_b, ["dark"]);
    const vRest_var = isNotEmpty(vRest) ? this._toVariables({ [_name]: vRest }, options3) : {};
    const csRest_var = isNotEmpty(csRest) ? this._toVariables({ [_name]: csRest }, options3) : {};
    const dark_var = isNotEmpty(dark) ? this._toVariables({ [_name]: dark }, options3) : {};
    const [vRest_css, vRest_tokens] = [(_c = vRest_var.declarations) != null ? _c : "", vRest_var.tokens || []];
    const [csRest_css, csRest_tokens] = [(_d = csRest_var.declarations) != null ? _d : "", csRest_var.tokens || []];
    const [dark_css, dark_tokens] = [(_e = dark_var.declarations) != null ? _e : "", dark_var.tokens || []];
    const tokens = [.../* @__PURE__ */ new Set([...vRest_tokens, ...csRest_tokens, ...dark_tokens])];
    const light_variable_css = this.transformCSS(_name, `${vRest_css}${csRest_css}`, "light", "variable", options3, set2, defaults2, selector);
    const dark_variable_css = this.transformCSS(_name, dark_css, "dark", "variable", options3, set2, defaults2, selector);
    return {
      css: `${light_variable_css}${dark_variable_css}`,
      tokens
    };
  },
  getPresetC({ name = "", theme: theme38 = {}, params, set: set2, defaults: defaults2 }) {
    var _a;
    const { preset, options: options3 } = theme38;
    const cPreset = (_a = preset == null ? void 0 : preset.components) == null ? void 0 : _a[name];
    return this.getPreset({ name, preset: cPreset, options: options3, params, set: set2, defaults: defaults2 });
  },
  getPresetD({ name = "", theme: theme38 = {}, params, set: set2, defaults: defaults2 }) {
    var _a;
    const dName = name.replace("-directive", "");
    const { preset, options: options3 } = theme38;
    const dPreset = (_a = preset == null ? void 0 : preset.directives) == null ? void 0 : _a[dName];
    return this.getPreset({ name: dName, preset: dPreset, options: options3, params, set: set2, defaults: defaults2 });
  },
  getColorSchemeOption(options3, defaults2) {
    var _a;
    return this.regex.resolve((_a = options3.darkModeSelector) != null ? _a : defaults2.options.darkModeSelector);
  },
  getLayerOrder(name, options3 = {}, params, defaults2) {
    const { cssLayer } = options3;
    if (cssLayer) {
      const order = resolve(cssLayer.order || "primeui", params);
      return `@layer ${order}`;
    }
    return "";
  },
  getCommonStyleSheet({ name = "", theme: theme38 = {}, params, props = {}, set: set2, defaults: defaults2 }) {
    const common = this.getCommon({ name, theme: theme38, params, set: set2, defaults: defaults2 });
    const _props = Object.entries(props).reduce((acc, [k, v2]) => acc.push(`${k}="${v2}"`) && acc, []).join(" ");
    return Object.entries(common || {}).reduce((acc, [key, value3]) => {
      if (value3 == null ? void 0 : value3.css) {
        const _css = minifyCSS(value3 == null ? void 0 : value3.css);
        const id2 = `${key}-variables`;
        acc.push(`<style type="text/css" data-primevue-style-id="${id2}" ${_props}>${_css}</style>`);
      }
      return acc;
    }, []).join("");
  },
  getStyleSheet({ name = "", theme: theme38 = {}, params, props = {}, set: set2, defaults: defaults2 }) {
    var _a;
    const options3 = { name, theme: theme38, params, set: set2, defaults: defaults2 };
    const preset_css = (_a = name.includes("-directive") ? this.getPresetD(options3) : this.getPresetC(options3)) == null ? void 0 : _a.css;
    const _props = Object.entries(props).reduce((acc, [k, v2]) => acc.push(`${k}="${v2}"`) && acc, []).join(" ");
    return preset_css ? `<style type="text/css" data-primevue-style-id="${name}-variables" ${_props}>${minifyCSS(preset_css)}</style>` : "";
  },
  createTokens(obj = {}, defaults2, parentKey = "", parentPath = "", tokens = {}) {
    Object.entries(obj).forEach(([key, value3]) => {
      const currentKey = matchRegex(key, defaults2.variable.excludedKeyRegex) ? parentKey : parentKey ? `${parentKey}.${toTokenKey$1(key)}` : toTokenKey$1(key);
      const currentPath = parentPath ? `${parentPath}.${key}` : key;
      if (isObject$5(value3)) {
        this.createTokens(value3, defaults2, currentKey, currentPath, tokens);
      } else {
        tokens[currentKey] || (tokens[currentKey] = {
          paths: [],
          computed(colorScheme, tokenPathMap = {}) {
            if (colorScheme) {
              const path = this.paths.find((p2) => p2.scheme === colorScheme) || this.paths.find((p2) => p2.scheme === "none");
              return path == null ? void 0 : path.computed(colorScheme, tokenPathMap["binding"]);
            }
            return this.paths.map((p2) => p2.computed(p2.scheme, tokenPathMap[p2.scheme]));
          }
        });
        tokens[currentKey].paths.push({
          path: currentPath,
          value: value3,
          scheme: currentPath.includes("colorScheme.light") ? "light" : currentPath.includes("colorScheme.dark") ? "dark" : "none",
          computed(colorScheme, tokenPathMap = {}) {
            const regex = /{([^}]*)}/g;
            let computedValue = value3;
            tokenPathMap["name"] = this.path;
            tokenPathMap["binding"] || (tokenPathMap["binding"] = {});
            if (matchRegex(value3, regex)) {
              const val = value3.trim();
              const _val = val.replaceAll(regex, (v2) => {
                var _a, _b;
                const path = v2.replace(/{|}/g, "");
                return (_b = (_a = tokens[path]) == null ? void 0 : _a.computed(colorScheme, tokenPathMap)) == null ? void 0 : _b.value;
              });
              const calculationRegex = /(\d+\w*\s+[\+\-\*\/]\s+\d+\w*)/g;
              const cleanedVarRegex = /var\([^)]+\)/g;
              computedValue = matchRegex(_val.replace(cleanedVarRegex, "0"), calculationRegex) ? `calc(${_val})` : _val;
            }
            isEmpty(tokenPathMap["binding"]) && delete tokenPathMap["binding"];
            return {
              colorScheme,
              path: this.path,
              paths: tokenPathMap,
              value: computedValue.includes("undefined") ? void 0 : computedValue
            };
          }
        });
      }
    });
    return tokens;
  },
  getTokenValue(tokens, path, defaults2) {
    var _a;
    const normalizePath = /* @__PURE__ */ __name((str) => {
      const strArr = str.split(".");
      return strArr.filter((s) => !matchRegex(s.toLowerCase(), defaults2.variable.excludedKeyRegex)).join(".");
    }, "normalizePath");
    const token = normalizePath(path);
    const colorScheme = path.includes("colorScheme.light") ? "light" : path.includes("colorScheme.dark") ? "dark" : void 0;
    const computedValues = [(_a = tokens[token]) == null ? void 0 : _a.computed(colorScheme)].flat().filter((computed2) => computed2);
    return computedValues.length === 1 ? computedValues[0].value : computedValues.reduce((acc = {}, computed2) => {
      const _a2 = computed2, { colorScheme: cs } = _a2, rest = __objRest(_a2, ["colorScheme"]);
      acc[cs] = rest;
      return acc;
    }, void 0);
  },
  transformCSS(name, css22, mode2, type, options3 = {}, set2, defaults2, selector) {
    if (isNotEmpty(css22)) {
      const { cssLayer } = options3;
      if (type !== "style") {
        const colorSchemeOption = this.getColorSchemeOption(options3, defaults2);
        const _css = selector ? getRule(selector, css22) : css22;
        css22 = mode2 === "dark" ? colorSchemeOption.reduce((acc, { selector: _selector }) => {
          if (isNotEmpty(_selector)) {
            acc += _selector.includes("[CSS]") ? _selector.replace("[CSS]", _css) : getRule(_selector, _css);
          }
          return acc;
        }, "") : getRule(selector != null ? selector : ":root", css22);
      }
      if (cssLayer) {
        const layerOptions = {
          name: "primeui",
          order: "primeui"
        };
        isObject$5(cssLayer) && (layerOptions.name = resolve(cssLayer.name, { name, type }));
        if (isNotEmpty(layerOptions.name)) {
          css22 = getRule(`@layer ${layerOptions.name}`, css22);
          set2 == null ? void 0 : set2.layerNames(layerOptions.name);
        }
      }
      return css22;
    }
    return "";
  }
};
var config_default = {
  defaults: {
    variable: {
      prefix: "p",
      selector: ":root",
      excludedKeyRegex: /^(primitive|semantic|components|directives|variables|colorscheme|light|dark|common|root|states)$/gi
    },
    options: {
      prefix: "p",
      darkModeSelector: "system",
      cssLayer: false
    }
  },
  _theme: void 0,
  _layerNames: /* @__PURE__ */ new Set(),
  _loadedStyleNames: /* @__PURE__ */ new Set(),
  _loadingStyles: /* @__PURE__ */ new Set(),
  _tokens: {},
  update(newValues = {}) {
    const { theme: theme38 } = newValues;
    if (theme38) {
      this._theme = __spreadProps(__spreadValues({}, theme38), {
        options: __spreadValues(__spreadValues({}, this.defaults.options), theme38.options)
      });
      this._tokens = themeUtils_default.createTokens(this.preset, this.defaults);
      this.clearLoadedStyleNames();
    }
  },
  get theme() {
    return this._theme;
  },
  get preset() {
    var _a;
    return ((_a = this.theme) == null ? void 0 : _a.preset) || {};
  },
  get options() {
    var _a;
    return ((_a = this.theme) == null ? void 0 : _a.options) || {};
  },
  get tokens() {
    return this._tokens;
  },
  getTheme() {
    return this.theme;
  },
  setTheme(newValue) {
    this.update({ theme: newValue });
    service_default.emit("theme:change", newValue);
  },
  getPreset() {
    return this.preset;
  },
  setPreset(newValue) {
    this._theme = __spreadProps(__spreadValues({}, this.theme), { preset: newValue });
    this._tokens = themeUtils_default.createTokens(newValue, this.defaults);
    this.clearLoadedStyleNames();
    service_default.emit("preset:change", newValue);
    service_default.emit("theme:change", this.theme);
  },
  getOptions() {
    return this.options;
  },
  setOptions(newValue) {
    this._theme = __spreadProps(__spreadValues({}, this.theme), { options: newValue });
    this.clearLoadedStyleNames();
    service_default.emit("options:change", newValue);
    service_default.emit("theme:change", this.theme);
  },
  getLayerNames() {
    return [...this._layerNames];
  },
  setLayerNames(layerName) {
    this._layerNames.add(layerName);
  },
  getLoadedStyleNames() {
    return this._loadedStyleNames;
  },
  isStyleNameLoaded(name) {
    return this._loadedStyleNames.has(name);
  },
  setLoadedStyleName(name) {
    this._loadedStyleNames.add(name);
  },
  deleteLoadedStyleName(name) {
    this._loadedStyleNames.delete(name);
  },
  clearLoadedStyleNames() {
    this._loadedStyleNames.clear();
  },
  getTokenValue(tokenPath) {
    return themeUtils_default.getTokenValue(this.tokens, tokenPath, this.defaults);
  },
  getCommon(name = "", params) {
    return themeUtils_default.getCommon({ name, theme: this.theme, params, defaults: this.defaults, set: { layerNames: this.setLayerNames.bind(this) } });
  },
  getComponent(name = "", params) {
    const options3 = { name, theme: this.theme, params, defaults: this.defaults, set: { layerNames: this.setLayerNames.bind(this) } };
    return themeUtils_default.getPresetC(options3);
  },
  getDirective(name = "", params) {
    const options3 = { name, theme: this.theme, params, defaults: this.defaults, set: { layerNames: this.setLayerNames.bind(this) } };
    return themeUtils_default.getPresetD(options3);
  },
  getCustomPreset(name = "", preset, selector, params) {
    const options3 = { name, preset, options: this.options, selector, params, defaults: this.defaults, set: { layerNames: this.setLayerNames.bind(this) } };
    return themeUtils_default.getPreset(options3);
  },
  getLayerOrderCSS(name = "") {
    return themeUtils_default.getLayerOrder(name, this.options, { names: this.getLayerNames() }, this.defaults);
  },
  transformCSS(name = "", css22, type = "style", mode2) {
    return themeUtils_default.transformCSS(name, css22, mode2, type, this.options, { layerNames: this.setLayerNames.bind(this) }, this.defaults);
  },
  getCommonStyleSheet(name = "", params, props = {}) {
    return themeUtils_default.getCommonStyleSheet({ name, theme: this.theme, params, props, defaults: this.defaults, set: { layerNames: this.setLayerNames.bind(this) } });
  },
  getStyleSheet(name, params, props = {}) {
    return themeUtils_default.getStyleSheet({ name, theme: this.theme, params, props, defaults: this.defaults, set: { layerNames: this.setLayerNames.bind(this) } });
  },
  onStyleMounted(name) {
    this._loadingStyles.add(name);
  },
  onStyleUpdated(name) {
    this._loadingStyles.add(name);
  },
  onStyleLoaded(event2, { name }) {
    if (this._loadingStyles.size) {
      this._loadingStyles.delete(name);
      service_default.emit(`theme:${name}:load`, event2);
      !this._loadingStyles.size && service_default.emit("theme:load");
    }
  }
};
function updatePreset$1(...presets) {
  const newPreset = mergeKeys(config_default.getPreset(), ...presets);
  config_default.setPreset(newPreset);
  return newPreset;
}
__name(updatePreset$1, "updatePreset$1");
function updatePrimaryPalette$1(primary) {
  return $t$1().primaryPalette(primary).update().preset;
}
__name(updatePrimaryPalette$1, "updatePrimaryPalette$1");
function updateSurfacePalette$1(palette2) {
  return $t$1().surfacePalette(palette2).update().preset;
}
__name(updateSurfacePalette$1, "updateSurfacePalette$1");
function usePreset$1(...presets) {
  const newPreset = mergeKeys(...presets);
  config_default.setPreset(newPreset);
  return newPreset;
}
__name(usePreset$1, "usePreset$1");
function useTheme$1(theme38) {
  return $t$1(theme38).update({ mergePresets: false });
}
__name(useTheme$1, "useTheme$1");
var FilterMatchMode = {
  STARTS_WITH: "startsWith",
  CONTAINS: "contains",
  NOT_CONTAINS: "notContains",
  ENDS_WITH: "endsWith",
  EQUALS: "equals",
  NOT_EQUALS: "notEquals",
  IN: "in",
  LESS_THAN: "lt",
  LESS_THAN_OR_EQUAL_TO: "lte",
  GREATER_THAN: "gt",
  GREATER_THAN_OR_EQUAL_TO: "gte",
  BETWEEN: "between",
  DATE_IS: "dateIs",
  DATE_IS_NOT: "dateIsNot",
  DATE_BEFORE: "dateBefore",
  DATE_AFTER: "dateAfter"
};
var FilterOperator = {
  AND: "and",
  OR: "or"
};
function _createForOfIteratorHelper$5(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (!t) {
    if (Array.isArray(r) || (t = _unsupportedIterableToArray$m(r)) || e) {
      t && (r = t);
      var _n = 0, F = /* @__PURE__ */ __name(function F2() {
      }, "F");
      return { s: F, n: /* @__PURE__ */ __name(function n() {
        return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
      }, "n"), e: /* @__PURE__ */ __name(function e2(r2) {
        throw r2;
      }, "e"), f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o, a = true, u = false;
  return { s: /* @__PURE__ */ __name(function s() {
    t = t.call(r);
  }, "s"), n: /* @__PURE__ */ __name(function n() {
    var r2 = t.next();
    return a = r2.done, r2;
  }, "n"), e: /* @__PURE__ */ __name(function e2(r2) {
    u = true, o = r2;
  }, "e"), f: /* @__PURE__ */ __name(function f() {
    try {
      a || null == t["return"] || t["return"]();
    } finally {
      if (u) throw o;
    }
  }, "f") };
}
__name(_createForOfIteratorHelper$5, "_createForOfIteratorHelper$5");
function _unsupportedIterableToArray$m(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$m(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$m(r, a) : void 0;
  }
}
__name(_unsupportedIterableToArray$m, "_unsupportedIterableToArray$m");
function _arrayLikeToArray$m(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
__name(_arrayLikeToArray$m, "_arrayLikeToArray$m");
var FilterService = {
  filter: /* @__PURE__ */ __name(function filter2(value3, fields, filterValue, filterMatchMode, filterLocale) {
    var filteredItems = [];
    if (!value3) {
      return filteredItems;
    }
    var _iterator = _createForOfIteratorHelper$5(value3), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var item2 = _step.value;
        if (typeof item2 === "string") {
          if (this.filters[filterMatchMode](item2, filterValue, filterLocale)) {
            filteredItems.push(item2);
            continue;
          }
        } else {
          var _iterator2 = _createForOfIteratorHelper$5(fields), _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              var field = _step2.value;
              var fieldValue = resolveFieldData(item2, field);
              if (this.filters[filterMatchMode](fieldValue, filterValue, filterLocale)) {
                filteredItems.push(item2);
                break;
              }
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return filteredItems;
  }, "filter"),
  filters: {
    startsWith: /* @__PURE__ */ __name(function startsWith(value3, filter4, filterLocale) {
      if (filter4 === void 0 || filter4 === null || filter4 === "") {
        return true;
      }
      if (value3 === void 0 || value3 === null) {
        return false;
      }
      var filterValue = removeAccents(filter4.toString()).toLocaleLowerCase(filterLocale);
      var stringValue = removeAccents(value3.toString()).toLocaleLowerCase(filterLocale);
      return stringValue.slice(0, filterValue.length) === filterValue;
    }, "startsWith"),
    contains: /* @__PURE__ */ __name(function contains2(value3, filter4, filterLocale) {
      if (filter4 === void 0 || filter4 === null || filter4 === "") {
        return true;
      }
      if (value3 === void 0 || value3 === null) {
        return false;
      }
      var filterValue = removeAccents(filter4.toString()).toLocaleLowerCase(filterLocale);
      var stringValue = removeAccents(value3.toString()).toLocaleLowerCase(filterLocale);
      return stringValue.indexOf(filterValue) !== -1;
    }, "contains"),
    notContains: /* @__PURE__ */ __name(function notContains(value3, filter4, filterLocale) {
      if (filter4 === void 0 || filter4 === null || filter4 === "") {
        return true;
      }
      if (value3 === void 0 || value3 === null) {
        return false;
      }
      var filterValue = removeAccents(filter4.toString()).toLocaleLowerCase(filterLocale);
      var stringValue = removeAccents(value3.toString()).toLocaleLowerCase(filterLocale);
      return stringValue.indexOf(filterValue) === -1;
    }, "notContains"),
    endsWith: /* @__PURE__ */ __name(function endsWith2(value3, filter4, filterLocale) {
      if (filter4 === void 0 || filter4 === null || filter4 === "") {
        return true;
      }
      if (value3 === void 0 || value3 === null) {
        return false;
      }
      var filterValue = removeAccents(filter4.toString()).toLocaleLowerCase(filterLocale);
      var stringValue = removeAccents(value3.toString()).toLocaleLowerCase(filterLocale);
      return stringValue.indexOf(filterValue, stringValue.length - filterValue.length) !== -1;
    }, "endsWith"),
    equals: /* @__PURE__ */ __name(function equals2(value3, filter4, filterLocale) {
      if (filter4 === void 0 || filter4 === null || filter4 === "") {
        return true;
      }
      if (value3 === void 0 || value3 === null) {
        return false;
      }
      if (value3.getTime && filter4.getTime) return value3.getTime() === filter4.getTime();
      else return removeAccents(value3.toString()).toLocaleLowerCase(filterLocale) == removeAccents(filter4.toString()).toLocaleLowerCase(filterLocale);
    }, "equals"),
    notEquals: /* @__PURE__ */ __name(function notEquals(value3, filter4, filterLocale) {
      if (filter4 === void 0 || filter4 === null || filter4 === "") {
        return false;
      }
      if (value3 === void 0 || value3 === null) {
        return true;
      }
      if (value3.getTime && filter4.getTime) return value3.getTime() !== filter4.getTime();
      else return removeAccents(value3.toString()).toLocaleLowerCase(filterLocale) != removeAccents(filter4.toString()).toLocaleLowerCase(filterLocale);
    }, "notEquals"),
    "in": /* @__PURE__ */ __name(function _in(value3, filter4) {
      if (filter4 === void 0 || filter4 === null || filter4.length === 0) {
        return true;
      }
      for (var i2 = 0; i2 < filter4.length; i2++) {
        if (equals(value3, filter4[i2])) {
          return true;
        }
      }
      return false;
    }, "_in"),
    between: /* @__PURE__ */ __name(function between(value3, filter4) {
      if (filter4 == null || filter4[0] == null || filter4[1] == null) {
        return true;
      }
      if (value3 === void 0 || value3 === null) {
        return false;
      }
      if (value3.getTime) return filter4[0].getTime() <= value3.getTime() && value3.getTime() <= filter4[1].getTime();
      else return filter4[0] <= value3 && value3 <= filter4[1];
    }, "between"),
    lt: /* @__PURE__ */ __name(function lt(value3, filter4) {
      if (filter4 === void 0 || filter4 === null) {
        return true;
      }
      if (value3 === void 0 || value3 === null) {
        return false;
      }
      if (value3.getTime && filter4.getTime) return value3.getTime() < filter4.getTime();
      else return value3 < filter4;
    }, "lt"),
    lte: /* @__PURE__ */ __name(function lte(value3, filter4) {
      if (filter4 === void 0 || filter4 === null) {
        return true;
      }
      if (value3 === void 0 || value3 === null) {
        return false;
      }
      if (value3.getTime && filter4.getTime) return value3.getTime() <= filter4.getTime();
      else return value3 <= filter4;
    }, "lte"),
    gt: /* @__PURE__ */ __name(function gt(value3, filter4) {
      if (filter4 === void 0 || filter4 === null) {
        return true;
      }
      if (value3 === void 0 || value3 === null) {
        return false;
      }
      if (value3.getTime && filter4.getTime) return value3.getTime() > filter4.getTime();
      else return value3 > filter4;
    }, "gt"),
    gte: /* @__PURE__ */ __name(function gte(value3, filter4) {
      if (filter4 === void 0 || filter4 === null) {
        return true;
      }
      if (value3 === void 0 || value3 === null) {
        return false;
      }
      if (value3.getTime && filter4.getTime) return value3.getTime() >= filter4.getTime();
      else return value3 >= filter4;
    }, "gte"),
    dateIs: /* @__PURE__ */ __name(function dateIs(value3, filter4) {
      if (filter4 === void 0 || filter4 === null) {
        return true;
      }
      if (value3 === void 0 || value3 === null) {
        return false;
      }
      return value3.toDateString() === filter4.toDateString();
    }, "dateIs"),
    dateIsNot: /* @__PURE__ */ __name(function dateIsNot(value3, filter4) {
      if (filter4 === void 0 || filter4 === null) {
        return true;
      }
      if (value3 === void 0 || value3 === null) {
        return false;
      }
      return value3.toDateString() !== filter4.toDateString();
    }, "dateIsNot"),
    dateBefore: /* @__PURE__ */ __name(function dateBefore(value3, filter4) {
      if (filter4 === void 0 || filter4 === null) {
        return true;
      }
      if (value3 === void 0 || value3 === null) {
        return false;
      }
      return value3.getTime() < filter4.getTime();
    }, "dateBefore"),
    dateAfter: /* @__PURE__ */ __name(function dateAfter(value3, filter4) {
      if (filter4 === void 0 || filter4 === null) {
        return true;
      }
      if (value3 === void 0 || value3 === null) {
        return false;
      }
      return value3.getTime() > filter4.getTime();
    }, "dateAfter")
  },
  register: /* @__PURE__ */ __name(function register2(rule, fn) {
    this.filters[rule] = fn;
  }, "register")
};
var PrimeIcons = {
  ALIGN_CENTER: "pi pi-align-center",
  ALIGN_JUSTIFY: "pi pi-align-justify",
  ALIGN_LEFT: "pi pi-align-left",
  ALIGN_RIGHT: "pi pi-align-right",
  AMAZON: "pi pi-amazon",
  ANDROID: "pi pi-android",
  ANGLE_DOUBLE_DOWN: "pi pi-angle-double-down",
  ANGLE_DOUBLE_LEFT: "pi pi-angle-double-left",
  ANGLE_DOUBLE_RIGHT: "pi pi-angle-double-right",
  ANGLE_DOUBLE_UP: "pi pi-angle-double-up",
  ANGLE_DOWN: "pi pi-angle-down",
  ANGLE_LEFT: "pi pi-angle-left",
  ANGLE_RIGHT: "pi pi-angle-right",
  ANGLE_UP: "pi pi-angle-up",
  APPLE: "pi pi-apple",
  ARROW_CIRCLE_DOWN: "pi pi-arrow-circle-down",
  ARROW_CIRCLE_LEFT: "pi pi-arrow-circle-left",
  ARROW_CIRCLE_RIGHT: "pi pi-arrow-circle-right",
  ARROW_CIRCLE_UP: "pi pi-arrow-circle-up",
  ARROW_DOWN: "pi pi-arrow-down",
  ARROW_DOWN_LEFT: "pi pi-arrow-down-left",
  ARROW_DOWN_RIGHT: "pi pi-arrow-down-right",
  ARROW_LEFT: "pi pi-arrow-left",
  ARROW_RIGHT: "pi pi-arrow-right",
  ARROW_RIGHT_ARROW_LEFT: "pi pi-arrow-right-arrow-left",
  ARROW_UP: "pi pi-arrow-up",
  ARROW_UP_LEFT: "pi pi-arrow-up-left",
  ARROW_UP_RIGHT: "pi pi-arrow-up-right",
  ARROW_H: "pi pi-arrows-h",
  ARROW_V: "pi pi-arrows-v",
  ARROW_A: "pi pi-arrows-alt",
  AT: "pi pi-at",
  BACKWARD: "pi pi-backward",
  BAN: "pi pi-ban",
  BARS: "pi pi-bars",
  BELL: "pi pi-bell",
  BITCOIN: "pi pi-bitcoin",
  BOLT: "pi pi-bolt",
  BOOK: "pi pi-book",
  BOOKMARK: "pi pi-bookmark",
  BOOKMARK_FILL: "pi pi-bookmark-fill",
  BOX: "pi pi-box",
  BRIEFCASE: "pi pi-briefcase",
  BUILDING: "pi pi-building",
  CALENDAR: "pi pi-calendar",
  CALENDAR_MINUS: "pi pi-calendar-minus",
  CALENDAR_PLUS: "pi pi-calendar-plus",
  CALENDAR_TIMES: "pi pi-calendar-times",
  CALCULATOR: "pi pi-calculator",
  CAMERA: "pi pi-camera",
  CAR: "pi pi-car",
  CARET_DOWN: "pi pi-caret-down",
  CARET_LEFT: "pi pi-caret-left",
  CARET_RIGHT: "pi pi-caret-right",
  CARET_UP: "pi pi-caret-up",
  CART_PLUS: "pi pi-cart-plus",
  CHART_BAR: "pi pi-chart-bar",
  CHART_LINE: "pi pi-chart-line",
  CHART_PIE: "pi pi-chart-pie",
  CHECK: "pi pi-check",
  CHECK_CIRCLE: "pi pi-check-circle",
  CHECK_SQUARE: "pi pi-check-square",
  CHEVRON_CIRCLE_DOWN: "pi pi-chevron-circle-down",
  CHEVRON_CIRCLE_LEFT: "pi pi-chevron-circle-left",
  CHEVRON_CIRCLE_RIGHT: "pi pi-chevron-circle-right",
  CHEVRON_CIRCLE_UP: "pi pi-chevron-circle-up",
  CHEVRON_DOWN: "pi pi-chevron-down",
  CHEVRON_LEFT: "pi pi-chevron-left",
  CHEVRON_RIGHT: "pi pi-chevron-right",
  CHEVRON_UP: "pi pi-chevron-up",
  CIRCLE: "pi pi-circle",
  CIRCLE_FILL: "pi pi-circle-fill",
  CLOCK: "pi pi-clock",
  CLONE: "pi pi-clone",
  CLOUD: "pi pi-cloud",
  CLOUD_DOWNLOAD: "pi pi-cloud-download",
  CLOUD_UPLOAD: "pi pi-cloud-upload",
  CODE: "pi pi-code",
  COG: "pi pi-cog",
  COMMENT: "pi pi-comment",
  COMMENTS: "pi pi-comments",
  COMPASS: "pi pi-compass",
  COPY: "pi pi-copy",
  CREDIT_CARD: "pi pi-credit-card",
  DATABASE: "pi pi-database",
  DELETELEFT: "pi pi-delete-left",
  DESKTOP: "pi pi-desktop",
  DIRECTIONS: "pi pi-directions",
  DIRECTIONS_ALT: "pi pi-directions-alt",
  DISCORD: "pi pi-discord",
  DOLLAR: "pi pi-dollar",
  DOWNLOAD: "pi pi-download",
  EJECT: "pi pi-eject",
  ELLIPSIS_H: "pi pi-ellipsis-h",
  ELLIPSIS_V: "pi pi-ellipsis-v",
  ENVELOPE: "pi pi-envelope",
  ERASER: "pi pi-eraser",
  EURO: "pi pi-euro",
  EXCLAMATION_CIRCLE: "pi pi-exclamation-circle",
  EXCLAMATION_TRIANGLE: "pi pi-exclamation-triangle",
  EXTERNAL_LINK: "pi pi-external-link",
  EYE: "pi pi-eye",
  EYE_SLASH: "pi pi-eye-slash",
  FACEBOOK: "pi pi-facebook",
  FAST_BACKWARD: "pi pi-fast-backward",
  FAST_FORWARD: "pi pi-fast-forward",
  FILE: "pi pi-file",
  FILE_EDIT: "pi pi-file-edit",
  FILE_EXCEL: "pi pi-file-excel",
  FILE_EXPORT: "pi pi-file-export",
  FILE_IMPORT: "pi pi-file-import",
  FILE_PDF: "pi pi-file-pdf",
  FILE_WORD: "pi pi-file-word",
  FILTER: "pi pi-filter",
  FILTER_FILL: "pi pi-filter-fill",
  FILTER_SLASH: "pi pi-filter-slash",
  FLAG: "pi pi-flag",
  FLAG_FILL: "pi pi-flag-fill",
  FOLDER: "pi pi-folder",
  FOLDER_OPEN: "pi pi-folder-open",
  FORWARD: "pi pi-forward",
  GIFT: "pi pi-gift",
  GITHUB: "pi pi-github",
  GLOBE: "pi pi-globe",
  GOOGLE: "pi pi-google",
  HASHTAG: "pi pi-hashtag",
  HEART: "pi pi-heart",
  HEART_FILL: "pi pi-heart-fill",
  HISTORY: "pi pi-history",
  HOURGLASS: "pi pi-hourglass",
  HOME: "pi pi-home",
  ID_CARD: "pi pi-id-card",
  IMAGE: "pi pi-image",
  IMAGES: "pi pi-images",
  INBOX: "pi pi-inbox",
  INFO: "pi pi-info",
  INFO_CIRCLE: "pi pi-info-circle",
  INSTAGRAM: "pi pi-instagram",
  KEY: "pi pi-key",
  LANGUAGE: "pi pi-language",
  LINK: "pi pi-link",
  LINKEDIN: "pi pi-linkedin",
  LIST: "pi pi-list",
  LOCK: "pi pi-lock",
  LOCK_OPEN: "pi pi-lock-open",
  MAP: "pi pi-map",
  MAP_MARKER: "pi pi-map-marker",
  MEGAPHONE: "pi pi-megaphone",
  MICREPHONE: "pi pi-microphone",
  MICROSOFT: "pi pi-microsoft",
  MINUS: "pi pi-minus",
  MINUS_CIRCLE: "pi pi-minus-circle",
  MOBILE: "pi pi-mobile",
  MONEY_BILL: "pi pi-money-bill",
  MOON: "pi pi-moon",
  PALETTE: "pi pi-palette",
  PAPERCLIP: "pi pi-paperclip",
  PAUSE: "pi pi-pause",
  PAYPAL: "pi pi-paypal",
  PENCIL: "pi pi-pencil",
  PERCENTAGE: "pi pi-percentage",
  PHONE: "pi pi-phone",
  PLAY: "pi pi-play",
  PLUS: "pi pi-plus",
  PLUS_CIRCLE: "pi pi-plus-circle",
  POUND: "pi pi-pound",
  POWER_OFF: "pi pi-power-off",
  PRIME: "pi pi-prime",
  PRINT: "pi pi-print",
  QRCODE: "pi pi-qrcode",
  QUESTION: "pi pi-question",
  QUESTION_CIRCLE: "pi pi-question-circle",
  REDDIT: "pi pi-reddit",
  REFRESH: "pi pi-refresh",
  REPLAY: "pi pi-replay",
  REPLY: "pi pi-reply",
  SAVE: "pi pi-save",
  SEARCH: "pi pi-search",
  SEARCH_MINUS: "pi pi-search-minus",
  SEARCH_PLUS: "pi pi-search-plus",
  SEND: "pi pi-send",
  SERVER: "pi pi-server",
  SHARE_ALT: "pi pi-share-alt",
  SHIELD: "pi pi-shield",
  SHOPPING_BAG: "pi pi-shopping-bag",
  SHOPPING_CART: "pi pi-shopping-cart",
  SIGN_IN: "pi pi-sign-in",
  SIGN_OUT: "pi pi-sign-out",
  SITEMAP: "pi pi-sitemap",
  SLACK: "pi pi-slack",
  SLIDERS_H: "pi pi-sliders-h",
  SLIDERS_V: "pi pi-sliders-v",
  SORT: "pi pi-sort",
  SORT_ALPHA_DOWN: "pi pi-sort-alpha-down",
  SORT_ALPHA_ALT_DOWN: "pi pi-sort-alpha-down-alt",
  SORT_ALPHA_UP: "pi pi-sort-alpha-up",
  SORT_ALPHA_ALT_UP: "pi pi-sort-alpha-up-alt",
  SORT_ALT: "pi pi-sort-alt",
  SORT_ALT_SLASH: "pi pi-sort-alt-slash",
  SORT_AMOUNT_DOWN: "pi pi-sort-amount-down",
  SORT_AMOUNT_DOWN_ALT: "pi pi-sort-amount-down-alt",
  SORT_AMOUNT_UP: "pi pi-sort-amount-up",
  SORT_AMOUNT_UP_ALT: "pi pi-sort-amount-up-alt",
  SORT_DOWN: "pi pi-sort-down",
  SORT_NUMERIC_DOWN: "pi pi-sort-numeric-down",
  SORT_NUMERIC_ALT_DOWN: "pi pi-sort-numeric-down-alt",
  SORT_NUMERIC_UP: "pi pi-sort-numeric-up",
  SORT_NUMERIC_ALT_UP: "pi pi-sort-numeric-up-alt",
  SORT_UP: "pi pi-sort-up",
  SPINNER: "pi pi-spinner",
  STAR: "pi pi-star",
  STAR_FILL: "pi pi-star-fill",
  STEP_BACKWARD: "pi pi-step-backward",
  STEP_BACKWARD_ALT: "pi pi-step-backward-alt",
  STEP_FORWARD: "pi pi-step-forward",
  STEP_FORWARD_ALT: "pi pi-step-forward-alt",
  STOP: "pi pi-stop",
  STOPWATCH: "pi pi-stopwatch",
  STOP_CIRCLE: "pi pi-stop-circle",
  SUN: "pi pi-sun",
  SYNC: "pi pi-sync",
  TABLE: "pi pi-table",
  TABLET: "pi pi-tablet",
  TAG: "pi pi-tag",
  TAGS: "pi pi-tags",
  TELEGRAM: "pi pi-telegram",
  TH_LARGE: "pi pi-th-large",
  THUMBS_DOWN: "pi pi-thumbs-down",
  THUMBS_DOWN_FILL: "pi pi-thumbs-down-fill",
  THUMBS_UP: "pi pi-thumbs-up",
  THUMBS_UP_FILL: "pi pi-thumbs-up-fill",
  TICKET: "pi pi-ticket",
  TIMES: "pi pi-times",
  TIMES_CIRCLE: "pi pi-times-circle",
  TRASH: "pi pi-trash",
  TRUCK: "pi pi-truck",
  TWITTER: "pi pi-twitter",
  UNDO: "pi pi-undo",
  UNLOCK: "pi pi-unlock",
  UPLOAD: "pi pi-upload",
  USER: "pi pi-user",
  USER_EDIT: "pi pi-user-edit",
  USER_MINUS: "pi pi-user-minus",
  USER_PLUS: "pi pi-user-plus",
  USERS: "pi pi-users",
  VERIFIED: "pi pi-verified",
  VIDEO: "pi pi-video",
  VIMEO: "pi pi-vimeo",
  VOLUME_DOWN: "pi pi-volume-down",
  VOLUME_OFF: "pi pi-volume-off",
  VOLUME_UP: "pi pi-volume-up",
  WALLET: "pi pi-wallet",
  WHATSAPP: "pi pi-whatsapp",
  WIFI: "pi pi-wifi",
  WINDOW_MAXIMIZE: "pi pi-window-maximize",
  WINDOW_MINIMIZE: "pi pi-window-minimize",
  WRENCH: "pi pi-wrench",
  YOUTUBE: "pi pi-youtube"
};
var ToastSeverities = {
  INFO: "info",
  WARN: "warn",
  ERROR: "error",
  SUCCESS: "success"
};
function hasClass(element, className) {
  if (element) {
    if (element.classList) return element.classList.contains(className);
    else return new RegExp("(^| )" + className + "( |$)", "gi").test(element.className);
  }
  return false;
}
__name(hasClass, "hasClass");
function addClass(element, className) {
  if (element && className) {
    const fn = /* @__PURE__ */ __name((_className) => {
      if (!hasClass(element, _className)) {
        if (element.classList) element.classList.add(_className);
        else element.className += " " + _className;
      }
    }, "fn");
    [className].flat().filter(Boolean).forEach((_classNames) => _classNames.split(" ").forEach(fn));
  }
}
__name(addClass, "addClass");
function calculateBodyScrollbarWidth() {
  return window.innerWidth - document.documentElement.offsetWidth;
}
__name(calculateBodyScrollbarWidth, "calculateBodyScrollbarWidth");
function getCSSVariableByRegex(variableRegex) {
  for (const sheet of document == null ? void 0 : document.styleSheets) {
    try {
      for (const rule of sheet == null ? void 0 : sheet.cssRules) {
        for (const property of rule == null ? void 0 : rule.style) {
          if (variableRegex.test(property)) {
            return { name: property, value: rule.style.getPropertyValue(property).trim() };
          }
        }
      }
    } catch (e) {
    }
  }
  return null;
}
__name(getCSSVariableByRegex, "getCSSVariableByRegex");
function blockBodyScroll(className = "p-overflow-hidden") {
  const variableData = getCSSVariableByRegex(/-scrollbar-width$/);
  (variableData == null ? void 0 : variableData.name) && document.body.style.setProperty(variableData.name, calculateBodyScrollbarWidth() + "px");
  addClass(document.body, className);
}
__name(blockBodyScroll, "blockBodyScroll");
function saveAs$1(file) {
  if (file) {
    let link = document.createElement("a");
    if (link.download !== void 0) {
      const { name, src } = file;
      link.setAttribute("href", src);
      link.setAttribute("download", name);
      link.style.display = "none";
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      return true;
    }
  }
  return false;
}
__name(saveAs$1, "saveAs$1");
function exportCSV(csv, filename) {
  let blob = new Blob([csv], {
    type: "application/csv;charset=utf-8;"
  });
  if (window.navigator.msSaveOrOpenBlob) {
    navigator.msSaveOrOpenBlob(blob, filename + ".csv");
  } else {
    const isDownloaded = saveAs$1({ name: filename + ".csv", src: URL.createObjectURL(blob) });
    if (!isDownloaded) {
      csv = "data:text/csv;charset=utf-8," + csv;
      window.open(encodeURI(csv));
    }
  }
}
__name(exportCSV, "exportCSV");
function removeClass(element, className) {
  if (element && className) {
    const fn = /* @__PURE__ */ __name((_className) => {
      if (element.classList) element.classList.remove(_className);
      else element.className = element.className.replace(new RegExp("(^|\\b)" + _className.split(" ").join("|") + "(\\b|$)", "gi"), " ");
    }, "fn");
    [className].flat().filter(Boolean).forEach((_classNames) => _classNames.split(" ").forEach(fn));
  }
}
__name(removeClass, "removeClass");
function unblockBodyScroll(className = "p-overflow-hidden") {
  const variableData = getCSSVariableByRegex(/-scrollbar-width$/);
  (variableData == null ? void 0 : variableData.name) && document.body.style.removeProperty(variableData.name);
  removeClass(document.body, className);
}
__name(unblockBodyScroll, "unblockBodyScroll");
function getHiddenElementDimensions(element) {
  let dimensions = { width: 0, height: 0 };
  if (element) {
    element.style.visibility = "hidden";
    element.style.display = "block";
    dimensions.width = element.offsetWidth;
    dimensions.height = element.offsetHeight;
    element.style.display = "none";
    element.style.visibility = "visible";
  }
  return dimensions;
}
__name(getHiddenElementDimensions, "getHiddenElementDimensions");
function getViewport() {
  let win = window, d = document, e = d.documentElement, g = d.getElementsByTagName("body")[0], w2 = win.innerWidth || e.clientWidth || g.clientWidth, h2 = win.innerHeight || e.clientHeight || g.clientHeight;
  return { width: w2, height: h2 };
}
__name(getViewport, "getViewport");
function getWindowScrollLeft() {
  let doc2 = document.documentElement;
  return (window.pageXOffset || doc2.scrollLeft) - (doc2.clientLeft || 0);
}
__name(getWindowScrollLeft, "getWindowScrollLeft");
function getWindowScrollTop() {
  let doc2 = document.documentElement;
  return (window.pageYOffset || doc2.scrollTop) - (doc2.clientTop || 0);
}
__name(getWindowScrollTop, "getWindowScrollTop");
function absolutePosition(element, target, gutter = true) {
  var _a, _b, _c, _d;
  if (element) {
    const elementDimensions = element.offsetParent ? { width: element.offsetWidth, height: element.offsetHeight } : getHiddenElementDimensions(element);
    const elementOuterHeight = elementDimensions.height;
    const elementOuterWidth = elementDimensions.width;
    const targetOuterHeight = target.offsetHeight;
    const targetOuterWidth = target.offsetWidth;
    const targetOffset = target.getBoundingClientRect();
    const windowScrollTop = getWindowScrollTop();
    const windowScrollLeft = getWindowScrollLeft();
    const viewport = getViewport();
    let top, left, origin2 = "top";
    if (targetOffset.top + targetOuterHeight + elementOuterHeight > viewport.height) {
      top = targetOffset.top + windowScrollTop - elementOuterHeight;
      origin2 = "bottom";
      if (top < 0) {
        top = windowScrollTop;
      }
    } else {
      top = targetOuterHeight + targetOffset.top + windowScrollTop;
    }
    if (targetOffset.left + elementOuterWidth > viewport.width) left = Math.max(0, targetOffset.left + windowScrollLeft + targetOuterWidth - elementOuterWidth);
    else left = targetOffset.left + windowScrollLeft;
    element.style.top = top + "px";
    element.style.left = left + "px";
    element.style.transformOrigin = origin2;
    gutter && (element.style.marginTop = origin2 === "bottom" ? `calc(${(_b = (_a = getCSSVariableByRegex(/-anchor-gutter$/)) == null ? void 0 : _a.value) != null ? _b : "2px"} * -1)` : (_d = (_c = getCSSVariableByRegex(/-anchor-gutter$/)) == null ? void 0 : _c.value) != null ? _d : "");
  }
}
__name(absolutePosition, "absolutePosition");
function addStyle(element, style) {
  if (element) {
    if (typeof style === "string") {
      element.style.cssText = style;
    } else {
      Object.entries(style || {}).forEach(([key, value3]) => element.style[key] = value3);
    }
  }
}
__name(addStyle, "addStyle");
function getOuterWidth(element, margin) {
  if (element instanceof HTMLElement) {
    let width2 = element.offsetWidth;
    if (margin) {
      let style = getComputedStyle(element);
      width2 += parseFloat(style.marginLeft) + parseFloat(style.marginRight);
    }
    return width2;
  }
  return 0;
}
__name(getOuterWidth, "getOuterWidth");
function relativePosition(element, target, gutter = true) {
  var _a, _b, _c, _d;
  if (element) {
    const elementDimensions = element.offsetParent ? { width: element.offsetWidth, height: element.offsetHeight } : getHiddenElementDimensions(element);
    const targetHeight = target.offsetHeight;
    const targetOffset = target.getBoundingClientRect();
    const viewport = getViewport();
    let top, left, origin2 = "top";
    if (targetOffset.top + targetHeight + elementDimensions.height > viewport.height) {
      top = -1 * elementDimensions.height;
      origin2 = "bottom";
      if (targetOffset.top + top < 0) {
        top = -1 * targetOffset.top;
      }
    } else {
      top = targetHeight;
    }
    if (elementDimensions.width > viewport.width) {
      left = targetOffset.left * -1;
    } else if (targetOffset.left + elementDimensions.width > viewport.width) {
      left = (targetOffset.left + elementDimensions.width - viewport.width) * -1;
    } else {
      left = 0;
    }
    element.style.top = top + "px";
    element.style.left = left + "px";
    element.style.transformOrigin = origin2;
    gutter && (element.style.marginTop = origin2 === "bottom" ? `calc(${(_b = (_a = getCSSVariableByRegex(/-anchor-gutter$/)) == null ? void 0 : _a.value) != null ? _b : "2px"} * -1)` : (_d = (_c = getCSSVariableByRegex(/-anchor-gutter$/)) == null ? void 0 : _c.value) != null ? _d : "");
  }
}
__name(relativePosition, "relativePosition");
function alignOverlay(overlay, target, appendTo, calculateMinWidth = true) {
  if (overlay && target) {
    if (appendTo === "self") {
      relativePosition(overlay, target);
    } else {
      calculateMinWidth && (overlay.style.minWidth = getOuterWidth(target) + "px");
      absolutePosition(overlay, target);
    }
  }
}
__name(alignOverlay, "alignOverlay");
function isElement(element) {
  return typeof HTMLElement === "object" ? element instanceof HTMLElement : element && typeof element === "object" && element !== null && element.nodeType === 1 && typeof element.nodeName === "string";
}
__name(isElement, "isElement");
function toElement(element) {
  let target = element;
  if (element && typeof element === "object") {
    if (element.hasOwnProperty("current")) {
      target = element.current;
    } else if (element.hasOwnProperty("el")) {
      if (element.el.hasOwnProperty("nativeElement")) {
        target = element.el.nativeElement;
      } else {
        target = element.el;
      }
    }
  }
  return isElement(target) ? target : void 0;
}
__name(toElement, "toElement");
function appendChild(element, child) {
  const target = toElement(element);
  if (target) target.appendChild(child);
  else throw new Error("Cannot append " + child + " to " + element);
}
__name(appendChild, "appendChild");
var calculatedScrollbarHeight = void 0;
function calculateScrollbarHeight(element) {
  if (element) {
    let style = getComputedStyle(element);
    return element.offsetHeight - element.clientHeight - parseFloat(style.borderTopWidth) - parseFloat(style.borderBottomWidth);
  } else {
    if (calculatedScrollbarHeight != null) return calculatedScrollbarHeight;
    let scrollDiv = document.createElement("div");
    addStyle(scrollDiv, {
      width: "100px",
      height: "100px",
      overflow: "scroll",
      position: "absolute",
      top: "-9999px"
    });
    document.body.appendChild(scrollDiv);
    let scrollbarHeight = scrollDiv.offsetHeight - scrollDiv.clientHeight;
    document.body.removeChild(scrollDiv);
    calculatedScrollbarHeight = scrollbarHeight;
    return scrollbarHeight;
  }
}
__name(calculateScrollbarHeight, "calculateScrollbarHeight");
var calculatedScrollbarWidth = void 0;
function calculateScrollbarWidth(element) {
  if (element) {
    let style = getComputedStyle(element);
    return element.offsetWidth - element.clientWidth - parseFloat(style.borderLeftWidth) - parseFloat(style.borderRightWidth);
  } else {
    if (calculatedScrollbarWidth != null) return calculatedScrollbarWidth;
    let scrollDiv = document.createElement("div");
    addStyle(scrollDiv, {
      width: "100px",
      height: "100px",
      overflow: "scroll",
      position: "absolute",
      top: "-9999px"
    });
    document.body.appendChild(scrollDiv);
    let scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
    document.body.removeChild(scrollDiv);
    calculatedScrollbarWidth = scrollbarWidth;
    return scrollbarWidth;
  }
}
__name(calculateScrollbarWidth, "calculateScrollbarWidth");
function clearSelection() {
  if (window.getSelection) {
    const selection = window.getSelection() || {};
    if (selection.empty) {
      selection.empty();
    } else if (selection.removeAllRanges && selection.rangeCount > 0 && selection.getRangeAt(0).getClientRects().length > 0) {
      selection.removeAllRanges();
    }
  }
}
__name(clearSelection, "clearSelection");
function setAttributes(element, attributes = {}) {
  if (isElement(element)) {
    const computedStyles = /* @__PURE__ */ __name((rule, value3) => {
      var _a, _b;
      const styles = ((_a = element == null ? void 0 : element.$attrs) == null ? void 0 : _a[rule]) ? [(_b = element == null ? void 0 : element.$attrs) == null ? void 0 : _b[rule]] : [];
      return [value3].flat().reduce((cv, v2) => {
        if (v2 !== null && v2 !== void 0) {
          const type = typeof v2;
          if (type === "string" || type === "number") {
            cv.push(v2);
          } else if (type === "object") {
            const _cv = Array.isArray(v2) ? computedStyles(rule, v2) : Object.entries(v2).map(([_k, _v]) => rule === "style" && (!!_v || _v === 0) ? `${_k.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase()}:${_v}` : !!_v ? _k : void 0);
            cv = _cv.length ? cv.concat(_cv.filter((c) => !!c)) : cv;
          }
        }
        return cv;
      }, styles);
    }, "computedStyles");
    Object.entries(attributes).forEach(([key, value3]) => {
      if (value3 !== void 0 && value3 !== null) {
        const matchedEvent = key.match(/^on(.+)/);
        if (matchedEvent) {
          element.addEventListener(matchedEvent[1].toLowerCase(), value3);
        } else if (key === "p-bind") {
          setAttributes(element, value3);
        } else {
          value3 = key === "class" ? [...new Set(computedStyles("class", value3))].join(" ").trim() : key === "style" ? computedStyles("style", value3).join(";").trim() : value3;
          (element.$attrs = element.$attrs || {}) && (element.$attrs[key] = value3);
          element.setAttribute(key, value3);
        }
      }
    });
  }
}
__name(setAttributes, "setAttributes");
function createElement(type, attributes = {}, ...children) {
  if (type) {
    const element = document.createElement(type);
    setAttributes(element, attributes);
    element.append(...children);
    return element;
  }
  return void 0;
}
__name(createElement, "createElement");
function createStyleAsString(css4, options3 = {}) {
  return css4 ? `'<style type="text/css" ${Object.entries(options3).reduce((s, [k, v2]) => s + `${k}="${v2}"`, " ")}>${css4}</style>'` : "";
}
__name(createStyleAsString, "createStyleAsString");
function createStyleTag(attributes = {}, container) {
  let element = document.createElement("style");
  setAttributes(element, attributes);
  if (!container) {
    container = document.head;
  }
  container.appendChild(element);
  return element;
}
__name(createStyleTag, "createStyleTag");
function fadeIn(element, duration) {
  if (element) {
    element.style.opacity = "0";
    let last = +/* @__PURE__ */ new Date();
    let opacity = "0";
    let tick = /* @__PURE__ */ __name(function() {
      opacity = `${+element.style.opacity + ((/* @__PURE__ */ new Date()).getTime() - last) / duration}`;
      element.style.opacity = opacity;
      last = +/* @__PURE__ */ new Date();
      if (+opacity < 1) {
        !!window.requestAnimationFrame && requestAnimationFrame(tick) || setTimeout(tick, 16);
      }
    }, "tick");
    tick();
  }
}
__name(fadeIn, "fadeIn");
function fadeOut(element, duration) {
  if (element) {
    let opacity = 1, interval = 50, gap = interval / duration;
    let fading = setInterval(() => {
      opacity -= gap;
      if (opacity <= 0) {
        opacity = 0;
        clearInterval(fading);
      }
      element.style.opacity = opacity.toString();
    }, interval);
  }
}
__name(fadeOut, "fadeOut");
function find(element, selector) {
  return isElement(element) ? Array.from(element.querySelectorAll(selector)) : [];
}
__name(find, "find");
function findSingle(element, selector) {
  return isElement(element) ? element.matches(selector) ? element : element.querySelector(selector) : null;
}
__name(findSingle, "findSingle");
function focus(element, options3) {
  element && document.activeElement !== element && element.focus(options3);
}
__name(focus, "focus");
function getAttribute(element, name) {
  if (isElement(element)) {
    const value3 = element.getAttribute(name);
    if (!isNaN(value3)) {
      return +value3;
    }
    if (value3 === "true" || value3 === "false") {
      return value3 === "true";
    }
    return value3;
  }
  return void 0;
}
__name(getAttribute, "getAttribute");
function resolveUserAgent() {
  let ua = navigator.userAgent.toLowerCase();
  let match = /(chrome)[ ]([\w.]+)/.exec(ua) || /(webkit)[ ]([\w.]+)/.exec(ua) || /(opera)(?:.*version|)[ ]([\w.]+)/.exec(ua) || /(msie) ([\w.]+)/.exec(ua) || ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) || [];
  return {
    browser: match[1] || "",
    version: match[2] || "0"
  };
}
__name(resolveUserAgent, "resolveUserAgent");
var browser = null;
function getBrowser() {
  if (!browser) {
    browser = {};
    let matched = resolveUserAgent();
    if (matched.browser) {
      browser[matched.browser] = true;
      browser["version"] = matched.version;
    }
    if (browser["chrome"]) {
      browser["webkit"] = true;
    } else if (browser["webkit"]) {
      browser["safari"] = true;
    }
  }
  return browser;
}
__name(getBrowser, "getBrowser");
function getCursorOffset(element, prevText, nextText, currentText) {
  if (element) {
    let style = getComputedStyle(element);
    let ghostDiv = document.createElement("div");
    ghostDiv.style.position = "absolute";
    ghostDiv.style.top = "0px";
    ghostDiv.style.left = "0px";
    ghostDiv.style.visibility = "hidden";
    ghostDiv.style.pointerEvents = "none";
    ghostDiv.style.overflow = style.overflow;
    ghostDiv.style.width = style.width;
    ghostDiv.style.height = style.height;
    ghostDiv.style.padding = style.padding;
    ghostDiv.style.border = style.border;
    ghostDiv.style.overflowWrap = style.overflowWrap;
    ghostDiv.style.whiteSpace = style.whiteSpace;
    ghostDiv.style.lineHeight = style.lineHeight;
    ghostDiv.innerHTML = prevText.replace(/\r\n|\r|\n/g, "<br />");
    let ghostSpan = document.createElement("span");
    ghostSpan.textContent = currentText;
    ghostDiv.appendChild(ghostSpan);
    let text = document.createTextNode(nextText);
    ghostDiv.appendChild(text);
    document.body.appendChild(ghostDiv);
    const { offsetLeft, offsetTop, clientHeight } = ghostSpan;
    document.body.removeChild(ghostDiv);
    return {
      left: Math.abs(offsetLeft - element.scrollLeft),
      top: Math.abs(offsetTop - element.scrollTop) + clientHeight
    };
  }
  return {
    top: "auto",
    left: "auto"
  };
}
__name(getCursorOffset, "getCursorOffset");
function getFocusableElements(element, selector = "") {
  let focusableElements = find(
    element,
    `button:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${selector},
            [href][clientHeight][clientWidth]:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${selector},
            input:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${selector},
            select:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${selector},
            textarea:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${selector},
            [tabIndex]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${selector},
            [contenteditable]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${selector}`
  );
  let visibleFocusableElements = [];
  for (let focusableElement of focusableElements) {
    if (getComputedStyle(focusableElement).display != "none" && getComputedStyle(focusableElement).visibility != "hidden") visibleFocusableElements.push(focusableElement);
  }
  return visibleFocusableElements;
}
__name(getFocusableElements, "getFocusableElements");
function getFirstFocusableElement(element, selector) {
  const focusableElements = getFocusableElements(element, selector);
  return focusableElements.length > 0 ? focusableElements[0] : null;
}
__name(getFirstFocusableElement, "getFirstFocusableElement");
function getHeight(element) {
  if (element) {
    let height = element.offsetHeight;
    let style = getComputedStyle(element);
    height -= parseFloat(style.paddingTop) + parseFloat(style.paddingBottom) + parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);
    return height;
  }
  return 0;
}
__name(getHeight, "getHeight");
function getHiddenElementOuterHeight(element) {
  if (element) {
    element.style.visibility = "hidden";
    element.style.display = "block";
    let elementHeight = element.offsetHeight;
    element.style.display = "none";
    element.style.visibility = "visible";
    return elementHeight;
  }
  return 0;
}
__name(getHiddenElementOuterHeight, "getHiddenElementOuterHeight");
function getHiddenElementOuterWidth(element) {
  if (element) {
    element.style.visibility = "hidden";
    element.style.display = "block";
    let elementWidth = element.offsetWidth;
    element.style.display = "none";
    element.style.visibility = "visible";
    return elementWidth;
  }
  return 0;
}
__name(getHiddenElementOuterWidth, "getHiddenElementOuterWidth");
function getParentNode(element) {
  if (element) {
    let parent = element.parentNode;
    if (parent && parent instanceof ShadowRoot && parent.host) {
      parent = parent.host;
    }
    return parent;
  }
  return null;
}
__name(getParentNode, "getParentNode");
function getIndex(element) {
  var _a;
  if (element) {
    let children = (_a = getParentNode(element)) == null ? void 0 : _a.childNodes;
    let num = 0;
    if (children) {
      for (let i2 = 0; i2 < children.length; i2++) {
        if (children[i2] === element) return num;
        if (children[i2].nodeType === 1) num++;
      }
    }
  }
  return -1;
}
__name(getIndex, "getIndex");
function getInnerWidth(element) {
  if (element) {
    let width2 = element.offsetWidth;
    let style = getComputedStyle(element);
    width2 -= parseFloat(style.borderLeft) + parseFloat(style.borderRight);
    return width2;
  }
  return 0;
}
__name(getInnerWidth, "getInnerWidth");
function getLastFocusableElement(element, selector) {
  const focusableElements = getFocusableElements(element, selector);
  return focusableElements.length > 0 ? focusableElements[focusableElements.length - 1] : null;
}
__name(getLastFocusableElement, "getLastFocusableElement");
function getNextElementSibling(element, selector) {
  let nextElement = element.nextElementSibling;
  while (nextElement) {
    if (nextElement.matches(selector)) {
      return nextElement;
    } else {
      nextElement = nextElement.nextElementSibling;
    }
  }
  return null;
}
__name(getNextElementSibling, "getNextElementSibling");
function getNextFocusableElement(container, element, selector) {
  const focusableElements = getFocusableElements(container, selector);
  const index2 = focusableElements.length > 0 ? focusableElements.findIndex((el) => el === element) : -1;
  const nextIndex = index2 > -1 && focusableElements.length >= index2 + 1 ? index2 + 1 : -1;
  return nextIndex > -1 ? focusableElements[nextIndex] : null;
}
__name(getNextFocusableElement, "getNextFocusableElement");
function getOffset(element) {
  if (element) {
    let rect = element.getBoundingClientRect();
    return {
      top: rect.top + (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0),
      left: rect.left + (window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0)
    };
  }
  return {
    top: "auto",
    left: "auto"
  };
}
__name(getOffset, "getOffset");
function getOuterHeight(element, margin) {
  if (element) {
    let height = element.offsetHeight;
    if (margin) {
      let style = getComputedStyle(element);
      height += parseFloat(style.marginTop) + parseFloat(style.marginBottom);
    }
    return height;
  }
  return 0;
}
__name(getOuterHeight, "getOuterHeight");
function getParents(element, parents = []) {
  const parent = getParentNode(element);
  return parent === null ? parents : getParents(parent, parents.concat([parent]));
}
__name(getParents, "getParents");
function getPreviousElementSibling(element, selector) {
  let previousElement = element.previousElementSibling;
  while (previousElement) {
    if (previousElement.matches(selector)) {
      return previousElement;
    } else {
      previousElement = previousElement.previousElementSibling;
    }
  }
  return null;
}
__name(getPreviousElementSibling, "getPreviousElementSibling");
function getScrollableParents(element) {
  let scrollableParents = [];
  if (element) {
    let parents = getParents(element);
    const overflowRegex = /(auto|scroll)/;
    const overflowCheck = /* @__PURE__ */ __name((node3) => {
      try {
        let styleDeclaration = window["getComputedStyle"](node3, null);
        return overflowRegex.test(styleDeclaration.getPropertyValue("overflow")) || overflowRegex.test(styleDeclaration.getPropertyValue("overflowX")) || overflowRegex.test(styleDeclaration.getPropertyValue("overflowY"));
      } catch (err) {
        return false;
      }
    }, "overflowCheck");
    for (let parent of parents) {
      let scrollSelectors = parent.nodeType === 1 && parent.dataset["scrollselectors"];
      if (scrollSelectors) {
        let selectors = scrollSelectors.split(",");
        for (let selector of selectors) {
          let el = findSingle(parent, selector);
          if (el && overflowCheck(el)) {
            scrollableParents.push(el);
          }
        }
      }
      if (parent.nodeType !== 9 && overflowCheck(parent)) {
        scrollableParents.push(parent);
      }
    }
  }
  return scrollableParents;
}
__name(getScrollableParents, "getScrollableParents");
function getSelection() {
  if (window.getSelection) return window.getSelection().toString();
  else if (document.getSelection) return document.getSelection().toString();
  return void 0;
}
__name(getSelection, "getSelection");
function isExist(element) {
  return !!(element !== null && typeof element !== "undefined" && element.nodeName && getParentNode(element));
}
__name(isExist, "isExist");
function getTargetElement(target, currentElement) {
  var _a;
  if (!target) return void 0;
  switch (target) {
    case "document":
      return document;
    case "window":
      return window;
    case "@next":
      return currentElement == null ? void 0 : currentElement.nextElementSibling;
    case "@prev":
      return currentElement == null ? void 0 : currentElement.previousElementSibling;
    case "@parent":
      return currentElement == null ? void 0 : currentElement.parentElement;
    case "@grandparent":
      return (_a = currentElement == null ? void 0 : currentElement.parentElement) == null ? void 0 : _a.parentElement;
    default:
      if (typeof target === "string") {
        return document.querySelector(target);
      }
      const isFunction3 = /* @__PURE__ */ __name((obj) => !!(obj && obj.constructor && obj.call && obj.apply), "isFunction");
      const element = toElement(isFunction3(target) ? target() : target);
      return (element == null ? void 0 : element.nodeType) === 9 || isExist(element) ? element : void 0;
  }
}
__name(getTargetElement, "getTargetElement");
function getUserAgent() {
  return navigator.userAgent;
}
__name(getUserAgent, "getUserAgent");
function getWidth(element) {
  if (element) {
    let width2 = element.offsetWidth;
    let style = getComputedStyle(element);
    width2 -= parseFloat(style.paddingLeft) + parseFloat(style.paddingRight) + parseFloat(style.borderLeftWidth) + parseFloat(style.borderRightWidth);
    return width2;
  }
  return 0;
}
__name(getWidth, "getWidth");
function hasCSSAnimation(element) {
  if (element) {
    const style = getComputedStyle(element);
    const animationDuration = parseFloat(style.getPropertyValue("animation-duration") || "0");
    return animationDuration > 0;
  }
  return false;
}
__name(hasCSSAnimation, "hasCSSAnimation");
function hasCSSTransition(element) {
  if (element) {
    const style = getComputedStyle(element);
    const transitionDuration = parseFloat(style.getPropertyValue("transition-duration") || "0");
    return transitionDuration > 0;
  }
  return false;
}
__name(hasCSSTransition, "hasCSSTransition");
function invokeElementMethod(element, methodName, args) {
  element[methodName].apply(element, args);
}
__name(invokeElementMethod, "invokeElementMethod");
function isAndroid$1() {
  return /(android)/i.test(navigator.userAgent);
}
__name(isAndroid$1, "isAndroid$1");
function isAttributeEquals(element, name, value3) {
  return isElement(element) ? getAttribute(element, name) === value3 : false;
}
__name(isAttributeEquals, "isAttributeEquals");
function isAttributeNotEquals(element, name, value3) {
  return !isAttributeEquals(element, name, value3);
}
__name(isAttributeNotEquals, "isAttributeNotEquals");
function isClickable(element) {
  if (element) {
    const targetNode = element.nodeName;
    const parentNode = element.parentElement && element.parentElement.nodeName;
    return targetNode === "INPUT" || targetNode === "TEXTAREA" || targetNode === "BUTTON" || targetNode === "A" || parentNode === "INPUT" || parentNode === "TEXTAREA" || parentNode === "BUTTON" || parentNode === "A" || !!element.closest(".p-button, .p-checkbox, .p-radiobutton");
  }
  return false;
}
__name(isClickable, "isClickable");
function isClient$1() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
__name(isClient$1, "isClient$1");
function isFocusableElement(element, selector = "") {
  return isElement(element) ? element.matches(`button:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${selector},
            [href][clientHeight][clientWidth]:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${selector},
            input:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${selector},
            select:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${selector},
            textarea:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${selector},
            [tabIndex]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${selector},
            [contenteditable]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${selector}`) : false;
}
__name(isFocusableElement, "isFocusableElement");
function isVisible(element) {
  return !!(element && element.offsetParent != null);
}
__name(isVisible, "isVisible");
function isHidden(element) {
  return !isVisible(element);
}
__name(isHidden, "isHidden");
function isIOS$1() {
  return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window["MSStream"];
}
__name(isIOS$1, "isIOS$1");
function isTouchDevice() {
  return "ontouchstart" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
}
__name(isTouchDevice, "isTouchDevice");
function nestedPosition(element, level) {
  var _a;
  if (element) {
    const parentItem = element.parentElement;
    const elementOffset = getOffset(parentItem);
    const viewport = getViewport();
    const sublistWidth = element.offsetParent ? element.offsetWidth : getHiddenElementOuterWidth(element);
    const itemOuterWidth = getOuterWidth((_a = parentItem == null ? void 0 : parentItem.children) == null ? void 0 : _a[0]);
    let left = "";
    if (elementOffset.left + itemOuterWidth + sublistWidth > viewport.width - calculateScrollbarWidth()) {
      if (elementOffset.left < sublistWidth) {
        if (level % 2 === 1) {
          left = elementOffset.left ? "-" + elementOffset.left + "px" : "100%";
        } else if (level % 2 === 0) {
          left = viewport.width - sublistWidth - calculateScrollbarWidth() + "px";
        }
      } else {
        left = "-100%";
      }
    } else {
      left = "100%";
    }
    element.style.top = "0px";
    element.style.left = left;
  }
}
__name(nestedPosition, "nestedPosition");
function remove(element) {
  var _a;
  if (element) {
    if (!("remove" in Element.prototype)) (_a = element.parentNode) == null ? void 0 : _a.removeChild(element);
    else element.remove();
  }
}
__name(remove, "remove");
function removeChild(element, child) {
  const target = toElement(element);
  if (target) target.removeChild(child);
  else throw new Error("Cannot remove " + child + " from " + element);
}
__name(removeChild, "removeChild");
function removeStyleTag(element) {
  var _a;
  if (isExist(element)) {
    try {
      (_a = element.parentNode) == null ? void 0 : _a.removeChild(element);
    } catch (error) {
    }
    return null;
  }
  return element;
}
__name(removeStyleTag, "removeStyleTag");
function scrollInView(container, item2) {
  let borderTopValue = getComputedStyle(container).getPropertyValue("borderTopWidth");
  let borderTop = borderTopValue ? parseFloat(borderTopValue) : 0;
  let paddingTopValue = getComputedStyle(container).getPropertyValue("paddingTop");
  let paddingTop = paddingTopValue ? parseFloat(paddingTopValue) : 0;
  let containerRect = container.getBoundingClientRect();
  let itemRect = item2.getBoundingClientRect();
  let offset = itemRect.top + document.body.scrollTop - (containerRect.top + document.body.scrollTop) - borderTop - paddingTop;
  let scroll = container.scrollTop;
  let elementHeight = container.clientHeight;
  let itemHeight = getOuterHeight(item2);
  if (offset < 0) {
    container.scrollTop = scroll + offset;
  } else if (offset + itemHeight > elementHeight) {
    container.scrollTop = scroll + offset - elementHeight + itemHeight;
  }
}
__name(scrollInView, "scrollInView");
function setAttribute(element, attribute = "", value3) {
  if (isElement(element) && value3 !== null && value3 !== void 0) {
    element.setAttribute(attribute, value3);
  }
}
__name(setAttribute, "setAttribute");
function _typeof$m(o) {
  "@babel/helpers - typeof";
  return _typeof$m = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$m(o);
}
__name(_typeof$m, "_typeof$m");
function ownKeys$j(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
__name(ownKeys$j, "ownKeys$j");
function _objectSpread$j(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$j(Object(t), true).forEach(function(r2) {
      _defineProperty$m(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$j(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
__name(_objectSpread$j, "_objectSpread$j");
function _defineProperty$m(e, r, t) {
  return (r = _toPropertyKey$l(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty$m, "_defineProperty$m");
function _toPropertyKey$l(t) {
  var i2 = _toPrimitive$l(t, "string");
  return "symbol" == _typeof$m(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$l, "_toPropertyKey$l");
function _toPrimitive$l(t, r) {
  if ("object" != _typeof$m(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$m(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive$l, "_toPrimitive$l");
function tryOnMounted$1(fn) {
  var sync = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  if (getCurrentInstance()) onMounted(fn);
  else if (sync) fn();
  else nextTick(fn);
}
__name(tryOnMounted$1, "tryOnMounted$1");
var _id$1 = 0;
function useStyle(css4) {
  var options3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var isLoaded = ref(false);
  var cssRef = ref(css4);
  var styleRef = ref(null);
  var defaultDocument2 = isClient$1() ? window.document : void 0;
  var _options$document = options3.document, document2 = _options$document === void 0 ? defaultDocument2 : _options$document, _options$immediate = options3.immediate, immediate = _options$immediate === void 0 ? true : _options$immediate, _options$manual = options3.manual, manual = _options$manual === void 0 ? false : _options$manual, _options$name = options3.name, name = _options$name === void 0 ? "style_".concat(++_id$1) : _options$name, _options$id = options3.id, id2 = _options$id === void 0 ? void 0 : _options$id, _options$media = options3.media, media = _options$media === void 0 ? void 0 : _options$media, _options$nonce = options3.nonce, nonce = _options$nonce === void 0 ? void 0 : _options$nonce, _options$first = options3.first, first = _options$first === void 0 ? false : _options$first, _options$onMounted = options3.onMounted, onStyleMounted2 = _options$onMounted === void 0 ? void 0 : _options$onMounted, _options$onUpdated = options3.onUpdated, onStyleUpdated2 = _options$onUpdated === void 0 ? void 0 : _options$onUpdated, _options$onLoad = options3.onLoad, onStyleLoaded2 = _options$onLoad === void 0 ? void 0 : _options$onLoad, _options$props = options3.props, props = _options$props === void 0 ? {} : _options$props;
  var stop2 = /* @__PURE__ */ __name(function stop3() {
  }, "stop");
  var load2 = /* @__PURE__ */ __name(function load3(_css) {
    var _props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!document2) return;
    var _styleProps = _objectSpread$j(_objectSpread$j({}, props), _props);
    var _name = _styleProps.name || name, _id2 = _styleProps.id || id2, _nonce = _styleProps.nonce || nonce;
    styleRef.value = document2.querySelector('style[data-primevue-style-id="'.concat(_name, '"]')) || document2.getElementById(_id2) || document2.createElement("style");
    if (!styleRef.value.isConnected) {
      cssRef.value = _css || css4;
      setAttributes(styleRef.value, {
        type: "text/css",
        id: _id2,
        media,
        nonce: _nonce
      });
      first ? document2.head.prepend(styleRef.value) : document2.head.appendChild(styleRef.value);
      setAttribute(styleRef.value, "data-primevue-style-id", _name);
      setAttributes(styleRef.value, _styleProps);
      styleRef.value.onload = function(event2) {
        return onStyleLoaded2 === null || onStyleLoaded2 === void 0 ? void 0 : onStyleLoaded2(event2, {
          name: _name
        });
      };
      onStyleMounted2 === null || onStyleMounted2 === void 0 || onStyleMounted2(_name);
    }
    if (isLoaded.value) return;
    stop2 = watch(cssRef, function(value3) {
      styleRef.value.textContent = value3;
      onStyleUpdated2 === null || onStyleUpdated2 === void 0 || onStyleUpdated2(_name);
    }, {
      immediate: true
    });
    isLoaded.value = true;
  }, "load");
  var unload = /* @__PURE__ */ __name(function unload2() {
    if (!document2 || !isLoaded.value) return;
    stop2();
    isExist(styleRef.value) && document2.head.removeChild(styleRef.value);
    isLoaded.value = false;
  }, "unload");
  if (immediate && !manual) tryOnMounted$1(load2);
  return {
    id: id2,
    name,
    el: styleRef,
    css: cssRef,
    unload,
    load: load2,
    isLoaded: readonly(isLoaded)
  };
}
__name(useStyle, "useStyle");
function _typeof$l(o) {
  "@babel/helpers - typeof";
  return _typeof$l = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$l(o);
}
__name(_typeof$l, "_typeof$l");
function _slicedToArray$5(r, e) {
  return _arrayWithHoles$5(r) || _iterableToArrayLimit$5(r, e) || _unsupportedIterableToArray$l(r, e) || _nonIterableRest$5();
}
__name(_slicedToArray$5, "_slicedToArray$5");
function _nonIterableRest$5() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableRest$5, "_nonIterableRest$5");
function _unsupportedIterableToArray$l(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$l(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$l(r, a) : void 0;
  }
}
__name(_unsupportedIterableToArray$l, "_unsupportedIterableToArray$l");
function _arrayLikeToArray$l(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
__name(_arrayLikeToArray$l, "_arrayLikeToArray$l");
function _iterableToArrayLimit$5(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i2, u, a = [], f = true, o = false;
    try {
      if (i2 = (t = t.call(r)).next, 0 === l) ;
      else for (; !(f = (e = i2.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
__name(_iterableToArrayLimit$5, "_iterableToArrayLimit$5");
function _arrayWithHoles$5(r) {
  if (Array.isArray(r)) return r;
}
__name(_arrayWithHoles$5, "_arrayWithHoles$5");
function ownKeys$i(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
__name(ownKeys$i, "ownKeys$i");
function _objectSpread$i(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$i(Object(t), true).forEach(function(r2) {
      _defineProperty$l(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$i(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
__name(_objectSpread$i, "_objectSpread$i");
function _defineProperty$l(e, r, t) {
  return (r = _toPropertyKey$k(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty$l, "_defineProperty$l");
function _toPropertyKey$k(t) {
  var i2 = _toPrimitive$k(t, "string");
  return "symbol" == _typeof$l(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$k, "_toPropertyKey$k");
function _toPrimitive$k(t, r) {
  if ("object" != _typeof$l(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$l(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive$k, "_toPrimitive$k");
var theme$z = /* @__PURE__ */ __name(function theme2(_ref) {
  var dt3 = _ref.dt;
  return "\n* {\n    box-sizing: border-box;\n}\n\n/* Non vue overlay animations */\n.p-connected-overlay {\n    opacity: 0;\n    transform: scaleY(0.8);\n    transition: transform 0.12s cubic-bezier(0, 0, 0.2, 1),\n        opacity 0.12s cubic-bezier(0, 0, 0.2, 1);\n}\n\n.p-connected-overlay-visible {\n    opacity: 1;\n    transform: scaleY(1);\n}\n\n.p-connected-overlay-hidden {\n    opacity: 0;\n    transform: scaleY(1);\n    transition: opacity 0.1s linear;\n}\n\n/* Vue based overlay animations */\n.p-connected-overlay-enter-from {\n    opacity: 0;\n    transform: scaleY(0.8);\n}\n\n.p-connected-overlay-leave-to {\n    opacity: 0;\n}\n\n.p-connected-overlay-enter-active {\n    transition: transform 0.12s cubic-bezier(0, 0, 0.2, 1),\n        opacity 0.12s cubic-bezier(0, 0, 0.2, 1);\n}\n\n.p-connected-overlay-leave-active {\n    transition: opacity 0.1s linear;\n}\n\n/* Toggleable Content */\n.p-toggleable-content-enter-from,\n.p-toggleable-content-leave-to {\n    max-height: 0;\n}\n\n.p-toggleable-content-enter-to,\n.p-toggleable-content-leave-from {\n    max-height: 1000px;\n}\n\n.p-toggleable-content-leave-active {\n    overflow: hidden;\n    transition: max-height 0.45s cubic-bezier(0, 1, 0, 1);\n}\n\n.p-toggleable-content-enter-active {\n    overflow: hidden;\n    transition: max-height 1s ease-in-out;\n}\n\n.p-disabled,\n.p-disabled * {\n    cursor: default;\n    pointer-events: none;\n    user-select: none;\n}\n\n.p-disabled,\n.p-component:disabled {\n    opacity: ".concat(dt3("disabled.opacity"), ";\n}\n\n.pi {\n    font-size: ").concat(dt3("icon.size"), ";\n}\n\n.p-icon {\n    width: ").concat(dt3("icon.size"), ";\n    height: ").concat(dt3("icon.size"), ";\n}\n\n.p-overlay-mask {\n    background: ").concat(dt3("mask.background"), ";\n    color: ").concat(dt3("mask.color"), ";\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n}\n\n.p-overlay-mask-enter {\n    animation: p-overlay-mask-enter-animation ").concat(dt3("mask.transition.duration"), " forwards;\n}\n\n.p-overlay-mask-leave {\n    animation: p-overlay-mask-leave-animation ").concat(dt3("mask.transition.duration"), " forwards;\n}\n\n@keyframes p-overlay-mask-enter-animation {\n    from {\n        background: transparent;\n    }\n    to {\n        background: ").concat(dt3("mask.background"), ";\n    }\n}\n@keyframes p-overlay-mask-leave-animation {\n    from {\n        background: ").concat(dt3("mask.background"), ";\n    }\n    to {\n        background: transparent;\n    }\n}\n");
}, "theme");
var css$2 = /* @__PURE__ */ __name(function css2(_ref2) {
  var dt3 = _ref2.dt;
  return "\n.p-hidden-accessible {\n    border: 0;\n    clip: rect(0 0 0 0);\n    height: 1px;\n    margin: -1px;\n    overflow: hidden;\n    padding: 0;\n    position: absolute;\n    width: 1px;\n}\n\n.p-hidden-accessible input,\n.p-hidden-accessible select {\n    transform: scale(0);\n}\n\n.p-overflow-hidden {\n    overflow: hidden;\n    padding-right: ".concat(dt3("scrollbar.width"), ";\n}\n");
}, "css");
var classes$C = {};
var inlineStyles$7 = {};
var BaseStyle = {
  name: "base",
  css: css$2,
  theme: theme$z,
  classes: classes$C,
  inlineStyles: inlineStyles$7,
  load: /* @__PURE__ */ __name(function load(style) {
    var options3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var transform2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function(cs) {
      return cs;
    };
    var computedStyle = transform2(resolve(style, {
      dt: dt$1
    }));
    return computedStyle ? useStyle(minifyCSS(computedStyle), _objectSpread$i({
      name: this.name
    }, options3)) : {};
  }, "load"),
  loadCSS: /* @__PURE__ */ __name(function loadCSS() {
    var options3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return this.load(this.css, options3);
  }, "loadCSS"),
  loadTheme: /* @__PURE__ */ __name(function loadTheme() {
    var _this = this;
    var options3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return this.load(this.theme, options3, function(computedStyle) {
      return config_default.transformCSS(options3.name || _this.name, computedStyle);
    });
  }, "loadTheme"),
  getCommonTheme: /* @__PURE__ */ __name(function getCommonTheme(params) {
    return config_default.getCommon(this.name, params);
  }, "getCommonTheme"),
  getComponentTheme: /* @__PURE__ */ __name(function getComponentTheme(params) {
    return config_default.getComponent(this.name, params);
  }, "getComponentTheme"),
  getDirectiveTheme: /* @__PURE__ */ __name(function getDirectiveTheme(params) {
    return config_default.getDirective(this.name, params);
  }, "getDirectiveTheme"),
  getPresetTheme: /* @__PURE__ */ __name(function getPresetTheme(preset, selector, params) {
    return config_default.getCustomPreset(this.name, preset, selector, params);
  }, "getPresetTheme"),
  getLayerOrderThemeCSS: /* @__PURE__ */ __name(function getLayerOrderThemeCSS() {
    return config_default.getLayerOrderCSS(this.name);
  }, "getLayerOrderThemeCSS"),
  getStyleSheet: /* @__PURE__ */ __name(function getStyleSheet() {
    var extendedCSS = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (this.css) {
      var _css = resolve(this.css, {
        dt: dt$1
      });
      var _style = minifyCSS("".concat(_css).concat(extendedCSS));
      var _props = Object.entries(props).reduce(function(acc, _ref3) {
        var _ref4 = _slicedToArray$5(_ref3, 2), k = _ref4[0], v2 = _ref4[1];
        return acc.push("".concat(k, '="').concat(v2, '"')) && acc;
      }, []).join(" ");
      return '<style type="text/css" data-primevue-style-id="'.concat(this.name, '" ').concat(_props, ">").concat(_style, "</style>");
    }
    return "";
  }, "getStyleSheet"),
  getCommonThemeStyleSheet: /* @__PURE__ */ __name(function getCommonThemeStyleSheet(params) {
    var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return config_default.getCommonStyleSheet(this.name, params, props);
  }, "getCommonThemeStyleSheet"),
  getThemeStyleSheet: /* @__PURE__ */ __name(function getThemeStyleSheet(params) {
    var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var css4 = [config_default.getStyleSheet(this.name, params, props)];
    if (this.theme) {
      var name = this.name === "base" ? "global-style" : "".concat(this.name, "-style");
      var _css = resolve(this.theme, {
        dt: dt$1
      });
      var _style = minifyCSS(config_default.transformCSS(name, _css));
      var _props = Object.entries(props).reduce(function(acc, _ref5) {
        var _ref6 = _slicedToArray$5(_ref5, 2), k = _ref6[0], v2 = _ref6[1];
        return acc.push("".concat(k, '="').concat(v2, '"')) && acc;
      }, []).join(" ");
      css4.push('<style type="text/css" data-primevue-style-id="'.concat(name, '" ').concat(_props, ">").concat(_style, "</style>"));
    }
    return css4.join("");
  }, "getThemeStyleSheet"),
  extend: /* @__PURE__ */ __name(function extend2(style) {
    return _objectSpread$i(_objectSpread$i({}, this), {}, {
      css: void 0,
      theme: void 0
    }, style);
  }, "extend")
};
var PrimeVueService = EventBus();
function _typeof$k(o) {
  "@babel/helpers - typeof";
  return _typeof$k = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$k(o);
}
__name(_typeof$k, "_typeof$k");
function ownKeys$h(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
__name(ownKeys$h, "ownKeys$h");
function _objectSpread$h(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$h(Object(t), true).forEach(function(r2) {
      _defineProperty$k(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$h(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
__name(_objectSpread$h, "_objectSpread$h");
function _defineProperty$k(e, r, t) {
  return (r = _toPropertyKey$j(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty$k, "_defineProperty$k");
function _toPropertyKey$j(t) {
  var i2 = _toPrimitive$j(t, "string");
  return "symbol" == _typeof$k(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$j, "_toPropertyKey$j");
function _toPrimitive$j(t, r) {
  if ("object" != _typeof$k(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$k(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive$j, "_toPrimitive$j");
var defaultOptions$2 = {
  ripple: false,
  inputStyle: null,
  inputVariant: null,
  locale: {
    startsWith: "Starts with",
    contains: "Contains",
    notContains: "Not contains",
    endsWith: "Ends with",
    equals: "Equals",
    notEquals: "Not equals",
    noFilter: "No Filter",
    lt: "Less than",
    lte: "Less than or equal to",
    gt: "Greater than",
    gte: "Greater than or equal to",
    dateIs: "Date is",
    dateIsNot: "Date is not",
    dateBefore: "Date is before",
    dateAfter: "Date is after",
    clear: "Clear",
    apply: "Apply",
    matchAll: "Match All",
    matchAny: "Match Any",
    addRule: "Add Rule",
    removeRule: "Remove Rule",
    accept: "Yes",
    reject: "No",
    choose: "Choose",
    upload: "Upload",
    cancel: "Cancel",
    completed: "Completed",
    pending: "Pending",
    fileSizeTypes: ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"],
    dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    chooseYear: "Choose Year",
    chooseMonth: "Choose Month",
    chooseDate: "Choose Date",
    prevDecade: "Previous Decade",
    nextDecade: "Next Decade",
    prevYear: "Previous Year",
    nextYear: "Next Year",
    prevMonth: "Previous Month",
    nextMonth: "Next Month",
    prevHour: "Previous Hour",
    nextHour: "Next Hour",
    prevMinute: "Previous Minute",
    nextMinute: "Next Minute",
    prevSecond: "Previous Second",
    nextSecond: "Next Second",
    am: "am",
    pm: "pm",
    today: "Today",
    weekHeader: "Wk",
    firstDayOfWeek: 0,
    showMonthAfterYear: false,
    dateFormat: "mm/dd/yy",
    weak: "Weak",
    medium: "Medium",
    strong: "Strong",
    passwordPrompt: "Enter a password",
    emptyFilterMessage: "No results found",
    searchMessage: "{0} results are available",
    selectionMessage: "{0} items selected",
    emptySelectionMessage: "No selected item",
    emptySearchMessage: "No results found",
    fileChosenMessage: "{0} files",
    noFileChosenMessage: "No file chosen",
    emptyMessage: "No available options",
    aria: {
      trueLabel: "True",
      falseLabel: "False",
      nullLabel: "Not Selected",
      star: "1 star",
      stars: "{star} stars",
      selectAll: "All items selected",
      unselectAll: "All items unselected",
      close: "Close",
      previous: "Previous",
      next: "Next",
      navigation: "Navigation",
      scrollTop: "Scroll Top",
      moveTop: "Move Top",
      moveUp: "Move Up",
      moveDown: "Move Down",
      moveBottom: "Move Bottom",
      moveToTarget: "Move to Target",
      moveToSource: "Move to Source",
      moveAllToTarget: "Move All to Target",
      moveAllToSource: "Move All to Source",
      pageLabel: "Page {page}",
      firstPageLabel: "First Page",
      lastPageLabel: "Last Page",
      nextPageLabel: "Next Page",
      prevPageLabel: "Previous Page",
      rowsPerPageLabel: "Rows per page",
      jumpToPageDropdownLabel: "Jump to Page Dropdown",
      jumpToPageInputLabel: "Jump to Page Input",
      selectRow: "Row Selected",
      unselectRow: "Row Unselected",
      expandRow: "Row Expanded",
      collapseRow: "Row Collapsed",
      showFilterMenu: "Show Filter Menu",
      hideFilterMenu: "Hide Filter Menu",
      filterOperator: "Filter Operator",
      filterConstraint: "Filter Constraint",
      editRow: "Row Edit",
      saveEdit: "Save Edit",
      cancelEdit: "Cancel Edit",
      listView: "List View",
      gridView: "Grid View",
      slide: "Slide",
      slideNumber: "{slideNumber}",
      zoomImage: "Zoom Image",
      zoomIn: "Zoom In",
      zoomOut: "Zoom Out",
      rotateRight: "Rotate Right",
      rotateLeft: "Rotate Left",
      listLabel: "Option List"
    }
  },
  filterMatchModeOptions: {
    text: [FilterMatchMode.STARTS_WITH, FilterMatchMode.CONTAINS, FilterMatchMode.NOT_CONTAINS, FilterMatchMode.ENDS_WITH, FilterMatchMode.EQUALS, FilterMatchMode.NOT_EQUALS],
    numeric: [FilterMatchMode.EQUALS, FilterMatchMode.NOT_EQUALS, FilterMatchMode.LESS_THAN, FilterMatchMode.LESS_THAN_OR_EQUAL_TO, FilterMatchMode.GREATER_THAN, FilterMatchMode.GREATER_THAN_OR_EQUAL_TO],
    date: [FilterMatchMode.DATE_IS, FilterMatchMode.DATE_IS_NOT, FilterMatchMode.DATE_BEFORE, FilterMatchMode.DATE_AFTER]
  },
  zIndex: {
    modal: 1100,
    overlay: 1e3,
    menu: 1e3,
    tooltip: 1100
  },
  theme: void 0,
  unstyled: false,
  pt: void 0,
  ptOptions: {
    mergeSections: true,
    mergeProps: false
  },
  csp: {
    nonce: void 0
  }
};
var PrimeVueSymbol = Symbol();
function usePrimeVue() {
  var PrimeVue2 = inject(PrimeVueSymbol);
  if (!PrimeVue2) {
    throw new Error("PrimeVue is not installed!");
  }
  return PrimeVue2;
}
__name(usePrimeVue, "usePrimeVue");
function setup(app2, options3) {
  var PrimeVue2 = {
    config: reactive(options3)
  };
  app2.config.globalProperties.$primevue = PrimeVue2;
  app2.provide(PrimeVueSymbol, PrimeVue2);
  clearConfig();
  setupConfig(app2, PrimeVue2);
  return PrimeVue2;
}
__name(setup, "setup");
var stopWatchers = [];
function clearConfig() {
  service_default.clear();
  stopWatchers.forEach(function(fn) {
    return fn === null || fn === void 0 ? void 0 : fn();
  });
  stopWatchers = [];
}
__name(clearConfig, "clearConfig");
function setupConfig(app2, PrimeVue2) {
  var isThemeChanged = ref(false);
  var loadCommonTheme = /* @__PURE__ */ __name(function loadCommonTheme2() {
    if (!config_default.isStyleNameLoaded("common")) {
      var _BaseStyle$getCommonT, _PrimeVue$config;
      var _ref = ((_BaseStyle$getCommonT = BaseStyle.getCommonTheme) === null || _BaseStyle$getCommonT === void 0 ? void 0 : _BaseStyle$getCommonT.call(BaseStyle)) || {}, primitive = _ref.primitive, semantic = _ref.semantic;
      var styleOptions = {
        nonce: (_PrimeVue$config = PrimeVue2.config) === null || _PrimeVue$config === void 0 || (_PrimeVue$config = _PrimeVue$config.csp) === null || _PrimeVue$config === void 0 ? void 0 : _PrimeVue$config.nonce
      };
      BaseStyle.load(primitive === null || primitive === void 0 ? void 0 : primitive.css, _objectSpread$h({
        name: "primitive-variables"
      }, styleOptions));
      BaseStyle.load(semantic === null || semantic === void 0 ? void 0 : semantic.css, _objectSpread$h({
        name: "semantic-variables"
      }, styleOptions));
      BaseStyle.loadTheme(_objectSpread$h({
        name: "global-style"
      }, styleOptions));
      config_default.setLoadedStyleName("common");
    }
  }, "loadCommonTheme");
  service_default.on("theme:change", function(newTheme) {
    if (!isThemeChanged.value) {
      app2.config.globalProperties.$primevue.config.theme = newTheme;
      isThemeChanged.value = true;
    }
  });
  var stopConfigWatcher = watch(PrimeVue2.config, function(newValue, oldValue) {
    PrimeVueService.emit("config:change", {
      newValue,
      oldValue
    });
  }, {
    immediate: true,
    deep: true
  });
  var stopRippleWatcher = watch(function() {
    return PrimeVue2.config.ripple;
  }, function(newValue, oldValue) {
    PrimeVueService.emit("config:ripple:change", {
      newValue,
      oldValue
    });
  }, {
    immediate: true,
    deep: true
  });
  var stopThemeWatcher = watch(function() {
    return PrimeVue2.config.theme;
  }, function(newValue, oldValue) {
    if (!isThemeChanged.value) {
      config_default.setTheme(newValue);
    }
    if (!PrimeVue2.config.unstyled) {
      loadCommonTheme();
    }
    isThemeChanged.value = false;
    PrimeVueService.emit("config:theme:change", {
      newValue,
      oldValue
    });
  }, {
    immediate: true,
    deep: true
  });
  var stopUnstyledWatcher = watch(function() {
    return PrimeVue2.config.unstyled;
  }, function(newValue, oldValue) {
    if (!newValue && PrimeVue2.config.theme) {
      loadCommonTheme();
    }
    PrimeVueService.emit("config:unstyled:change", {
      newValue,
      oldValue
    });
  }, {
    immediate: true,
    deep: true
  });
  stopWatchers.push(stopConfigWatcher);
  stopWatchers.push(stopRippleWatcher);
  stopWatchers.push(stopThemeWatcher);
  stopWatchers.push(stopUnstyledWatcher);
}
__name(setupConfig, "setupConfig");
var PrimeVue = {
  install: /* @__PURE__ */ __name(function install2(app2, options3) {
    var configOptions = _objectSpread$h(_objectSpread$h({}, defaultOptions$2), options3);
    setup(app2, configOptions);
  }, "install")
};
var index$1l = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  panel: {
    borderWidth: "0 0 1px 0",
    borderColor: "{content.border.color}"
  },
  header: {
    color: "{text.muted.color}",
    hoverColor: "{text.color}",
    activeColor: "{text.color}",
    padding: "1.125rem",
    fontWeight: "600",
    borderRadius: "0",
    borderWidth: "0",
    borderColor: "{content.border.color}",
    background: "{content.background}",
    hoverBackground: "{content.background}",
    activeBackground: "{content.background}",
    activeHoverBackground: "{content.background}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    },
    toggleIcon: {
      color: "{text.muted.color}",
      hoverColor: "{text.color}",
      activeColor: "{text.color}",
      activeHoverColor: "{text.color}"
    },
    first: {
      topBorderRadius: "{content.border.radius}",
      borderWidth: "0"
    },
    last: {
      bottomBorderRadius: "{content.border.radius}",
      activeBottomBorderRadius: "0"
    }
  },
  content: {
    borderWidth: "0",
    borderColor: "{content.border.color}",
    background: "{content.background}",
    color: "{text.color}",
    padding: "0 1.125rem 1.125rem 1.125rem"
  }
};
var index$1k = {
  root: {
    background: "{form.field.background}",
    disabledBackground: "{form.field.disabled.background}",
    filledBackground: "{form.field.filled.background}",
    filledFocusBackground: "{form.field.filled.focus.background}",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.hover.border.color}",
    focusBorderColor: "{form.field.focus.border.color}",
    invalidBorderColor: "{form.field.invalid.border.color}",
    color: "{form.field.color}",
    disabledColor: "{form.field.disabled.color}",
    placeholderColor: "{form.field.placeholder.color}",
    shadow: "{form.field.shadow}",
    paddingX: "{form.field.padding.x}",
    paddingY: "{form.field.padding.y}",
    borderRadius: "{form.field.border.radius}",
    focusRing: {
      width: "{form.field.focus.ring.width}",
      style: "{form.field.focus.ring.style}",
      color: "{form.field.focus.ring.color}",
      offset: "{form.field.focus.ring.offset}",
      shadow: "{form.field.focus.ring.shadow}"
    },
    transitionDuration: "{form.field.transition.duration}"
  },
  overlay: {
    background: "{overlay.select.background}",
    borderColor: "{overlay.select.border.color}",
    borderRadius: "{overlay.select.border.radius}",
    color: "{overlay.select.color}",
    shadow: "{overlay.select.shadow}"
  },
  list: {
    padding: "{list.padding}",
    gap: "{list.gap}"
  },
  option: {
    focusBackground: "{list.option.focus.background}",
    selectedBackground: "{list.option.selected.background}",
    selectedFocusBackground: "{list.option.selected.focus.background}",
    color: "{list.option.color}",
    focusColor: "{list.option.focus.color}",
    selectedColor: "{list.option.selected.color}",
    selectedFocusColor: "{list.option.selected.focus.color}",
    padding: "{list.option.padding}",
    borderRadius: "{list.option.border.radius}"
  },
  optionGroup: {
    background: "{list.option.group.background}",
    color: "{list.option.group.color}",
    fontWeight: "{list.option.group.font.weight}",
    padding: "{list.option.group.padding}"
  },
  dropdown: {
    width: "2.5rem",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.border.color}",
    activeBorderColor: "{form.field.border.color}",
    borderRadius: "{form.field.border.radius}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  chip: {
    borderRadius: "{border.radius.sm}"
  },
  emptyMessage: {
    padding: "{list.option.padding}"
  },
  colorScheme: {
    light: {
      dropdown: {
        background: "{surface.100}",
        hoverBackground: "{surface.200}",
        activeBackground: "{surface.300}",
        color: "{surface.600}",
        hoverColor: "{surface.700}",
        activeColor: "{surface.800}"
      }
    },
    dark: {
      dropdown: {
        background: "{surface.800}",
        hoverBackground: "{surface.700}",
        activeBackground: "{surface.600}",
        color: "{surface.300}",
        hoverColor: "{surface.200}",
        activeColor: "{surface.100}"
      }
    }
  }
};
var index$1j = {
  root: {
    width: "2rem",
    height: "2rem",
    fontSize: "1rem",
    background: "{content.border.color}",
    borderRadius: "{content.border.radius}"
  },
  group: {
    borderColor: "{content.background}",
    offset: "-1rem"
  },
  lg: {
    width: "3rem",
    height: "3rem",
    fontSize: "1.5rem"
  },
  xl: {
    width: "4rem",
    height: "4rem",
    fontSize: "2rem"
  }
};
var index$1i = {
  root: {
    borderRadius: "{border.radius.md}",
    padding: "0 0.5rem",
    fontSize: "0.75rem",
    fontWeight: "700",
    minWidth: "1.5rem",
    height: "1.5rem"
  },
  dot: {
    size: "0.5rem"
  },
  sm: {
    fontSize: "0.625rem",
    minWidth: "1.25rem",
    height: "1.25rem"
  },
  lg: {
    fontSize: "0.875rem",
    minWidth: "1.75rem",
    height: "1.75rem"
  },
  xl: {
    fontSize: "1rem",
    minWidth: "2rem",
    height: "2rem"
  },
  colorScheme: {
    light: {
      primary: {
        background: "{primary.color}",
        color: "{primary.contrast.color}"
      },
      secondary: {
        background: "{surface.100}",
        color: "{surface.600}"
      },
      success: {
        background: "{green.500}",
        color: "{surface.0}"
      },
      info: {
        background: "{sky.500}",
        color: "{surface.0}"
      },
      warn: {
        background: "{orange.500}",
        color: "{surface.0}"
      },
      danger: {
        background: "{red.500}",
        color: "{surface.0}"
      },
      contrast: {
        background: "{surface.950}",
        color: "{surface.0}"
      }
    },
    dark: {
      primary: {
        background: "{primary.color}",
        color: "{primary.contrast.color}"
      },
      secondary: {
        background: "{surface.800}",
        color: "{surface.300}"
      },
      success: {
        background: "{green.400}",
        color: "{green.950}"
      },
      info: {
        background: "{sky.400}",
        color: "{sky.950}"
      },
      warn: {
        background: "{orange.400}",
        color: "{orange.950}"
      },
      danger: {
        background: "{red.400}",
        color: "{red.950}"
      },
      contrast: {
        background: "{surface.0}",
        color: "{surface.950}"
      }
    }
  }
};
var index$1h = {
  root: {
    borderRadius: "{content.border.radius}"
  }
};
var index$1g = {
  root: {
    padding: "1rem",
    background: "{content.background}",
    gap: "0.5rem",
    transitionDuration: "{transition.duration}"
  },
  item: {
    color: "{text.muted.color}",
    hoverColor: "{text.color}",
    iconColor: "{navigation.item.icon.color}",
    borderRadius: "{content.border.radius}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  separator: {
    color: "{navigation.item.icon.color}"
  }
};
var index$1f = {
  root: {
    borderRadius: "{form.field.border.radius}",
    roundedBorderRadius: "2rem",
    gap: "0.5rem",
    paddingX: "{form.field.padding.x}",
    paddingY: "{form.field.padding.y}",
    iconOnlyWidth: "2.5rem",
    sm: {
      fontSize: "0.875rem",
      paddingX: "0.625rem",
      paddingY: "0.375rem"
    },
    lg: {
      fontSize: "1.125rem",
      paddingX: "0.875rem",
      paddingY: "0.625rem"
    },
    label: {
      fontWeight: "500"
    },
    raisedShadow: "0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12)",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      offset: "{focus.ring.offset}"
    },
    badgeSize: "1rem",
    transitionDuration: "{form.field.transition.duration}"
  },
  colorScheme: {
    light: {
      root: {
        primary: {
          background: "{primary.color}",
          hoverBackground: "{primary.hover.color}",
          activeBackground: "{primary.active.color}",
          borderColor: "{primary.color}",
          hoverBorderColor: "{primary.hover.color}",
          activeBorderColor: "{primary.active.color}",
          color: "{primary.contrast.color}",
          hoverColor: "{primary.contrast.color}",
          activeColor: "{primary.contrast.color}",
          focusRing: {
            color: "{primary.color}",
            shadow: "none"
          }
        },
        secondary: {
          background: "{surface.100}",
          hoverBackground: "{surface.200}",
          activeBackground: "{surface.300}",
          borderColor: "{surface.100}",
          hoverBorderColor: "{surface.200}",
          activeBorderColor: "{surface.300}",
          color: "{surface.600}",
          hoverColor: "{surface.700}",
          activeColor: "{surface.800}",
          focusRing: {
            color: "{surface.600}",
            shadow: "none"
          }
        },
        info: {
          background: "{sky.500}",
          hoverBackground: "{sky.600}",
          activeBackground: "{sky.700}",
          borderColor: "{sky.500}",
          hoverBorderColor: "{sky.600}",
          activeBorderColor: "{sky.700}",
          color: "#ffffff",
          hoverColor: "#ffffff",
          activeColor: "#ffffff",
          focusRing: {
            color: "{sky.500}",
            shadow: "none"
          }
        },
        success: {
          background: "{green.500}",
          hoverBackground: "{green.600}",
          activeBackground: "{green.700}",
          borderColor: "{green.500}",
          hoverBorderColor: "{green.600}",
          activeBorderColor: "{green.700}",
          color: "#ffffff",
          hoverColor: "#ffffff",
          activeColor: "#ffffff",
          focusRing: {
            color: "{green.500}",
            shadow: "none"
          }
        },
        warn: {
          background: "{orange.500}",
          hoverBackground: "{orange.600}",
          activeBackground: "{orange.700}",
          borderColor: "{orange.500}",
          hoverBorderColor: "{orange.600}",
          activeBorderColor: "{orange.700}",
          color: "#ffffff",
          hoverColor: "#ffffff",
          activeColor: "#ffffff",
          focusRing: {
            color: "{orange.500}",
            shadow: "none"
          }
        },
        help: {
          background: "{purple.500}",
          hoverBackground: "{purple.600}",
          activeBackground: "{purple.700}",
          borderColor: "{purple.500}",
          hoverBorderColor: "{purple.600}",
          activeBorderColor: "{purple.700}",
          color: "#ffffff",
          hoverColor: "#ffffff",
          activeColor: "#ffffff",
          focusRing: {
            color: "{purple.500}",
            shadow: "none"
          }
        },
        danger: {
          background: "{red.500}",
          hoverBackground: "{red.600}",
          activeBackground: "{red.700}",
          borderColor: "{red.500}",
          hoverBorderColor: "{red.600}",
          activeBorderColor: "{red.700}",
          color: "#ffffff",
          hoverColor: "#ffffff",
          activeColor: "#ffffff",
          focusRing: {
            color: "{red.500}",
            shadow: "none"
          }
        },
        contrast: {
          background: "{surface.950}",
          hoverBackground: "{surface.900}",
          activeBackground: "{surface.800}",
          borderColor: "{surface.950}",
          hoverBorderColor: "{surface.900}",
          activeBorderColor: "{surface.800}",
          color: "{surface.0}",
          hoverColor: "{surface.0}",
          activeColor: "{surface.0}",
          focusRing: {
            color: "{surface.950}",
            shadow: "none"
          }
        }
      },
      outlined: {
        primary: {
          hoverBackground: "{primary.50}",
          activeBackground: "{primary.100}",
          borderColor: "{primary.200}",
          color: "{primary.color}"
        },
        secondary: {
          hoverBackground: "{surface.50}",
          activeBackground: "{surface.100}",
          borderColor: "{surface.200}",
          color: "{surface.500}"
        },
        success: {
          hoverBackground: "{green.50}",
          activeBackground: "{green.100}",
          borderColor: "{green.200}",
          color: "{green.500}"
        },
        info: {
          hoverBackground: "{sky.50}",
          activeBackground: "{sky.100}",
          borderColor: "{sky.200}",
          color: "{sky.500}"
        },
        warn: {
          hoverBackground: "{orange.50}",
          activeBackground: "{orange.100}",
          borderColor: "{orange.200}",
          color: "{orange.500}"
        },
        help: {
          hoverBackground: "{purple.50}",
          activeBackground: "{purple.100}",
          borderColor: "{purple.200}",
          color: "{purple.500}"
        },
        danger: {
          hoverBackground: "{red.50}",
          activeBackground: "{red.100}",
          borderColor: "{red.200}",
          color: "{red.500}"
        },
        contrast: {
          hoverBackground: "{surface.50}",
          activeBackground: "{surface.100}",
          borderColor: "{surface.700}",
          color: "{surface.950}"
        },
        plain: {
          hoverBackground: "{surface.50}",
          activeBackground: "{surface.100}",
          borderColor: "{surface.200}",
          color: "{surface.700}"
        }
      },
      text: {
        primary: {
          hoverBackground: "{primary.50}",
          activeBackground: "{primary.100}",
          color: "{primary.color}"
        },
        secondary: {
          hoverBackground: "{surface.50}",
          activeBackground: "{surface.100}",
          color: "{surface.500}"
        },
        success: {
          hoverBackground: "{green.50}",
          activeBackground: "{green.100}",
          color: "{green.500}"
        },
        info: {
          hoverBackground: "{sky.50}",
          activeBackground: "{sky.100}",
          color: "{sky.500}"
        },
        warn: {
          hoverBackground: "{orange.50}",
          activeBackground: "{orange.100}",
          color: "{orange.500}"
        },
        help: {
          hoverBackground: "{purple.50}",
          activeBackground: "{purple.100}",
          color: "{purple.500}"
        },
        danger: {
          hoverBackground: "{red.50}",
          activeBackground: "{red.100}",
          color: "{red.500}"
        },
        plain: {
          hoverBackground: "{surface.50}",
          activeBackground: "{surface.100}",
          color: "{surface.700}"
        }
      },
      link: {
        color: "{primary.color}",
        hoverColor: "{primary.color}",
        activeColor: "{primary.color}"
      }
    },
    dark: {
      root: {
        primary: {
          background: "{primary.color}",
          hoverBackground: "{primary.hover.color}",
          activeBackground: "{primary.active.color}",
          borderColor: "{primary.color}",
          hoverBorderColor: "{primary.hover.color}",
          activeBorderColor: "{primary.active.color}",
          color: "{primary.contrast.color}",
          hoverColor: "{primary.contrast.color}",
          activeColor: "{primary.contrast.color}",
          focusRing: {
            color: "{primary.color}",
            shadow: "none"
          }
        },
        secondary: {
          background: "{surface.800}",
          hoverBackground: "{surface.700}",
          activeBackground: "{surface.600}",
          borderColor: "{surface.800}",
          hoverBorderColor: "{surface.700}",
          activeBorderColor: "{surface.600}",
          color: "{surface.300}",
          hoverColor: "{surface.200}",
          activeColor: "{surface.100}",
          focusRing: {
            color: "{surface.300}",
            shadow: "none"
          }
        },
        info: {
          background: "{sky.400}",
          hoverBackground: "{sky.300}",
          activeBackground: "{sky.200}",
          borderColor: "{sky.400}",
          hoverBorderColor: "{sky.300}",
          activeBorderColor: "{sky.200}",
          color: "{sky.950}",
          hoverColor: "{sky.950}",
          activeColor: "{sky.950}",
          focusRing: {
            color: "{sky.400}",
            shadow: "none"
          }
        },
        success: {
          background: "{green.400}",
          hoverBackground: "{green.300}",
          activeBackground: "{green.200}",
          borderColor: "{green.400}",
          hoverBorderColor: "{green.300}",
          activeBorderColor: "{green.200}",
          color: "{green.950}",
          hoverColor: "{green.950}",
          activeColor: "{green.950}",
          focusRing: {
            color: "{green.400}",
            shadow: "none"
          }
        },
        warn: {
          background: "{orange.400}",
          hoverBackground: "{orange.300}",
          activeBackground: "{orange.200}",
          borderColor: "{orange.400}",
          hoverBorderColor: "{orange.300}",
          activeBorderColor: "{orange.200}",
          color: "{orange.950}",
          hoverColor: "{orange.950}",
          activeColor: "{orange.950}",
          focusRing: {
            color: "{orange.400}",
            shadow: "none"
          }
        },
        help: {
          background: "{purple.400}",
          hoverBackground: "{purple.300}",
          activeBackground: "{purple.200}",
          borderColor: "{purple.400}",
          hoverBorderColor: "{purple.300}",
          activeBorderColor: "{purple.200}",
          color: "{purple.950}",
          hoverColor: "{purple.950}",
          activeColor: "{purple.950}",
          focusRing: {
            color: "{purple.400}",
            shadow: "none"
          }
        },
        danger: {
          background: "{red.400}",
          hoverBackground: "{red.300}",
          activeBackground: "{red.200}",
          borderColor: "{red.400}",
          hoverBorderColor: "{red.300}",
          activeBorderColor: "{red.200}",
          color: "{red.950}",
          hoverColor: "{red.950}",
          activeColor: "{red.950}",
          focusRing: {
            color: "{red.400}",
            shadow: "none"
          }
        },
        contrast: {
          background: "{surface.0}",
          hoverBackground: "{surface.100}",
          activeBackground: "{surface.200}",
          borderColor: "{surface.0}",
          hoverBorderColor: "{surface.100}",
          activeBorderColor: "{surface.200}",
          color: "{surface.950}",
          hoverColor: "{surface.950}",
          activeColor: "{surface.950}",
          focusRing: {
            color: "{surface.0}",
            shadow: "none"
          }
        }
      },
      outlined: {
        primary: {
          hoverBackground: "color-mix(in srgb, {primary.color}, transparent 96%)",
          activeBackground: "color-mix(in srgb, {primary.color}, transparent 84%)",
          borderColor: "{primary.700}",
          color: "{primary.color}"
        },
        secondary: {
          hoverBackground: "rgba(255,255,255,0.04)",
          activeBackground: "rgba(255,255,255,0.16)",
          borderColor: "{surface.700}",
          color: "{surface.400}"
        },
        success: {
          hoverBackground: "color-mix(in srgb, {green.400}, transparent 96%)",
          activeBackground: "color-mix(in srgb, {green.400}, transparent 84%)",
          borderColor: "{green.700}",
          color: "{green.400}"
        },
        info: {
          hoverBackground: "color-mix(in srgb, {sky.400}, transparent 96%)",
          activeBackground: "color-mix(in srgb, {sky.400}, transparent 84%)",
          borderColor: "{sky.700}",
          color: "{sky.400}"
        },
        warn: {
          hoverBackground: "color-mix(in srgb, {orange.400}, transparent 96%)",
          activeBackground: "color-mix(in srgb, {orange.400}, transparent 84%)",
          borderColor: "{orange.700}",
          color: "{orange.400}"
        },
        help: {
          hoverBackground: "color-mix(in srgb, {help.400}, transparent 96%)",
          activeBackground: "color-mix(in srgb, {help.400}, transparent 84%)",
          borderColor: "{purple.700}",
          color: "{purple.400}"
        },
        danger: {
          hoverBackground: "color-mix(in srgb, {danger.400}, transparent 96%)",
          activeBackground: "color-mix(in srgb, {danger.400}, transparent 84%)",
          borderColor: "{red.700}",
          color: "{red.400}"
        },
        contrast: {
          hoverBackground: "{surface.800}",
          activeBackground: "{surface.700}",
          borderColor: "{surface.500}",
          color: "{surface.0}"
        },
        plain: {
          hoverBackground: "{surface.800}",
          activeBackground: "{surface.700}",
          borderColor: "{surface.600}",
          color: "{surface.0}"
        }
      },
      text: {
        primary: {
          hoverBackground: "color-mix(in srgb, {primary.color}, transparent 96%)",
          activeBackground: "color-mix(in srgb, {primary.color}, transparent 84%)",
          color: "{primary.color}"
        },
        secondary: {
          hoverBackground: "{surface.800}",
          activeBackground: "{surface.700}",
          color: "{surface.400}"
        },
        success: {
          hoverBackground: "color-mix(in srgb, {green.400}, transparent 96%)",
          activeBackground: "color-mix(in srgb, {green.400}, transparent 84%)",
          color: "{green.400}"
        },
        info: {
          hoverBackground: "color-mix(in srgb, {sky.400}, transparent 96%)",
          activeBackground: "color-mix(in srgb, {sky.400}, transparent 84%)",
          color: "{sky.400}"
        },
        warn: {
          hoverBackground: "color-mix(in srgb, {orange.400}, transparent 96%)",
          activeBackground: "color-mix(in srgb, {orange.400}, transparent 84%)",
          color: "{orange.400}"
        },
        help: {
          hoverBackground: "color-mix(in srgb, {purple.400}, transparent 96%)",
          activeBackground: "color-mix(in srgb, {purple.400}, transparent 84%)",
          color: "{purple.400}"
        },
        danger: {
          hoverBackground: "color-mix(in srgb, {red.400}, transparent 96%)",
          activeBackground: "color-mix(in srgb, {red.400}, transparent 84%)",
          color: "{red.400}"
        },
        plain: {
          hoverBackground: "{surface.800}",
          activeBackground: "{surface.700}",
          color: "{surface.0}"
        }
      },
      link: {
        color: "{primary.color}",
        hoverColor: "{primary.color}",
        activeColor: "{primary.color}"
      }
    }
  }
};
var index$1e = {
  root: {
    background: "{content.background}",
    borderRadius: "{border.radius.xl}",
    color: "{content.color}",
    shadow: "0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgba(0, 0, 0, 0.1)"
  },
  body: {
    padding: "1.25rem",
    gap: "0.5rem"
  },
  caption: {
    gap: "0.5rem"
  },
  title: {
    fontSize: "1.25rem",
    fontWeight: "500"
  },
  subtitle: {
    color: "{text.muted.color}"
  }
};
var index$1d = {
  root: {
    indicatorList: {
      padding: "1rem",
      gap: "0.5rem"
    },
    indicator: {
      width: "2rem",
      height: "0.5rem",
      borderRadius: "{content.border.radius}",
      focusRing: {
        width: "{focus.ring.width}",
        style: "{focus.ring.style}",
        color: "{focus.ring.color}",
        offset: "{focus.ring.offset}",
        shadow: "{focus.ring.shadow}"
      }
    },
    transitionDuration: "{transition.duration}"
  },
  colorScheme: {
    light: {
      indicator: {
        background: "{surface.200}",
        hoverBackground: "{surface.300}",
        activeBackground: "{primary.color}"
      }
    },
    dark: {
      indicator: {
        background: "{surface.700}",
        hoverBackground: "{surface.600}",
        activeBackground: "{primary.color}"
      }
    }
  }
};
var index$1c = {
  root: {
    background: "{form.field.background}",
    disabledBackground: "{form.field.disabled.background}",
    filledBackground: "{form.field.filled.background}",
    filledFocusBackground: "{form.field.filled.focus.background}",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.hover.border.color}",
    focusBorderColor: "{form.field.focus.border.color}",
    invalidBorderColor: "{form.field.invalid.border.color}",
    color: "{form.field.color}",
    disabledColor: "{form.field.disabled.color}",
    placeholderColor: "{form.field.placeholder.color}",
    shadow: "{form.field.shadow}",
    paddingX: "{form.field.padding.x}",
    paddingY: "{form.field.padding.y}",
    borderRadius: "{form.field.border.radius}",
    focusRing: {
      width: "{form.field.focus.ring.width}",
      style: "{form.field.focus.ring.style}",
      color: "{form.field.focus.ring.color}",
      offset: "{form.field.focus.ring.offset}",
      shadow: "{form.field.focus.ring.shadow}"
    },
    transitionDuration: "{form.field.transition.duration}"
  },
  dropdown: {
    width: "2.5rem",
    color: "{form.field.icon.color}"
  },
  overlay: {
    background: "{overlay.select.background}",
    borderColor: "{overlay.select.border.color}",
    borderRadius: "{overlay.select.border.radius}",
    color: "{overlay.select.color}",
    shadow: "{overlay.select.shadow}"
  },
  list: {
    padding: "{list.padding}",
    gap: "{list.gap}"
  },
  option: {
    focusBackground: "{list.option.focus.background}",
    selectedBackground: "{list.option.selected.background}",
    selectedFocusBackground: "{list.option.selected.focus.background}",
    color: "{list.option.color}",
    focusColor: "{list.option.focus.color}",
    selectedColor: "{list.option.selected.color}",
    selectedFocusColor: "{list.option.selected.focus.color}",
    padding: "{list.option.padding}",
    borderRadius: "{list.option.border.radius}",
    icon: {
      color: "{list.option.icon.color}",
      focusColor: "{list.option.icon.focus.color}",
      size: "0.875rem"
    }
  }
};
var index$1b = {
  root: {
    borderRadius: "{border.radius.sm}",
    width: "1.25rem",
    height: "1.25rem",
    background: "{form.field.background}",
    checkedBackground: "{primary.color}",
    checkedHoverBackground: "{primary.hover.color}",
    disabledBackground: "{form.field.disabled.background}",
    filledBackground: "{form.field.filled.background}",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.hover.border.color}",
    focusBorderColor: "{form.field.border.color}",
    checkedBorderColor: "{primary.color}",
    checkedHoverBorderColor: "{primary.hover.color}",
    checkedFocusBorderColor: "{primary.color}",
    invalidBorderColor: "{form.field.invalid.border.color}",
    shadow: "{form.field.shadow}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    },
    transitionDuration: "{form.field.transition.duration}"
  },
  icon: {
    size: "0.875rem",
    color: "{form.field.color}",
    checkedColor: "{primary.contrast.color}",
    checkedHoverColor: "{primary.contrast.color}",
    disabledColor: "{form.field.disabled.color}"
  }
};
var index$1a = {
  root: {
    borderRadius: "16px",
    paddingX: "0.75rem",
    paddingY: "0.5rem",
    gap: "0.5rem",
    transitionDuration: "{transition.duration}"
  },
  image: {
    width: "2rem",
    height: "2rem"
  },
  icon: {
    size: "1rem"
  },
  removeIcon: {
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{form.field.focus.ring.shadow}"
    }
  },
  colorScheme: {
    light: {
      root: {
        background: "{surface.100}",
        color: "{surface.800}"
      },
      icon: {
        color: "{surface.800}"
      },
      removeIcon: {
        color: "{surface.800}"
      }
    },
    dark: {
      root: {
        background: "{surface.800}",
        color: "{surface.0}"
      },
      icon: {
        color: "{surface.0}"
      },
      removeIcon: {
        color: "{surfaec.0}"
      }
    }
  }
};
var index$19 = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  preview: {
    width: "1.5rem",
    height: "1.5rem",
    borderRadius: "{form.field.border.radius}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  panel: {
    shadow: "{overlay.popover.shadow}",
    borderRadius: "{overlay.popover.borderRadius}"
  },
  colorScheme: {
    light: {
      panel: {
        background: "{surface.800}",
        borderColor: "{surface.900}"
      },
      handle: {
        color: "{surface.0}"
      }
    },
    dark: {
      panel: {
        background: "{surface.900}",
        borderColor: "{surface.700}"
      },
      handle: {
        color: "{surface.0}"
      }
    }
  }
};
var index$18 = {
  icon: {
    size: "2rem",
    color: "{overlay.modal.color}"
  },
  content: {
    gap: "1rem"
  }
};
var index$17 = {
  root: {
    background: "{overlay.popover.background}",
    borderColor: "{overlay.popover.border.color}",
    color: "{overlay.popover.color}",
    borderRadius: "{overlay.popover.border.radius}",
    shadow: "{overlay.popover.shadow}",
    gutter: "10px",
    arrowOffset: "1.25rem"
  },
  content: {
    padding: "{overlay.popover.padding}",
    gap: "1rem"
  },
  icon: {
    size: "1.5rem",
    color: "{overlay.popover.color}"
  },
  footer: {
    gap: "0.5rem",
    padding: "0 {overlay.popover.padding} {overlay.popover.padding} {overlay.popover.padding}"
  }
};
var index$16 = {
  root: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    color: "{content.color}",
    borderRadius: "{content.border.radius}",
    shadow: "{overlay.navigation.shadow}",
    transitionDuration: "{transition.duration}"
  },
  list: {
    padding: "{navigation.list.padding}",
    gap: "{navigation.list.gap}"
  },
  item: {
    focusBackground: "{navigation.item.focus.background}",
    activeBackground: "{navigation.item.active.background}",
    color: "{navigation.item.color}",
    focusColor: "{navigation.item.focus.color}",
    activeColor: "{navigation.item.active.color}",
    padding: "{navigation.item.padding}",
    borderRadius: "{navigation.item.border.radius}",
    gap: "{navigation.item.gap}",
    icon: {
      color: "{navigation.item.icon.color}",
      focusColor: "{navigation.item.icon.focus.color}",
      activeColor: "{navigation.item.icon.active.color}"
    }
  },
  submenuIcon: {
    size: "{navigation.submenu.icon.size}",
    color: "{navigation.submenu.icon.color}",
    focusColor: "{navigation.submenu.icon.focus.color}",
    activeColor: "{navigation.submenu.icon.active.color}"
  },
  separator: {
    borderColor: "{content.border.color}"
  }
};
var index$15 = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  header: {
    background: "{content.background}",
    borderColor: "{datatable.border.color}",
    color: "{content.color}",
    borderWidth: "0 0 1px 0",
    padding: "0.75rem 1rem"
  },
  headerCell: {
    background: "{content.background}",
    hoverBackground: "{content.hover.background}",
    selectedBackground: "{highlight.background}",
    borderColor: "{datatable.border.color}",
    color: "{content.color}",
    hoverColor: "{content.hover.color}",
    selectedColor: "{highlight.color}",
    gap: "0.5rem",
    padding: "0.75rem 1rem",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "-1px",
      shadow: "{focus.ring.shadow}"
    }
  },
  columnTitle: {
    fontWeight: "600"
  },
  row: {
    background: "{content.background}",
    hoverBackground: "{content.hover.background}",
    selectedBackground: "{highlight.background}",
    color: "{content.color}",
    hoverColor: "{content.hover.color}",
    selectedColor: "{highlight.color}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "-1px",
      shadow: "{focus.ring.shadow}"
    }
  },
  bodyCell: {
    borderColor: "{datatable.border.color}",
    padding: "0.75rem 1rem"
  },
  footerCell: {
    background: "{content.background}",
    borderColor: "{datatable.border.color}",
    color: "{content.color}",
    padding: "0.75rem 1rem"
  },
  columnFooter: {
    fontWeight: "600"
  },
  footer: {
    background: "{content.background}",
    borderColor: "{datatable.border.color}",
    color: "{content.color}",
    borderWidth: "0 0 1px 0",
    padding: "0.75rem 1rem"
  },
  dropPointColor: "{primary.color}",
  columnResizerWidth: "0.5rem",
  resizeIndicator: {
    width: "1px",
    color: "{primary.color}"
  },
  sortIcon: {
    color: "{text.muted.color}",
    hoverColor: "{text.hover.muted.color}"
  },
  loadingIcon: {
    size: "2rem"
  },
  rowToggleButton: {
    hoverBackground: "{content.hover.background}",
    selectedHoverBackground: "{content.background}",
    color: "{text.muted.color}",
    hoverColor: "{text.color}",
    selectedHoverColor: "{primary.color}",
    size: "1.75rem",
    borderRadius: "50%",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  filter: {
    inlineGap: "0.5rem",
    overlaySelect: {
      background: "{overlay.select.background}",
      borderColor: "{overlay.select.border.color}",
      borderRadius: "{overlay.select.border.radius}",
      color: "{overlay.select.color}",
      shadow: "{overlay.select.shadow}"
    },
    overlayPopover: {
      background: "{overlay.popover.background}",
      borderColor: "{overlay.popover.border.color}",
      borderRadius: "{overlay.popover.border.radius}",
      color: "{overlay.popover.color}",
      shadow: "{overlay.popover.shadow}",
      padding: "{overlay.popover.padding}",
      gap: "0.5rem"
    },
    rule: {
      borderColor: "{content.border.color}"
    },
    constraintList: {
      padding: "{list.padding}",
      gap: "{list.gap}"
    },
    constraint: {
      focusBackground: "{list.option.focus.background}",
      selectedBackground: "{list.option.selected.background}",
      selectedFocusBackground: "{list.option.selected.focus.background}",
      color: "{list.option.color}",
      focusColor: "{list.option.focus.color}",
      selectedColor: "{list.option.selected.color}",
      selectedFocusColor: "{list.option.selected.focus.color}",
      separator: {
        borderColor: "{content.border.color}"
      },
      padding: "{list.option.padding}",
      borderRadius: "{list.option.border.radius}"
    }
  },
  paginatorTop: {
    borderColor: "{datatable.border.color}",
    borderWidth: "0 0 1px 0"
  },
  paginatorBottom: {
    borderColor: "{datatable.border.color}",
    borderWidth: "0 0 1px 0"
  },
  colorScheme: {
    light: {
      root: {
        borderColor: "{content.border.color}"
      },
      row: {
        stripedBackground: "{surface.50}"
      },
      bodyCell: {
        selectedBorderColor: "{primary.100}"
      }
    },
    dark: {
      root: {
        borderColor: "{surface.800}"
      },
      row: {
        stripedBackground: "{surface.950}"
      },
      bodyCell: {
        selectedBorderColor: "{primary.900}"
      }
    }
  }
};
var index$14 = {
  root: {
    borderColor: "transparent",
    borderWidth: "0",
    borderRadius: "0",
    padding: "0"
  },
  header: {
    background: "{content.background}",
    color: "{content.color}",
    borderColor: "{content.border.color}",
    borderWidth: "0 0 1px 0",
    padding: "0.75rem 1rem",
    borderRadius: "0"
  },
  content: {
    background: "{content.background}",
    color: "{content.color}",
    borderColor: "transparent",
    borderWidth: "0",
    padding: "0",
    borderRadius: "0"
  },
  footer: {
    background: "{content.background}",
    color: "{content.color}",
    borderColor: "{content.border.color}",
    borderWidth: "1px 0 0 0",
    padding: "0.75rem 1rem",
    borderRadius: "0"
  },
  paginatorTop: {
    borderColor: "{content.border.color}",
    borderWidth: "0 0 1px 0"
  },
  paginatorBottom: {
    borderColor: "{content.border.color}",
    borderWidth: "1px 0 0 0"
  }
};
var index$13 = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  panel: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    color: "{content.color}",
    borderRadius: "{content.border.radius}",
    shadow: "{overlay.popover.shadow}",
    padding: "{overlay.popover.padding}"
  },
  header: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    color: "{content.color}",
    padding: "0 0 0.5rem 0",
    fontWeight: "500",
    gap: "0.5rem"
  },
  title: {
    gap: "0.5rem",
    fontWeight: "500"
  },
  dropdown: {
    width: "2.5rem",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.border.color}",
    activeBorderColor: "{form.field.border.color}",
    borderRadius: "{form.field.border.radius}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  inputIcon: {
    color: "{form.field.icon.color}"
  },
  selectMonth: {
    hoverBackground: "{content.hover.background}",
    color: "{content.color}",
    hoverColor: "{content.hover.color}",
    padding: "0.25rem 0.5rem",
    borderRadius: "{content.border.radius}"
  },
  selectYear: {
    hoverBackground: "{content.hover.background}",
    color: "{content.color}",
    hoverColor: "{content.hover.color}",
    padding: "0.25rem 0.5rem",
    borderRadius: "{content.border.radius}"
  },
  group: {
    borderColor: "{content.border.color}",
    gap: "{overlay.popover.padding}"
  },
  dayView: {
    margin: "0.5rem 0 0 0"
  },
  weekDay: {
    padding: "0.25rem",
    fontWeight: "500",
    color: "{content.color}"
  },
  date: {
    hoverBackground: "{content.hover.background}",
    selectedBackground: "{primary.color}",
    rangeSelectedBackground: "{highlight.background}",
    color: "{content.color}",
    hoverColor: "{content.hover.color}",
    selectedColor: "{primary.contrast.color}",
    rangeSelectedColor: "{highlight.color}",
    width: "2rem",
    height: "2rem",
    borderRadius: "50%",
    padding: "0.25rem",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  monthView: {
    margin: "0.5rem 0 0 0"
  },
  month: {
    borderRadius: "{content.border.radius}"
  },
  yearView: {
    margin: "0.5rem 0 0 0"
  },
  year: {
    borderRadius: "{content.border.radius}"
  },
  buttonbar: {
    padding: "0.5rem 0 0 0",
    borderColor: "{content.border.color}"
  },
  timePicker: {
    padding: "0.5rem 0 0 0",
    borderColor: "{content.border.color}",
    gap: "0.5rem",
    buttonGap: "0.25rem"
  },
  colorScheme: {
    light: {
      dropdown: {
        background: "{surface.100}",
        hoverBackground: "{surface.200}",
        activeBackground: "{surface.300}",
        color: "{surface.600}",
        hoverColor: "{surface.700}",
        activeColor: "{surface.800}"
      },
      today: {
        background: "{surface.200}",
        color: "{surface.900}"
      }
    },
    dark: {
      dropdown: {
        background: "{surface.800}",
        hoverBackground: "{surface.700}",
        activeBackground: "{surface.600}",
        color: "{surface.300}",
        hoverColor: "{surface.200}",
        activeColor: "{surface.100}"
      },
      today: {
        background: "{surface.700}",
        color: "{surface.0}"
      }
    }
  }
};
var index$12 = {
  root: {
    background: "{overlay.modal.background}",
    borderColor: "{overlay.modal.border.color}",
    color: "{overlay.modal.color}",
    borderRadius: "{overlay.modal.border.radius}",
    shadow: "{overlay.modal.shadow}"
  },
  header: {
    padding: "{overlay.modal.padding}",
    gap: "0.5rem"
  },
  title: {
    fontSize: "1.25rem",
    fontWeight: "600"
  },
  content: {
    padding: "0 {overlay.modal.padding} {overlay.modal.padding} {overlay.modal.padding}"
  },
  footer: {
    padding: "0 {overlay.modal.padding} {overlay.modal.padding} {overlay.modal.padding}",
    gap: "0.5rem"
  }
};
var index$11 = {
  root: {
    borderColor: "{content.border.color}"
  },
  content: {
    background: "{content.background}",
    color: "{text.color}"
  },
  horizontal: {
    margin: "1rem 0",
    padding: "0 1rem",
    content: {
      padding: "0 0.5rem"
    }
  },
  vertical: {
    margin: "0 1rem",
    padding: "0.5rem 0",
    content: {
      padding: "0.5rem 0"
    }
  }
};
var index$10 = {
  root: {
    background: "rgba(255, 255, 255, 0.1)",
    borderColor: "rgba(255, 255, 255, 0.2)",
    padding: "0.5rem",
    borderRadius: "{border.radius.xl}"
  },
  item: {
    borderRadius: "{content.border.radius}",
    padding: "0.5rem",
    size: "3rem",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  }
};
var index$$ = {
  root: {
    background: "{overlay.modal.background}",
    borderColor: "{overlay.modal.border.color}",
    color: "{overlay.modal.color}",
    borderRadius: "{overlay.modal.border.radius}",
    shadow: "{overlay.modal.shadow}"
  },
  header: {
    padding: "{overlay.modal.padding}"
  },
  title: {
    fontSize: "1.5rem",
    fontWeight: "600"
  },
  content: {
    padding: "0 {overlay.modal.padding} {overlay.modal.padding} {overlay.modal.padding}"
  }
};
var index$_ = {
  toolbar: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    borderRadius: "{content.border.radius}"
  },
  toolbarItem: {
    color: "{text.muted.color}",
    hoverColor: "{text.color}",
    activeColor: "{primary.color}"
  },
  overlay: {
    background: "{overlay.select.background}",
    borderColor: "{overlay.select.border.color}",
    borderRadius: "{overlay.select.border.radius}",
    color: "{overlay.select.color}",
    shadow: "{overlay.select.shadow}",
    padding: "{list.padding}"
  },
  overlayOption: {
    focusBackground: "{list.option.focus.background}",
    color: "{list.option.color}",
    focusColor: "{list.option.focus.color}",
    padding: "{list.option.padding}",
    borderRadius: "{list.option.border.radius}"
  },
  content: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    color: "{content.color}",
    borderRadius: "{content.border.radius}"
  }
};
var index$Z = {
  root: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    borderRadius: "{content.border.radius}",
    color: "{content.color}",
    padding: "0 1.125rem 1.125rem 1.125rem",
    transitionDuration: "{transition.duration}"
  },
  legend: {
    background: "{content.background}",
    hoverBackground: "{content.hover.background}",
    color: "{content.color}",
    hoverColor: "{content.hover.color}",
    borderRadius: "{content.border.radius}",
    borderWidth: "1px",
    borderColor: "transparent",
    padding: "0.5rem 0.75rem",
    gap: "0.5rem",
    fontWeight: "600",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  toggleIcon: {
    color: "{text.muted.color}",
    hoverColor: "{text.hover.muted.color}"
  },
  content: {
    padding: "0"
  }
};
var index$Y = {
  root: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    color: "{content.color}",
    borderRadius: "{content.border.radius}",
    transitionDuration: "{transition.duration}"
  },
  header: {
    background: "transparent",
    color: "{text.color}",
    padding: "1.125rem",
    borderWidth: "0",
    borderRadius: "0",
    gap: "0.5rem"
  },
  content: {
    highlightBorderColor: "{primary.color}",
    padding: "0 1.125rem 1.125rem 1.125rem"
  },
  file: {
    padding: "1rem",
    gap: "1rem",
    borderColor: "{content.border.color}",
    info: {
      gap: "0.5rem"
    }
  },
  progressbar: {
    height: "0.25rem"
  },
  basic: {
    gap: "0.5rem"
  }
};
var index$X = {
  root: {
    color: "{form.field.float.label.color}",
    focusColor: "{form.field.float.label.focus.color}",
    invalidColor: "{form.field.float.label.invalid.color}",
    transitionDuration: "0.2s"
  }
};
var index$W = {
  root: {
    borderWidth: "1px",
    borderColor: "{content.border.color}",
    borderRadius: "{content.border.radius}",
    transitionDuration: "{transition.duration}"
  },
  navButton: {
    background: "rgba(255, 255, 255, 0.1)",
    hoverBackground: "rgba(255, 255, 255, 0.2)",
    color: "{surface.100}",
    hoverColor: "{surface.0}",
    size: "3rem",
    gutter: "0.5rem",
    prev: {
      borderRadius: "50%"
    },
    next: {
      borderRadius: "50%"
    },
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  navIcon: {
    size: "1.5rem"
  },
  thumbnailsContent: {
    background: "{content.background}",
    padding: "1rem 0.25rem"
  },
  thumbnailNavButton: {
    size: "2rem",
    borderRadius: "{content.border.radius}",
    gutter: "0.5rem",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  thumbnailNavButtonIcon: {
    size: "1rem"
  },
  caption: {
    background: "rgba(0, 0, 0, 0.5)",
    color: "{surface.100}",
    padding: "1rem"
  },
  indicatorList: {
    gap: "0.5rem",
    padding: "1rem"
  },
  indicatorButton: {
    width: "1rem",
    height: "1rem",
    activeBackground: "{primary.color}",
    borderRadius: "50%",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  insetIndicatorList: {
    background: "rgba(0, 0, 0, 0.5)"
  },
  insetIndicatorButton: {
    background: "rgba(255, 255, 255, 0.4)",
    hoverBackground: "rgba(255, 255, 255, 0.6)",
    activeBackground: "rgba(255, 255, 255, 0.9)"
  },
  mask: {
    background: "{mask.background}",
    color: "{mask.color}"
  },
  closeButton: {
    size: "3rem",
    gutter: "0.5rem",
    background: "rgba(255, 255, 255, 0.1)",
    hoverBackground: "rgba(255, 255, 255, 0.2)",
    color: "{surface.50}",
    hoverColor: "{surface.0}",
    borderRadius: "50%",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  closeButtonIcon: {
    size: "1.5rem"
  },
  colorScheme: {
    light: {
      thumbnailNavButton: {
        hoverBackground: "{surface.100}",
        color: "{surface.600}",
        hoverColor: "{surface.700}"
      },
      indicatorButton: {
        background: "{surface.200}",
        hoverBackground: "{surface.300}"
      }
    },
    dark: {
      thumbnailNavButton: {
        hoverBackground: "{surface.700}",
        color: "{surface.400}",
        hoverColor: "{surface.0}"
      },
      indicatorButton: {
        background: "{surface.700}",
        hoverBackground: "{surface.600}"
      }
    }
  }
};
var index$V = {
  icon: {
    color: "{form.field.icon.color}"
  }
};
var index$U = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  preview: {
    icon: {
      size: "1.5rem"
    },
    mask: {
      background: "{mask.background}",
      color: "{mask.color}"
    }
  },
  toolbar: {
    position: {
      left: "auto",
      right: "1rem",
      top: "1rem",
      bottom: "auto"
    },
    blur: "8px",
    background: "rgba(255,255,255,0.1)",
    borderColor: "rgba(255,255,255,0.2)",
    borderWidth: "1px",
    borderRadius: "30px",
    padding: ".5rem",
    gap: "0.5rem"
  },
  action: {
    hoverBackground: "rgba(255,255,255,0.1)",
    color: "{surface.50}",
    hoverColor: "{surface.0}",
    size: "3rem",
    iconSize: "1.5rem",
    borderRadius: "50%",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  }
};
var index$T = {
  root: {
    padding: "{form.field.padding.y} {form.field.padding.x}",
    borderRadius: "{content.border.radius}",
    gap: "0.5rem"
  },
  text: {
    fontWeight: "500"
  },
  icon: {
    size: "1rem"
  },
  colorScheme: {
    light: {
      info: {
        background: "color-mix(in srgb, {blue.50}, transparent 5%)",
        borderColor: "{blue.200}",
        color: "{blue.600}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {blue.500}, transparent 96%)"
      },
      success: {
        background: "color-mix(in srgb, {green.50}, transparent 5%)",
        borderColor: "{green.200}",
        color: "{green.600}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {green.500}, transparent 96%)"
      },
      warn: {
        background: "color-mix(in srgb,{yellow.50}, transparent 5%)",
        borderColor: "{yellow.200}",
        color: "{yellow.600}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {yellow.500}, transparent 96%)"
      },
      error: {
        background: "color-mix(in srgb, {red.50}, transparent 5%)",
        borderColor: "{red.200}",
        color: "{red.600}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {red.500}, transparent 96%)"
      },
      secondary: {
        background: "{surface.100}",
        borderColor: "{surface.200}",
        color: "{surface.600}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.500}, transparent 96%)"
      },
      contrast: {
        background: "{surface.900}",
        borderColor: "{surface.950}",
        color: "{surface.50}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.950}, transparent 96%)"
      }
    },
    dark: {
      info: {
        background: "color-mix(in srgb, {blue.500}, transparent 84%)",
        borderColor: "color-mix(in srgb, {blue.700}, transparent 64%)",
        color: "{blue.500}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {blue.500}, transparent 96%)"
      },
      success: {
        background: "color-mix(in srgb, {green.500}, transparent 84%)",
        borderColor: "color-mix(in srgb, {green.700}, transparent 64%)",
        color: "{green.500}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {green.500}, transparent 96%)"
      },
      warn: {
        background: "color-mix(in srgb, {yellow.500}, transparent 84%)",
        borderColor: "color-mix(in srgb, {yellow.700}, transparent 64%)",
        color: "{yellow.500}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {yellow.500}, transparent 96%)"
      },
      error: {
        background: "color-mix(in srgb, {red.500}, transparent 84%)",
        borderColor: "color-mix(in srgb, {red.700}, transparent 64%)",
        color: "{red.500}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {red.500}, transparent 96%)"
      },
      secondary: {
        background: "{surface.800}",
        borderColor: "{surface.700}",
        color: "{surface.300}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.500}, transparent 96%)"
      },
      contrast: {
        background: "{surface.0}",
        borderColor: "{surface.100}",
        color: "{surface.950}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.950}, transparent 96%)"
      }
    }
  }
};
var index$S = {
  root: {
    padding: "{form.field.padding.y} {form.field.padding.x}",
    borderRadius: "{content.border.radius}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    },
    transitionDuration: "{transition.duration}"
  },
  display: {
    hoverBackground: "{content.hover.background}",
    hoverColor: "{content.hover.color}"
  }
};
var index$R = {
  root: {
    background: "{form.field.background}",
    disabledBackground: "{form.field.disabled.background}",
    filledBackground: "{form.field.filled.background}",
    filledFocusBackground: "{form.field.filled.focus.background}",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.hover.border.color}",
    focusBorderColor: "{form.field.focus.border.color}",
    invalidBorderColor: "{form.field.invalid.border.color}",
    color: "{form.field.color}",
    disabledColor: "{form.field.disabled.color}",
    placeholderColor: "{form.field.placeholder.color}",
    shadow: "{form.field.shadow}",
    paddingX: "{form.field.padding.x}",
    paddingY: "{form.field.padding.y}",
    borderRadius: "{form.field.border.radius}",
    focusRing: {
      width: "{form.field.focus.ring.width}",
      style: "{form.field.focus.ring.style}",
      color: "{form.field.focus.ring.color}",
      offset: "{form.field.focus.ring.offset}",
      shadow: "{form.field.focus.ring.shadow}"
    },
    transitionDuration: "{form.field.transition.duration}"
  },
  chip: {
    borderRadius: "{border.radius.sm}"
  },
  colorScheme: {
    light: {
      chip: {
        focusBackground: "{surface.200}",
        color: "{surface.800}"
      }
    },
    dark: {
      chip: {
        focusBackground: "{surface.700}",
        color: "{surface.0}"
      }
    }
  }
};
var index$Q = {
  addon: {
    background: "{form.field.background}",
    borderColor: "{form.field.border.color}",
    color: "{form.field.icon.color}",
    borderRadius: "{form.field.border.radius}"
  }
};
var index$P = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  button: {
    width: "2.5rem",
    borderRadius: "{form.field.border.radius}",
    verticalPadding: "{form.field.padding.y}"
  },
  colorScheme: {
    light: {
      button: {
        background: "transparent",
        hoverBackground: "{surface.100}",
        activeBackground: "{surface.200}",
        borderColor: "{form.field.border.color}",
        hoverBorderColor: "{form.field.border.color}",
        activeBorderColor: "{form.field.border.color}",
        color: "{surface.400}",
        hoverColor: "{surface.500}",
        activeColor: "{surface.600}"
      }
    },
    dark: {
      button: {
        background: "transparent",
        hoverBackground: "{surface.800}",
        activeBackground: "{surface.700}",
        borderColor: "{form.field.border.color}",
        hoverBorderColor: "{form.field.border.color}",
        activeBorderColor: "{form.field.border.color}",
        color: "{surface.400}",
        hoverColor: "{surface.300}",
        activeColor: "{surface.200}"
      }
    }
  }
};
var index$O = {
  root: {
    background: "{form.field.background}",
    disabledBackground: "{form.field.disabled.background}",
    filledBackground: "{form.field.filled.background}",
    filledFocusBackground: "{form.field.filled.focus.background}",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.hover.border.color}",
    focusBorderColor: "{form.field.focus.border.color}",
    invalidBorderColor: "{form.field.invalid.border.color}",
    color: "{form.field.color}",
    disabledColor: "{form.field.disabled.color}",
    placeholderColor: "{form.field.placeholder.color}",
    shadow: "{form.field.shadow}",
    paddingX: "{form.field.padding.x}",
    paddingY: "{form.field.padding.y}",
    borderRadius: "{form.field.border.radius}",
    focusRing: {
      width: "{form.field.focus.ring.width}",
      style: "{form.field.focus.ring.style}",
      color: "{form.field.focus.ring.color}",
      offset: "{form.field.focus.ring.offset}",
      shadow: "{form.field.focus.ring.shadow}"
    },
    transitionDuration: "{form.field.transition.duration}",
    sm: {
      fontSize: "0.875rem",
      paddingX: "0.625rem",
      paddingY: "0.375rem"
    },
    lg: {
      fontSize: "1.125rem",
      paddingX: "0.875rem",
      paddingY: "0.625rem"
    }
  }
};
var index$N = {
  root: {
    transitionDuration: "{transition.duration}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  value: {
    background: "{primary.color}"
  },
  range: {
    background: "{content.border.color}"
  },
  text: {
    color: "{text.muted.color}"
  }
};
var index$M = {
  root: {
    background: "{form.field.background}",
    disabledBackground: "{form.field.disabled.background}",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.hover.border.color}",
    focusBorderColor: "{form.field.focus.border.color}",
    invalidBorderColor: "{form.field.invalid.border.color}",
    color: "{form.field.color}",
    disabledColor: "{form.field.disabled.color}",
    shadow: "{form.field.shadow}",
    borderRadius: "{form.field.border.radius}",
    focusRing: {
      width: "{form.field.focus.ring.width}",
      style: "{form.field.focus.ring.style}",
      color: "{form.field.focus.ring.color}",
      offset: "{form.field.focus.ring.offset}",
      shadow: "{form.field.focus.ring.shadow}"
    },
    transitionDuration: "{form.field.transition.duration}"
  },
  list: {
    padding: "{list.padding}",
    gap: "{list.gap}",
    header: {
      padding: "{list.header.padding}"
    }
  },
  option: {
    focusBackground: "{list.option.focus.background}",
    selectedBackground: "{list.option.selected.background}",
    selectedFocusBackground: "{list.option.selected.focus.background}",
    color: "{list.option.color}",
    focusColor: "{list.option.focus.color}",
    selectedColor: "{list.option.selected.color}",
    selectedFocusColor: "{list.option.selected.focus.color}",
    padding: "{list.option.padding}",
    borderRadius: "{list.option.border.radius}"
  },
  optionGroup: {
    background: "{list.option.group.background}",
    color: "{list.option.group.color}",
    fontWeight: "{list.option.group.font.weight}",
    padding: "{list.option.group.padding}"
  },
  checkmark: {
    color: "{list.option.color}",
    gutterStart: "-0.375rem",
    gutterEnd: "0.375rem"
  },
  emptyMessage: {
    padding: "{list.option.padding}"
  },
  colorScheme: {
    light: {
      option: {
        stripedBackground: "{surface.50}"
      }
    },
    dark: {
      option: {
        stripedBackground: "{surface.900}"
      }
    }
  }
};
var index$L = {
  root: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    borderRadius: "{content.border.radius}",
    color: "{content.color}",
    gap: "0.5rem",
    verticalOrientation: {
      padding: "{navigation.list.padding}",
      gap: "0"
    },
    horizontalOrientation: {
      padding: "0.5rem 0.75rem"
    },
    transitionDuration: "{transition.duration}"
  },
  baseItem: {
    borderRadius: "{content.border.radius}",
    padding: "{navigation.item.padding}"
  },
  item: {
    focusBackground: "{navigation.item.focus.background}",
    activeBackground: "{navigation.item.active.background}",
    color: "{navigation.item.color}",
    focusColor: "{navigation.item.focus.color}",
    activeColor: "{navigation.item.active.color}",
    padding: "{navigation.item.padding}",
    borderRadius: "{navigation.item.border.radius}",
    gap: "{navigation.item.gap}",
    icon: {
      color: "{navigation.item.icon.color}",
      focusColor: "{navigation.item.icon.focus.color}",
      activeColor: "{navigation.item.icon.active.color}"
    }
  },
  overlay: {
    padding: "0",
    background: "{content.background}",
    borderColor: "{content.border.color}",
    borderRadius: "{content.border.radius}",
    color: "{content.color}",
    shadow: "{overlay.navigation.shadow}",
    gap: "0.5rem"
  },
  submenu: {
    padding: "{navigation.list.padding}",
    gap: "{navigation.list.gap}"
  },
  submenuLabel: {
    padding: "{navigation.submenu.label.padding}",
    fontWeight: "{navigation.submenu.label.font.weight}",
    background: "{navigation.submenu.label.background.}",
    color: "{navigation.submenu.label.color}"
  },
  submenuIcon: {
    size: "{navigation.submenu.icon.size}",
    color: "{navigation.submenu.icon.color}",
    focusColor: "{navigation.submenu.icon.focus.color}",
    activeColor: "{navigation.submenu.icon.active.color}"
  },
  separator: {
    borderColor: "{content.border.color}"
  },
  mobileButton: {
    borderRadius: "50%",
    size: "1.75rem",
    color: "{text.muted.color}",
    hoverColor: "{text.muted.hover.color}",
    hoverBackground: "{content.hover.background}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  }
};
var index$K = {
  root: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    color: "{content.color}",
    borderRadius: "{content.border.radius}",
    shadow: "{overlay.navigation.shadow}",
    transitionDuration: "{transition.duration}"
  },
  list: {
    padding: "{navigation.list.padding}",
    gap: "{navigation.list.gap}"
  },
  item: {
    focusBackground: "{navigation.item.focus.background}",
    color: "{navigation.item.color}",
    focusColor: "{navigation.item.focus.color}",
    padding: "{navigation.item.padding}",
    borderRadius: "{navigation.item.border.radius}",
    gap: "{navigation.item.gap}",
    icon: {
      color: "{navigation.item.icon.color}",
      focusColor: "{navigation.item.icon.focus.color}"
    }
  },
  submenuLabel: {
    padding: "{navigation.submenu.label.padding}",
    fontWeight: "{navigation.submenu.label.font.weight}",
    background: "{navigation.submenu.label.background.}",
    color: "{navigation.submenu.label.color}"
  },
  separator: {
    borderColor: "{content.border.color}"
  }
};
var index$J = {
  root: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    borderRadius: "{content.border.radius}",
    color: "{content.color}",
    gap: "0.5rem",
    padding: "0.5rem 0.75rem",
    transitionDuration: "{transition.duration}"
  },
  baseItem: {
    borderRadius: "{content.border.radius}",
    padding: "{navigation.item.padding}"
  },
  item: {
    focusBackground: "{navigation.item.focus.background}",
    activeBackground: "{navigation.item.active.background}",
    color: "{navigation.item.color}",
    focusColor: "{navigation.item.focus.color}",
    activeColor: "{navigation.item.active.color}",
    padding: "{navigation.item.padding}",
    borderRadius: "{navigation.item.border.radius}",
    gap: "{navigation.item.gap}",
    icon: {
      color: "{navigation.item.icon.color}",
      focusColor: "{navigation.item.icon.focus.color}",
      activeColor: "{navigation.item.icon.active.color}"
    }
  },
  submenu: {
    padding: "{navigation.list.padding}",
    gap: "{navigation.list.gap}",
    background: "{content.background}",
    borderColor: "{content.border.color}",
    borderRadius: "{content.border.radius}",
    shadow: "{overlay.navigation.shadow}",
    mobileIndent: "1rem"
  },
  submenuIcon: {
    size: "{navigation.submenu.icon.size}",
    color: "{navigation.submenu.icon.color}",
    focusColor: "{navigation.submenu.icon.focus.color}",
    activeColor: "{navigation.submenu.icon.active.color}"
  },
  separator: {
    borderColor: "{content.border.color}"
  },
  mobileButton: {
    borderRadius: "50%",
    size: "1.75rem",
    color: "{text.muted.color}",
    hoverColor: "{text.muted.hover.color}",
    hoverBackground: "{content.hover.background}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  }
};
var index$I = {
  root: {
    borderRadius: "{content.border.radius}",
    borderWidth: "1px",
    transitionDuration: "{transition.duration}"
  },
  content: {
    padding: "0.5rem 0.75rem",
    gap: "0.5rem"
  },
  text: {
    fontSize: "1rem",
    fontWeight: "500"
  },
  icon: {
    size: "1.125rem"
  },
  closeButton: {
    width: "1.75rem",
    height: "1.75rem",
    borderRadius: "50%",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      offset: "{focus.ring.offset}"
    }
  },
  closeIcon: {
    size: "1rem"
  },
  colorScheme: {
    light: {
      info: {
        background: "color-mix(in srgb, {blue.50}, transparent 5%)",
        borderColor: "{blue.200}",
        color: "{blue.600}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {blue.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "{blue.100}",
          focusRing: {
            color: "{blue.600}",
            shadow: "none"
          }
        }
      },
      success: {
        background: "color-mix(in srgb, {green.50}, transparent 5%)",
        borderColor: "{green.200}",
        color: "{green.600}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {green.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "{green.100}",
          focusRing: {
            color: "{green.600}",
            shadow: "none"
          }
        }
      },
      warn: {
        background: "color-mix(in srgb,{yellow.50}, transparent 5%)",
        borderColor: "{yellow.200}",
        color: "{yellow.600}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {yellow.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "{yellow.100}",
          focusRing: {
            color: "{yellow.600}",
            shadow: "none"
          }
        }
      },
      error: {
        background: "color-mix(in srgb, {red.50}, transparent 5%)",
        borderColor: "{red.200}",
        color: "{red.600}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {red.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "{red.100}",
          focusRing: {
            color: "{red.600}",
            shadow: "none"
          }
        }
      },
      secondary: {
        background: "{surface.100}",
        borderColor: "{surface.200}",
        color: "{surface.600}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "{surface.200}",
          focusRing: {
            color: "{surface.600}",
            shadow: "none"
          }
        }
      },
      contrast: {
        background: "{surface.900}",
        borderColor: "{surface.950}",
        color: "{surface.50}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.950}, transparent 96%)",
        closeButton: {
          hoverBackground: "{surface.800}",
          focusRing: {
            color: "{surface.50}",
            shadow: "none"
          }
        }
      }
    },
    dark: {
      info: {
        background: "color-mix(in srgb, {blue.500}, transparent 84%)",
        borderColor: "color-mix(in srgb, {blue.700}, transparent 64%)",
        color: "{blue.500}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {blue.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "rgba(255, 255, 255, 0.05)",
          focusRing: {
            color: "{blue.500}",
            shadow: "none"
          }
        }
      },
      success: {
        background: "color-mix(in srgb, {green.500}, transparent 84%)",
        borderColor: "color-mix(in srgb, {green.700}, transparent 64%)",
        color: "{green.500}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {green.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "rgba(255, 255, 255, 0.05)",
          focusRing: {
            color: "{green.500}",
            shadow: "none"
          }
        }
      },
      warn: {
        background: "color-mix(in srgb, {yellow.500}, transparent 84%)",
        borderColor: "color-mix(in srgb, {yellow.700}, transparent 64%)",
        color: "{yellow.500}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {yellow.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "rgba(255, 255, 255, 0.05)",
          focusRing: {
            color: "{yellow.500}",
            shadow: "none"
          }
        }
      },
      error: {
        background: "color-mix(in srgb, {red.500}, transparent 84%)",
        borderColor: "color-mix(in srgb, {red.700}, transparent 64%)",
        color: "{red.500}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {red.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "rgba(255, 255, 255, 0.05)",
          focusRing: {
            color: "{red.500}",
            shadow: "none"
          }
        }
      },
      secondary: {
        background: "{surface.800}",
        borderColor: "{surface.700}",
        color: "{surface.300}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "{surface.700}",
          focusRing: {
            color: "{surface.300}",
            shadow: "none"
          }
        }
      },
      contrast: {
        background: "{surface.0}",
        borderColor: "{surface.100}",
        color: "{surface.950}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.950}, transparent 96%)",
        closeButton: {
          hoverBackground: "{surface.100}",
          focusRing: {
            color: "{surface.950}",
            shadow: "none"
          }
        }
      }
    }
  }
};
var index$H = {
  root: {
    borderRadius: "{content.border.radius}",
    gap: "1rem"
  },
  meters: {
    background: "{content.border.color}",
    size: "0.5rem"
  },
  label: {
    gap: "0.5rem"
  },
  labelMarker: {
    size: "0.5rem"
  },
  labelIcon: {
    size: "1rem"
  },
  labelList: {
    verticalGap: "0.5rem",
    horizontalGap: "1rem"
  }
};
var index$G = {
  root: {
    background: "{form.field.background}",
    disabledBackground: "{form.field.disabled.background}",
    filledBackground: "{form.field.filled.background}",
    filledFocusBackground: "{form.field.filled.focus.background}",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.hover.border.color}",
    focusBorderColor: "{form.field.focus.border.color}",
    invalidBorderColor: "{form.field.invalid.border.color}",
    color: "{form.field.color}",
    disabledColor: "{form.field.disabled.color}",
    placeholderColor: "{form.field.placeholder.color}",
    shadow: "{form.field.shadow}",
    paddingX: "{form.field.padding.x}",
    paddingY: "{form.field.padding.y}",
    borderRadius: "{form.field.border.radius}",
    focusRing: {
      width: "{form.field.focus.ring.width}",
      style: "{form.field.focus.ring.style}",
      color: "{form.field.focus.ring.color}",
      offset: "{form.field.focus.ring.offset}",
      shadow: "{form.field.focus.ring.shadow}"
    },
    transitionDuration: "{form.field.transition.duration}"
  },
  dropdown: {
    width: "2.5rem",
    color: "{form.field.icon.color}"
  },
  overlay: {
    background: "{overlay.select.background}",
    borderColor: "{overlay.select.border.color}",
    borderRadius: "{overlay.select.border.radius}",
    color: "{overlay.select.color}",
    shadow: "{overlay.select.shadow}"
  },
  list: {
    padding: "{list.padding}",
    gap: "{list.gap}",
    header: {
      padding: "{list.header.padding}"
    }
  },
  option: {
    focusBackground: "{list.option.focus.background}",
    selectedBackground: "{list.option.selected.background}",
    selectedFocusBackground: "{list.option.selected.focus.background}",
    color: "{list.option.color}",
    focusColor: "{list.option.focus.color}",
    selectedColor: "{list.option.selected.color}",
    selectedFocusColor: "{list.option.selected.focus.color}",
    padding: "{list.option.padding}",
    borderRadius: "{list.option.border.radius}",
    gap: "0.5rem"
  },
  optionGroup: {
    background: "{list.option.group.background}",
    color: "{list.option.group.color}",
    fontWeight: "{list.option.group.font.weight}",
    padding: "{list.option.group.padding}"
  },
  chip: {
    borderRadius: "{border.radius.sm}"
  },
  emptyMessage: {
    padding: "{list.option.padding}"
  }
};
var index$F = {
  root: {
    gap: "1.125rem"
  },
  controls: {
    gap: "0.5rem"
  }
};
var index$E = {
  root: {
    gutter: "0.75rem",
    transitionDuration: "{transition.duration}"
  },
  node: {
    background: "{content.background}",
    hoverBackground: "{content.hover.background}",
    selectedBackground: "{highlight.background}",
    borderColor: "{content.border.color}",
    color: "{content.color}",
    selectedColor: "{highlight.color}",
    hoverColor: "{content.hover.color}",
    padding: "0.75rem 1rem",
    toggleablePadding: "0.75rem 1rem 1.25rem 1rem",
    borderRadius: "{content.border.radius}"
  },
  nodeToggleButton: {
    background: "{content.background}",
    hoverBackground: "{content.hover.background}",
    borderColor: "{content.border.color}",
    color: "{text.muted.color}",
    hoverColor: "{text.color}",
    size: "1.5rem",
    borderRadius: "50%",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  connector: {
    color: "{content.border.color}",
    borderRadius: "{content.border.radius}",
    height: "24px"
  }
};
var index$D = {
  root: {
    outline: {
      width: "2px",
      color: "{content.background}"
    }
  }
};
var index$C = {
  root: {
    padding: "0.5rem 1rem",
    gap: "0.25rem",
    borderRadius: "{content.border.radius}",
    background: "{content.background}",
    color: "{content.color}",
    transitionDuration: "{transition.duration}"
  },
  navButton: {
    background: "transparent",
    hoverBackground: "{content.hover.background}",
    selectedBackground: "{highlight.background}",
    color: "{text.muted.color}",
    hoverColor: "{text.hover.muted.color}",
    selectedColor: "{highlight.color}",
    width: "2.5rem",
    height: "2.5rem",
    borderRadius: "50%",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  currentPageReport: {
    color: "{text.muted.color}"
  },
  jumpToPageInput: {
    maxWidth: "2.5rem"
  }
};
var index$B = {
  root: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    color: "{content.color}",
    borderRadius: "{content.border.radius}"
  },
  header: {
    background: "transparent",
    color: "{text.color}",
    padding: "1.125rem",
    borderColor: "{content.border.color}",
    borderWidth: "0",
    borderRadius: "0"
  },
  toggleableHeader: {
    padding: "0.375rem 1.125rem"
  },
  title: {
    fontWeight: "600"
  },
  content: {
    padding: "0 1.125rem 1.125rem 1.125rem"
  },
  footer: {
    padding: "0 1.125rem 1.125rem 1.125rem"
  }
};
var index$A = {
  root: {
    gap: "0.5rem",
    transitionDuration: "{transition.duration}"
  },
  panel: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    borderWidth: "1px",
    color: "{content.color}",
    padding: "0.25rem 0.25rem",
    borderRadius: "{content.border.radius}",
    first: {
      borderWidth: "1px",
      topBorderRadius: "{content.border.radius}"
    },
    last: {
      borderWidth: "1px",
      bottomBorderRadius: "{content.border.radius}"
    }
  },
  item: {
    focusBackground: "{navigation.item.focus.background}",
    color: "{navigation.item.color}",
    focusColor: "{navigation.item.focus.color}",
    gap: "0.5rem",
    padding: "{navigation.item.padding}",
    borderRadius: "{content.border.radius}",
    icon: {
      color: "{navigation.item.icon.color}",
      focusColor: "{navigation.item.icon.focus.color}"
    }
  },
  submenu: {
    indent: "1rem"
  },
  submenuIcon: {
    color: "{navigation.submenu.icon.color}",
    focusColor: "{navigation.submenu.icon.focus.color}"
  }
};
var index$z = {
  meter: {
    background: "{content.border.color}",
    borderRadius: "{content.border.radius}",
    height: ".75rem"
  },
  icon: {
    color: "{form.field.icon.color}"
  },
  overlay: {
    background: "{overlay.popover.background}",
    borderColor: "{overlay.popover.border.color}",
    borderRadius: "{overlay.popover.border.radius}",
    color: "{overlay.popover.color}",
    padding: "{overlay.popover.padding}",
    shadow: "{overlay.popover.shadow}"
  },
  content: {
    gap: "0.5rem"
  },
  colorScheme: {
    light: {
      strength: {
        weakBackground: "{red.500}",
        mediumBackground: "{amber.500}",
        strongBackground: "{green.500}"
      }
    },
    dark: {
      strength: {
        weakBackground: "{red.400}",
        mediumBackground: "{amber.400}",
        strongBackground: "{green.400}"
      }
    }
  }
};
var index$y = {
  root: {
    gap: "1.125rem"
  },
  controls: {
    gap: "0.5rem"
  }
};
var index$x = {
  root: {
    background: "{overlay.popover.background}",
    borderColor: "{overlay.popover.border.color}",
    color: "{overlay.popover.color}",
    borderRadius: "{overlay.popover.border.radius}",
    shadow: "{overlay.popover.shadow}",
    gutter: "10px",
    arrowOffset: "1.25rem"
  },
  content: {
    padding: "{overlay.popover.padding}"
  }
};
var index$w = {
  root: {
    background: "{content.border.color}",
    borderRadius: "{content.border.radius}",
    height: "1.25rem"
  },
  value: {
    background: "{primary.color}"
  },
  label: {
    color: "{primary.contrast.color}",
    fontSize: "0.75rem",
    fontWeight: "600"
  }
};
var index$v = {
  colorScheme: {
    light: {
      root: {
        "color.1": "{red.500}",
        "color.2": "{blue.500}",
        "color.3": "{green.500}",
        "color.4": "{yellow.500}"
      }
    },
    dark: {
      root: {
        "color.1": "{red.400}",
        "color.2": "{blue.400}",
        "color.3": "{green.400}",
        "color.4": "{yellow.400}"
      }
    }
  }
};
var index$u = {
  root: {
    width: "1.25rem",
    height: "1.25rem",
    background: "{form.field.background}",
    checkedBackground: "{primary.color}",
    checkedHoverBackground: "{primary.hover.color}",
    disabledBackground: "{form.field.disabled.background}",
    filledBackground: "{form.field.filled.background}",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.hover.border.color}",
    focusBorderColor: "{form.field.border.color}",
    checkedBorderColor: "{primary.color}",
    checkedHoverBorderColor: "{primary.hover.color}",
    checkedFocusBorderColor: "{primary.color}",
    invalidBorderColor: "{form.field.invalid.border.color}",
    shadow: "{form.field.shadow}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    },
    transitionDuration: "{form.field.transition.duration}"
  },
  icon: {
    size: "0.75rem",
    checkedColor: "{primary.contrast.color}",
    checkedHoverColor: "{primary.contrast.color}",
    disabledColor: "{form.field.disabled.color}"
  }
};
var index$t = {
  root: {
    gap: "0.25rem",
    transitionDuration: "{transition.duration}"
  },
  icon: {
    size: "1rem",
    color: "{text.muted.color}",
    hoverColor: "{primary.color}",
    activeColor: "{primary.color}"
  }
};
var index$s = {
  colorScheme: {
    light: {
      root: {
        background: "rgba(0,0,0,0.1)"
      }
    },
    dark: {
      root: {
        background: "rgba(255,255,255,0.3)"
      }
    }
  }
};
var index$r = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  bar: {
    size: "9px",
    borderRadius: "{border.radius.sm}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  colorScheme: {
    light: {
      bar: {
        background: "{surface.100}"
      }
    },
    dark: {
      bar: {
        background: "{surface.800}"
      }
    }
  }
};
var index$q = {
  root: {
    background: "{form.field.background}",
    disabledBackground: "{form.field.disabled.background}",
    filledBackground: "{form.field.filled.background}",
    filledFocusBackground: "{form.field.filled.focus.background}",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.hover.border.color}",
    focusBorderColor: "{form.field.focus.border.color}",
    invalidBorderColor: "{form.field.invalid.border.color}",
    color: "{form.field.color}",
    disabledColor: "{form.field.disabled.color}",
    placeholderColor: "{form.field.placeholder.color}",
    shadow: "{form.field.shadow}",
    paddingX: "{form.field.padding.x}",
    paddingY: "{form.field.padding.y}",
    borderRadius: "{form.field.border.radius}",
    focusRing: {
      width: "{form.field.focus.ring.width}",
      style: "{form.field.focus.ring.style}",
      color: "{form.field.focus.ring.color}",
      offset: "{form.field.focus.ring.offset}",
      shadow: "{form.field.focus.ring.shadow}"
    },
    transitionDuration: "{form.field.transition.duration}"
  },
  dropdown: {
    width: "2.5rem",
    color: "{form.field.icon.color}"
  },
  overlay: {
    background: "{overlay.select.background}",
    borderColor: "{overlay.select.border.color}",
    borderRadius: "{overlay.select.border.radius}",
    color: "{overlay.select.color}",
    shadow: "{overlay.select.shadow}"
  },
  list: {
    padding: "{list.padding}",
    gap: "{list.gap}",
    header: {
      padding: "{list.header.padding}"
    }
  },
  option: {
    focusBackground: "{list.option.focus.background}",
    selectedBackground: "{list.option.selected.background}",
    selectedFocusBackground: "{list.option.selected.focus.background}",
    color: "{list.option.color}",
    focusColor: "{list.option.focus.color}",
    selectedColor: "{list.option.selected.color}",
    selectedFocusColor: "{list.option.selected.focus.color}",
    padding: "{list.option.padding}",
    borderRadius: "{list.option.border.radius}"
  },
  optionGroup: {
    background: "{list.option.group.background}",
    color: "{list.option.group.color}",
    fontWeight: "{list.option.group.font.weight}",
    padding: "{list.option.group.padding}"
  },
  clearIcon: {
    color: "{form.field.icon.color}"
  },
  checkmark: {
    color: "{list.option.color}",
    gutterStart: "-0.375rem",
    gutterEnd: "0.375rem"
  },
  emptyMessage: {
    padding: "{list.option.padding}"
  }
};
var index$p = {
  root: {
    borderRadius: "{form.field.border.radius}"
  },
  colorScheme: {
    light: {
      root: {
        invalidBorderColor: "{form.field.invalid.border.color}"
      }
    },
    dark: {
      root: {
        invalidBorderColor: "{form.field.invalid.border.color}"
      }
    }
  }
};
var index$o = {
  root: {
    borderRadius: "{content.border.radius}"
  },
  colorScheme: {
    light: {
      root: {
        background: "{surface.200}",
        animationBackground: "rgba(255,255,255,0.4)"
      }
    },
    dark: {
      root: {
        background: "rgba(255, 255, 255, 0.06)",
        animationBackground: "rgba(255, 255, 255, 0.04)"
      }
    }
  }
};
var index$n = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  track: {
    background: "{content.border.color}",
    borderRadius: "{content.border.radius}",
    size: "3px"
  },
  range: {
    background: "{primary.color}"
  },
  handle: {
    width: "20px",
    height: "20px",
    borderRadius: "50%",
    background: "{content.border.color}",
    hoverBackground: "{content.border.color}",
    content: {
      borderRadius: "50%",
      hoverBackground: "{content.background}",
      width: "16px",
      height: "16px",
      shadow: "0px 0.5px 0px 0px rgba(0, 0, 0, 0.08), 0px 1px 1px 0px rgba(0, 0, 0, 0.14)"
    },
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  colorScheme: {
    light: {
      handle: {
        contentBackground: "{surface.0}"
      }
    },
    dark: {
      handle: {
        contentBackground: "{surface.950}"
      }
    }
  }
};
var index$m = {
  root: {
    gap: "0.5rem",
    transitionDuration: "{transition.duration}"
  }
};
var index$l = {
  root: {
    borderRadius: "{form.field.border.radius}",
    roundedBorderRadius: "2rem",
    raisedShadow: "0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12)"
  }
};
var index$k = {
  root: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    color: "{content.color}",
    transitionDuration: "{transition.duration}"
  },
  gutter: {
    background: "{content.border.color}"
  },
  handle: {
    size: "24px",
    background: "transparent",
    borderRadius: "{content.border.radius}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  }
};
var index$j = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  separator: {
    background: "{content.border.color}",
    activeBackground: "{primary.color}",
    margin: "0 0 0 1.625rem",
    size: "2px"
  },
  step: {
    padding: "0.5rem",
    gap: "1rem"
  },
  stepHeader: {
    padding: "0",
    borderRadius: "{content.border.radius}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    },
    gap: "0.5rem"
  },
  stepTitle: {
    color: "{text.muted.color}",
    activeColor: "{primary.color}",
    fontWeight: "500"
  },
  stepNumber: {
    background: "{content.background}",
    activeBackground: "{content.background}",
    borderColor: "{content.border.color}",
    activeBorderColor: "{content.border.color}",
    color: "{text.muted.color}",
    activeColor: "{primary.color}",
    size: "2rem",
    fontSize: "1.143rem",
    fontWeight: "500",
    borderRadius: "50%",
    shadow: "0px 0.5px 0px 0px rgba(0, 0, 0, 0.06), 0px 1px 1px 0px rgba(0, 0, 0, 0.12)"
  },
  steppanels: {
    padding: "0.875rem 0.5rem 1.125rem 0.5rem"
  },
  steppanel: {
    background: "{content.background}",
    color: "{content.color}",
    padding: "0 0 0 1rem",
    last: {
      padding: "0 0 0 1.625rem"
    }
  }
};
var index$i = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  separator: {
    background: "{content.border.color}"
  },
  itemLink: {
    borderRadius: "{content.border.radius}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    },
    gap: "0.5rem"
  },
  itemLabel: {
    color: "{text.muted.color}",
    activeColor: "{primary.color}",
    fontWeight: "500"
  },
  itemNumber: {
    background: "{content.background}",
    activeBackground: "{content.background}",
    borderColor: "{content.border.color}",
    activeBorderColor: "{content.border.color}",
    color: "{text.muted.color}",
    activeColor: "{primary.color}",
    size: "2rem",
    fontSize: "1.143rem",
    fontWeight: "500",
    borderRadius: "50%",
    shadow: "0px 0.5px 0px 0px rgba(0, 0, 0, 0.06), 0px 1px 1px 0px rgba(0, 0, 0, 0.12)"
  }
};
var index$h = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  tablist: {
    borderWidth: "0 0 1px 0",
    background: "{content.background}",
    borderColor: "{content.border.color}"
  },
  item: {
    background: "transparent",
    hoverBackground: "transparent",
    activeBackground: "transparent",
    borderWidth: "0 0 1px 0",
    borderColor: "{content.border.color}",
    hoverBorderColor: "{content.border.color}",
    activeBorderColor: "{primary.color}",
    color: "{text.muted.color}",
    hoverColor: "{text.color}",
    activeColor: "{primary.color}",
    padding: "1rem 1.125rem",
    fontWeight: "600",
    margin: "0 0 -1px 0",
    gap: "0.5rem",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  itemIcon: {
    color: "{text.muted.color}",
    hoverColor: "{text.color}",
    activeColor: "{primary.color}"
  },
  activeBar: {
    height: "1px",
    bottom: "-1px",
    background: "{primary.color}"
  }
};
var index$g = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  tablist: {
    borderWidth: "0 0 1px 0",
    background: "{content.background}",
    borderColor: "{content.border.color}"
  },
  tab: {
    background: "transparent",
    hoverBackground: "transparent",
    activeBackground: "transparent",
    borderWidth: "0 0 1px 0",
    borderColor: "{content.border.color}",
    hoverBorderColor: "{content.border.color}",
    activeBorderColor: "{primary.color}",
    color: "{text.muted.color}",
    hoverColor: "{text.color}",
    activeColor: "{primary.color}",
    padding: "1rem 1.125rem",
    fontWeight: "600",
    margin: "0 0 -1px 0",
    gap: "0.5rem",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  tabpanel: {
    background: "{content.background}",
    color: "{content.color}",
    padding: "0.875rem 1.125rem 1.125rem 1.125rem",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "inset {focus.ring.shadow}"
    }
  },
  navButton: {
    background: "{content.background}",
    color: "{text.muted.color}",
    hoverColor: "{text.color}",
    width: "2.5rem",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "-1px",
      shadow: "{focus.ring.shadow}"
    }
  },
  activeBar: {
    height: "1px",
    bottom: "-1px",
    background: "{primary.color}"
  },
  colorScheme: {
    light: {
      navButton: {
        boxShadow: "0px 0px 10px 50px rgba(255, 255, 255, 0.6)"
      }
    },
    dark: {
      navButton: {
        boxShadow: "0px 0px 10px 50px color-mix(in srgb, {content.background}, transparent 50%)"
      }
    }
  }
};
var index$f = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  tabList: {
    background: "{content.background}",
    borderColor: "{content.border.color}"
  },
  tab: {
    borderColor: "{content.border.color}",
    activeBorderColor: "{primary.color}",
    color: "{text.muted.color}",
    hoverColor: "{text.color}",
    activeColor: "{primary.color}"
  },
  tabPanel: {
    background: "{content.background}",
    color: "{content.color}"
  },
  navButton: {
    background: "{content.background}",
    color: "{text.muted.color}",
    hoverColor: "{text.color}"
  },
  colorScheme: {
    light: {
      navButton: {
        boxShadow: "0px 0px 10px 50px rgba(255, 255, 255, 0.6)"
      }
    },
    dark: {
      navButton: {
        boxShadow: "0px 0px 10px 50px color-mix(in srgb, {content.background}, transparent 50%)"
      }
    }
  }
};
var index$e = {
  root: {
    fontSize: "0.875rem",
    fontWeight: "700",
    padding: "0.25rem 0.5rem",
    gap: "0.25rem",
    borderRadius: "{content.border.radius}",
    roundedBorderRadius: "{border.radius.xl}"
  },
  icon: {
    size: "0.75rem"
  },
  colorScheme: {
    light: {
      primary: {
        background: "{primary.100}",
        color: "{primary.700}"
      },
      secondary: {
        background: "{surface.100}",
        color: "{surface.600}"
      },
      success: {
        background: "{green.100}",
        color: "{green.700}"
      },
      info: {
        background: "{sky.100}",
        color: "{sky.700}"
      },
      warn: {
        background: "{orange.100}",
        color: "{orange.700}"
      },
      danger: {
        background: "{red.100}",
        color: "{red.700}"
      },
      contrast: {
        background: "{surface.950}",
        color: "{surface.0}"
      }
    },
    dark: {
      primary: {
        background: "color-mix(in srgb, {primary.500}, transparent 84%)",
        color: "{primary.300}"
      },
      secondary: {
        background: "{surface.800}",
        color: "{surface.300}"
      },
      success: {
        background: "color-mix(in srgb, {green.500}, transparent 84%)",
        color: "{green.300}"
      },
      info: {
        background: "color-mix(in srgb, {sky.500}, transparent 84%)",
        color: "{sky.300}"
      },
      warn: {
        background: "color-mix(in srgb, {orange.500}, transparent 84%)",
        color: "{orange.300}"
      },
      danger: {
        background: "color-mix(in srgb, {red.500}, transparent 84%)",
        color: "{red.300}"
      },
      contrast: {
        background: "{surface.0}",
        color: "{surface.950}"
      }
    }
  }
};
var index$d = {
  root: {
    background: "{form.field.background}",
    borderColor: "{form.field.border.color}",
    color: "{form.field.color}",
    height: "18rem",
    padding: "{form.field.padding.y} {form.field.padding.x}",
    borderRadius: "{form.field.border.radius}"
  },
  prompt: {
    gap: "0.25rem"
  },
  commandResponse: {
    margin: "2px 0"
  }
};
var index$c = {
  root: {
    background: "{form.field.background}",
    disabledBackground: "{form.field.disabled.background}",
    filledBackground: "{form.field.filled.background}",
    filledFocusBackground: "{form.field.filled.focus.background}",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.hover.border.color}",
    focusBorderColor: "{form.field.focus.border.color}",
    invalidBorderColor: "{form.field.invalid.border.color}",
    color: "{form.field.color}",
    disabledColor: "{form.field.disabled.color}",
    placeholderColor: "{form.field.placeholder.color}",
    shadow: "{form.field.shadow}",
    paddingX: "{form.field.padding.x}",
    paddingY: "{form.field.padding.y}",
    borderRadius: "{form.field.border.radius}",
    focusRing: {
      width: "{form.field.focus.ring.width}",
      style: "{form.field.focus.ring.style}",
      color: "{form.field.focus.ring.color}",
      offset: "{form.field.focus.ring.offset}",
      shadow: "{form.field.focus.ring.shadow}"
    },
    transitionDuration: "{form.field.transition.duration}"
  }
};
var index$b = {
  root: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    color: "{content.color}",
    borderRadius: "{content.border.radius}",
    shadow: "{overlay.navigation.shadow}",
    transitionDuration: "{transition.duration}"
  },
  list: {
    padding: "{navigation.list.padding}",
    gap: "{navigation.list.gap}"
  },
  item: {
    focusBackground: "{navigation.item.focus.background}",
    activeBackground: "{navigation.item.active.background}",
    color: "{navigation.item.color}",
    focusColor: "{navigation.item.focus.color}",
    activeColor: "{navigation.item.active.color}",
    padding: "{navigation.item.padding}",
    borderRadius: "{navigation.item.border.radius}",
    gap: "{navigation.item.gap}",
    icon: {
      color: "{navigation.item.icon.color}",
      focusColor: "{navigation.item.icon.focus.color}",
      activeColor: "{navigation.item.icon.active.color}"
    }
  },
  submenuLabel: {
    padding: "{navigation.submenu.label.padding}",
    fontWeight: "{navigation.submenu.label.font.weight}",
    background: "{navigation.submenu.label.background.}",
    color: "{navigation.submenu.label.color}"
  },
  submenuIcon: {
    size: "{navigation.submenu.icon.size}",
    color: "{navigation.submenu.icon.color}",
    focusColor: "{navigation.submenu.icon.focus.color}",
    activeColor: "{navigation.submenu.icon.active.color}"
  },
  separator: {
    borderColor: "{content.border.color}"
  }
};
var index$a = {
  event: {
    minHeight: "5rem"
  },
  horizontal: {
    eventContent: {
      padding: "1rem 0"
    }
  },
  vertical: {
    eventContent: {
      padding: "0 1rem"
    }
  },
  eventMarker: {
    size: "1.125rem",
    borderRadius: "50%",
    borderWidth: "2px",
    background: "{content.background}",
    borderColor: "{content.border.color}",
    content: {
      borderRadius: "50%",
      size: "0.375rem",
      background: "{primary.color}",
      insetShadow: "0px 0.5px 0px 0px rgba(0, 0, 0, 0.06), 0px 1px 1px 0px rgba(0, 0, 0, 0.12)"
    }
  },
  eventConnector: {
    color: "{content.border.color}",
    size: "2px"
  }
};
var index$9 = {
  root: {
    width: "25rem",
    borderRadius: "{content.border.radius}",
    borderWidth: "1px",
    transitionDuration: "{transition.duration}"
  },
  icon: {
    size: "1.125rem"
  },
  content: {
    padding: "{overlay.popover.padding}",
    gap: "0.5rem"
  },
  text: {
    gap: "0.5rem"
  },
  summary: {
    fontWeight: "500",
    fontSize: "1rem"
  },
  detail: {
    fontWeight: "500",
    fontSize: "0.875rem"
  },
  closeButton: {
    width: "1.75rem",
    height: "1.75rem",
    borderRadius: "50%",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      offset: "{focus.ring.offset}"
    }
  },
  closeIcon: {
    size: "1rem"
  },
  colorScheme: {
    light: {
      blur: "1.5px",
      info: {
        background: "color-mix(in srgb, {blue.50}, transparent 5%)",
        borderColor: "{blue.200}",
        color: "{blue.600}",
        detailColor: "{surface.700}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {blue.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "{blue.100}",
          focusRing: {
            color: "{blue.600}",
            shadow: "none"
          }
        }
      },
      success: {
        background: "color-mix(in srgb, {green.50}, transparent 5%)",
        borderColor: "{green.200}",
        color: "{green.600}",
        detailColor: "{surface.700}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {green.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "{green.100}",
          focusRing: {
            color: "{green.600}",
            shadow: "none"
          }
        }
      },
      warn: {
        background: "color-mix(in srgb,{yellow.50}, transparent 5%)",
        borderColor: "{yellow.200}",
        color: "{yellow.600}",
        detailColor: "{surface.700}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {yellow.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "{yellow.100}",
          focusRing: {
            color: "{yellow.600}",
            shadow: "none"
          }
        }
      },
      error: {
        background: "color-mix(in srgb, {red.50}, transparent 5%)",
        borderColor: "{red.200}",
        color: "{red.600}",
        detailColor: "{surface.700}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {red.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "{red.100}",
          focusRing: {
            color: "{red.600}",
            shadow: "none"
          }
        }
      },
      secondary: {
        background: "{surface.100}",
        borderColor: "{surface.200}",
        color: "{surface.600}",
        detailColor: "{surface.700}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "{surface.200}",
          focusRing: {
            color: "{surface.600}",
            shadow: "none"
          }
        }
      },
      contrast: {
        background: "{surface.900}",
        borderColor: "{surface.950}",
        color: "{surface.50}",
        detailColor: "{surface.0}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.950}, transparent 96%)",
        closeButton: {
          hoverBackground: "{surface.800}",
          focusRing: {
            color: "{surface.50}",
            shadow: "none"
          }
        }
      }
    },
    dark: {
      blur: "10px",
      info: {
        background: "color-mix(in srgb, {blue.500}, transparent 84%)",
        borderColor: "color-mix(in srgb, {blue.700}, transparent 64%)",
        color: "{blue.500}",
        detailColor: "{surface.0}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {blue.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "rgba(255, 255, 255, 0.05)",
          focusRing: {
            color: "{blue.500}",
            shadow: "none"
          }
        }
      },
      success: {
        background: "color-mix(in srgb, {green.500}, transparent 84%)",
        borderColor: "color-mix(in srgb, {green.700}, transparent 64%)",
        color: "{green.500}",
        detailColor: "{surface.0}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {green.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "rgba(255, 255, 255, 0.05)",
          focusRing: {
            color: "{green.500}",
            shadow: "none"
          }
        }
      },
      warn: {
        background: "color-mix(in srgb, {yellow.500}, transparent 84%)",
        borderColor: "color-mix(in srgb, {yellow.700}, transparent 64%)",
        color: "{yellow.500}",
        detailColor: "{surface.0}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {yellow.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "rgba(255, 255, 255, 0.05)",
          focusRing: {
            color: "{yellow.500}",
            shadow: "none"
          }
        }
      },
      error: {
        background: "color-mix(in srgb, {red.500}, transparent 84%)",
        borderColor: "color-mix(in srgb, {red.700}, transparent 64%)",
        color: "{red.500}",
        detailColor: "{surface.0}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {red.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "rgba(255, 255, 255, 0.05)",
          focusRing: {
            color: "{red.500}",
            shadow: "none"
          }
        }
      },
      secondary: {
        background: "{surface.800}",
        borderColor: "{surface.700}",
        color: "{surface.300}",
        detailColor: "{surface.0}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "{surface.700}",
          focusRing: {
            color: "{surface.300}",
            shadow: "none"
          }
        }
      },
      contrast: {
        background: "{surface.0}",
        borderColor: "{surface.100}",
        color: "{surface.950}",
        detailColor: "{surface.950}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.950}, transparent 96%)",
        closeButton: {
          hoverBackground: "{surface.100}",
          focusRing: {
            color: "{surface.950}",
            shadow: "none"
          }
        }
      }
    }
  }
};
var index$8 = {
  root: {
    padding: "0.5rem 1rem",
    borderRadius: "{content.border.radius}",
    gap: "0.5rem",
    fontWeight: "500",
    disabledBackground: "{form.field.disabled.background}",
    disabledBorderColor: "{form.field.disabled.background}",
    disabledColor: "{form.field.disabled.color}",
    invalidBorderColor: "{form.field.invalid.border.color}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    },
    transitionDuration: "{form.field.transition.duration}"
  },
  icon: {
    disabledColor: "{form.field.disabled.color}"
  },
  content: {
    left: "0.25rem",
    top: "0.25rem",
    checkedShadow: "0px 1px 2px 0px rgba(0, 0, 0, 0.02), 0px 1px 2px 0px rgba(0, 0, 0, 0.04)"
  },
  colorScheme: {
    light: {
      root: {
        background: "{surface.100}",
        checkedBackground: "{surface.100}",
        hoverBackground: "{surface.100}",
        borderColor: "{surface.100}",
        color: "{surface.500}",
        hoverColor: "{surface.700}",
        checkedColor: "{surface.900}",
        checkedBorderColor: "{surface.100}"
      },
      content: {
        checkedBackground: "{surface.0}"
      },
      icon: {
        color: "{surface.500}",
        hoverColor: "{surface.700}",
        checkedColor: "{surface.900}"
      }
    },
    dark: {
      root: {
        background: "{surface.950}",
        checkedBackground: "{surface.950}",
        hoverBackground: "{surface.950}",
        borderColor: "{surface.950}",
        color: "{surface.400}",
        hoverColor: "{surface.300}",
        checkedColor: "{surface.0}",
        checkedBorderColor: "{surface.950}"
      },
      content: {
        checkedBackground: "{surface.800}"
      },
      icon: {
        color: "{surface.400}",
        hoverColor: "{surface.300}",
        checkedColor: "{surface.0}"
      }
    }
  }
};
var index$7 = {
  root: {
    width: "2.5rem",
    height: "1.5rem",
    borderRadius: "30px",
    gap: "0.25rem",
    shadow: "{form.field.shadow}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    },
    borderWidth: "1px",
    borderColor: "transparent",
    hoverBorderColor: "transparent",
    checkedBorderColor: "transparent",
    checkedHoverBorderColor: "transparent",
    invalidBorderColor: "{form.field.invalid.border.color}",
    transitionDuration: "{form.field.transition.duration}",
    slideDuration: "0.2s"
  },
  handle: {
    borderRadius: "50%",
    size: "1rem"
  },
  colorScheme: {
    light: {
      root: {
        background: "{surface.300}",
        hoverBackground: "{surface.400}",
        checkedBackground: "{primary.color}",
        checkedHoverBackground: "{primary.hover.color}"
      },
      handle: {
        background: "{surface.0}",
        hoverBackground: "{surface.0}",
        checkedBackground: "{surface.0}",
        checkedHoverBackground: "{surface.0}"
      }
    },
    dark: {
      root: {
        background: "{surface.700}",
        hoverBackground: "{surface.600}",
        checkedBackground: "{primary.color}",
        checkedHoverBackground: "{primary.hover.color}"
      },
      handle: {
        background: "{surface.400}",
        hoverBackground: "{surface.300}",
        checkedBackground: "{surface.900}",
        checkedHoverBackground: "{surface.900}"
      }
    }
  }
};
var index$6 = {
  root: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    borderRadius: "{content.border.radius}",
    color: "{content.color}",
    gap: "0.5rem",
    padding: "0.75rem"
  }
};
var index$5 = {
  root: {
    maxWidth: "12.5rem",
    gutter: "0.25rem",
    shadow: "{overlay.popover.shadow}",
    padding: "0.5rem 0.75rem",
    borderRadius: "{overlay.popover.border.radius}"
  },
  colorScheme: {
    light: {
      root: {
        background: "{surface.700}",
        color: "{surface.0}"
      }
    },
    dark: {
      root: {
        background: "{surface.700}",
        color: "{surface.0}"
      }
    }
  }
};
var index$4 = {
  root: {
    background: "{content.background}",
    color: "{content.color}",
    padding: "1rem",
    gap: "2px",
    indent: "1rem",
    transitionDuration: "{transition.duration}"
  },
  node: {
    padding: "0.25rem 0.5rem",
    borderRadius: "{content.border.radius}",
    hoverBackground: "{content.hover.background}",
    selectedBackground: "{highlight.background}",
    color: "{text.color}",
    hoverColor: "{text.hover.color}",
    selectedColor: "{highlight.color}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "-1px",
      shadow: "{focus.ring.shadow}"
    },
    gap: "0.25rem"
  },
  nodeIcon: {
    color: "{text.muted.color}",
    hoverColor: "{text.hover.muted.color}",
    selectedColor: "{highlight.color}"
  },
  nodeToggleButton: {
    borderRadius: "50%",
    size: "1.75rem",
    hoverBackground: "{content.hover.background}",
    selectedHoverBackground: "{content.background}",
    color: "{text.muted.color}",
    hoverColor: "{text.hover.muted.color}",
    selectedHoverColor: "{primary.color}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  loadingIcon: {
    size: "2rem"
  }
};
var index$3 = {
  root: {
    background: "{form.field.background}",
    disabledBackground: "{form.field.disabled.background}",
    filledBackground: "{form.field.filled.background}",
    filledFocusBackground: "{form.field.filled.focus.background}",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.hover.border.color}",
    focusBorderColor: "{form.field.focus.border.color}",
    invalidBorderColor: "{form.field.invalid.border.color}",
    color: "{form.field.color}",
    disabledColor: "{form.field.disabled.color}",
    placeholderColor: "{form.field.placeholder.color}",
    shadow: "{form.field.shadow}",
    paddingX: "{form.field.padding.x}",
    paddingY: "{form.field.padding.y}",
    borderRadius: "{form.field.border.radius}",
    focusRing: {
      width: "{form.field.focus.ring.width}",
      style: "{form.field.focus.ring.style}",
      color: "{form.field.focus.ring.color}",
      offset: "{form.field.focus.ring.offset}",
      shadow: "{form.field.focus.ring.shadow}"
    },
    transitionDuration: "{form.field.transition.duration}"
  },
  dropdown: {
    width: "2.5rem",
    color: "{form.field.icon.color}"
  },
  overlay: {
    background: "{overlay.select.background}",
    borderColor: "{overlay.select.border.color}",
    borderRadius: "{overlay.select.border.radius}",
    color: "{overlay.select.color}",
    shadow: "{overlay.select.shadow}"
  },
  tree: {
    padding: "{list.padding}"
  },
  emptyMessage: {
    padding: "{list.option.padding}"
  },
  chip: {
    borderRadius: "{border.radius.sm}"
  }
};
var index$2 = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  header: {
    background: "{content.background}",
    borderColor: "{treetable.border.color}",
    color: "{content.color}",
    borderWidth: "0 0 1px 0",
    padding: "0.75rem 1rem"
  },
  headerCell: {
    background: "{content.background}",
    hoverBackground: "{content.hover.background}",
    selectedBackground: "{highlight.background}",
    borderColor: "{treetable.border.color}",
    color: "{content.color}",
    hoverColor: "{content.hover.color}",
    selectedColor: "{highlight.color}",
    gap: "0.5rem",
    padding: "0.75rem 1rem",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "-1px",
      shadow: "{focus.ring.shadow}"
    }
  },
  columnTitle: {
    fontWeight: "600"
  },
  row: {
    background: "{content.background}",
    hoverBackground: "{content.hover.background}",
    selectedBackground: "{highlight.background}",
    color: "{content.color}",
    hoverColor: "{content.hover.color}",
    selectedColor: "{highlight.color}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "-1px",
      shadow: "{focus.ring.shadow}"
    }
  },
  bodyCell: {
    borderColor: "{treetable.border.color}",
    padding: "0.75rem 1rem",
    gap: "0.5rem"
  },
  footerCell: {
    background: "{content.background}",
    borderColor: "{treetable.border.color}",
    color: "{content.color}",
    padding: "0.75rem 1rem"
  },
  columnFooter: {
    fontWeight: "600"
  },
  footer: {
    background: "{content.background}",
    borderColor: "{treetable.border.color}",
    color: "{content.color}",
    borderWidth: "0 0 1px 0",
    padding: "0.75rem 1rem"
  },
  columnResizerWidth: "0.5rem",
  resizeIndicator: {
    width: "1px",
    color: "{primary.color}"
  },
  sortIcon: {
    color: "{text.muted.color}",
    hoverColor: "{text.hover.muted.color}"
  },
  loadingIcon: {
    size: "2rem"
  },
  nodeToggleButton: {
    hoverBackground: "{content.hover.background}",
    selectedHoverBackground: "{content.background}",
    color: "{text.muted.color}",
    hoverColor: "{text.color}",
    selectedHoverColor: "{primary.color}",
    size: "1.75rem",
    borderRadius: "50%",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  paginatorTop: {
    borderColor: "{content.border.color}",
    borderWidth: "0 0 1px 0"
  },
  paginatorBottom: {
    borderColor: "{content.border.color}",
    borderWidth: "0 0 1px 0"
  },
  colorScheme: {
    light: {
      root: {
        borderColor: "{content.border.color}"
      },
      bodyCell: {
        selectedBorderColor: "{primary.100}"
      }
    },
    dark: {
      root: {
        borderColor: "{surface.800}"
      },
      bodyCell: {
        selectedBorderColor: "{primary.900}"
      }
    }
  }
};
var index$1 = {
  primitive: {
    borderRadius: {
      none: "0",
      xs: "2px",
      sm: "4px",
      md: "6px",
      lg: "8px",
      xl: "12px"
    },
    emerald: {
      50: "#ecfdf5",
      100: "#d1fae5",
      200: "#a7f3d0",
      300: "#6ee7b7",
      400: "#34d399",
      500: "#10b981",
      600: "#059669",
      700: "#047857",
      800: "#065f46",
      900: "#064e3b",
      950: "#022c22"
    },
    green: {
      50: "#f0fdf4",
      100: "#dcfce7",
      200: "#bbf7d0",
      300: "#86efac",
      400: "#4ade80",
      500: "#22c55e",
      600: "#16a34a",
      700: "#15803d",
      800: "#166534",
      900: "#14532d",
      950: "#052e16"
    },
    lime: {
      50: "#f7fee7",
      100: "#ecfccb",
      200: "#d9f99d",
      300: "#bef264",
      400: "#a3e635",
      500: "#84cc16",
      600: "#65a30d",
      700: "#4d7c0f",
      800: "#3f6212",
      900: "#365314",
      950: "#1a2e05"
    },
    red: {
      50: "#fef2f2",
      100: "#fee2e2",
      200: "#fecaca",
      300: "#fca5a5",
      400: "#f87171",
      500: "#ef4444",
      600: "#dc2626",
      700: "#b91c1c",
      800: "#991b1b",
      900: "#7f1d1d",
      950: "#450a0a"
    },
    orange: {
      50: "#fff7ed",
      100: "#ffedd5",
      200: "#fed7aa",
      300: "#fdba74",
      400: "#fb923c",
      500: "#f97316",
      600: "#ea580c",
      700: "#c2410c",
      800: "#9a3412",
      900: "#7c2d12",
      950: "#431407"
    },
    amber: {
      50: "#fffbeb",
      100: "#fef3c7",
      200: "#fde68a",
      300: "#fcd34d",
      400: "#fbbf24",
      500: "#f59e0b",
      600: "#d97706",
      700: "#b45309",
      800: "#92400e",
      900: "#78350f",
      950: "#451a03"
    },
    yellow: {
      50: "#fefce8",
      100: "#fef9c3",
      200: "#fef08a",
      300: "#fde047",
      400: "#facc15",
      500: "#eab308",
      600: "#ca8a04",
      700: "#a16207",
      800: "#854d0e",
      900: "#713f12",
      950: "#422006"
    },
    teal: {
      50: "#f0fdfa",
      100: "#ccfbf1",
      200: "#99f6e4",
      300: "#5eead4",
      400: "#2dd4bf",
      500: "#14b8a6",
      600: "#0d9488",
      700: "#0f766e",
      800: "#115e59",
      900: "#134e4a",
      950: "#042f2e"
    },
    cyan: {
      50: "#ecfeff",
      100: "#cffafe",
      200: "#a5f3fc",
      300: "#67e8f9",
      400: "#22d3ee",
      500: "#06b6d4",
      600: "#0891b2",
      700: "#0e7490",
      800: "#155e75",
      900: "#164e63",
      950: "#083344"
    },
    sky: {
      50: "#f0f9ff",
      100: "#e0f2fe",
      200: "#bae6fd",
      300: "#7dd3fc",
      400: "#38bdf8",
      500: "#0ea5e9",
      600: "#0284c7",
      700: "#0369a1",
      800: "#075985",
      900: "#0c4a6e",
      950: "#082f49"
    },
    blue: {
      50: "#eff6ff",
      100: "#dbeafe",
      200: "#bfdbfe",
      300: "#93c5fd",
      400: "#60a5fa",
      500: "#3b82f6",
      600: "#2563eb",
      700: "#1d4ed8",
      800: "#1e40af",
      900: "#1e3a8a",
      950: "#172554"
    },
    indigo: {
      50: "#eef2ff",
      100: "#e0e7ff",
      200: "#c7d2fe",
      300: "#a5b4fc",
      400: "#818cf8",
      500: "#6366f1",
      600: "#4f46e5",
      700: "#4338ca",
      800: "#3730a3",
      900: "#312e81",
      950: "#1e1b4b"
    },
    violet: {
      50: "#f5f3ff",
      100: "#ede9fe",
      200: "#ddd6fe",
      300: "#c4b5fd",
      400: "#a78bfa",
      500: "#8b5cf6",
      600: "#7c3aed",
      700: "#6d28d9",
      800: "#5b21b6",
      900: "#4c1d95",
      950: "#2e1065"
    },
    purple: {
      50: "#faf5ff",
      100: "#f3e8ff",
      200: "#e9d5ff",
      300: "#d8b4fe",
      400: "#c084fc",
      500: "#a855f7",
      600: "#9333ea",
      700: "#7e22ce",
      800: "#6b21a8",
      900: "#581c87",
      950: "#3b0764"
    },
    fuchsia: {
      50: "#fdf4ff",
      100: "#fae8ff",
      200: "#f5d0fe",
      300: "#f0abfc",
      400: "#e879f9",
      500: "#d946ef",
      600: "#c026d3",
      700: "#a21caf",
      800: "#86198f",
      900: "#701a75",
      950: "#4a044e"
    },
    pink: {
      50: "#fdf2f8",
      100: "#fce7f3",
      200: "#fbcfe8",
      300: "#f9a8d4",
      400: "#f472b6",
      500: "#ec4899",
      600: "#db2777",
      700: "#be185d",
      800: "#9d174d",
      900: "#831843",
      950: "#500724"
    },
    rose: {
      50: "#fff1f2",
      100: "#ffe4e6",
      200: "#fecdd3",
      300: "#fda4af",
      400: "#fb7185",
      500: "#f43f5e",
      600: "#e11d48",
      700: "#be123c",
      800: "#9f1239",
      900: "#881337",
      950: "#4c0519"
    },
    slate: {
      50: "#f8fafc",
      100: "#f1f5f9",
      200: "#e2e8f0",
      300: "#cbd5e1",
      400: "#94a3b8",
      500: "#64748b",
      600: "#475569",
      700: "#334155",
      800: "#1e293b",
      900: "#0f172a",
      950: "#020617"
    },
    gray: {
      50: "#f9fafb",
      100: "#f3f4f6",
      200: "#e5e7eb",
      300: "#d1d5db",
      400: "#9ca3af",
      500: "#6b7280",
      600: "#4b5563",
      700: "#374151",
      800: "#1f2937",
      900: "#111827",
      950: "#030712"
    },
    zinc: {
      50: "#fafafa",
      100: "#f4f4f5",
      200: "#e4e4e7",
      300: "#d4d4d8",
      400: "#a1a1aa",
      500: "#71717a",
      600: "#52525b",
      700: "#3f3f46",
      800: "#27272a",
      900: "#18181b",
      950: "#09090b"
    },
    neutral: {
      50: "#fafafa",
      100: "#f5f5f5",
      200: "#e5e5e5",
      300: "#d4d4d4",
      400: "#a3a3a3",
      500: "#737373",
      600: "#525252",
      700: "#404040",
      800: "#262626",
      900: "#171717",
      950: "#0a0a0a"
    },
    stone: {
      50: "#fafaf9",
      100: "#f5f5f4",
      200: "#e7e5e4",
      300: "#d6d3d1",
      400: "#a8a29e",
      500: "#78716c",
      600: "#57534e",
      700: "#44403c",
      800: "#292524",
      900: "#1c1917",
      950: "#0c0a09"
    }
  },
  semantic: {
    transitionDuration: "0.2s",
    focusRing: {
      width: "1px",
      style: "solid",
      color: "{primary.color}",
      offset: "2px",
      shadow: "none"
    },
    disabledOpacity: "0.6",
    iconSize: "1rem",
    anchorGutter: "2px",
    primary: {
      50: "{emerald.50}",
      100: "{emerald.100}",
      200: "{emerald.200}",
      300: "{emerald.300}",
      400: "{emerald.400}",
      500: "{emerald.500}",
      600: "{emerald.600}",
      700: "{emerald.700}",
      800: "{emerald.800}",
      900: "{emerald.900}",
      950: "{emerald.950}"
    },
    formField: {
      paddingX: "0.75rem",
      paddingY: "0.5rem",
      borderRadius: "{border.radius.md}",
      focusRing: {
        width: "0",
        style: "none",
        color: "transparent",
        offset: "0",
        shadow: "none"
      },
      transitionDuration: "{transition.duration}"
    },
    list: {
      padding: "0.25rem 0.25rem",
      gap: "2px",
      header: {
        padding: "0.5rem 0.75rem 0.25rem 0.75rem"
      },
      option: {
        padding: "0.5rem 0.75rem",
        borderRadius: "{border.radius.sm}"
      },
      optionGroup: {
        padding: "0.5rem 0.75rem",
        fontWeight: "600"
      }
    },
    content: {
      borderRadius: "{border.radius.md}"
    },
    mask: {
      transitionDuration: "0.15s"
    },
    navigation: {
      list: {
        padding: "0.25rem 0.25rem",
        gap: "2px"
      },
      item: {
        padding: "0.5rem 0.75rem",
        borderRadius: "{border.radius.sm}",
        gap: "0.5rem"
      },
      submenuLabel: {
        padding: "0.5rem 0.75rem",
        fontWeight: "600"
      },
      submenuIcon: {
        size: "0.875rem"
      }
    },
    overlay: {
      select: {
        borderRadius: "{border.radius.md}",
        shadow: "0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1)"
      },
      popover: {
        borderRadius: "{border.radius.md}",
        padding: "0.75rem",
        shadow: "0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1)"
      },
      modal: {
        borderRadius: "{border.radius.xl}",
        padding: "1.25rem",
        shadow: "0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1)"
      },
      navigation: {
        shadow: "0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1)"
      }
    },
    colorScheme: {
      light: {
        surface: {
          0: "#ffffff",
          50: "{slate.50}",
          100: "{slate.100}",
          200: "{slate.200}",
          300: "{slate.300}",
          400: "{slate.400}",
          500: "{slate.500}",
          600: "{slate.600}",
          700: "{slate.700}",
          800: "{slate.800}",
          900: "{slate.900}",
          950: "{slate.950}"
        },
        primary: {
          color: "{primary.500}",
          contrastColor: "#ffffff",
          hoverColor: "{primary.600}",
          activeColor: "{primary.700}"
        },
        highlight: {
          background: "{primary.50}",
          focusBackground: "{primary.100}",
          color: "{primary.700}",
          focusColor: "{primary.800}"
        },
        mask: {
          background: "rgba(0,0,0,0.4)",
          color: "{surface.200}"
        },
        formField: {
          background: "{surface.0}",
          disabledBackground: "{surface.200}",
          filledBackground: "{surface.50}",
          filledFocusBackground: "{surface.50}",
          borderColor: "{surface.300}",
          hoverBorderColor: "{surface.400}",
          focusBorderColor: "{primary.color}",
          invalidBorderColor: "{red.400}",
          color: "{surface.700}",
          disabledColor: "{surface.500}",
          placeholderColor: "{surface.500}",
          floatLabelColor: "{surface.500}",
          floatLabelFocusColor: "{surface.500}",
          floatLabelInvalidColor: "{red.400}",
          iconColor: "{surface.400}",
          shadow: "0 0 #0000, 0 0 #0000, 0 1px 2px 0 rgba(18, 18, 23, 0.05)"
        },
        text: {
          color: "{surface.700}",
          hoverColor: "{surface.800}",
          mutedColor: "{surface.500}",
          hoverMutedColor: "{surface.600}"
        },
        content: {
          background: "{surface.0}",
          hoverBackground: "{surface.100}",
          borderColor: "{surface.200}",
          color: "{text.color}",
          hoverColor: "{text.hover.color}"
        },
        overlay: {
          select: {
            background: "{surface.0}",
            borderColor: "{surface.200}",
            color: "{text.color}"
          },
          popover: {
            background: "{surface.0}",
            borderColor: "{surface.200}",
            color: "{text.color}"
          },
          modal: {
            background: "{surface.0}",
            borderColor: "{surface.200}",
            color: "{text.color}"
          }
        },
        list: {
          option: {
            focusBackground: "{surface.100}",
            selectedBackground: "{highlight.background}",
            selectedFocusBackground: "{highlight.focus.background}",
            color: "{text.color}",
            focusColor: "{text.hover.color}",
            selectedColor: "{highlight.color}",
            selectedFocusColor: "{highlight.focus.color}",
            icon: {
              color: "{surface.400}",
              focusColor: "{surface.500}"
            }
          },
          optionGroup: {
            background: "transparent",
            color: "{text.muted.color}"
          }
        },
        navigation: {
          item: {
            focusBackground: "{surface.100}",
            activeBackground: "{surface.100}",
            color: "{text.color}",
            focusColor: "{text.hover.color}",
            activeColor: "{text.hover.color}",
            icon: {
              color: "{surface.400}",
              focusColor: "{surface.500}",
              activeColor: "{surface.500}"
            }
          },
          submenuLabel: {
            background: "transparent",
            color: "{text.muted.color}"
          },
          submenuIcon: {
            color: "{surface.400}",
            focusColor: "{surface.500}",
            activeColor: "{surface.500}"
          }
        }
      },
      dark: {
        surface: {
          0: "#ffffff",
          50: "{zinc.50}",
          100: "{zinc.100}",
          200: "{zinc.200}",
          300: "{zinc.300}",
          400: "{zinc.400}",
          500: "{zinc.500}",
          600: "{zinc.600}",
          700: "{zinc.700}",
          800: "{zinc.800}",
          900: "{zinc.900}",
          950: "{zinc.950}"
        },
        primary: {
          color: "{primary.400}",
          contrastColor: "{surface.900}",
          hoverColor: "{primary.300}",
          activeColor: "{primary.200}"
        },
        highlight: {
          background: "color-mix(in srgb, {primary.400}, transparent 84%)",
          focusBackground: "color-mix(in srgb, {primary.400}, transparent 76%)",
          color: "rgba(255,255,255,.87)",
          focusColor: "rgba(255,255,255,.87)"
        },
        mask: {
          background: "rgba(0,0,0,0.6)",
          color: "{surface.200}"
        },
        formField: {
          background: "{surface.950}",
          disabledBackground: "{surface.700}",
          filledBackground: "{surface.800}",
          filledFocusBackground: "{surface.800}",
          borderColor: "{surface.700}",
          hoverBorderColor: "{surface.600}",
          focusBorderColor: "{primary.color}",
          invalidBorderColor: "{red.300}",
          color: "{surface.0}",
          disabledColor: "{surface.400}",
          placeholderColor: "{surface.400}",
          floatLabelColor: "{surface.400}",
          floatLabelFocusColor: "{surface.400}",
          floatLabelInvalidColor: "{red.300}",
          iconColor: "{surface.400}",
          shadow: "0 0 #0000, 0 0 #0000, 0 1px 2px 0 rgba(18, 18, 23, 0.05)"
        },
        text: {
          color: "{surface.0}",
          hoverColor: "{surface.0}",
          mutedColor: "{surface.400}",
          hoverMutedColor: "{surface.300}"
        },
        content: {
          background: "{surface.900}",
          hoverBackground: "{surface.800}",
          borderColor: "{surface.700}",
          color: "{text.color}",
          hoverColor: "{text.hover.color}"
        },
        overlay: {
          select: {
            background: "{surface.900}",
            borderColor: "{surface.700}",
            color: "{text.color}"
          },
          popover: {
            background: "{surface.900}",
            borderColor: "{surface.700}",
            color: "{text.color}"
          },
          modal: {
            background: "{surface.900}",
            borderColor: "{surface.700}",
            color: "{text.color}"
          }
        },
        list: {
          option: {
            focusBackground: "{surface.800}",
            selectedBackground: "{highlight.background}",
            selectedFocusBackground: "{highlight.focus.background}",
            color: "{text.color}",
            focusColor: "{text.hover.color}",
            selectedColor: "{highlight.color}",
            selectedFocusColor: "{highlight.focus.color}",
            icon: {
              color: "{surface.500}",
              focusColor: "{surface.400}"
            }
          },
          optionGroup: {
            background: "transparent",
            color: "{text.muted.color}"
          }
        },
        navigation: {
          item: {
            focusBackground: "{surface.800}",
            activeBackground: "{surface.800}",
            color: "{text.color}",
            focusColor: "{text.hover.color}",
            activeColor: "{text.hover.color}",
            icon: {
              color: "{surface.500}",
              focusColor: "{surface.400}",
              activeColor: "{surface.400}"
            }
          },
          submenuLabel: {
            background: "transparent",
            color: "{text.muted.color}"
          },
          submenuIcon: {
            color: "{surface.500}",
            focusColor: "{surface.400}",
            activeColor: "{surface.400}"
          }
        }
      }
    }
  },
  components: {
    accordion: index$1l,
    autocomplete: index$1k,
    avatar: index$1j,
    badge: index$1i,
    blockui: index$1h,
    breadcrumb: index$1g,
    button: index$1f,
    datepicker: index$13,
    card: index$1e,
    carousel: index$1d,
    cascadeselect: index$1c,
    checkbox: index$1b,
    chip: index$1a,
    colorpicker: index$19,
    confirmdialog: index$18,
    confirmpopup: index$17,
    contextmenu: index$16,
    dataview: index$14,
    datatable: index$15,
    dialog: index$12,
    divider: index$11,
    dock: index$10,
    drawer: index$$,
    editor: index$_,
    fieldset: index$Z,
    fileupload: index$Y,
    floatlabel: index$X,
    galleria: index$W,
    iconfield: index$V,
    image: index$U,
    inlinemessage: index$T,
    inplace: index$S,
    inputchips: index$R,
    inputgroup: index$Q,
    inputnumber: index$P,
    inputtext: index$O,
    knob: index$N,
    listbox: index$M,
    megamenu: index$L,
    menu: index$K,
    menubar: index$J,
    message: index$I,
    metergroup: index$H,
    multiselect: index$G,
    orderlist: index$F,
    organizationchart: index$E,
    overlaybadge: index$D,
    popover: index$x,
    paginator: index$C,
    password: index$z,
    panel: index$B,
    panelmenu: index$A,
    picklist: index$y,
    progressbar: index$w,
    progressspinner: index$v,
    radiobutton: index$u,
    rating: index$t,
    scrollpanel: index$r,
    select: index$q,
    selectbutton: index$p,
    skeleton: index$o,
    slider: index$n,
    speeddial: index$m,
    splitter: index$k,
    splitbutton: index$l,
    stepper: index$j,
    steps: index$i,
    tabmenu: index$h,
    tabs: index$g,
    tabview: index$f,
    textarea: index$c,
    tieredmenu: index$b,
    tag: index$e,
    terminal: index$d,
    timeline: index$a,
    togglebutton: index$8,
    toggleswitch: index$7,
    tree: index$4,
    treeselect: index$3,
    treetable: index$2,
    toast: index$9,
    toolbar: index$6
  },
  directives: {
    tooltip: index$5,
    ripple: index$s
  }
};
function ownKeys$2$2(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
__name(ownKeys$2$2, "ownKeys$2$2");
function _objectSpread$2$2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$2$2(Object(t), true).forEach(function(r2) {
      _defineProperty$3$1(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$2$2(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
__name(_objectSpread$2$2, "_objectSpread$2$2");
function _defineProperty$3$1(e, r, t) {
  return (r = _toPropertyKey$3$1(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty$3$1, "_defineProperty$3$1");
function _toPropertyKey$3$1(t) {
  var i2 = _toPrimitive$3$1(t, "string");
  return "symbol" == _typeof$3$1(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$3$1, "_toPropertyKey$3$1");
function _toPrimitive$3$1(t, r) {
  if ("object" != _typeof$3$1(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$3$1(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive$3$1, "_toPrimitive$3$1");
function _toConsumableArray$2$1(r) {
  return _arrayWithoutHoles$2$1(r) || _iterableToArray$2$1(r) || _unsupportedIterableToArray$3$1(r) || _nonIterableSpread$2$1();
}
__name(_toConsumableArray$2$1, "_toConsumableArray$2$1");
function _nonIterableSpread$2$1() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableSpread$2$1, "_nonIterableSpread$2$1");
function _unsupportedIterableToArray$3$1(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$3$1(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$3$1(r, a) : void 0;
  }
}
__name(_unsupportedIterableToArray$3$1, "_unsupportedIterableToArray$3$1");
function _iterableToArray$2$1(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
__name(_iterableToArray$2$1, "_iterableToArray$2$1");
function _arrayWithoutHoles$2$1(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$3$1(r);
}
__name(_arrayWithoutHoles$2$1, "_arrayWithoutHoles$2$1");
function _arrayLikeToArray$3$1(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
__name(_arrayLikeToArray$3$1, "_arrayLikeToArray$3$1");
function _typeof$3$1(o) {
  "@babel/helpers - typeof";
  return _typeof$3$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$3$1(o);
}
__name(_typeof$3$1, "_typeof$3$1");
var SharedUtils = {
  object: {
    isEmpty: /* @__PURE__ */ __name(function isEmpty2(value3) {
      return value3 === null || value3 === void 0 || value3 === "" || Array.isArray(value3) && value3.length === 0 || !(value3 instanceof Date) && _typeof$3$1(value3) === "object" && Object.keys(value3).length === 0;
    }, "isEmpty"),
    isNotEmpty: /* @__PURE__ */ __name(function isNotEmpty2(value3) {
      return !this.isEmpty(value3);
    }, "isNotEmpty"),
    isFunction: /* @__PURE__ */ __name(function isFunction2(value3) {
      return !!(value3 && value3.constructor && value3.call && value3.apply);
    }, "isFunction"),
    isObject: /* @__PURE__ */ __name(function isObject2(value3) {
      var empty = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      return value3 instanceof Object && value3.constructor === Object && (empty || Object.keys(value3).length !== 0);
    }, "isObject"),
    isArray: /* @__PURE__ */ __name(function isArray2(value3) {
      var empty = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      return Array.isArray(value3) && (empty || value3.length !== 0);
    }, "isArray"),
    isString: /* @__PURE__ */ __name(function isString2(value3) {
      var empty = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      return typeof value3 === "string" && (empty || value3 !== "");
    }, "isString"),
    isNumber: /* @__PURE__ */ __name(function isNumber2(value3) {
      return !isNaN(value3);
    }, "isNumber"),
    toFlatCase: /* @__PURE__ */ __name(function toFlatCase2(str) {
      return this.isString(str) ? str.replace(/(-|_)/g, "").toLowerCase() : str;
    }, "toFlatCase"),
    toKebabCase: /* @__PURE__ */ __name(function toKebabCase2(str) {
      return this.isString(str) ? str.replace(/(_)/g, "-").replace(/[A-Z]/g, function(c, i2) {
        return i2 === 0 ? c : "-" + c.toLowerCase();
      }).toLowerCase() : str;
    }, "toKebabCase"),
    toTokenKey: /* @__PURE__ */ __name(function toTokenKey2(str) {
      return this.isString(str) ? str.replace(/[A-Z]/g, function(c, i2) {
        return i2 === 0 ? c : "." + c.toLowerCase();
      }).toLowerCase() : str;
    }, "toTokenKey"),
    merge: /* @__PURE__ */ __name(function merge2(value1, value22) {
      if (this.isArray(value1)) {
        value1.push.apply(value1, _toConsumableArray$2$1(value22 || []));
      } else if (this.isObject(value1)) {
        Object.assign(value1, value22);
      }
    }, "merge"),
    mergeKeysByRegex: /* @__PURE__ */ __name(function mergeKeysByRegex() {
      var _this = this;
      var target = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var source = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var regex = arguments.length > 2 ? arguments[2] : void 0;
      var mergedObj = _objectSpread$2$2({}, target);
      Object.keys(source).forEach(function(key) {
        if (_this.test(regex, key)) {
          if (_this.isObject(source[key]) && key in target && _this.isObject(target[key])) {
            mergedObj[key] = _this.mergeKeysByRegex(target[key], source[key], regex);
          } else {
            mergedObj[key] = source[key];
          }
        } else {
          mergedObj[key] = source[key];
        }
      });
      return mergedObj;
    }, "mergeKeysByRegex"),
    mergeKeys: /* @__PURE__ */ __name(function mergeKeys2() {
      var _this2 = this;
      var _mergeKeys = /* @__PURE__ */ __name(function _mergeKeys2() {
        var target = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var source = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var mergedObj = _objectSpread$2$2({}, target);
        Object.keys(source).forEach(function(key) {
          if (_this2.isObject(source[key]) && key in target && _this2.isObject(target[key])) {
            mergedObj[key] = _mergeKeys2(target[key], source[key]);
          } else {
            mergedObj[key] = source[key];
          }
        });
        return mergedObj;
      }, "_mergeKeys");
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return args.reduce(function(acc, obj, i2) {
        return i2 === 0 ? obj : _mergeKeys(acc, obj);
      }, {});
    }, "mergeKeys"),
    getItemValue: /* @__PURE__ */ __name(function getItemValue(obj) {
      for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        params[_key2 - 1] = arguments[_key2];
      }
      return this.isFunction(obj) ? obj.apply(void 0, params) : obj;
    }, "getItemValue"),
    getOptionValue: /* @__PURE__ */ __name(function getOptionValue(options3) {
      var _this3 = this;
      var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var fKeys = this.toFlatCase(key).split(".");
      var fKey = fKeys.shift();
      return fKey ? this.isObject(options3) ? this.getOptionValue(this.getItemValue(options3[Object.keys(options3).find(function(k) {
        return _this3.toFlatCase(k) === fKey;
      }) || ""], params), fKeys.join("."), params) : void 0 : this.getItemValue(options3, params);
    }, "getOptionValue"),
    test: /* @__PURE__ */ __name(function test2(regex, str) {
      if (regex) {
        var match = regex.test(str);
        regex.lastIndex = 0;
        return match;
      }
      return false;
    }, "test"),
    toValue: /* @__PURE__ */ __name(function toValue2(value3) {
      return this.isObject(value3) && value3.hasOwnProperty("value") && value3.hasOwnProperty("type") ? value3.value : value3;
    }, "toValue"),
    toUnit: /* @__PURE__ */ __name(function toUnit2(value3) {
      var _this4 = this;
      var variable = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var excludedProperties = ["opacity", "z-index", "line-height", "font-weight", "flex", "flex-grow", "flex-shrink", "order"];
      if (!excludedProperties.some(function(property) {
        return variable.endsWith(property);
      })) {
        var val = "".concat(value3).trim();
        var valArr = val.split(" ");
        return valArr.map(function(v2) {
          return _this4.isNumber(v2) ? "".concat(v2, "px") : v2;
        }).join(" ");
      }
      return value3;
    }, "toUnit"),
    toNormalizePrefix: /* @__PURE__ */ __name(function toNormalizePrefix2(prefix2) {
      return prefix2.replaceAll(/ /g, "").replace(/[^\w]/g, "-");
    }, "toNormalizePrefix"),
    toNormalizeVariable: /* @__PURE__ */ __name(function toNormalizeVariable2() {
      var prefix2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      var variable = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      return this.toNormalizePrefix("".concat(this.isString(prefix2, false) && this.isString(variable, false) ? "".concat(prefix2, "-") : prefix2).concat(variable));
    }, "toNormalizeVariable"),
    getVariableName: /* @__PURE__ */ __name(function getVariableName2() {
      var prefix2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      var variable = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      return "--".concat(this.toNormalizeVariable(prefix2, variable));
    }, "getVariableName"),
    getVariableValue: /* @__PURE__ */ __name(function getVariableValue2(value3) {
      var _this5 = this;
      var variable = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var prefix2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
      var excludedKeyRegexes = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];
      var fallback = arguments.length > 4 ? arguments[4] : void 0;
      if (this.isString(value3)) {
        var regex = /{([^}]*)}/g;
        var val = value3.trim();
        if (this.test(regex, val)) {
          var _val = val.replaceAll(regex, function(v2) {
            var path = v2.replace(/{|}/g, "");
            var keys2 = path.split(".").filter(function(_v) {
              return !excludedKeyRegexes.some(function(_r) {
                return _this5.test(_r, _v);
              });
            });
            return "var(".concat(_this5.getVariableName(prefix2, _this5.toKebabCase(keys2.join("-")))).concat(_this5.isNotEmpty(fallback) ? ", ".concat(fallback) : "", ")");
          });
          var calculationRegex = /(\d+\s+[\+\-\*\/]\s+\d+)/g;
          var cleanedVarRegex = /var\([^)]+\)/g;
          return this.test(calculationRegex, _val.replace(cleanedVarRegex, "0")) ? "calc(".concat(_val, ")") : _val;
        }
        return this.toUnit(val, variable);
      } else if (this.isNumber(value3)) {
        return this.toUnit(value3, variable);
      }
      return void 0;
    }, "getVariableValue"),
    getComputedValue: /* @__PURE__ */ __name(function getComputedValue2() {
      var _this6 = this;
      var obj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var value3 = arguments.length > 1 ? arguments[1] : void 0;
      if (this.isString(value3)) {
        var regex = /{([^}]*)}/g;
        var val = value3.trim();
        return this.test(regex, val) ? val.replaceAll(regex, function(v2) {
          return _this6.getOptionValue(obj, v2.replace(/{|}/g, ""));
        }) : val;
      } else if (this.isNumber(value3)) {
        return value3;
      }
      return void 0;
    }, "getComputedValue"),
    setProperty: /* @__PURE__ */ __name(function setProperty2(properties, key, value3) {
      if (this.isString(key, false)) {
        properties.push("".concat(key, ":").concat(value3, ";"));
      }
    }, "setProperty"),
    getRule: /* @__PURE__ */ __name(function getRule2(selector, properties) {
      if (selector) {
        return "".concat(selector, "{").concat(properties, "}");
      }
      return "";
    }, "getRule"),
    minifyCSS: /* @__PURE__ */ __name(function minifyCSS2(css4) {
      return css4 ? css4.replace(/\/\*(?:(?!\*\/)[\s\S])*\*\/|[\r\n\t]+/g, "").replace(/ {2,}/g, " ").replace(/ ([{:}]) /g, "$1").replace(/([;,]) /g, "$1").replace(/ !/g, "!").replace(/: /g, ":") : css4;
    }, "minifyCSS")
  },
  dom: {
    isClient: /* @__PURE__ */ __name(function isClient2() {
      return !!(typeof window !== "undefined" && window.document && window.document.createElement);
    }, "isClient"),
    addClass: /* @__PURE__ */ __name(function addClass2(element, className) {
      if (element && className && !this.hasClass(element, className)) {
        if (element.classList) element.classList.add(className);
        else element.className += " " + className;
      }
    }, "addClass"),
    removeClass: /* @__PURE__ */ __name(function removeClass2(element, className) {
      if (element && className) {
        if (element.classList) element.classList.remove(className);
        else element.className = element.className.replace(new RegExp("(^|\\b)" + className.split(" ").join("|") + "(\\b|$)", "gi"), " ");
      }
    }, "removeClass"),
    hasClass: /* @__PURE__ */ __name(function hasClass2(element, className) {
      if (element) {
        if (element.classList) return element.classList.contains(className);
        else return new RegExp("(^| )" + className + "( |$)", "gi").test(element.className);
      }
      return false;
    }, "hasClass"),
    removeMultipleClasses: /* @__PURE__ */ __name(function removeMultipleClasses(element, classNames) {
      var _this7 = this;
      if (element && classNames) {
        [classNames].flat().filter(Boolean).forEach(function(cNames) {
          return cNames.split(" ").forEach(function(className) {
            return _this7.removeClass(element, className);
          });
        });
      }
    }, "removeMultipleClasses")
  }
};
function normalizeColor(color) {
  if (color.length === 4) {
    color = "#".concat(color[1]).concat(color[1]).concat(color[2]).concat(color[2]).concat(color[3]).concat(color[3]);
  }
  return color;
}
__name(normalizeColor, "normalizeColor");
function hexToRgb$1(hex) {
  var bigint = parseInt(hex.substring(1), 16);
  var r = bigint >> 16 & 255;
  var g = bigint >> 8 & 255;
  var b = bigint & 255;
  return {
    r,
    g,
    b
  };
}
__name(hexToRgb$1, "hexToRgb$1");
function rgbToHex$1(r, g, b) {
  return "#".concat(r.toString(16).padStart(2, "0")).concat(g.toString(16).padStart(2, "0")).concat(b.toString(16).padStart(2, "0"));
}
__name(rgbToHex$1, "rgbToHex$1");
var mix = /* @__PURE__ */ __name(function(color1, color2, weight) {
  color1 = normalizeColor(color1);
  color2 = normalizeColor(color2);
  var p2 = weight / 100;
  var w2 = p2 * 2 - 1;
  var w1 = (w2 + 1) / 2;
  var w22 = 1 - w1;
  var rgb1 = hexToRgb$1(color1);
  var rgb2 = hexToRgb$1(color2);
  var r = Math.round(rgb1.r * w1 + rgb2.r * w22);
  var g = Math.round(rgb1.g * w1 + rgb2.g * w22);
  var b = Math.round(rgb1.b * w1 + rgb2.b * w22);
  return rgbToHex$1(r, g, b);
}, "mix");
var shade = /* @__PURE__ */ __name(function(color, percent) {
  return mix("#000000", color, percent);
}, "shade");
var tint = /* @__PURE__ */ __name(function(color, percent) {
  return mix("#ffffff", color, percent);
}, "tint");
var scales = [50, 100, 200, 300, 400, 500, 600, 700, 800, 900, 950];
var palette = /* @__PURE__ */ __name(function(color) {
  if (/{([^}]*)}/g.test(color)) {
    var token = color.replace(/{|}/g, "");
    return scales.reduce(function(acc, scale) {
      return acc[scale] = "{".concat(token, ".").concat(scale, "}"), acc;
    }, {});
  }
  return typeof color === "string" ? scales.reduce(function(acc, scale, i2) {
    return acc[scale] = i2 <= 5 ? tint(color, (5 - i2) * 19) : shade(color, (i2 - 5) * 15), acc;
  }, {}) : color;
}, "palette");
function createService() {
  var allHandlers = /* @__PURE__ */ new Map();
  return {
    on: /* @__PURE__ */ __name(function on(type, handler6) {
      var handlers2 = allHandlers.get(type);
      if (!handlers2) handlers2 = [handler6];
      else handlers2.push(handler6);
      allHandlers.set(type, handlers2);
      return this;
    }, "on"),
    off: /* @__PURE__ */ __name(function off(type, handler6) {
      var handlers2 = allHandlers.get(type);
      if (handlers2) {
        handlers2.splice(handlers2.indexOf(handler6) >>> 0, 1);
      }
      return this;
    }, "off"),
    emit: /* @__PURE__ */ __name(function emit2(type, evt) {
      var handlers2 = allHandlers.get(type);
      if (handlers2) {
        handlers2.slice().map(function(handler6) {
          handler6(evt);
        });
      }
    }, "emit")
  };
}
__name(createService, "createService");
var ThemeService = createService();
function _typeof$2$2(o) {
  "@babel/helpers - typeof";
  return _typeof$2$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$2$2(o);
}
__name(_typeof$2$2, "_typeof$2$2");
function _toConsumableArray$1$2(r) {
  return _arrayWithoutHoles$1$2(r) || _iterableToArray$1$2(r) || _unsupportedIterableToArray$2$1(r) || _nonIterableSpread$1$2();
}
__name(_toConsumableArray$1$2, "_toConsumableArray$1$2");
function _nonIterableSpread$1$2() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableSpread$1$2, "_nonIterableSpread$1$2");
function _unsupportedIterableToArray$2$1(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$2$1(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$2$1(r, a) : void 0;
  }
}
__name(_unsupportedIterableToArray$2$1, "_unsupportedIterableToArray$2$1");
function _iterableToArray$1$2(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
__name(_iterableToArray$1$2, "_iterableToArray$1$2");
function _arrayWithoutHoles$1$2(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$2$1(r);
}
__name(_arrayWithoutHoles$1$2, "_arrayWithoutHoles$1$2");
function _arrayLikeToArray$2$1(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
__name(_arrayLikeToArray$2$1, "_arrayLikeToArray$2$1");
function ownKeys$1$3(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
__name(ownKeys$1$3, "ownKeys$1$3");
function _objectSpread$1$3(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$1$3(Object(t), true).forEach(function(r2) {
      _defineProperty$2$2(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1$3(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
__name(_objectSpread$1$3, "_objectSpread$1$3");
function _defineProperty$2$2(e, r, t) {
  return (r = _toPropertyKey$2$2(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty$2$2, "_defineProperty$2$2");
function _toPropertyKey$2$2(t) {
  var i2 = _toPrimitive$2$2(t, "string");
  return "symbol" == _typeof$2$2(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$2$2, "_toPropertyKey$2$2");
function _toPrimitive$2$2(t, r) {
  if ("object" != _typeof$2$2(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$2$2(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive$2$2, "_toPrimitive$2$2");
var Theme = {
  defaults: {
    variable: {
      prefix: "p",
      selector: ":root",
      excludedKeyRegex: /^(primitive|semantic|components|directives|variables|colorscheme|light|dark|common|root|states)$/gi
    },
    options: {
      prefix: "p",
      darkModeSelector: "system",
      cssLayer: false
    }
  },
  _theme: void 0,
  _layerNames: /* @__PURE__ */ new Set(),
  _loadedStyleNames: /* @__PURE__ */ new Set(),
  _loadingStyles: /* @__PURE__ */ new Set(),
  _tokens: {},
  update: /* @__PURE__ */ __name(function update() {
    var newValues = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var theme38 = newValues.theme;
    if (theme38) {
      this._theme = _objectSpread$1$3(_objectSpread$1$3({}, theme38), {}, {
        options: _objectSpread$1$3(_objectSpread$1$3({}, this.defaults.options), theme38.options)
      });
      this._tokens = ThemeUtils.createTokens(this.preset, this.defaults);
      this.clearLoadedStyleNames();
    }
  }, "update"),
  get theme() {
    return this._theme;
  },
  get preset() {
    var _this$theme;
    return ((_this$theme = this.theme) === null || _this$theme === void 0 ? void 0 : _this$theme.preset) || {};
  },
  get options() {
    var _this$theme2;
    return ((_this$theme2 = this.theme) === null || _this$theme2 === void 0 ? void 0 : _this$theme2.options) || {};
  },
  get tokens() {
    return this._tokens;
  },
  getTheme: /* @__PURE__ */ __name(function getTheme() {
    return this.theme;
  }, "getTheme"),
  setTheme: /* @__PURE__ */ __name(function setTheme(newValue) {
    this.update({
      theme: newValue
    });
    ThemeService.emit("theme:change", newValue);
  }, "setTheme"),
  getPreset: /* @__PURE__ */ __name(function getPreset() {
    return this.preset;
  }, "getPreset"),
  setPreset: /* @__PURE__ */ __name(function setPreset(newValue) {
    this._theme = _objectSpread$1$3(_objectSpread$1$3({}, this.theme), {}, {
      preset: newValue
    });
    this._tokens = ThemeUtils.createTokens(newValue, this.defaults);
    this.clearLoadedStyleNames();
    ThemeService.emit("preset:change", newValue);
    ThemeService.emit("theme:change", this.theme);
  }, "setPreset"),
  getOptions: /* @__PURE__ */ __name(function getOptions() {
    return this.options;
  }, "getOptions"),
  setOptions: /* @__PURE__ */ __name(function setOptions(newValue) {
    this._theme = _objectSpread$1$3(_objectSpread$1$3({}, this.theme), {}, {
      options: newValue
    });
    this.clearLoadedStyleNames();
    ThemeService.emit("options:change", newValue);
    ThemeService.emit("theme:change", this.theme);
  }, "setOptions"),
  getLayerNames: /* @__PURE__ */ __name(function getLayerNames() {
    return _toConsumableArray$1$2(this._layerNames);
  }, "getLayerNames"),
  setLayerNames: /* @__PURE__ */ __name(function setLayerNames(layerName) {
    this._layerNames.add(layerName);
  }, "setLayerNames"),
  getLoadedStyleNames: /* @__PURE__ */ __name(function getLoadedStyleNames() {
    return this._loadedStyleNames;
  }, "getLoadedStyleNames"),
  isStyleNameLoaded: /* @__PURE__ */ __name(function isStyleNameLoaded(name) {
    return this._loadedStyleNames.has(name);
  }, "isStyleNameLoaded"),
  setLoadedStyleName: /* @__PURE__ */ __name(function setLoadedStyleName(name) {
    this._loadedStyleNames.add(name);
  }, "setLoadedStyleName"),
  deleteLoadedStyleName: /* @__PURE__ */ __name(function deleteLoadedStyleName(name) {
    this._loadedStyleNames["delete"](name);
  }, "deleteLoadedStyleName"),
  clearLoadedStyleNames: /* @__PURE__ */ __name(function clearLoadedStyleNames() {
    this._loadedStyleNames.clear();
  }, "clearLoadedStyleNames"),
  getTokenValue: /* @__PURE__ */ __name(function getTokenValue(tokenPath) {
    return ThemeUtils.getTokenValue(this.tokens, tokenPath, this.defaults);
  }, "getTokenValue"),
  getCommon: /* @__PURE__ */ __name(function getCommon() {
    var name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    var params = arguments.length > 1 ? arguments[1] : void 0;
    return ThemeUtils.getCommon({
      name,
      theme: this.theme,
      params,
      defaults: this.defaults,
      set: {
        layerNames: this.setLayerNames.bind(this)
      }
    });
  }, "getCommon"),
  getComponent: /* @__PURE__ */ __name(function getComponent() {
    var name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    var params = arguments.length > 1 ? arguments[1] : void 0;
    var options3 = {
      name,
      theme: this.theme,
      params,
      defaults: this.defaults,
      set: {
        layerNames: this.setLayerNames.bind(this)
      }
    };
    return ThemeUtils.getPresetC(options3);
  }, "getComponent"),
  getDirective: /* @__PURE__ */ __name(function getDirective() {
    var name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    var params = arguments.length > 1 ? arguments[1] : void 0;
    var options3 = {
      name,
      theme: this.theme,
      params,
      defaults: this.defaults,
      set: {
        layerNames: this.setLayerNames.bind(this)
      }
    };
    return ThemeUtils.getPresetD(options3);
  }, "getDirective"),
  getCustomPreset: /* @__PURE__ */ __name(function getCustomPreset() {
    var name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    var preset = arguments.length > 1 ? arguments[1] : void 0;
    var selector = arguments.length > 2 ? arguments[2] : void 0;
    var params = arguments.length > 3 ? arguments[3] : void 0;
    var options3 = {
      name,
      preset,
      options: this.options,
      selector,
      params,
      defaults: this.defaults,
      set: {
        layerNames: this.setLayerNames.bind(this)
      }
    };
    return ThemeUtils.getPreset(options3);
  }, "getCustomPreset"),
  getLayerOrderCSS: /* @__PURE__ */ __name(function getLayerOrderCSS() {
    var name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    return ThemeUtils.getLayerOrder(name, this.options, {
      names: this.getLayerNames()
    }, this.defaults);
  }, "getLayerOrderCSS"),
  transformCSS: /* @__PURE__ */ __name(function transformCSS() {
    var name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    var css4 = arguments.length > 1 ? arguments[1] : void 0;
    var type = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "style";
    var mode2 = arguments.length > 3 ? arguments[3] : void 0;
    return ThemeUtils.transformCSS(name, css4, mode2, type, this.options, {
      layerNames: this.setLayerNames.bind(this)
    }, this.defaults);
  }, "transformCSS"),
  getCommonStyleSheet: /* @__PURE__ */ __name(function getCommonStyleSheet() {
    var name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    var params = arguments.length > 1 ? arguments[1] : void 0;
    var props = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return ThemeUtils.getCommonStyleSheet({
      name,
      theme: this.theme,
      params,
      props,
      defaults: this.defaults,
      set: {
        layerNames: this.setLayerNames.bind(this)
      }
    });
  }, "getCommonStyleSheet"),
  getStyleSheet: /* @__PURE__ */ __name(function getStyleSheet2(name, params) {
    var props = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return ThemeUtils.getStyleSheet({
      name,
      theme: this.theme,
      params,
      props,
      defaults: this.defaults,
      set: {
        layerNames: this.setLayerNames.bind(this)
      }
    });
  }, "getStyleSheet"),
  onStyleMounted: /* @__PURE__ */ __name(function onStyleMounted(name) {
    this._loadingStyles.add(name);
  }, "onStyleMounted"),
  onStyleUpdated: /* @__PURE__ */ __name(function onStyleUpdated(name) {
    this._loadingStyles.add(name);
  }, "onStyleUpdated"),
  onStyleLoaded: /* @__PURE__ */ __name(function onStyleLoaded(event2, _ref) {
    var name = _ref.name;
    if (this._loadingStyles.size) {
      this._loadingStyles["delete"](name);
      ThemeService.emit("theme:".concat(name, ":load"), event2);
      !this._loadingStyles.size && ThemeService.emit("theme:load");
    }
  }, "onStyleLoaded")
};
var $dt = /* @__PURE__ */ __name(function $dt2(tokenPath) {
  var _variable$match;
  var theme38 = Theme.getTheme();
  var variable = dtwt(theme38, tokenPath, void 0, "variable");
  var name = (_variable$match = variable.match(/--[\w-]+/g)) === null || _variable$match === void 0 ? void 0 : _variable$match[0];
  var value3 = dtwt(theme38, tokenPath, void 0, "value");
  return {
    name,
    variable,
    value: value3
  };
}, "$dt");
var dt = /* @__PURE__ */ __name(function dt2() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return dtwt.apply(void 0, [Theme.getTheme()].concat(args));
}, "dt");
var dtwt = /* @__PURE__ */ __name(function dtwt2() {
  var theme38 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var tokenPath = arguments.length > 1 ? arguments[1] : void 0;
  var fallback = arguments.length > 2 ? arguments[2] : void 0;
  var type = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "variable";
  if (tokenPath) {
    var _ref = Theme.defaults || {}, VARIABLE = _ref.variable, OPTIONS = _ref.options;
    var _ref2 = (theme38 === null || theme38 === void 0 ? void 0 : theme38.options) || OPTIONS || {}, prefix2 = _ref2.prefix, transform2 = _ref2.transform;
    var regex = /{([^}]*)}/g;
    var token = SharedUtils.object.test(regex, tokenPath) ? tokenPath : "{".concat(tokenPath, "}");
    var isStrictTransform = type === "value" || transform2 === "strict";
    return isStrictTransform ? Theme.getTokenValue(tokenPath) : SharedUtils.object.getVariableValue(token, void 0, prefix2, [VARIABLE.excludedKeyRegex], fallback);
  }
  return "";
}, "dtwt");
var css$1 = /* @__PURE__ */ __name(function css3(style) {
  return SharedUtils.object.getItemValue(style, {
    dt
  });
}, "css");
function _typeof$1$5(o) {
  "@babel/helpers - typeof";
  return _typeof$1$5 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$1$5(o);
}
__name(_typeof$1$5, "_typeof$1$5");
function ownKeys$g(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
__name(ownKeys$g, "ownKeys$g");
function _objectSpread$g(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$g(Object(t), true).forEach(function(r2) {
      _defineProperty$1$3(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$g(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
__name(_objectSpread$g, "_objectSpread$g");
function _defineProperty$1$3(e, r, t) {
  return (r = _toPropertyKey$1$4(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty$1$3, "_defineProperty$1$3");
function _toPropertyKey$1$4(t) {
  var i2 = _toPrimitive$1$4(t, "string");
  return "symbol" == _typeof$1$5(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$1$4, "_toPropertyKey$1$4");
function _toPrimitive$1$4(t, r) {
  if ("object" != _typeof$1$5(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$1$5(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive$1$4, "_toPrimitive$1$4");
var $t = /* @__PURE__ */ __name(function $t2() {
  var theme38 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var _preset = theme38.preset, _options = theme38.options;
  return {
    preset: /* @__PURE__ */ __name(function preset(value3) {
      _preset = _preset ? SharedUtils.object.mergeKeys(_preset, value3) : value3;
      return this;
    }, "preset"),
    options: /* @__PURE__ */ __name(function options3(value3) {
      _options = _options ? _objectSpread$g(_objectSpread$g({}, _options), value3) : value3;
      return this;
    }, "options"),
    // features
    primaryPalette: /* @__PURE__ */ __name(function primaryPalette(primary) {
      var _ref = _preset || {}, semantic = _ref.semantic;
      _preset = _objectSpread$g(_objectSpread$g({}, _preset), {}, {
        semantic: _objectSpread$g(_objectSpread$g({}, semantic), {}, {
          primary
        })
      });
      return this;
    }, "primaryPalette"),
    surfacePalette: /* @__PURE__ */ __name(function surfacePalette(surface) {
      var _semantic$colorScheme, _semantic$colorScheme2;
      var _ref2 = _preset || {}, semantic = _ref2.semantic;
      var lightSurface = surface !== null && surface !== void 0 && surface.hasOwnProperty("light") ? surface === null || surface === void 0 ? void 0 : surface.light : surface;
      var darkSurface = surface !== null && surface !== void 0 && surface.hasOwnProperty("dark") ? surface === null || surface === void 0 ? void 0 : surface.dark : surface;
      var newColorScheme = {
        colorScheme: {
          light: _objectSpread$g(_objectSpread$g({}, semantic === null || semantic === void 0 || (_semantic$colorScheme = semantic.colorScheme) === null || _semantic$colorScheme === void 0 ? void 0 : _semantic$colorScheme.light), !!lightSurface && {
            surface: lightSurface
          }),
          dark: _objectSpread$g(_objectSpread$g({}, semantic === null || semantic === void 0 || (_semantic$colorScheme2 = semantic.colorScheme) === null || _semantic$colorScheme2 === void 0 ? void 0 : _semantic$colorScheme2.dark), !!darkSurface && {
            surface: darkSurface
          })
        }
      };
      _preset = _objectSpread$g(_objectSpread$g({}, _preset), {}, {
        semantic: _objectSpread$g(_objectSpread$g({}, semantic), newColorScheme)
      });
      return this;
    }, "surfacePalette"),
    // actions
    define: /* @__PURE__ */ __name(function define() {
      var _ref3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref3$useDefaultPrese = _ref3.useDefaultPreset, useDefaultPreset = _ref3$useDefaultPrese === void 0 ? false : _ref3$useDefaultPrese, _ref3$useDefaultOptio = _ref3.useDefaultOptions, useDefaultOptions = _ref3$useDefaultOptio === void 0 ? false : _ref3$useDefaultOptio;
      return {
        preset: useDefaultPreset ? Theme.getPreset() : _preset,
        options: useDefaultOptions ? Theme.getOptions() : _options
      };
    }, "define"),
    update: /* @__PURE__ */ __name(function update2() {
      var _ref4 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref4$mergePresets = _ref4.mergePresets, mergePresets = _ref4$mergePresets === void 0 ? true : _ref4$mergePresets, _ref4$mergeOptions = _ref4.mergeOptions, mergeOptions2 = _ref4$mergeOptions === void 0 ? true : _ref4$mergeOptions;
      var newTheme = {
        preset: mergePresets ? SharedUtils.object.mergeKeys(Theme.getPreset(), _preset) : _preset,
        options: mergeOptions2 ? _objectSpread$g(_objectSpread$g({}, Theme.getOptions()), _options) : _options
      };
      Theme.setTheme(newTheme);
      return newTheme;
    }, "update"),
    use: /* @__PURE__ */ __name(function use(options3) {
      var newTheme = this.define(options3);
      Theme.setTheme(newTheme);
      return newTheme;
    }, "use")
  };
}, "$t");
function _slicedToArray$1$1(r, e) {
  return _arrayWithHoles$1$1(r) || _iterableToArrayLimit$1$1(r, e) || _unsupportedIterableToArray$1$2(r, e) || _nonIterableRest$1$1();
}
__name(_slicedToArray$1$1, "_slicedToArray$1$1");
function _nonIterableRest$1$1() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableRest$1$1, "_nonIterableRest$1$1");
function _unsupportedIterableToArray$1$2(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$1$2(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$1$2(r, a) : void 0;
  }
}
__name(_unsupportedIterableToArray$1$2, "_unsupportedIterableToArray$1$2");
function _arrayLikeToArray$1$2(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
__name(_arrayLikeToArray$1$2, "_arrayLikeToArray$1$2");
function _iterableToArrayLimit$1$1(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i2, u, a = [], f = true, o = false;
    try {
      if (i2 = (t = t.call(r)).next, 0 === l) ;
      else for (; !(f = (e = i2.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
__name(_iterableToArrayLimit$1$1, "_iterableToArrayLimit$1$1");
function _arrayWithHoles$1$1(r) {
  if (Array.isArray(r)) return r;
}
__name(_arrayWithHoles$1$1, "_arrayWithHoles$1$1");
function toVariables(theme38) {
  var options3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var VARIABLE = Theme.defaults.variable;
  var _options$prefix = options3.prefix, prefix2 = _options$prefix === void 0 ? VARIABLE.prefix : _options$prefix, _options$selector = options3.selector, selector = _options$selector === void 0 ? VARIABLE.selector : _options$selector, _options$excludedKeyR = options3.excludedKeyRegex, excludedKeyRegex = _options$excludedKeyR === void 0 ? VARIABLE.excludedKeyRegex : _options$excludedKeyR;
  var _toVariables2 = /* @__PURE__ */ __name(function _toVariables4(_theme) {
    var _prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    return Object.entries(_theme).reduce(function(acc, _ref) {
      var _ref2 = _slicedToArray$1$1(_ref, 2), key = _ref2[0], value3 = _ref2[1];
      var px = SharedUtils.object.test(excludedKeyRegex, key) ? SharedUtils.object.toNormalizeVariable(_prefix) : SharedUtils.object.toNormalizeVariable(_prefix, SharedUtils.object.toKebabCase(key));
      var v2 = SharedUtils.object.toValue(value3);
      if (SharedUtils.object.isObject(v2)) {
        var _toVariables22 = _toVariables4(v2, px), _variables = _toVariables22.variables, _tokens = _toVariables22.tokens;
        SharedUtils.object.merge(acc["tokens"], _tokens);
        SharedUtils.object.merge(acc["variables"], _variables);
      } else {
        acc["tokens"].push((prefix2 ? px.replace("".concat(prefix2, "-"), "") : px).replaceAll("-", "."));
        SharedUtils.object.setProperty(acc["variables"], SharedUtils.object.getVariableName(px), SharedUtils.object.getVariableValue(v2, px, prefix2, [excludedKeyRegex]));
      }
      return acc;
    }, {
      variables: [],
      tokens: []
    });
  }, "_toVariables");
  var _toVariables3 = _toVariables2(theme38, prefix2), variables = _toVariables3.variables, tokens = _toVariables3.tokens;
  return {
    value: variables,
    tokens,
    declarations: variables.join(""),
    css: SharedUtils.object.getRule(selector, variables.join(""))
  };
}
__name(toVariables, "toVariables");
function _typeof$j(o) {
  "@babel/helpers - typeof";
  return _typeof$j = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$j(o);
}
__name(_typeof$j, "_typeof$j");
var _excluded = ["colorScheme"], _excluded2 = ["dark"], _excluded3 = ["colorScheme"], _excluded4 = ["dark"], _excluded5 = ["colorScheme"];
function _slicedToArray$4(r, e) {
  return _arrayWithHoles$4(r) || _iterableToArrayLimit$4(r, e) || _unsupportedIterableToArray$k(r, e) || _nonIterableRest$4();
}
__name(_slicedToArray$4, "_slicedToArray$4");
function _nonIterableRest$4() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableRest$4, "_nonIterableRest$4");
function _iterableToArrayLimit$4(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i2, u, a = [], f = true, o = false;
    try {
      if (i2 = (t = t.call(r)).next, 0 === l) ;
      else for (; !(f = (e = i2.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
__name(_iterableToArrayLimit$4, "_iterableToArrayLimit$4");
function _arrayWithHoles$4(r) {
  if (Array.isArray(r)) return r;
}
__name(_arrayWithHoles$4, "_arrayWithHoles$4");
function _defineProperty$j(e, r, t) {
  return (r = _toPropertyKey$i(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty$j, "_defineProperty$j");
function _toPropertyKey$i(t) {
  var i2 = _toPrimitive$i(t, "string");
  return "symbol" == _typeof$j(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$i, "_toPropertyKey$i");
function _toPrimitive$i(t, r) {
  if ("object" != _typeof$j(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$j(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive$i, "_toPrimitive$i");
function _toConsumableArray$f(r) {
  return _arrayWithoutHoles$f(r) || _iterableToArray$g(r) || _unsupportedIterableToArray$k(r) || _nonIterableSpread$f();
}
__name(_toConsumableArray$f, "_toConsumableArray$f");
function _nonIterableSpread$f() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableSpread$f, "_nonIterableSpread$f");
function _unsupportedIterableToArray$k(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$k(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$k(r, a) : void 0;
  }
}
__name(_unsupportedIterableToArray$k, "_unsupportedIterableToArray$k");
function _iterableToArray$g(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
__name(_iterableToArray$g, "_iterableToArray$g");
function _arrayWithoutHoles$f(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$k(r);
}
__name(_arrayWithoutHoles$f, "_arrayWithoutHoles$f");
function _arrayLikeToArray$k(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
__name(_arrayLikeToArray$k, "_arrayLikeToArray$k");
function _objectWithoutProperties(e, t) {
  if (null == e) return {};
  var o, r, i2 = _objectWithoutPropertiesLoose(e, t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], t.indexOf(o) >= 0 || {}.propertyIsEnumerable.call(e, o) && (i2[o] = e[o]);
  }
  return i2;
}
__name(_objectWithoutProperties, "_objectWithoutProperties");
function _objectWithoutPropertiesLoose(r, e) {
  if (null == r) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (e.indexOf(n) >= 0) continue;
    t[n] = r[n];
  }
  return t;
}
__name(_objectWithoutPropertiesLoose, "_objectWithoutPropertiesLoose");
var ThemeUtils = {
  regex: {
    rules: {
      "class": {
        pattern: /^\.([a-zA-Z][\w-]*)$/,
        resolve: /* @__PURE__ */ __name(function resolve2(value3) {
          return {
            type: "class",
            selector: value3,
            matched: this.pattern.test(value3.trim())
          };
        }, "resolve")
      },
      attr: {
        pattern: /^\[(.*)\]$/,
        resolve: /* @__PURE__ */ __name(function resolve3(value3) {
          return {
            type: "attr",
            selector: ":root".concat(value3),
            matched: this.pattern.test(value3.trim())
          };
        }, "resolve")
      },
      media: {
        pattern: /^@media (.*)$/,
        resolve: /* @__PURE__ */ __name(function resolve4(value3) {
          return {
            type: "media",
            selector: "".concat(value3, "{:root{[CSS]}}"),
            matched: this.pattern.test(value3.trim())
          };
        }, "resolve")
      },
      system: {
        pattern: /^system$/,
        resolve: /* @__PURE__ */ __name(function resolve5(value3) {
          return {
            type: "system",
            selector: "@media (prefers-color-scheme: dark){:root{[CSS]}}",
            matched: this.pattern.test(value3.trim())
          };
        }, "resolve")
      },
      custom: {
        resolve: /* @__PURE__ */ __name(function resolve6(value3) {
          return {
            type: "custom",
            selector: value3,
            matched: true
          };
        }, "resolve")
      }
    },
    resolve: /* @__PURE__ */ __name(function resolve7(value3) {
      var _this = this;
      var rules = Object.keys(this.rules).filter(function(k) {
        return k !== "custom";
      }).map(function(r) {
        return _this.rules[r];
      });
      return [value3].flat().map(function(v2) {
        var _rules$map$find;
        return (_rules$map$find = rules.map(function(r) {
          return r.resolve(v2);
        }).find(function(rr) {
          return rr.matched;
        })) !== null && _rules$map$find !== void 0 ? _rules$map$find : _this.rules.custom.resolve(v2);
      });
    }, "resolve")
  },
  _toVariables: /* @__PURE__ */ __name(function _toVariables(theme38, options3) {
    return toVariables(theme38, {
      prefix: options3 === null || options3 === void 0 ? void 0 : options3.prefix
    });
  }, "_toVariables"),
  getCommon: /* @__PURE__ */ __name(function getCommon2(_ref) {
    var _ref$name = _ref.name, name = _ref$name === void 0 ? "" : _ref$name, _ref$theme = _ref.theme, theme38 = _ref$theme === void 0 ? {} : _ref$theme;
    _ref.params;
    var set2 = _ref.set, defaults2 = _ref.defaults;
    var preset = theme38.preset, options3 = theme38.options;
    var primitive_css, primitive_tokens, semantic_css, semantic_tokens;
    if (SharedUtils.object.isNotEmpty(preset)) {
      var _prim_var$declaration, _sRest_var$declaratio, _csRest_var$declarati, _dark_var$declaration;
      var primitive = preset.primitive, semantic = preset.semantic;
      var _ref2 = semantic || {}, colorScheme = _ref2.colorScheme, sRest = _objectWithoutProperties(_ref2, _excluded);
      var _ref3 = colorScheme || {}, dark = _ref3.dark, csRest = _objectWithoutProperties(_ref3, _excluded2);
      var prim_var = SharedUtils.object.isNotEmpty(primitive) ? this._toVariables({
        primitive
      }, options3) : {};
      var sRest_var = SharedUtils.object.isNotEmpty(sRest) ? this._toVariables({
        semantic: sRest
      }, options3) : {};
      var csRest_var = SharedUtils.object.isNotEmpty(csRest) ? this._toVariables({
        light: csRest
      }, options3) : {};
      var dark_var = SharedUtils.object.isNotEmpty(dark) ? this._toVariables({
        dark
      }, options3) : {};
      var _ref4 = [(_prim_var$declaration = prim_var.declarations) !== null && _prim_var$declaration !== void 0 ? _prim_var$declaration : "", prim_var.tokens], prim_css = _ref4[0], prim_tokens = _ref4[1];
      var sRest_css = (_sRest_var$declaratio = sRest_var.declarations) !== null && _sRest_var$declaratio !== void 0 ? _sRest_var$declaratio : "", sRest_tokens = sRest_var.tokens || [];
      var csRest_css = (_csRest_var$declarati = csRest_var.declarations) !== null && _csRest_var$declarati !== void 0 ? _csRest_var$declarati : "", csRest_tokens = csRest_var.tokens || [];
      var dark_css = (_dark_var$declaration = dark_var.declarations) !== null && _dark_var$declaration !== void 0 ? _dark_var$declaration : "", dark_tokens = dark_var.tokens || [];
      primitive_css = this.transformCSS(name, prim_css, "light", "variable", options3, set2, defaults2);
      primitive_tokens = prim_tokens;
      var semantic_light_css = this.transformCSS(name, "".concat(sRest_css).concat(csRest_css, "color-scheme:light"), "light", "variable", options3, set2, defaults2);
      var semantic_dark_css = this.transformCSS(name, "".concat(dark_css, "color-scheme:dark"), "dark", "variable", options3, set2, defaults2);
      semantic_css = "".concat(semantic_light_css).concat(semantic_dark_css);
      semantic_tokens = _toConsumableArray$f(new Set([].concat(_toConsumableArray$f(sRest_tokens), _toConsumableArray$f(csRest_tokens), _toConsumableArray$f(dark_tokens))));
    }
    return {
      primitive: {
        css: primitive_css,
        tokens: primitive_tokens
      },
      semantic: {
        css: semantic_css,
        tokens: semantic_tokens
      }
    };
  }, "getCommon"),
  getPreset: /* @__PURE__ */ __name(function getPreset2(_ref5) {
    var _vRest_var$declaratio, _csRest_var$declarati2, _dark_var$declaration2;
    var _ref5$name = _ref5.name, name = _ref5$name === void 0 ? "" : _ref5$name, _ref5$preset = _ref5.preset, preset = _ref5$preset === void 0 ? {} : _ref5$preset, options3 = _ref5.options;
    _ref5.params;
    var set2 = _ref5.set, defaults2 = _ref5.defaults, selector = _ref5.selector;
    var _name = name.replace("-directive", "");
    var colorScheme = preset.colorScheme, vRest = _objectWithoutProperties(preset, _excluded3);
    var _ref6 = colorScheme || {}, dark = _ref6.dark, csRest = _objectWithoutProperties(_ref6, _excluded4);
    var vRest_var = SharedUtils.object.isNotEmpty(vRest) ? this._toVariables(_defineProperty$j({}, _name, vRest), options3) : {};
    var csRest_var = SharedUtils.object.isNotEmpty(csRest) ? this._toVariables(_defineProperty$j({}, _name, csRest), options3) : {};
    var dark_var = SharedUtils.object.isNotEmpty(dark) ? this._toVariables(_defineProperty$j({}, _name, dark), options3) : {};
    var vRest_css = (_vRest_var$declaratio = vRest_var.declarations) !== null && _vRest_var$declaratio !== void 0 ? _vRest_var$declaratio : "", vRest_tokens = vRest_var.tokens || [];
    var csRest_css = (_csRest_var$declarati2 = csRest_var.declarations) !== null && _csRest_var$declarati2 !== void 0 ? _csRest_var$declarati2 : "", csRest_tokens = csRest_var.tokens || [];
    var dark_css = (_dark_var$declaration2 = dark_var.declarations) !== null && _dark_var$declaration2 !== void 0 ? _dark_var$declaration2 : "", dark_tokens = dark_var.tokens || [];
    var tokens = _toConsumableArray$f(new Set([].concat(_toConsumableArray$f(vRest_tokens), _toConsumableArray$f(csRest_tokens), _toConsumableArray$f(dark_tokens))));
    var light_variable_css = this.transformCSS(_name, "".concat(vRest_css).concat(csRest_css), "light", "variable", options3, set2, defaults2, selector);
    var dark_variable_css = this.transformCSS(_name, dark_css, "dark", "variable", options3, set2, defaults2, selector);
    return {
      css: "".concat(light_variable_css).concat(dark_variable_css),
      tokens
    };
  }, "getPreset"),
  getPresetC: /* @__PURE__ */ __name(function getPresetC(_ref7) {
    var _preset$components;
    var _ref7$name = _ref7.name, name = _ref7$name === void 0 ? "" : _ref7$name, _ref7$theme = _ref7.theme, theme38 = _ref7$theme === void 0 ? {} : _ref7$theme, params = _ref7.params, set2 = _ref7.set, defaults2 = _ref7.defaults;
    var preset = theme38.preset, options3 = theme38.options;
    var cPreset = preset === null || preset === void 0 || (_preset$components = preset.components) === null || _preset$components === void 0 ? void 0 : _preset$components[name];
    return this.getPreset({
      name,
      preset: cPreset,
      options: options3,
      params,
      set: set2,
      defaults: defaults2
    });
  }, "getPresetC"),
  getPresetD: /* @__PURE__ */ __name(function getPresetD(_ref8) {
    var _preset$directives;
    var _ref8$name = _ref8.name, name = _ref8$name === void 0 ? "" : _ref8$name, _ref8$theme = _ref8.theme, theme38 = _ref8$theme === void 0 ? {} : _ref8$theme, params = _ref8.params, set2 = _ref8.set, defaults2 = _ref8.defaults;
    var dName = name.replace("-directive", "");
    var preset = theme38.preset, options3 = theme38.options;
    var dPreset = preset === null || preset === void 0 || (_preset$directives = preset.directives) === null || _preset$directives === void 0 ? void 0 : _preset$directives[dName];
    return this.getPreset({
      name: dName,
      preset: dPreset,
      options: options3,
      params,
      set: set2,
      defaults: defaults2
    });
  }, "getPresetD"),
  getColorSchemeOption: /* @__PURE__ */ __name(function getColorSchemeOption(options3, defaults2) {
    var _options$darkModeSele;
    return this.regex.resolve((_options$darkModeSele = options3.darkModeSelector) !== null && _options$darkModeSele !== void 0 ? _options$darkModeSele : defaults2.options.darkModeSelector);
  }, "getColorSchemeOption"),
  getLayerOrder: /* @__PURE__ */ __name(function getLayerOrder(name) {
    var options3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var params = arguments.length > 2 ? arguments[2] : void 0;
    var cssLayer = options3.cssLayer;
    if (cssLayer) {
      var order = SharedUtils.object.getItemValue(cssLayer.order || "primeui", params);
      return "@layer ".concat(order);
    }
    return "";
  }, "getLayerOrder"),
  getCommonStyleSheet: /* @__PURE__ */ __name(function getCommonStyleSheet2(_ref9) {
    var _ref9$name = _ref9.name, name = _ref9$name === void 0 ? "" : _ref9$name, _ref9$theme = _ref9.theme, theme38 = _ref9$theme === void 0 ? {} : _ref9$theme, params = _ref9.params, _ref9$props = _ref9.props, props = _ref9$props === void 0 ? {} : _ref9$props, set2 = _ref9.set, defaults2 = _ref9.defaults;
    var common = this.getCommon({
      name,
      theme: theme38,
      params,
      set: set2,
      defaults: defaults2
    });
    var _props = Object.entries(props).reduce(function(acc, _ref10) {
      var _ref11 = _slicedToArray$4(_ref10, 2), k = _ref11[0], v2 = _ref11[1];
      return acc.push("".concat(k, '="').concat(v2, '"')) && acc;
    }, []).join(" ");
    return Object.entries(common || {}).reduce(function(acc, _ref12) {
      var _ref13 = _slicedToArray$4(_ref12, 2), key = _ref13[0], value3 = _ref13[1];
      if (value3 !== null && value3 !== void 0 && value3.css) {
        var _css = SharedUtils.object.minifyCSS(value3 === null || value3 === void 0 ? void 0 : value3.css);
        var id2 = "".concat(key, "-variables");
        acc.push('<style type="text/css" data-primevue-style-id="'.concat(id2, '" ').concat(_props, ">").concat(_css, "</style>"));
      }
      return acc;
    }, []).join("");
  }, "getCommonStyleSheet"),
  getStyleSheet: /* @__PURE__ */ __name(function getStyleSheet3(_ref14) {
    var _ref15;
    var _ref14$name = _ref14.name, name = _ref14$name === void 0 ? "" : _ref14$name, _ref14$theme = _ref14.theme, theme38 = _ref14$theme === void 0 ? {} : _ref14$theme, params = _ref14.params, _ref14$props = _ref14.props, props = _ref14$props === void 0 ? {} : _ref14$props, set2 = _ref14.set, defaults2 = _ref14.defaults;
    var options3 = {
      name,
      theme: theme38,
      params,
      set: set2,
      defaults: defaults2
    };
    var preset_css = (_ref15 = name.includes("-directive") ? this.getPresetD(options3) : this.getPresetC(options3)) === null || _ref15 === void 0 ? void 0 : _ref15.css;
    var _props = Object.entries(props).reduce(function(acc, _ref16) {
      var _ref17 = _slicedToArray$4(_ref16, 2), k = _ref17[0], v2 = _ref17[1];
      return acc.push("".concat(k, '="').concat(v2, '"')) && acc;
    }, []).join(" ");
    return preset_css ? '<style type="text/css" data-primevue-style-id="'.concat(name, '-variables" ').concat(_props, ">").concat(SharedUtils.object.minifyCSS(preset_css), "</style>") : "";
  }, "getStyleSheet"),
  createTokens: /* @__PURE__ */ __name(function createTokens() {
    var _this2 = this;
    var obj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var defaults2 = arguments.length > 1 ? arguments[1] : void 0;
    var parentKey = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
    var parentPath = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "";
    var tokens = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
    Object.entries(obj).forEach(function(_ref18) {
      var _ref19 = _slicedToArray$4(_ref18, 2), key = _ref19[0], value3 = _ref19[1];
      var currentKey = SharedUtils.object.test(defaults2.variable.excludedKeyRegex, key) ? parentKey : parentKey ? "".concat(parentKey, ".").concat(SharedUtils.object.toTokenKey(key)) : SharedUtils.object.toTokenKey(key);
      var currentPath = parentPath ? "".concat(parentPath, ".").concat(key) : key;
      if (SharedUtils.object.isObject(value3)) {
        _this2.createTokens(value3, defaults2, currentKey, currentPath, tokens);
      } else {
        tokens[currentKey] || (tokens[currentKey] = {
          paths: [],
          computed: /* @__PURE__ */ __name(function computed2(colorScheme) {
            var tokenPathMap = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            if (colorScheme) {
              var path = this.paths.find(function(p2) {
                return p2.scheme === colorScheme;
              }) || this.paths.find(function(p2) {
                return p2.scheme === "none";
              });
              return path === null || path === void 0 ? void 0 : path.computed(colorScheme, tokenPathMap["binding"]);
            }
            return this.paths.map(function(p2) {
              return p2.computed(p2.scheme, tokenPathMap[p2.scheme]);
            });
          }, "computed")
        });
        tokens[currentKey].paths.push({
          path: currentPath,
          value: value3,
          scheme: currentPath.includes("colorScheme.light") ? "light" : currentPath.includes("colorScheme.dark") ? "dark" : "none",
          computed: /* @__PURE__ */ __name(function computed2(colorScheme) {
            var _binding;
            var tokenPathMap = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            var regex = /{([^}]*)}/g;
            var computedValue = value3;
            tokenPathMap["name"] = this.path;
            tokenPathMap[_binding = "binding"] || (tokenPathMap[_binding] = {});
            if (SharedUtils.object.test(regex, value3)) {
              var val = value3.trim();
              var _val = val.replaceAll(regex, function(v2) {
                var _tokens$path;
                var path = v2.replace(/{|}/g, "");
                return (_tokens$path = tokens[path]) === null || _tokens$path === void 0 || (_tokens$path = _tokens$path.computed(colorScheme, tokenPathMap)) === null || _tokens$path === void 0 ? void 0 : _tokens$path.value;
              });
              var calculationRegex = /(\d+\w*\s+[\+\-\*\/]\s+\d+\w*)/g;
              var cleanedVarRegex = /var\([^)]+\)/g;
              computedValue = SharedUtils.object.test(calculationRegex, _val.replace(cleanedVarRegex, "0")) ? "calc(".concat(_val, ")") : _val;
            }
            SharedUtils.object.isEmpty(tokenPathMap["binding"]) && delete tokenPathMap["binding"];
            return {
              colorScheme,
              path: this.path,
              paths: tokenPathMap,
              value: computedValue.includes("undefined") ? void 0 : computedValue
            };
          }, "computed")
        });
      }
    });
    return tokens;
  }, "createTokens"),
  getTokenValue: /* @__PURE__ */ __name(function getTokenValue2(tokens, path, defaults2) {
    var _tokens$token;
    var normalizePath = /* @__PURE__ */ __name(function normalizePath2(str) {
      var strArr = str.split(".");
      return strArr.filter(function(s) {
        return !SharedUtils.object.test(defaults2.variable.excludedKeyRegex, s.toLowerCase());
      }).join(".");
    }, "normalizePath");
    var token = normalizePath(path);
    var colorScheme = path.includes("colorScheme.light") ? "light" : path.includes("colorScheme.dark") ? "dark" : void 0;
    var computedValues = [(_tokens$token = tokens[token]) === null || _tokens$token === void 0 ? void 0 : _tokens$token.computed(colorScheme)].flat().filter(function(computed2) {
      return computed2;
    });
    return computedValues.length === 1 ? computedValues[0].value : computedValues.reduce(function() {
      var acc = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var computed2 = arguments.length > 1 ? arguments[1] : void 0;
      var cs = computed2.colorScheme, rest = _objectWithoutProperties(computed2, _excluded5);
      acc[cs] = rest;
      return acc;
    }, void 0);
  }, "getTokenValue"),
  transformCSS: /* @__PURE__ */ __name(function transformCSS2(name, css4, mode2, type) {
    var options3 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
    var set2 = arguments.length > 5 ? arguments[5] : void 0;
    var defaults2 = arguments.length > 6 ? arguments[6] : void 0;
    var selector = arguments.length > 7 ? arguments[7] : void 0;
    if (SharedUtils.object.isNotEmpty(css4)) {
      var cssLayer = options3.cssLayer;
      if (type !== "style") {
        var colorSchemeOption = this.getColorSchemeOption(options3, defaults2);
        var _css = selector ? SharedUtils.object.getRule(selector, css4) : css4;
        css4 = mode2 === "dark" ? colorSchemeOption.reduce(function(acc, _ref20) {
          var _selector = _ref20.selector;
          if (SharedUtils.object.isNotEmpty(_selector)) {
            acc += _selector.includes("[CSS]") ? _selector.replace("[CSS]", _css) : SharedUtils.object.getRule(_selector, _css);
          }
          return acc;
        }, "") : SharedUtils.object.getRule(selector !== null && selector !== void 0 ? selector : ":root", css4);
      }
      if (cssLayer) {
        var layerOptions = {
          name: "primeui",
          order: "primeui"
        };
        SharedUtils.object.isObject(cssLayer) && (layerOptions.name = SharedUtils.object.getItemValue(cssLayer.name, {
          name,
          type
        }));
        if (SharedUtils.object.isNotEmpty(layerOptions.name)) {
          css4 = SharedUtils.object.getRule("@layer ".concat(layerOptions.name), css4);
          set2 === null || set2 === void 0 || set2.layerNames(layerOptions.name);
        }
      }
      return css4;
    }
    return "";
  }, "transformCSS")
};
var definePreset = /* @__PURE__ */ __name(function() {
  var _SharedUtils$object;
  return (_SharedUtils$object = SharedUtils.object).mergeKeys.apply(_SharedUtils$object, arguments);
}, "definePreset");
var updatePreset = /* @__PURE__ */ __name(function() {
  var _SharedUtils$object;
  for (var _len = arguments.length, presets = new Array(_len), _key = 0; _key < _len; _key++) {
    presets[_key] = arguments[_key];
  }
  var newPreset = (_SharedUtils$object = SharedUtils.object).mergeKeys.apply(_SharedUtils$object, [Theme.getPreset()].concat(presets));
  Theme.setPreset(newPreset);
  return newPreset;
}, "updatePreset");
var updatePrimaryPalette = /* @__PURE__ */ __name(function(primary) {
  return $t().primaryPalette(primary).update().preset;
}, "updatePrimaryPalette");
var updateSurfacePalette = /* @__PURE__ */ __name(function(surface) {
  return $t().surfacePalette(surface).update().preset;
}, "updateSurfacePalette");
var usePreset = /* @__PURE__ */ __name(function() {
  var _SharedUtils$object;
  var newPreset = (_SharedUtils$object = SharedUtils.object).mergeKeys.apply(_SharedUtils$object, arguments);
  Theme.setPreset(newPreset);
  return newPreset;
}, "usePreset");
var useTheme = /* @__PURE__ */ __name(function(theme38) {
  return $t(theme38).update({
    mergePresets: false
  });
}, "useTheme");
var ConfirmationEventBus = EventBus();
var PrimeVueConfirmSymbol = Symbol();
function useConfirm() {
  var PrimeVueConfirm = inject(PrimeVueConfirmSymbol);
  if (!PrimeVueConfirm) {
    throw new Error("No PrimeVue Confirmation provided!");
  }
  return PrimeVueConfirm;
}
__name(useConfirm, "useConfirm");
var ConfirmationService = {
  install: /* @__PURE__ */ __name(function install3(app2) {
    var ConfirmationService2 = {
      require: /* @__PURE__ */ __name(function require2(options3) {
        ConfirmationEventBus.emit("confirm", options3);
      }, "require"),
      close: /* @__PURE__ */ __name(function close4() {
        ConfirmationEventBus.emit("close");
      }, "close")
    };
    app2.config.globalProperties.$confirm = ConfirmationService2;
    app2.provide(PrimeVueConfirmSymbol, ConfirmationService2);
  }, "install")
};
var ToastEventBus = EventBus();
var PrimeVueToastSymbol = Symbol();
function useToast() {
  var PrimeVueToast = inject(PrimeVueToastSymbol);
  if (!PrimeVueToast) {
    throw new Error("No PrimeVue Toast provided!");
  }
  return PrimeVueToast;
}
__name(useToast, "useToast");
var ToastService = {
  install: /* @__PURE__ */ __name(function install4(app2) {
    var ToastService2 = {
      add: /* @__PURE__ */ __name(function add3(message3) {
        ToastEventBus.emit("add", message3);
      }, "add"),
      remove: /* @__PURE__ */ __name(function remove5(message3) {
        ToastEventBus.emit("remove", message3);
      }, "remove"),
      removeGroup: /* @__PURE__ */ __name(function removeGroup(group) {
        ToastEventBus.emit("remove-group", group);
      }, "removeGroup"),
      removeAllGroups: /* @__PURE__ */ __name(function removeAllGroups() {
        ToastEventBus.emit("remove-all-groups");
      }, "removeAllGroups")
    };
    app2.config.globalProperties.$toast = ToastService2;
    app2.provide(PrimeVueToastSymbol, ToastService2);
  }, "install")
};
function handler() {
  let zIndexes = [];
  const generateZIndex = /* @__PURE__ */ __name((key, autoZIndex, baseZIndex = 999) => {
    const lastZIndex = getLastZIndex(key, autoZIndex, baseZIndex);
    const newZIndex = lastZIndex.value + (lastZIndex.key === key ? 0 : baseZIndex) + 1;
    zIndexes.push({ key, value: newZIndex });
    return newZIndex;
  }, "generateZIndex");
  const revertZIndex = /* @__PURE__ */ __name((zIndex) => {
    zIndexes = zIndexes.filter((obj) => obj.value !== zIndex);
  }, "revertZIndex");
  const getCurrentZIndex = /* @__PURE__ */ __name((key, autoZIndex) => {
    return getLastZIndex(key, autoZIndex).value;
  }, "getCurrentZIndex");
  const getLastZIndex = /* @__PURE__ */ __name((key, autoZIndex, baseZIndex = 0) => {
    return [...zIndexes].reverse().find((obj) => autoZIndex ? true : obj.key === key) || { key, value: baseZIndex };
  }, "getLastZIndex");
  const getZIndex = /* @__PURE__ */ __name((element) => {
    return element ? parseInt(element.style.zIndex, 10) || 0 : 0;
  }, "getZIndex");
  return {
    get: getZIndex,
    set: /* @__PURE__ */ __name((key, element, baseZIndex) => {
      if (element) {
        element.style.zIndex = String(generateZIndex(key, true, baseZIndex));
      }
    }, "set"),
    clear: /* @__PURE__ */ __name((element) => {
      if (element) {
        revertZIndex(getZIndex(element));
        element.style.zIndex = "";
      }
    }, "clear"),
    getCurrent: /* @__PURE__ */ __name((key) => getCurrentZIndex(key, true), "getCurrent")
  };
}
__name(handler, "handler");
var ZIndex = handler();
var lastIds = {};
function uuid(prefix2 = "pui_id_") {
  if (!lastIds.hasOwnProperty(prefix2)) {
    lastIds[prefix2] = 0;
  }
  lastIds[prefix2]++;
  return `${prefix2}${lastIds[prefix2]}`;
}
__name(uuid, "uuid");
function _typeof$1$4(o) {
  "@babel/helpers - typeof";
  return _typeof$1$4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$1$4(o);
}
__name(_typeof$1$4, "_typeof$1$4");
function _classCallCheck$1(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
__name(_classCallCheck$1, "_classCallCheck$1");
function _defineProperties$1(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey$1$3(o.key), o);
  }
}
__name(_defineProperties$1, "_defineProperties$1");
function _createClass$1(e, r, t) {
  return r && _defineProperties$1(e.prototype, r), Object.defineProperty(e, "prototype", { writable: false }), e;
}
__name(_createClass$1, "_createClass$1");
function _toPropertyKey$1$3(t) {
  var i2 = _toPrimitive$1$3(t, "string");
  return "symbol" == _typeof$1$4(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$1$3, "_toPropertyKey$1$3");
function _toPrimitive$1$3(t, r) {
  if ("object" != _typeof$1$4(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r);
    if ("object" != _typeof$1$4(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t);
}
__name(_toPrimitive$1$3, "_toPrimitive$1$3");
var ConnectedOverlayScrollHandler = /* @__PURE__ */ function() {
  function ConnectedOverlayScrollHandler2(element) {
    var listener = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
    };
    _classCallCheck$1(this, ConnectedOverlayScrollHandler2);
    this.element = element;
    this.listener = listener;
  }
  __name(ConnectedOverlayScrollHandler2, "ConnectedOverlayScrollHandler");
  return _createClass$1(ConnectedOverlayScrollHandler2, [{
    key: "bindScrollListener",
    value: /* @__PURE__ */ __name(function bindScrollListener7() {
      this.scrollableParents = getScrollableParents(this.element);
      for (var i2 = 0; i2 < this.scrollableParents.length; i2++) {
        this.scrollableParents[i2].addEventListener("scroll", this.listener);
      }
    }, "bindScrollListener")
  }, {
    key: "unbindScrollListener",
    value: /* @__PURE__ */ __name(function unbindScrollListener7() {
      if (this.scrollableParents) {
        for (var i2 = 0; i2 < this.scrollableParents.length; i2++) {
          this.scrollableParents[i2].removeEventListener("scroll", this.listener);
        }
      }
    }, "unbindScrollListener")
  }, {
    key: "destroy",
    value: /* @__PURE__ */ __name(function destroy() {
      this.unbindScrollListener();
      this.element = null;
      this.listener = null;
      this.scrollableParents = null;
    }, "destroy")
  }]);
}();
function _typeof$i(o) {
  "@babel/helpers - typeof";
  return _typeof$i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$i(o);
}
__name(_typeof$i, "_typeof$i");
function _toConsumableArray$e(r) {
  return _arrayWithoutHoles$e(r) || _iterableToArray$f(r) || _unsupportedIterableToArray$j(r) || _nonIterableSpread$e();
}
__name(_toConsumableArray$e, "_toConsumableArray$e");
function _nonIterableSpread$e() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableSpread$e, "_nonIterableSpread$e");
function _unsupportedIterableToArray$j(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$j(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$j(r, a) : void 0;
  }
}
__name(_unsupportedIterableToArray$j, "_unsupportedIterableToArray$j");
function _iterableToArray$f(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
__name(_iterableToArray$f, "_iterableToArray$f");
function _arrayWithoutHoles$e(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$j(r);
}
__name(_arrayWithoutHoles$e, "_arrayWithoutHoles$e");
function _arrayLikeToArray$j(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
__name(_arrayLikeToArray$j, "_arrayLikeToArray$j");
function _classCallCheck(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
__name(_classCallCheck, "_classCallCheck");
function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey$h(o.key), o);
  }
}
__name(_defineProperties, "_defineProperties");
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), Object.defineProperty(e, "prototype", { writable: false }), e;
}
__name(_createClass, "_createClass");
function _defineProperty$i(e, r, t) {
  return (r = _toPropertyKey$h(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty$i, "_defineProperty$i");
function _toPropertyKey$h(t) {
  var i2 = _toPrimitive$h(t, "string");
  return "symbol" == _typeof$i(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$h, "_toPropertyKey$h");
function _toPrimitive$h(t, r) {
  if ("object" != _typeof$i(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r);
    if ("object" != _typeof$i(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t);
}
__name(_toPrimitive$h, "_toPrimitive$h");
var _default = /* @__PURE__ */ function() {
  function _default4(_ref) {
    var init2 = _ref.init, type = _ref.type;
    _classCallCheck(this, _default4);
    _defineProperty$i(this, "helpers", void 0);
    _defineProperty$i(this, "type", void 0);
    this.helpers = new Set(init2);
    this.type = type;
  }
  __name(_default4, "_default");
  return _createClass(_default4, [{
    key: "add",
    value: /* @__PURE__ */ __name(function add3(instance) {
      this.helpers.add(instance);
    }, "add")
  }, {
    key: "update",
    value: /* @__PURE__ */ __name(function update2() {
    }, "update")
  }, {
    key: "delete",
    value: /* @__PURE__ */ __name(function _delete(instance) {
      this.helpers["delete"](instance);
    }, "_delete")
  }, {
    key: "clear",
    value: /* @__PURE__ */ __name(function clear3() {
      this.helpers.clear();
    }, "clear")
  }, {
    key: "get",
    value: /* @__PURE__ */ __name(function get2(parentInstance, slots) {
      var children = this._get(parentInstance, slots);
      var computed2 = children ? this._recursive(_toConsumableArray$e(this.helpers), children) : null;
      return isNotEmpty(computed2) ? computed2 : null;
    }, "get")
  }, {
    key: "_isMatched",
    value: /* @__PURE__ */ __name(function _isMatched(instance, key) {
      var _parent$vnode;
      var parent = instance === null || instance === void 0 ? void 0 : instance.parent;
      return (parent === null || parent === void 0 || (_parent$vnode = parent.vnode) === null || _parent$vnode === void 0 ? void 0 : _parent$vnode.key) === key || parent && this._isMatched(parent, key) || false;
    }, "_isMatched")
  }, {
    key: "_get",
    value: /* @__PURE__ */ __name(function _get(parentInstance, slots) {
      var _ref2, _ref2$default;
      return ((_ref2 = slots || (parentInstance === null || parentInstance === void 0 ? void 0 : parentInstance.$slots)) === null || _ref2 === void 0 || (_ref2$default = _ref2["default"]) === null || _ref2$default === void 0 ? void 0 : _ref2$default.call(_ref2)) || null;
    }, "_get")
  }, {
    key: "_recursive",
    value: /* @__PURE__ */ __name(function _recursive() {
      var _this = this;
      var helpers = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      var children = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      var components = [];
      children.forEach(function(child) {
        if (child.children instanceof Array) {
          components = components.concat(_this._recursive(components, child.children));
        } else if (child.type.name === _this.type) {
          components.push(child);
        } else if (isNotEmpty(child.key)) {
          components = components.concat(helpers.filter(function(c) {
            return _this._isMatched(c, child.key);
          }).map(function(c) {
            return c.vnode;
          }));
        }
      });
      return components;
    }, "_recursive")
  }]);
}();
function UniqueComponentId() {
  var prefix2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "pv_id_";
  return uuid(prefix2);
}
__name(UniqueComponentId, "UniqueComponentId");
function getVNodeProp(vnode, prop2) {
  if (vnode) {
    var props = vnode.props;
    if (props) {
      var kebabProp = prop2.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
      var propName = Object.prototype.hasOwnProperty.call(props, kebabProp) ? kebabProp : prop2;
      return vnode.type["extends"].props[prop2].type === Boolean && props[propName] === "" ? true : props[propName];
    }
  }
  return null;
}
__name(getVNodeProp, "getVNodeProp");
var Base = {
  _loadedStyleNames: /* @__PURE__ */ new Set(),
  getLoadedStyleNames: /* @__PURE__ */ __name(function getLoadedStyleNames2() {
    return this._loadedStyleNames;
  }, "getLoadedStyleNames"),
  isStyleNameLoaded: /* @__PURE__ */ __name(function isStyleNameLoaded2(name) {
    return this._loadedStyleNames.has(name);
  }, "isStyleNameLoaded"),
  setLoadedStyleName: /* @__PURE__ */ __name(function setLoadedStyleName2(name) {
    this._loadedStyleNames.add(name);
  }, "setLoadedStyleName"),
  deleteLoadedStyleName: /* @__PURE__ */ __name(function deleteLoadedStyleName2(name) {
    this._loadedStyleNames["delete"](name);
  }, "deleteLoadedStyleName"),
  clearLoadedStyleNames: /* @__PURE__ */ __name(function clearLoadedStyleNames2() {
    this._loadedStyleNames.clear();
  }, "clearLoadedStyleNames")
};
function _typeof$h(o) {
  "@babel/helpers - typeof";
  return _typeof$h = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$h(o);
}
__name(_typeof$h, "_typeof$h");
function _slicedToArray$3(r, e) {
  return _arrayWithHoles$3(r) || _iterableToArrayLimit$3(r, e) || _unsupportedIterableToArray$i(r, e) || _nonIterableRest$3();
}
__name(_slicedToArray$3, "_slicedToArray$3");
function _nonIterableRest$3() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableRest$3, "_nonIterableRest$3");
function _unsupportedIterableToArray$i(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$i(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$i(r, a) : void 0;
  }
}
__name(_unsupportedIterableToArray$i, "_unsupportedIterableToArray$i");
function _arrayLikeToArray$i(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
__name(_arrayLikeToArray$i, "_arrayLikeToArray$i");
function _iterableToArrayLimit$3(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i2, u, a = [], f = true, o = false;
    try {
      if (i2 = (t = t.call(r)).next, 0 === l) ;
      else for (; !(f = (e = i2.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
__name(_iterableToArrayLimit$3, "_iterableToArrayLimit$3");
function _arrayWithHoles$3(r) {
  if (Array.isArray(r)) return r;
}
__name(_arrayWithHoles$3, "_arrayWithHoles$3");
function ownKeys$f(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
__name(ownKeys$f, "ownKeys$f");
function _objectSpread$f(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$f(Object(t), true).forEach(function(r2) {
      _defineProperty$h(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$f(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
__name(_objectSpread$f, "_objectSpread$f");
function _defineProperty$h(e, r, t) {
  return (r = _toPropertyKey$g(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty$h, "_defineProperty$h");
function _toPropertyKey$g(t) {
  var i2 = _toPrimitive$g(t, "string");
  return "symbol" == _typeof$h(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$g, "_toPropertyKey$g");
function _toPrimitive$g(t, r) {
  if ("object" != _typeof$h(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$h(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive$g, "_toPrimitive$g");
var BaseDirective = {
  _getMeta: /* @__PURE__ */ __name(function _getMeta() {
    return [isObject$5(arguments.length <= 0 ? void 0 : arguments[0]) ? void 0 : arguments.length <= 0 ? void 0 : arguments[0], resolve(isObject$5(arguments.length <= 0 ? void 0 : arguments[0]) ? arguments.length <= 0 ? void 0 : arguments[0] : arguments.length <= 1 ? void 0 : arguments[1])];
  }, "_getMeta"),
  _getConfig: /* @__PURE__ */ __name(function _getConfig(binding, vnode) {
    var _ref, _binding$instance, _vnode$ctx;
    return (_ref = (binding === null || binding === void 0 || (_binding$instance = binding.instance) === null || _binding$instance === void 0 ? void 0 : _binding$instance.$primevue) || (vnode === null || vnode === void 0 || (_vnode$ctx = vnode.ctx) === null || _vnode$ctx === void 0 || (_vnode$ctx = _vnode$ctx.appContext) === null || _vnode$ctx === void 0 || (_vnode$ctx = _vnode$ctx.config) === null || _vnode$ctx === void 0 || (_vnode$ctx = _vnode$ctx.globalProperties) === null || _vnode$ctx === void 0 ? void 0 : _vnode$ctx.$primevue)) === null || _ref === void 0 ? void 0 : _ref.config;
  }, "_getConfig"),
  _getOptionValue: getKeyValue,
  _getPTValue: /* @__PURE__ */ __name(function _getPTValue() {
    var _instance$binding, _instance$$primevueCo;
    var instance = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var obj = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var key = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
    var params = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    var searchInDefaultPT = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
    var getValue2 = /* @__PURE__ */ __name(function getValue3() {
      var value3 = BaseDirective._getOptionValue.apply(BaseDirective, arguments);
      return isString$4(value3) || isArray$3(value3) ? {
        "class": value3
      } : value3;
    }, "getValue");
    var _ref2 = ((_instance$binding = instance.binding) === null || _instance$binding === void 0 || (_instance$binding = _instance$binding.value) === null || _instance$binding === void 0 ? void 0 : _instance$binding.ptOptions) || ((_instance$$primevueCo = instance.$primevueConfig) === null || _instance$$primevueCo === void 0 ? void 0 : _instance$$primevueCo.ptOptions) || {}, _ref2$mergeSections = _ref2.mergeSections, mergeSections = _ref2$mergeSections === void 0 ? true : _ref2$mergeSections, _ref2$mergeProps = _ref2.mergeProps, useMergeProps = _ref2$mergeProps === void 0 ? false : _ref2$mergeProps;
    var global2 = searchInDefaultPT ? BaseDirective._useDefaultPT(instance, instance.defaultPT(), getValue2, key, params) : void 0;
    var self2 = BaseDirective._usePT(instance, BaseDirective._getPT(obj, instance.$name), getValue2, key, _objectSpread$f(_objectSpread$f({}, params), {}, {
      global: global2 || {}
    }));
    var datasets = BaseDirective._getPTDatasets(instance, key);
    return mergeSections || !mergeSections && self2 ? useMergeProps ? BaseDirective._mergeProps(instance, useMergeProps, global2, self2, datasets) : _objectSpread$f(_objectSpread$f(_objectSpread$f({}, global2), self2), datasets) : _objectSpread$f(_objectSpread$f({}, self2), datasets);
  }, "_getPTValue"),
  _getPTDatasets: /* @__PURE__ */ __name(function _getPTDatasets() {
    var instance = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    var datasetPrefix = "data-pc-";
    return _objectSpread$f(_objectSpread$f({}, key === "root" && _defineProperty$h({}, "".concat(datasetPrefix, "name"), toFlatCase(instance.$name))), {}, _defineProperty$h({}, "".concat(datasetPrefix, "section"), toFlatCase(key)));
  }, "_getPTDatasets"),
  _getPT: /* @__PURE__ */ __name(function _getPT(pt) {
    var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    var callback = arguments.length > 2 ? arguments[2] : void 0;
    var getValue2 = /* @__PURE__ */ __name(function getValue3(value3) {
      var _computedValue$_key;
      var computedValue = callback ? callback(value3) : value3;
      var _key = toFlatCase(key);
      return (_computedValue$_key = computedValue === null || computedValue === void 0 ? void 0 : computedValue[_key]) !== null && _computedValue$_key !== void 0 ? _computedValue$_key : computedValue;
    }, "getValue");
    return pt !== null && pt !== void 0 && pt.hasOwnProperty("_usept") ? {
      _usept: pt["_usept"],
      originalValue: getValue2(pt.originalValue),
      value: getValue2(pt.value)
    } : getValue2(pt);
  }, "_getPT"),
  _usePT: /* @__PURE__ */ __name(function _usePT() {
    var instance = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var pt = arguments.length > 1 ? arguments[1] : void 0;
    var callback = arguments.length > 2 ? arguments[2] : void 0;
    var key = arguments.length > 3 ? arguments[3] : void 0;
    var params = arguments.length > 4 ? arguments[4] : void 0;
    var fn = /* @__PURE__ */ __name(function fn2(value4) {
      return callback(value4, key, params);
    }, "fn");
    if (pt !== null && pt !== void 0 && pt.hasOwnProperty("_usept")) {
      var _instance$$primevueCo2;
      var _ref4 = pt["_usept"] || ((_instance$$primevueCo2 = instance.$primevueConfig) === null || _instance$$primevueCo2 === void 0 ? void 0 : _instance$$primevueCo2.ptOptions) || {}, _ref4$mergeSections = _ref4.mergeSections, mergeSections = _ref4$mergeSections === void 0 ? true : _ref4$mergeSections, _ref4$mergeProps = _ref4.mergeProps, useMergeProps = _ref4$mergeProps === void 0 ? false : _ref4$mergeProps;
      var originalValue = fn(pt.originalValue);
      var value3 = fn(pt.value);
      if (originalValue === void 0 && value3 === void 0) return void 0;
      else if (isString$4(value3)) return value3;
      else if (isString$4(originalValue)) return originalValue;
      return mergeSections || !mergeSections && value3 ? useMergeProps ? BaseDirective._mergeProps(instance, useMergeProps, originalValue, value3) : _objectSpread$f(_objectSpread$f({}, originalValue), value3) : value3;
    }
    return fn(pt);
  }, "_usePT"),
  _useDefaultPT: /* @__PURE__ */ __name(function _useDefaultPT() {
    var instance = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var defaultPT2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var callback = arguments.length > 2 ? arguments[2] : void 0;
    var key = arguments.length > 3 ? arguments[3] : void 0;
    var params = arguments.length > 4 ? arguments[4] : void 0;
    return BaseDirective._usePT(instance, defaultPT2, callback, key, params);
  }, "_useDefaultPT"),
  _loadStyles: /* @__PURE__ */ __name(function _loadStyles(el, binding, vnode) {
    var _config$csp;
    var config = BaseDirective._getConfig(binding, vnode);
    var useStyleOptions = {
      nonce: config === null || config === void 0 || (_config$csp = config.csp) === null || _config$csp === void 0 ? void 0 : _config$csp.nonce
    };
    BaseDirective._loadCoreStyles(el.$instance, useStyleOptions);
    BaseDirective._loadThemeStyles(el.$instance, useStyleOptions);
    BaseDirective._loadScopedThemeStyles(el.$instance, useStyleOptions);
    BaseDirective._themeChangeListener(function() {
      return BaseDirective._loadThemeStyles(el.$instance, useStyleOptions);
    });
  }, "_loadStyles"),
  _loadCoreStyles: /* @__PURE__ */ __name(function _loadCoreStyles() {
    var _instance$$style, _instance$$style2;
    var instance = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var useStyleOptions = arguments.length > 1 ? arguments[1] : void 0;
    if (!Base.isStyleNameLoaded((_instance$$style = instance.$style) === null || _instance$$style === void 0 ? void 0 : _instance$$style.name) && (_instance$$style2 = instance.$style) !== null && _instance$$style2 !== void 0 && _instance$$style2.name) {
      var _instance$$style3;
      BaseStyle.loadCSS(useStyleOptions);
      instance.isUnstyled() && ((_instance$$style3 = instance.$style) === null || _instance$$style3 === void 0 ? void 0 : _instance$$style3.loadCSS(useStyleOptions));
      Base.setLoadedStyleName(instance.$style.name);
    }
  }, "_loadCoreStyles"),
  _loadThemeStyles: /* @__PURE__ */ __name(function _loadThemeStyles() {
    var _instance$$style5, _instance$$style6;
    var instance = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var useStyleOptions = arguments.length > 1 ? arguments[1] : void 0;
    if (instance !== null && instance !== void 0 && instance.isUnstyled()) return;
    if (!config_default.isStyleNameLoaded("common")) {
      var _instance$$style4, _instance$$style4$get;
      var _ref5 = ((_instance$$style4 = instance.$style) === null || _instance$$style4 === void 0 || (_instance$$style4$get = _instance$$style4.getCommonTheme) === null || _instance$$style4$get === void 0 ? void 0 : _instance$$style4$get.call(_instance$$style4)) || {}, primitive = _ref5.primitive, semantic = _ref5.semantic;
      BaseStyle.load(primitive === null || primitive === void 0 ? void 0 : primitive.css, _objectSpread$f({
        name: "primitive-variables"
      }, useStyleOptions));
      BaseStyle.load(semantic === null || semantic === void 0 ? void 0 : semantic.css, _objectSpread$f({
        name: "semantic-variables"
      }, useStyleOptions));
      BaseStyle.loadTheme(_objectSpread$f({
        name: "global-style"
      }, useStyleOptions));
      config_default.setLoadedStyleName("common");
    }
    if (!config_default.isStyleNameLoaded((_instance$$style5 = instance.$style) === null || _instance$$style5 === void 0 ? void 0 : _instance$$style5.name) && (_instance$$style6 = instance.$style) !== null && _instance$$style6 !== void 0 && _instance$$style6.name) {
      var _instance$$style7, _instance$$style7$get, _instance$$style8, _instance$$style9;
      var _ref6 = ((_instance$$style7 = instance.$style) === null || _instance$$style7 === void 0 || (_instance$$style7$get = _instance$$style7.getDirectiveTheme) === null || _instance$$style7$get === void 0 ? void 0 : _instance$$style7$get.call(_instance$$style7)) || {}, css4 = _ref6.css;
      (_instance$$style8 = instance.$style) === null || _instance$$style8 === void 0 || _instance$$style8.load(css4, _objectSpread$f({
        name: "".concat(instance.$style.name, "-variables")
      }, useStyleOptions));
      (_instance$$style9 = instance.$style) === null || _instance$$style9 === void 0 || _instance$$style9.loadTheme(_objectSpread$f({
        name: "".concat(instance.$style.name, "-style")
      }, useStyleOptions));
      config_default.setLoadedStyleName(instance.$style.name);
    }
    if (!config_default.isStyleNameLoaded("layer-order")) {
      var _instance$$style10, _instance$$style10$ge;
      var layerOrder = (_instance$$style10 = instance.$style) === null || _instance$$style10 === void 0 || (_instance$$style10$ge = _instance$$style10.getLayerOrderThemeCSS) === null || _instance$$style10$ge === void 0 ? void 0 : _instance$$style10$ge.call(_instance$$style10);
      BaseStyle.load(layerOrder, _objectSpread$f({
        name: "layer-order",
        first: true
      }, useStyleOptions));
      config_default.setLoadedStyleName("layer-order");
    }
  }, "_loadThemeStyles"),
  _loadScopedThemeStyles: /* @__PURE__ */ __name(function _loadScopedThemeStyles() {
    var instance = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var useStyleOptions = arguments.length > 1 ? arguments[1] : void 0;
    var preset = instance.preset();
    if (preset && instance.$attrSelector) {
      var _instance$$style11, _instance$$style11$ge, _instance$$style12;
      var _ref7 = ((_instance$$style11 = instance.$style) === null || _instance$$style11 === void 0 || (_instance$$style11$ge = _instance$$style11.getPresetTheme) === null || _instance$$style11$ge === void 0 ? void 0 : _instance$$style11$ge.call(_instance$$style11, preset, "[".concat(instance.$attrSelector, "]"))) || {}, css4 = _ref7.css;
      var scopedStyle = (_instance$$style12 = instance.$style) === null || _instance$$style12 === void 0 ? void 0 : _instance$$style12.load(css4, _objectSpread$f({
        name: "".concat(instance.$attrSelector, "-").concat(instance.$style.name)
      }, useStyleOptions));
      instance.scopedStyleEl = scopedStyle.el;
    }
  }, "_loadScopedThemeStyles"),
  _themeChangeListener: /* @__PURE__ */ __name(function _themeChangeListener() {
    var callback = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function() {
    };
    Base.clearLoadedStyleNames();
    service_default.on("theme:change", callback);
  }, "_themeChangeListener"),
  _hook: /* @__PURE__ */ __name(function _hook(directiveName, hookName, el, binding, vnode, prevVnode) {
    var _binding$value, _config$pt;
    var name = "on".concat(toCapitalCase(hookName));
    var config = BaseDirective._getConfig(binding, vnode);
    var instance = el === null || el === void 0 ? void 0 : el.$instance;
    var selfHook = BaseDirective._usePT(instance, BaseDirective._getPT(binding === null || binding === void 0 || (_binding$value = binding.value) === null || _binding$value === void 0 ? void 0 : _binding$value.pt, directiveName), BaseDirective._getOptionValue, "hooks.".concat(name));
    var defaultHook = BaseDirective._useDefaultPT(instance, config === null || config === void 0 || (_config$pt = config.pt) === null || _config$pt === void 0 || (_config$pt = _config$pt.directives) === null || _config$pt === void 0 ? void 0 : _config$pt[directiveName], BaseDirective._getOptionValue, "hooks.".concat(name));
    var options3 = {
      el,
      binding,
      vnode,
      prevVnode
    };
    selfHook === null || selfHook === void 0 || selfHook(instance, options3);
    defaultHook === null || defaultHook === void 0 || defaultHook(instance, options3);
  }, "_hook"),
  _mergeProps: /* @__PURE__ */ __name(function _mergeProps() {
    var fn = arguments.length > 1 ? arguments[1] : void 0;
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key2 = 2; _key2 < _len; _key2++) {
      args[_key2 - 2] = arguments[_key2];
    }
    return isFunction$3(fn) ? fn.apply(void 0, args) : mergeProps.apply(void 0, args);
  }, "_mergeProps"),
  _extend: /* @__PURE__ */ __name(function _extend(name) {
    var options3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var handleHook = /* @__PURE__ */ __name(function handleHook2(hook, el, binding, vnode, prevVnode) {
      var _el$$instance$hook, _el$$instance9, _el$$pd;
      el._$instances = el._$instances || {};
      var config = BaseDirective._getConfig(binding, vnode);
      var $prevInstance = el._$instances[name] || {};
      var $options = isEmpty($prevInstance) ? _objectSpread$f(_objectSpread$f({}, options3), options3 === null || options3 === void 0 ? void 0 : options3.methods) : {};
      el._$instances[name] = _objectSpread$f(_objectSpread$f({}, $prevInstance), {}, {
        /* new instance variables to pass in directive methods */
        $name: name,
        $host: el,
        $binding: binding,
        $modifiers: binding === null || binding === void 0 ? void 0 : binding.modifiers,
        $value: binding === null || binding === void 0 ? void 0 : binding.value,
        $el: $prevInstance["$el"] || el || void 0,
        $style: _objectSpread$f({
          classes: void 0,
          inlineStyles: void 0,
          load: /* @__PURE__ */ __name(function load2() {
          }, "load"),
          loadCSS: /* @__PURE__ */ __name(function loadCSS2() {
          }, "loadCSS"),
          loadTheme: /* @__PURE__ */ __name(function loadTheme2() {
          }, "loadTheme")
        }, options3 === null || options3 === void 0 ? void 0 : options3.style),
        $primevueConfig: config,
        $attrSelector: el.$attrSelector,
        /* computed instance variables */
        defaultPT: /* @__PURE__ */ __name(function defaultPT2() {
          return BaseDirective._getPT(config === null || config === void 0 ? void 0 : config.pt, void 0, function(value3) {
            var _value$directives;
            return value3 === null || value3 === void 0 || (_value$directives = value3.directives) === null || _value$directives === void 0 ? void 0 : _value$directives[name];
          });
        }, "defaultPT"),
        isUnstyled: /* @__PURE__ */ __name(function isUnstyled2() {
          var _el$$instance, _el$$instance2;
          return ((_el$$instance = el.$instance) === null || _el$$instance === void 0 || (_el$$instance = _el$$instance.$binding) === null || _el$$instance === void 0 || (_el$$instance = _el$$instance.value) === null || _el$$instance === void 0 ? void 0 : _el$$instance.unstyled) !== void 0 ? (_el$$instance2 = el.$instance) === null || _el$$instance2 === void 0 || (_el$$instance2 = _el$$instance2.$binding) === null || _el$$instance2 === void 0 || (_el$$instance2 = _el$$instance2.value) === null || _el$$instance2 === void 0 ? void 0 : _el$$instance2.unstyled : config === null || config === void 0 ? void 0 : config.unstyled;
        }, "isUnstyled"),
        theme: /* @__PURE__ */ __name(function theme38() {
          var _el$$instance3;
          return (_el$$instance3 = el.$instance) === null || _el$$instance3 === void 0 || (_el$$instance3 = _el$$instance3.$primevueConfig) === null || _el$$instance3 === void 0 ? void 0 : _el$$instance3.theme;
        }, "theme"),
        preset: /* @__PURE__ */ __name(function preset() {
          var _el$$instance4;
          return (_el$$instance4 = el.$instance) === null || _el$$instance4 === void 0 || (_el$$instance4 = _el$$instance4.$binding) === null || _el$$instance4 === void 0 || (_el$$instance4 = _el$$instance4.value) === null || _el$$instance4 === void 0 ? void 0 : _el$$instance4.dt;
        }, "preset"),
        /* instance's methods */
        ptm: /* @__PURE__ */ __name(function ptm2() {
          var _el$$instance5;
          var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          return BaseDirective._getPTValue(el.$instance, (_el$$instance5 = el.$instance) === null || _el$$instance5 === void 0 || (_el$$instance5 = _el$$instance5.$binding) === null || _el$$instance5 === void 0 || (_el$$instance5 = _el$$instance5.value) === null || _el$$instance5 === void 0 ? void 0 : _el$$instance5.pt, key, _objectSpread$f({}, params));
        }, "ptm"),
        ptmo: /* @__PURE__ */ __name(function ptmo2() {
          var obj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
          var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          return BaseDirective._getPTValue(el.$instance, obj, key, params, false);
        }, "ptmo"),
        cx: /* @__PURE__ */ __name(function cx2() {
          var _el$$instance6, _el$$instance7;
          var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          return !((_el$$instance6 = el.$instance) !== null && _el$$instance6 !== void 0 && _el$$instance6.isUnstyled()) ? BaseDirective._getOptionValue((_el$$instance7 = el.$instance) === null || _el$$instance7 === void 0 || (_el$$instance7 = _el$$instance7.$style) === null || _el$$instance7 === void 0 ? void 0 : _el$$instance7.classes, key, _objectSpread$f({}, params)) : void 0;
        }, "cx"),
        sx: /* @__PURE__ */ __name(function sx2() {
          var _el$$instance8;
          var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          var when = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          return when ? BaseDirective._getOptionValue((_el$$instance8 = el.$instance) === null || _el$$instance8 === void 0 || (_el$$instance8 = _el$$instance8.$style) === null || _el$$instance8 === void 0 ? void 0 : _el$$instance8.inlineStyles, key, _objectSpread$f({}, params)) : void 0;
        }, "sx")
      }, $options);
      el.$instance = el._$instances[name];
      (_el$$instance$hook = (_el$$instance9 = el.$instance)[hook]) === null || _el$$instance$hook === void 0 || _el$$instance$hook.call(_el$$instance9, el, binding, vnode, prevVnode);
      el["$".concat(name)] = el.$instance;
      BaseDirective._hook(name, hook, el, binding, vnode, prevVnode);
      el.$pd || (el.$pd = {});
      el.$pd[name] = _objectSpread$f(_objectSpread$f({}, (_el$$pd = el.$pd) === null || _el$$pd === void 0 ? void 0 : _el$$pd[name]), {}, {
        name,
        instance: el.$instance
      });
    }, "handleHook");
    var handleWatch = /* @__PURE__ */ __name(function handleWatch2(el) {
      var _el$$instance10, _watchers$config, _el$$instance11, _watchers$configRipp, _el$$instance12;
      var watchers = (_el$$instance10 = el.$instance) === null || _el$$instance10 === void 0 ? void 0 : _el$$instance10.watch;
      watchers === null || watchers === void 0 || (_watchers$config = watchers["config"]) === null || _watchers$config === void 0 || _watchers$config.call(el.$instance, (_el$$instance11 = el.$instance) === null || _el$$instance11 === void 0 ? void 0 : _el$$instance11.$primevueConfig);
      PrimeVueService.on("config:change", function(_ref8) {
        var _watchers$config2;
        var newValue = _ref8.newValue, oldValue = _ref8.oldValue;
        return watchers === null || watchers === void 0 || (_watchers$config2 = watchers["config"]) === null || _watchers$config2 === void 0 ? void 0 : _watchers$config2.call(el.$instance, newValue, oldValue);
      });
      watchers === null || watchers === void 0 || (_watchers$configRipp = watchers["config.ripple"]) === null || _watchers$configRipp === void 0 || _watchers$configRipp.call(el.$instance, (_el$$instance12 = el.$instance) === null || _el$$instance12 === void 0 || (_el$$instance12 = _el$$instance12.$primevueConfig) === null || _el$$instance12 === void 0 ? void 0 : _el$$instance12.ripple);
      PrimeVueService.on("config:ripple:change", function(_ref9) {
        var _watchers$configRipp2;
        var newValue = _ref9.newValue, oldValue = _ref9.oldValue;
        return watchers === null || watchers === void 0 || (_watchers$configRipp2 = watchers["config.ripple"]) === null || _watchers$configRipp2 === void 0 ? void 0 : _watchers$configRipp2.call(el.$instance, newValue, oldValue);
      });
    }, "handleWatch");
    return {
      created: /* @__PURE__ */ __name(function created3(el, binding, vnode, prevVnode) {
        handleHook("created", el, binding, vnode, prevVnode);
      }, "created"),
      beforeMount: /* @__PURE__ */ __name(function beforeMount4(el, binding, vnode, prevVnode) {
        el.$attrSelector = UniqueComponentId("pd");
        BaseDirective._loadStyles(el, binding, vnode);
        handleHook("beforeMount", el, binding, vnode, prevVnode);
        handleWatch(el);
      }, "beforeMount"),
      mounted: /* @__PURE__ */ __name(function mounted23(el, binding, vnode, prevVnode) {
        BaseDirective._loadStyles(el, binding, vnode);
        handleHook("mounted", el, binding, vnode, prevVnode);
      }, "mounted"),
      beforeUpdate: /* @__PURE__ */ __name(function beforeUpdate2(el, binding, vnode, prevVnode) {
        handleHook("beforeUpdate", el, binding, vnode, prevVnode);
      }, "beforeUpdate"),
      updated: /* @__PURE__ */ __name(function updated12(el, binding, vnode, prevVnode) {
        BaseDirective._loadStyles(el, binding, vnode);
        handleHook("updated", el, binding, vnode, prevVnode);
      }, "updated"),
      beforeUnmount: /* @__PURE__ */ __name(function beforeUnmount17(el, binding, vnode, prevVnode) {
        handleHook("beforeUnmount", el, binding, vnode, prevVnode);
      }, "beforeUnmount"),
      unmounted: /* @__PURE__ */ __name(function unmounted6(el, binding, vnode, prevVnode) {
        var _el$$instance13;
        (_el$$instance13 = el.$instance) === null || _el$$instance13 === void 0 || (_el$$instance13 = _el$$instance13.scopedStyleEl) === null || _el$$instance13 === void 0 || (_el$$instance13 = _el$$instance13.value) === null || _el$$instance13 === void 0 || _el$$instance13.remove();
        handleHook("unmounted", el, binding, vnode, prevVnode);
      }, "unmounted")
    };
  }, "_extend"),
  extend: /* @__PURE__ */ __name(function extend3() {
    var _BaseDirective$_getMe = BaseDirective._getMeta.apply(BaseDirective, arguments), _BaseDirective$_getMe2 = _slicedToArray$3(_BaseDirective$_getMe, 2), name = _BaseDirective$_getMe2[0], options3 = _BaseDirective$_getMe2[1];
    return _objectSpread$f({
      extend: /* @__PURE__ */ __name(function extend4() {
        var _BaseDirective$_getMe3 = BaseDirective._getMeta.apply(BaseDirective, arguments), _BaseDirective$_getMe4 = _slicedToArray$3(_BaseDirective$_getMe3, 2), _name = _BaseDirective$_getMe4[0], _options = _BaseDirective$_getMe4[1];
        return BaseDirective.extend(_name, _objectSpread$f(_objectSpread$f(_objectSpread$f({}, options3), options3 === null || options3 === void 0 ? void 0 : options3.methods), _options));
      }, "extend")
    }, BaseDirective._extend(name, options3));
  }, "extend")
};
var theme$y = /* @__PURE__ */ __name(function theme3(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-tooltip {\n    position: absolute;\n    display: none;\n    max-width: ".concat(dt3("tooltip.max.width"), ";\n}\n\n.p-tooltip-right,\n.p-tooltip-left {\n    padding: 0 ").concat(dt3("tooltip.gutter"), ";\n}\n\n.p-tooltip-top,\n.p-tooltip-bottom {\n    padding: ").concat(dt3("tooltip.gutter"), " 0;\n}\n\n.p-tooltip-text {\n    white-space: pre-line;\n    word-break: break-word;\n    background: ").concat(dt3("tooltip.background"), ";\n    color: ").concat(dt3("tooltip.color"), ";\n    padding: ").concat(dt3("tooltip.padding"), ";\n    box-shadow: ").concat(dt3("tooltip.shadow"), ";\n    border-radius: ").concat(dt3("tooltip.border.radius"), ";\n}\n\n.p-tooltip-arrow {\n    position: absolute;\n    width: 0;\n    height: 0;\n    border-color: transparent;\n    border-style: solid;\n    scale: 2;\n}\n\n.p-tooltip-right .p-tooltip-arrow {\n    margin-top: calc(-1 * ").concat(dt3("tooltip.gutter"), ");\n    border-width: ").concat(dt3("tooltip.gutter"), " ").concat(dt3("tooltip.gutter"), " ").concat(dt3("tooltip.gutter"), " 0;\n    border-right-color: ").concat(dt3("tooltip.background"), ";\n}\n\n.p-tooltip-left .p-tooltip-arrow {\n    margin-top: calc(-1 * ").concat(dt3("tooltip.gutter"), ");\n    border-width: ").concat(dt3("tooltip.gutter"), " 0 ").concat(dt3("tooltip.gutter"), " ").concat(dt3("tooltip.gutter"), ";\n    border-left-color: ").concat(dt3("tooltip.background"), ";\n}\n\n.p-tooltip-top .p-tooltip-arrow {\n    margin-left: calc(-1 * ").concat(dt3("tooltip.gutter"), ");\n    border-width: ").concat(dt3("tooltip.gutter"), " ").concat(dt3("tooltip.gutter"), " 0 ").concat(dt3("tooltip.gutter"), ";\n    border-top-color: ").concat(dt3("tooltip.background"), ";\n    border-bottom-color: ").concat(dt3("tooltip.background"), ";\n}\n\n.p-tooltip-bottom .p-tooltip-arrow {\n    margin-left: calc(-1 * ").concat(dt3("tooltip.gutter"), ");\n    border-width: 0 ").concat(dt3("tooltip.gutter"), " ").concat(dt3("tooltip.gutter"), " ").concat(dt3("tooltip.gutter"), ";\n    border-top-color: ").concat(dt3("tooltip.background"), ";\n    border-bottom-color: ").concat(dt3("tooltip.background"), ";\n}\n");
}, "theme");
var classes$B = {
  root: "p-tooltip p-component",
  arrow: "p-tooltip-arrow",
  text: "p-tooltip-text"
};
var TooltipStyle = BaseStyle.extend({
  name: "tooltip-directive",
  theme: theme$y,
  classes: classes$B
});
var BaseTooltip = BaseDirective.extend({
  style: TooltipStyle
});
function _slicedToArray$2(r, e) {
  return _arrayWithHoles$2(r) || _iterableToArrayLimit$2(r, e) || _unsupportedIterableToArray$h(r, e) || _nonIterableRest$2();
}
__name(_slicedToArray$2, "_slicedToArray$2");
function _nonIterableRest$2() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableRest$2, "_nonIterableRest$2");
function _unsupportedIterableToArray$h(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$h(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$h(r, a) : void 0;
  }
}
__name(_unsupportedIterableToArray$h, "_unsupportedIterableToArray$h");
function _arrayLikeToArray$h(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
__name(_arrayLikeToArray$h, "_arrayLikeToArray$h");
function _iterableToArrayLimit$2(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i2, u, a = [], f = true, o = false;
    try {
      if (i2 = (t = t.call(r)).next, 0 === l) ;
      else for (; !(f = (e = i2.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
__name(_iterableToArrayLimit$2, "_iterableToArrayLimit$2");
function _arrayWithHoles$2(r) {
  if (Array.isArray(r)) return r;
}
__name(_arrayWithHoles$2, "_arrayWithHoles$2");
function _defineProperty$g(e, r, t) {
  return (r = _toPropertyKey$f(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty$g, "_defineProperty$g");
function _toPropertyKey$f(t) {
  var i2 = _toPrimitive$f(t, "string");
  return "symbol" == _typeof$g(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$f, "_toPropertyKey$f");
function _toPrimitive$f(t, r) {
  if ("object" != _typeof$g(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$g(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive$f, "_toPrimitive$f");
function _typeof$g(o) {
  "@babel/helpers - typeof";
  return _typeof$g = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$g(o);
}
__name(_typeof$g, "_typeof$g");
var Tooltip = BaseTooltip.extend("tooltip", {
  beforeMount: /* @__PURE__ */ __name(function beforeMount(el, options3) {
    var _options$instance$$pr;
    var target = this.getTarget(el);
    target.$_ptooltipModifiers = this.getModifiers(options3);
    if (!options3.value) return;
    else if (typeof options3.value === "string") {
      target.$_ptooltipValue = options3.value;
      target.$_ptooltipDisabled = false;
      target.$_ptooltipEscape = true;
      target.$_ptooltipClass = null;
      target.$_ptooltipFitContent = true;
      target.$_ptooltipIdAttr = UniqueComponentId() + "_tooltip";
      target.$_ptooltipShowDelay = 0;
      target.$_ptooltipHideDelay = 0;
      target.$_ptooltipAutoHide = true;
    } else if (_typeof$g(options3.value) === "object" && options3.value) {
      if (isEmpty(options3.value.value) || options3.value.value.trim() === "") return;
      else {
        target.$_ptooltipValue = options3.value.value;
        target.$_ptooltipDisabled = !!options3.value.disabled === options3.value.disabled ? options3.value.disabled : false;
        target.$_ptooltipEscape = !!options3.value.escape === options3.value.escape ? options3.value.escape : true;
        target.$_ptooltipClass = options3.value["class"] || "";
        target.$_ptooltipFitContent = !!options3.value.fitContent === options3.value.fitContent ? options3.value.fitContent : true;
        target.$_ptooltipIdAttr = options3.value.id || UniqueComponentId() + "_tooltip";
        target.$_ptooltipShowDelay = options3.value.showDelay || 0;
        target.$_ptooltipHideDelay = options3.value.hideDelay || 0;
        target.$_ptooltipAutoHide = !!options3.value.autoHide === options3.value.autoHide ? options3.value.autoHide : true;
      }
    }
    target.$_ptooltipZIndex = (_options$instance$$pr = options3.instance.$primevue) === null || _options$instance$$pr === void 0 || (_options$instance$$pr = _options$instance$$pr.config) === null || _options$instance$$pr === void 0 || (_options$instance$$pr = _options$instance$$pr.zIndex) === null || _options$instance$$pr === void 0 ? void 0 : _options$instance$$pr.tooltip;
    this.bindEvents(target, options3);
    el.setAttribute("data-pd-tooltip", true);
  }, "beforeMount"),
  updated: /* @__PURE__ */ __name(function updated(el, options3) {
    var target = this.getTarget(el);
    target.$_ptooltipModifiers = this.getModifiers(options3);
    this.unbindEvents(target);
    if (!options3.value) {
      return;
    }
    if (typeof options3.value === "string") {
      target.$_ptooltipValue = options3.value;
      target.$_ptooltipDisabled = false;
      target.$_ptooltipEscape = true;
      target.$_ptooltipClass = null;
      target.$_ptooltipIdAttr = target.$_ptooltipIdAttr || UniqueComponentId() + "_tooltip";
      target.$_ptooltipShowDelay = 0;
      target.$_ptooltipHideDelay = 0;
      target.$_ptooltipAutoHide = true;
      this.bindEvents(target, options3);
    } else if (_typeof$g(options3.value) === "object" && options3.value) {
      if (isEmpty(options3.value.value) || options3.value.value.trim() === "") {
        this.unbindEvents(target, options3);
        return;
      } else {
        target.$_ptooltipValue = options3.value.value;
        target.$_ptooltipDisabled = !!options3.value.disabled === options3.value.disabled ? options3.value.disabled : false;
        target.$_ptooltipEscape = !!options3.value.escape === options3.value.escape ? options3.value.escape : true;
        target.$_ptooltipClass = options3.value["class"] || "";
        target.$_ptooltipFitContent = !!options3.value.fitContent === options3.value.fitContent ? options3.value.fitContent : true;
        target.$_ptooltipIdAttr = options3.value.id || target.$_ptooltipIdAttr || UniqueComponentId() + "_tooltip";
        target.$_ptooltipShowDelay = options3.value.showDelay || 0;
        target.$_ptooltipHideDelay = options3.value.hideDelay || 0;
        target.$_ptooltipAutoHide = !!options3.value.autoHide === options3.value.autoHide ? options3.value.autoHide : true;
        this.bindEvents(target, options3);
      }
    }
  }, "updated"),
  unmounted: /* @__PURE__ */ __name(function unmounted(el, options3) {
    var target = this.getTarget(el);
    this.remove(target);
    this.unbindEvents(target, options3);
    if (target.$_ptooltipScrollHandler) {
      target.$_ptooltipScrollHandler.destroy();
      target.$_ptooltipScrollHandler = null;
    }
  }, "unmounted"),
  timer: void 0,
  methods: {
    bindEvents: /* @__PURE__ */ __name(function bindEvents(el, options3) {
      var _this = this;
      var modifiers = el.$_ptooltipModifiers;
      if (modifiers.focus) {
        el.$_focusevent = function(event2) {
          return _this.onFocus(event2, options3);
        };
        el.addEventListener("focus", el.$_focusevent);
        el.addEventListener("blur", this.onBlur.bind(this));
      } else {
        el.$_mouseenterevent = function(event2) {
          return _this.onMouseEnter(event2, options3);
        };
        el.addEventListener("mouseenter", el.$_mouseenterevent);
        el.addEventListener("mouseleave", this.onMouseLeave.bind(this));
        el.addEventListener("click", this.onClick.bind(this));
      }
      el.addEventListener("keydown", this.onKeydown.bind(this));
    }, "bindEvents"),
    unbindEvents: /* @__PURE__ */ __name(function unbindEvents(el) {
      var modifiers = el.$_ptooltipModifiers;
      if (modifiers.focus) {
        el.removeEventListener("focus", el.$_focusevent);
        el.$_focusevent = null;
        el.removeEventListener("blur", this.onBlur.bind(this));
      } else {
        el.removeEventListener("mouseenter", el.$_mouseenterevent);
        el.$_mouseenterevent = null;
        el.removeEventListener("mouseleave", this.onMouseLeave.bind(this));
        el.removeEventListener("click", this.onClick.bind(this));
      }
      el.removeEventListener("keydown", this.onKeydown.bind(this));
    }, "unbindEvents"),
    bindScrollListener: /* @__PURE__ */ __name(function bindScrollListener(el) {
      var _this2 = this;
      if (!el.$_ptooltipScrollHandler) {
        el.$_ptooltipScrollHandler = new ConnectedOverlayScrollHandler(el, function() {
          _this2.hide(el);
        });
      }
      el.$_ptooltipScrollHandler.bindScrollListener();
    }, "bindScrollListener"),
    unbindScrollListener: /* @__PURE__ */ __name(function unbindScrollListener(el) {
      if (el.$_ptooltipScrollHandler) {
        el.$_ptooltipScrollHandler.unbindScrollListener();
      }
    }, "unbindScrollListener"),
    onMouseEnter: /* @__PURE__ */ __name(function onMouseEnter(event2, options3) {
      var el = event2.currentTarget;
      var showDelay = el.$_ptooltipShowDelay;
      this.show(el, options3, showDelay);
    }, "onMouseEnter"),
    onMouseLeave: /* @__PURE__ */ __name(function onMouseLeave(event2) {
      var el = event2.currentTarget;
      var hideDelay = el.$_ptooltipHideDelay;
      var autoHide = el.$_ptooltipAutoHide;
      if (!autoHide) {
        var valid = getAttribute(event2.target, "data-pc-name") === "tooltip" || getAttribute(event2.target, "data-pc-section") === "arrow" || getAttribute(event2.target, "data-pc-section") === "text" || getAttribute(event2.relatedTarget, "data-pc-name") === "tooltip" || getAttribute(event2.relatedTarget, "data-pc-section") === "arrow" || getAttribute(event2.relatedTarget, "data-pc-section") === "text";
        !valid && this.hide(el, hideDelay);
      } else {
        this.hide(el, hideDelay);
      }
    }, "onMouseLeave"),
    onFocus: /* @__PURE__ */ __name(function onFocus(event2, options3) {
      var el = event2.currentTarget;
      var showDelay = el.$_ptooltipShowDelay;
      this.show(el, options3, showDelay);
    }, "onFocus"),
    onBlur: /* @__PURE__ */ __name(function onBlur(event2) {
      var el = event2.currentTarget;
      var hideDelay = el.$_ptooltipHideDelay;
      this.hide(el, hideDelay);
    }, "onBlur"),
    onClick: /* @__PURE__ */ __name(function onClick(event2) {
      var el = event2.currentTarget;
      var hideDelay = el.$_ptooltipHideDelay;
      this.hide(el, hideDelay);
    }, "onClick"),
    onKeydown: /* @__PURE__ */ __name(function onKeydown(event2) {
      var el = event2.currentTarget;
      var hideDelay = el.$_ptooltipHideDelay;
      event2.code === "Escape" && this.hide(event2.currentTarget, hideDelay);
    }, "onKeydown"),
    tooltipActions: /* @__PURE__ */ __name(function tooltipActions(el, options3) {
      if (el.$_ptooltipDisabled || !isExist(el)) {
        return;
      }
      var tooltipElement = this.create(el, options3);
      this.align(el);
      !this.isUnstyled() && fadeIn(tooltipElement, 250);
      var $this = this;
      window.addEventListener("resize", /* @__PURE__ */ __name(function onWindowResize() {
        if (!isTouchDevice()) {
          $this.hide(el);
        }
        window.removeEventListener("resize", onWindowResize);
      }, "onWindowResize"));
      tooltipElement.addEventListener("mouseleave", /* @__PURE__ */ __name(function onTooltipLeave() {
        $this.hide(el);
        tooltipElement.removeEventListener("mouseleave", onTooltipLeave);
      }, "onTooltipLeave"));
      this.bindScrollListener(el);
      ZIndex.set("tooltip", tooltipElement, el.$_ptooltipZIndex);
    }, "tooltipActions"),
    show: /* @__PURE__ */ __name(function show(el, options3, showDelay) {
      var _this3 = this;
      if (showDelay !== void 0) {
        this.timer = setTimeout(function() {
          return _this3.tooltipActions(el, options3);
        }, showDelay);
      } else {
        this.tooltipActions(el, options3);
      }
    }, "show"),
    tooltipRemoval: /* @__PURE__ */ __name(function tooltipRemoval(el) {
      this.remove(el);
      this.unbindScrollListener(el);
    }, "tooltipRemoval"),
    hide: /* @__PURE__ */ __name(function hide(el, hideDelay) {
      var _this4 = this;
      clearTimeout(this.timer);
      if (hideDelay !== void 0) {
        setTimeout(function() {
          return _this4.tooltipRemoval(el);
        }, hideDelay);
      } else {
        this.tooltipRemoval(el);
      }
    }, "hide"),
    getTooltipElement: /* @__PURE__ */ __name(function getTooltipElement(el) {
      return document.getElementById(el.$_ptooltipId);
    }, "getTooltipElement"),
    create: /* @__PURE__ */ __name(function create(el) {
      var modifiers = el.$_ptooltipModifiers;
      var tooltipArrow = createElement("div", {
        "class": !this.isUnstyled() && this.cx("arrow"),
        "p-bind": this.ptm("arrow", {
          context: modifiers
        })
      });
      var tooltipText = createElement("div", {
        "class": !this.isUnstyled() && this.cx("text"),
        "p-bind": this.ptm("text", {
          context: modifiers
        })
      });
      if (!el.$_ptooltipEscape) {
        tooltipText.innerHTML = el.$_ptooltipValue;
      } else {
        tooltipText.innerHTML = "";
        tooltipText.appendChild(document.createTextNode(el.$_ptooltipValue));
      }
      var container = createElement("div", _defineProperty$g(_defineProperty$g({
        id: el.$_ptooltipIdAttr,
        role: "tooltip",
        style: {
          display: "inline-block",
          width: el.$_ptooltipFitContent ? "fit-content" : void 0,
          pointerEvents: !this.isUnstyled() && el.$_ptooltipAutoHide && "none"
        },
        "class": [!this.isUnstyled() && this.cx("root"), el.$_ptooltipClass]
      }, this.$attrSelector, ""), "p-bind", this.ptm("root", {
        context: modifiers
      })), tooltipArrow, tooltipText);
      document.body.appendChild(container);
      el.$_ptooltipId = container.id;
      this.$el = container;
      return container;
    }, "create"),
    remove: /* @__PURE__ */ __name(function remove2(el) {
      if (el) {
        var tooltipElement = this.getTooltipElement(el);
        if (tooltipElement && tooltipElement.parentElement) {
          ZIndex.clear(tooltipElement);
          document.body.removeChild(tooltipElement);
        }
        el.$_ptooltipId = null;
      }
    }, "remove"),
    align: /* @__PURE__ */ __name(function align(el) {
      var modifiers = el.$_ptooltipModifiers;
      if (modifiers.top) {
        this.alignTop(el);
        if (this.isOutOfBounds(el)) {
          this.alignBottom(el);
          if (this.isOutOfBounds(el)) {
            this.alignTop(el);
          }
        }
      } else if (modifiers.left) {
        this.alignLeft(el);
        if (this.isOutOfBounds(el)) {
          this.alignRight(el);
          if (this.isOutOfBounds(el)) {
            this.alignTop(el);
            if (this.isOutOfBounds(el)) {
              this.alignBottom(el);
              if (this.isOutOfBounds(el)) {
                this.alignLeft(el);
              }
            }
          }
        }
      } else if (modifiers.bottom) {
        this.alignBottom(el);
        if (this.isOutOfBounds(el)) {
          this.alignTop(el);
          if (this.isOutOfBounds(el)) {
            this.alignBottom(el);
          }
        }
      } else {
        this.alignRight(el);
        if (this.isOutOfBounds(el)) {
          this.alignLeft(el);
          if (this.isOutOfBounds(el)) {
            this.alignTop(el);
            if (this.isOutOfBounds(el)) {
              this.alignBottom(el);
              if (this.isOutOfBounds(el)) {
                this.alignRight(el);
              }
            }
          }
        }
      }
    }, "align"),
    getHostOffset: /* @__PURE__ */ __name(function getHostOffset(el) {
      var offset = el.getBoundingClientRect();
      var targetLeft = offset.left + getWindowScrollLeft();
      var targetTop = offset.top + getWindowScrollTop();
      return {
        left: targetLeft,
        top: targetTop
      };
    }, "getHostOffset"),
    alignRight: /* @__PURE__ */ __name(function alignRight(el) {
      this.preAlign(el, "right");
      var tooltipElement = this.getTooltipElement(el);
      var hostOffset = this.getHostOffset(el);
      var left = hostOffset.left + getOuterWidth(el);
      var top = hostOffset.top + (getOuterHeight(el) - getOuterHeight(tooltipElement)) / 2;
      tooltipElement.style.left = left + "px";
      tooltipElement.style.top = top + "px";
    }, "alignRight"),
    alignLeft: /* @__PURE__ */ __name(function alignLeft(el) {
      this.preAlign(el, "left");
      var tooltipElement = this.getTooltipElement(el);
      var hostOffset = this.getHostOffset(el);
      var left = hostOffset.left - getOuterWidth(tooltipElement);
      var top = hostOffset.top + (getOuterHeight(el) - getOuterHeight(tooltipElement)) / 2;
      tooltipElement.style.left = left + "px";
      tooltipElement.style.top = top + "px";
    }, "alignLeft"),
    alignTop: /* @__PURE__ */ __name(function alignTop(el) {
      this.preAlign(el, "top");
      var tooltipElement = this.getTooltipElement(el);
      var hostOffset = this.getHostOffset(el);
      var left = hostOffset.left + (getOuterWidth(el) - getOuterWidth(tooltipElement)) / 2;
      var top = hostOffset.top - getOuterHeight(tooltipElement);
      tooltipElement.style.left = left + "px";
      tooltipElement.style.top = top + "px";
    }, "alignTop"),
    alignBottom: /* @__PURE__ */ __name(function alignBottom(el) {
      this.preAlign(el, "bottom");
      var tooltipElement = this.getTooltipElement(el);
      var hostOffset = this.getHostOffset(el);
      var left = hostOffset.left + (getOuterWidth(el) - getOuterWidth(tooltipElement)) / 2;
      var top = hostOffset.top + getOuterHeight(el);
      tooltipElement.style.left = left + "px";
      tooltipElement.style.top = top + "px";
    }, "alignBottom"),
    preAlign: /* @__PURE__ */ __name(function preAlign(el, position2) {
      var tooltipElement = this.getTooltipElement(el);
      tooltipElement.style.left = "-999px";
      tooltipElement.style.top = "-999px";
      removeClass(tooltipElement, "p-tooltip-".concat(tooltipElement.$_ptooltipPosition));
      !this.isUnstyled() && addClass(tooltipElement, "p-tooltip-".concat(position2));
      tooltipElement.$_ptooltipPosition = position2;
      tooltipElement.setAttribute("data-p-position", position2);
      var arrowElement = findSingle(tooltipElement, '[data-pc-section="arrow"]');
      arrowElement.style.top = position2 === "bottom" ? "0" : position2 === "right" || position2 === "left" || position2 !== "right" && position2 !== "left" && position2 !== "top" && position2 !== "bottom" ? "50%" : null;
      arrowElement.style.bottom = position2 === "top" ? "0" : null;
      arrowElement.style.left = position2 === "right" || position2 !== "right" && position2 !== "left" && position2 !== "top" && position2 !== "bottom" ? "0" : position2 === "top" || position2 === "bottom" ? "50%" : null;
      arrowElement.style.right = position2 === "left" ? "0" : null;
    }, "preAlign"),
    isOutOfBounds: /* @__PURE__ */ __name(function isOutOfBounds(el) {
      var tooltipElement = this.getTooltipElement(el);
      var offset = tooltipElement.getBoundingClientRect();
      var targetTop = offset.top;
      var targetLeft = offset.left;
      var width2 = getOuterWidth(tooltipElement);
      var height = getOuterHeight(tooltipElement);
      var viewport = getViewport();
      return targetLeft + width2 > viewport.width || targetLeft < 0 || targetTop < 0 || targetTop + height > viewport.height;
    }, "isOutOfBounds"),
    getTarget: /* @__PURE__ */ __name(function getTarget2(el) {
      return hasClass(el, "p-inputwrapper") ? findSingle(el, "input") : el;
    }, "getTarget"),
    getModifiers: /* @__PURE__ */ __name(function getModifiers(options3) {
      if (options3.modifiers && Object.keys(options3.modifiers).length) {
        return options3.modifiers;
      }
      if (options3.arg && _typeof$g(options3.arg) === "object") {
        return Object.entries(options3.arg).reduce(function(acc, _ref) {
          var _ref2 = _slicedToArray$2(_ref, 2), key = _ref2[0], val = _ref2[1];
          if (key === "event" || key === "position") acc[val] = true;
          return acc;
        }, {});
      }
      return {};
    }, "getModifiers")
  }
});
var BaseComponentStyle = BaseStyle.extend({
  name: "common"
});
function _typeof$f(o) {
  "@babel/helpers - typeof";
  return _typeof$f = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$f(o);
}
__name(_typeof$f, "_typeof$f");
function _toArray(r) {
  return _arrayWithHoles$1(r) || _iterableToArray$e(r) || _unsupportedIterableToArray$g(r) || _nonIterableRest$1();
}
__name(_toArray, "_toArray");
function _iterableToArray$e(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
__name(_iterableToArray$e, "_iterableToArray$e");
function _slicedToArray$1(r, e) {
  return _arrayWithHoles$1(r) || _iterableToArrayLimit$1(r, e) || _unsupportedIterableToArray$g(r, e) || _nonIterableRest$1();
}
__name(_slicedToArray$1, "_slicedToArray$1");
function _nonIterableRest$1() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableRest$1, "_nonIterableRest$1");
function _unsupportedIterableToArray$g(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$g(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$g(r, a) : void 0;
  }
}
__name(_unsupportedIterableToArray$g, "_unsupportedIterableToArray$g");
function _arrayLikeToArray$g(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
__name(_arrayLikeToArray$g, "_arrayLikeToArray$g");
function _iterableToArrayLimit$1(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i2, u, a = [], f = true, o = false;
    try {
      if (i2 = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = false;
      } else for (; !(f = (e = i2.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
__name(_iterableToArrayLimit$1, "_iterableToArrayLimit$1");
function _arrayWithHoles$1(r) {
  if (Array.isArray(r)) return r;
}
__name(_arrayWithHoles$1, "_arrayWithHoles$1");
function ownKeys$e(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
__name(ownKeys$e, "ownKeys$e");
function _objectSpread$e(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$e(Object(t), true).forEach(function(r2) {
      _defineProperty$f(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$e(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
__name(_objectSpread$e, "_objectSpread$e");
function _defineProperty$f(e, r, t) {
  return (r = _toPropertyKey$e(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty$f, "_defineProperty$f");
function _toPropertyKey$e(t) {
  var i2 = _toPrimitive$e(t, "string");
  return "symbol" == _typeof$f(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$e, "_toPropertyKey$e");
function _toPrimitive$e(t, r) {
  if ("object" != _typeof$f(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$f(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive$e, "_toPrimitive$e");
var script$X = {
  name: "BaseComponent",
  props: {
    pt: {
      type: Object,
      "default": void 0
    },
    ptOptions: {
      type: Object,
      "default": void 0
    },
    unstyled: {
      type: Boolean,
      "default": void 0
    },
    dt: {
      type: Object,
      "default": void 0
    }
  },
  inject: {
    $parentInstance: {
      "default": void 0
    }
  },
  watch: {
    isUnstyled: {
      immediate: true,
      handler: /* @__PURE__ */ __name(function handler2(newValue) {
        if (!newValue) {
          this._loadCoreStyles();
          this._themeChangeListener(this._loadCoreStyles);
        }
      }, "handler")
    },
    dt: {
      immediate: true,
      handler: /* @__PURE__ */ __name(function handler3(newValue) {
        var _this = this;
        if (newValue) {
          this._loadScopedThemeStyles(newValue);
          this._themeChangeListener(function() {
            return _this._loadScopedThemeStyles(newValue);
          });
        } else {
          this._unloadScopedThemeStyles();
        }
      }, "handler")
    }
  },
  scopedStyleEl: void 0,
  rootEl: void 0,
  beforeCreate: /* @__PURE__ */ __name(function beforeCreate() {
    var _this$pt, _this$pt2, _this$pt3, _ref, _ref$onBeforeCreate, _this$$primevueConfig, _this$$primevue, _this$$primevue2, _this$$primevue3, _ref2, _ref2$onBeforeCreate;
    var _usept = (_this$pt = this.pt) === null || _this$pt === void 0 ? void 0 : _this$pt["_usept"];
    var originalValue = _usept ? (_this$pt2 = this.pt) === null || _this$pt2 === void 0 || (_this$pt2 = _this$pt2.originalValue) === null || _this$pt2 === void 0 ? void 0 : _this$pt2[this.$.type.name] : void 0;
    var value3 = _usept ? (_this$pt3 = this.pt) === null || _this$pt3 === void 0 || (_this$pt3 = _this$pt3.value) === null || _this$pt3 === void 0 ? void 0 : _this$pt3[this.$.type.name] : this.pt;
    (_ref = value3 || originalValue) === null || _ref === void 0 || (_ref = _ref.hooks) === null || _ref === void 0 || (_ref$onBeforeCreate = _ref["onBeforeCreate"]) === null || _ref$onBeforeCreate === void 0 || _ref$onBeforeCreate.call(_ref);
    var _useptInConfig = (_this$$primevueConfig = this.$primevueConfig) === null || _this$$primevueConfig === void 0 || (_this$$primevueConfig = _this$$primevueConfig.pt) === null || _this$$primevueConfig === void 0 ? void 0 : _this$$primevueConfig["_usept"];
    var originalValueInConfig = _useptInConfig ? (_this$$primevue = this.$primevue) === null || _this$$primevue === void 0 || (_this$$primevue = _this$$primevue.config) === null || _this$$primevue === void 0 || (_this$$primevue = _this$$primevue.pt) === null || _this$$primevue === void 0 ? void 0 : _this$$primevue.originalValue : void 0;
    var valueInConfig = _useptInConfig ? (_this$$primevue2 = this.$primevue) === null || _this$$primevue2 === void 0 || (_this$$primevue2 = _this$$primevue2.config) === null || _this$$primevue2 === void 0 || (_this$$primevue2 = _this$$primevue2.pt) === null || _this$$primevue2 === void 0 ? void 0 : _this$$primevue2.value : (_this$$primevue3 = this.$primevue) === null || _this$$primevue3 === void 0 || (_this$$primevue3 = _this$$primevue3.config) === null || _this$$primevue3 === void 0 ? void 0 : _this$$primevue3.pt;
    (_ref2 = valueInConfig || originalValueInConfig) === null || _ref2 === void 0 || (_ref2 = _ref2[this.$.type.name]) === null || _ref2 === void 0 || (_ref2 = _ref2.hooks) === null || _ref2 === void 0 || (_ref2$onBeforeCreate = _ref2["onBeforeCreate"]) === null || _ref2$onBeforeCreate === void 0 || _ref2$onBeforeCreate.call(_ref2);
  }, "beforeCreate"),
  created: /* @__PURE__ */ __name(function created() {
    this._hook("onCreated");
  }, "created"),
  beforeMount: /* @__PURE__ */ __name(function beforeMount2() {
    this._loadStyles();
    this._hook("onBeforeMount");
  }, "beforeMount"),
  mounted: /* @__PURE__ */ __name(function mounted() {
    this.rootEl = findSingle(this.$el, '[data-pc-name="'.concat(toFlatCase(this.$.type.name), '"]'));
    if (this.rootEl) {
      this.rootEl.setAttribute(this.$attrSelector, "");
      this.rootEl.$pc = _objectSpread$e({
        name: this.$.type.name
      }, this.$params);
    }
    this._hook("onMounted");
  }, "mounted"),
  beforeUpdate: /* @__PURE__ */ __name(function beforeUpdate() {
    this._hook("onBeforeUpdate");
  }, "beforeUpdate"),
  updated: /* @__PURE__ */ __name(function updated2() {
    this._hook("onUpdated");
  }, "updated"),
  beforeUnmount: /* @__PURE__ */ __name(function beforeUnmount() {
    this._hook("onBeforeUnmount");
  }, "beforeUnmount"),
  unmounted: /* @__PURE__ */ __name(function unmounted2() {
    this._unloadScopedThemeStyles();
    this._hook("onUnmounted");
  }, "unmounted"),
  methods: {
    _hook: /* @__PURE__ */ __name(function _hook2(hookName) {
      if (!this.$options.hostName) {
        var selfHook = this._usePT(this._getPT(this.pt, this.$.type.name), this._getOptionValue, "hooks.".concat(hookName));
        var defaultHook = this._useDefaultPT(this._getOptionValue, "hooks.".concat(hookName));
        selfHook === null || selfHook === void 0 || selfHook();
        defaultHook === null || defaultHook === void 0 || defaultHook();
      }
    }, "_hook"),
    _mergeProps: /* @__PURE__ */ __name(function _mergeProps2(fn) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key2 = 1; _key2 < _len; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      return isFunction(fn) ? fn.apply(void 0, args) : mergeProps.apply(void 0, args);
    }, "_mergeProps"),
    _loadStyles: /* @__PURE__ */ __name(function _loadStyles2() {
      var _this2 = this;
      var _load = /* @__PURE__ */ __name(function _load2() {
        if (!Base.isStyleNameLoaded("base")) {
          BaseStyle.loadCSS(_this2.$styleOptions);
          _this2._loadGlobalStyles();
          Base.setLoadedStyleName("base");
        }
        _this2._loadThemeStyles();
      }, "_load");
      _load();
      this._themeChangeListener(_load);
    }, "_loadStyles"),
    _loadCoreStyles: /* @__PURE__ */ __name(function _loadCoreStyles2() {
      var _this$$style, _this$$style2;
      if (!Base.isStyleNameLoaded((_this$$style = this.$style) === null || _this$$style === void 0 ? void 0 : _this$$style.name) && (_this$$style2 = this.$style) !== null && _this$$style2 !== void 0 && _this$$style2.name) {
        BaseComponentStyle.loadCSS(this.$styleOptions);
        this.$options.style && this.$style.loadCSS(this.$styleOptions);
        Base.setLoadedStyleName(this.$style.name);
      }
    }, "_loadCoreStyles"),
    _loadGlobalStyles: /* @__PURE__ */ __name(function _loadGlobalStyles() {
      var globalCSS = this._useGlobalPT(this._getOptionValue, "global.css", this.$params);
      isNotEmpty(globalCSS) && BaseStyle.load(globalCSS, _objectSpread$e({
        name: "global"
      }, this.$styleOptions));
    }, "_loadGlobalStyles"),
    _loadThemeStyles: /* @__PURE__ */ __name(function _loadThemeStyles2() {
      var _this$$style4, _this$$style5;
      if (this.isUnstyled) return;
      if (!config_default.isStyleNameLoaded("common")) {
        var _this$$style3, _this$$style3$getComm;
        var _ref3 = ((_this$$style3 = this.$style) === null || _this$$style3 === void 0 || (_this$$style3$getComm = _this$$style3.getCommonTheme) === null || _this$$style3$getComm === void 0 ? void 0 : _this$$style3$getComm.call(_this$$style3)) || {}, primitive = _ref3.primitive, semantic = _ref3.semantic;
        BaseStyle.load(primitive === null || primitive === void 0 ? void 0 : primitive.css, _objectSpread$e({
          name: "primitive-variables"
        }, this.$styleOptions));
        BaseStyle.load(semantic === null || semantic === void 0 ? void 0 : semantic.css, _objectSpread$e({
          name: "semantic-variables"
        }, this.$styleOptions));
        BaseStyle.loadTheme(_objectSpread$e({
          name: "global-style"
        }, this.$styleOptions));
        config_default.setLoadedStyleName("common");
      }
      if (!config_default.isStyleNameLoaded((_this$$style4 = this.$style) === null || _this$$style4 === void 0 ? void 0 : _this$$style4.name) && (_this$$style5 = this.$style) !== null && _this$$style5 !== void 0 && _this$$style5.name) {
        var _this$$style6, _this$$style6$getComp, _this$$style7, _this$$style8;
        var _ref4 = ((_this$$style6 = this.$style) === null || _this$$style6 === void 0 || (_this$$style6$getComp = _this$$style6.getComponentTheme) === null || _this$$style6$getComp === void 0 ? void 0 : _this$$style6$getComp.call(_this$$style6)) || {}, css4 = _ref4.css;
        (_this$$style7 = this.$style) === null || _this$$style7 === void 0 || _this$$style7.load(css4, _objectSpread$e({
          name: "".concat(this.$style.name, "-variables")
        }, this.$styleOptions));
        (_this$$style8 = this.$style) === null || _this$$style8 === void 0 || _this$$style8.loadTheme(_objectSpread$e({
          name: "".concat(this.$style.name, "-style")
        }, this.$styleOptions));
        config_default.setLoadedStyleName(this.$style.name);
      }
      if (!config_default.isStyleNameLoaded("layer-order")) {
        var _this$$style9, _this$$style9$getLaye;
        var layerOrder = (_this$$style9 = this.$style) === null || _this$$style9 === void 0 || (_this$$style9$getLaye = _this$$style9.getLayerOrderThemeCSS) === null || _this$$style9$getLaye === void 0 ? void 0 : _this$$style9$getLaye.call(_this$$style9);
        BaseStyle.load(layerOrder, _objectSpread$e({
          name: "layer-order",
          first: true
        }, this.$styleOptions));
        config_default.setLoadedStyleName("layer-order");
      }
    }, "_loadThemeStyles"),
    _loadScopedThemeStyles: /* @__PURE__ */ __name(function _loadScopedThemeStyles2(preset) {
      var _this$$style10, _this$$style10$getPre, _this$$style11;
      var _ref5 = ((_this$$style10 = this.$style) === null || _this$$style10 === void 0 || (_this$$style10$getPre = _this$$style10.getPresetTheme) === null || _this$$style10$getPre === void 0 ? void 0 : _this$$style10$getPre.call(_this$$style10, preset, "[".concat(this.$attrSelector, "]"))) || {}, css4 = _ref5.css;
      var scopedStyle = (_this$$style11 = this.$style) === null || _this$$style11 === void 0 ? void 0 : _this$$style11.load(css4, _objectSpread$e({
        name: "".concat(this.$attrSelector, "-").concat(this.$style.name)
      }, this.$styleOptions));
      this.scopedStyleEl = scopedStyle.el;
    }, "_loadScopedThemeStyles"),
    _unloadScopedThemeStyles: /* @__PURE__ */ __name(function _unloadScopedThemeStyles() {
      var _this$scopedStyleEl;
      (_this$scopedStyleEl = this.scopedStyleEl) === null || _this$scopedStyleEl === void 0 || (_this$scopedStyleEl = _this$scopedStyleEl.value) === null || _this$scopedStyleEl === void 0 || _this$scopedStyleEl.remove();
    }, "_unloadScopedThemeStyles"),
    _themeChangeListener: /* @__PURE__ */ __name(function _themeChangeListener2() {
      var callback = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function() {
      };
      Base.clearLoadedStyleNames();
      service_default.on("theme:change", callback);
    }, "_themeChangeListener"),
    _getHostInstance: /* @__PURE__ */ __name(function _getHostInstance(instance) {
      return instance ? this.$options.hostName ? instance.$.type.name === this.$options.hostName ? instance : this._getHostInstance(instance.$parentInstance) : instance.$parentInstance : void 0;
    }, "_getHostInstance"),
    _getPropValue: /* @__PURE__ */ __name(function _getPropValue(name) {
      var _this$_getHostInstanc;
      return this[name] || ((_this$_getHostInstanc = this._getHostInstance(this)) === null || _this$_getHostInstanc === void 0 ? void 0 : _this$_getHostInstanc[name]);
    }, "_getPropValue"),
    _getOptionValue: /* @__PURE__ */ __name(function _getOptionValue(options3) {
      var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return getKeyValue(options3, key, params);
    }, "_getOptionValue"),
    _getPTValue: /* @__PURE__ */ __name(function _getPTValue2() {
      var _this$$primevueConfig2;
      var obj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var searchInDefaultPT = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
      var searchOut = /./g.test(key) && !!params[key.split(".")[0]];
      var _ref6 = this._getPropValue("ptOptions") || ((_this$$primevueConfig2 = this.$primevueConfig) === null || _this$$primevueConfig2 === void 0 ? void 0 : _this$$primevueConfig2.ptOptions) || {}, _ref6$mergeSections = _ref6.mergeSections, mergeSections = _ref6$mergeSections === void 0 ? true : _ref6$mergeSections, _ref6$mergeProps = _ref6.mergeProps, useMergeProps = _ref6$mergeProps === void 0 ? false : _ref6$mergeProps;
      var global2 = searchInDefaultPT ? searchOut ? this._useGlobalPT(this._getPTClassValue, key, params) : this._useDefaultPT(this._getPTClassValue, key, params) : void 0;
      var self2 = searchOut ? void 0 : this._getPTSelf(obj, this._getPTClassValue, key, _objectSpread$e(_objectSpread$e({}, params), {}, {
        global: global2 || {}
      }));
      var datasets = this._getPTDatasets(key);
      return mergeSections || !mergeSections && self2 ? useMergeProps ? this._mergeProps(useMergeProps, global2, self2, datasets) : _objectSpread$e(_objectSpread$e(_objectSpread$e({}, global2), self2), datasets) : _objectSpread$e(_objectSpread$e({}, self2), datasets);
    }, "_getPTValue"),
    _getPTSelf: /* @__PURE__ */ __name(function _getPTSelf() {
      var obj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key3 = 1; _key3 < _len2; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }
      return mergeProps(
        this._usePT.apply(this, [this._getPT(obj, this.$name)].concat(args)),
        // Exp; <component :pt="{}"
        this._usePT.apply(this, [this.$_attrsPT].concat(args))
        // Exp; <component :pt:[passthrough_key]:[attribute]="{value}" or <component :pt:[passthrough_key]="() =>{value}"
      );
    }, "_getPTSelf"),
    _getPTDatasets: /* @__PURE__ */ __name(function _getPTDatasets2() {
      var _this$pt4, _this$pt5;
      var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      var datasetPrefix = "data-pc-";
      var isExtended = key === "root" && isNotEmpty((_this$pt4 = this.pt) === null || _this$pt4 === void 0 ? void 0 : _this$pt4["data-pc-section"]);
      return key !== "transition" && _objectSpread$e(_objectSpread$e({}, key === "root" && _objectSpread$e(_defineProperty$f({}, "".concat(datasetPrefix, "name"), toFlatCase(isExtended ? (_this$pt5 = this.pt) === null || _this$pt5 === void 0 ? void 0 : _this$pt5["data-pc-section"] : this.$.type.name)), isExtended && _defineProperty$f({}, "".concat(datasetPrefix, "extend"), toFlatCase(this.$.type.name)))), {}, _defineProperty$f({}, "".concat(datasetPrefix, "section"), toFlatCase(key)));
    }, "_getPTDatasets"),
    _getPTClassValue: /* @__PURE__ */ __name(function _getPTClassValue() {
      var value3 = this._getOptionValue.apply(this, arguments);
      return isString$4(value3) || isArray$3(value3) ? {
        "class": value3
      } : value3;
    }, "_getPTClassValue"),
    _getPT: /* @__PURE__ */ __name(function _getPT2(pt) {
      var _this3 = this;
      var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var callback = arguments.length > 2 ? arguments[2] : void 0;
      var getValue2 = /* @__PURE__ */ __name(function getValue3(value3) {
        var _ref8;
        var checkSameKey = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var computedValue = callback ? callback(value3) : value3;
        var _key = toFlatCase(key);
        var _cKey = toFlatCase(_this3.$name);
        return (_ref8 = checkSameKey ? _key !== _cKey ? computedValue === null || computedValue === void 0 ? void 0 : computedValue[_key] : void 0 : computedValue === null || computedValue === void 0 ? void 0 : computedValue[_key]) !== null && _ref8 !== void 0 ? _ref8 : computedValue;
      }, "getValue");
      return pt !== null && pt !== void 0 && pt.hasOwnProperty("_usept") ? {
        _usept: pt["_usept"],
        originalValue: getValue2(pt.originalValue),
        value: getValue2(pt.value)
      } : getValue2(pt, true);
    }, "_getPT"),
    _usePT: /* @__PURE__ */ __name(function _usePT2(pt, callback, key, params) {
      var fn = /* @__PURE__ */ __name(function fn2(value4) {
        return callback(value4, key, params);
      }, "fn");
      if (pt !== null && pt !== void 0 && pt.hasOwnProperty("_usept")) {
        var _this$$primevueConfig3;
        var _ref9 = pt["_usept"] || ((_this$$primevueConfig3 = this.$primevueConfig) === null || _this$$primevueConfig3 === void 0 ? void 0 : _this$$primevueConfig3.ptOptions) || {}, _ref9$mergeSections = _ref9.mergeSections, mergeSections = _ref9$mergeSections === void 0 ? true : _ref9$mergeSections, _ref9$mergeProps = _ref9.mergeProps, useMergeProps = _ref9$mergeProps === void 0 ? false : _ref9$mergeProps;
        var originalValue = fn(pt.originalValue);
        var value3 = fn(pt.value);
        if (originalValue === void 0 && value3 === void 0) return void 0;
        else if (isString$4(value3)) return value3;
        else if (isString$4(originalValue)) return originalValue;
        return mergeSections || !mergeSections && value3 ? useMergeProps ? this._mergeProps(useMergeProps, originalValue, value3) : _objectSpread$e(_objectSpread$e({}, originalValue), value3) : value3;
      }
      return fn(pt);
    }, "_usePT"),
    _useGlobalPT: /* @__PURE__ */ __name(function _useGlobalPT(callback, key, params) {
      return this._usePT(this.globalPT, callback, key, params);
    }, "_useGlobalPT"),
    _useDefaultPT: /* @__PURE__ */ __name(function _useDefaultPT2(callback, key, params) {
      return this._usePT(this.defaultPT, callback, key, params);
    }, "_useDefaultPT"),
    ptm: /* @__PURE__ */ __name(function ptm() {
      var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return this._getPTValue(this.pt, key, _objectSpread$e(_objectSpread$e({}, this.$params), params));
    }, "ptm"),
    ptmi: /* @__PURE__ */ __name(function ptmi() {
      var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return mergeProps(this.$_attrsWithoutPT, this.ptm(key, params));
    }, "ptmi"),
    ptmo: /* @__PURE__ */ __name(function ptmo() {
      var obj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return this._getPTValue(obj, key, _objectSpread$e({
        instance: this
      }, params), false);
    }, "ptmo"),
    cx: /* @__PURE__ */ __name(function cx() {
      var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return !this.isUnstyled ? this._getOptionValue(this.$style.classes, key, _objectSpread$e(_objectSpread$e({}, this.$params), params)) : void 0;
    }, "cx"),
    sx: /* @__PURE__ */ __name(function sx() {
      var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      var when = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      if (when) {
        var self2 = this._getOptionValue(this.$style.inlineStyles, key, _objectSpread$e(_objectSpread$e({}, this.$params), params));
        var base = this._getOptionValue(BaseComponentStyle.inlineStyles, key, _objectSpread$e(_objectSpread$e({}, this.$params), params));
        return [base, self2];
      }
      return void 0;
    }, "sx")
  },
  computed: {
    globalPT: /* @__PURE__ */ __name(function globalPT() {
      var _this$$primevueConfig4, _this4 = this;
      return this._getPT((_this$$primevueConfig4 = this.$primevueConfig) === null || _this$$primevueConfig4 === void 0 ? void 0 : _this$$primevueConfig4.pt, void 0, function(value3) {
        return resolve(value3, {
          instance: _this4
        });
      });
    }, "globalPT"),
    defaultPT: /* @__PURE__ */ __name(function defaultPT() {
      var _this$$primevueConfig5, _this5 = this;
      return this._getPT((_this$$primevueConfig5 = this.$primevueConfig) === null || _this$$primevueConfig5 === void 0 ? void 0 : _this$$primevueConfig5.pt, void 0, function(value3) {
        return _this5._getOptionValue(value3, _this5.$name, _objectSpread$e({}, _this5.$params)) || resolve(value3, _objectSpread$e({}, _this5.$params));
      });
    }, "defaultPT"),
    isUnstyled: /* @__PURE__ */ __name(function isUnstyled() {
      var _this$$primevueConfig6;
      return this.unstyled !== void 0 ? this.unstyled : (_this$$primevueConfig6 = this.$primevueConfig) === null || _this$$primevueConfig6 === void 0 ? void 0 : _this$$primevueConfig6.unstyled;
    }, "isUnstyled"),
    $theme: /* @__PURE__ */ __name(function $theme() {
      var _this$$primevueConfig7;
      return (_this$$primevueConfig7 = this.$primevueConfig) === null || _this$$primevueConfig7 === void 0 ? void 0 : _this$$primevueConfig7.theme;
    }, "$theme"),
    $style: /* @__PURE__ */ __name(function $style() {
      return _objectSpread$e(_objectSpread$e({
        classes: void 0,
        inlineStyles: void 0,
        load: /* @__PURE__ */ __name(function load2() {
        }, "load"),
        loadCSS: /* @__PURE__ */ __name(function loadCSS2() {
        }, "loadCSS"),
        loadTheme: /* @__PURE__ */ __name(function loadTheme2() {
        }, "loadTheme")
      }, (this._getHostInstance(this) || {}).$style), this.$options.style);
    }, "$style"),
    $styleOptions: /* @__PURE__ */ __name(function $styleOptions() {
      var _this$$primevueConfig8;
      return {
        nonce: (_this$$primevueConfig8 = this.$primevueConfig) === null || _this$$primevueConfig8 === void 0 || (_this$$primevueConfig8 = _this$$primevueConfig8.csp) === null || _this$$primevueConfig8 === void 0 ? void 0 : _this$$primevueConfig8.nonce
      };
    }, "$styleOptions"),
    $primevueConfig: /* @__PURE__ */ __name(function $primevueConfig() {
      var _this$$primevue4;
      return (_this$$primevue4 = this.$primevue) === null || _this$$primevue4 === void 0 ? void 0 : _this$$primevue4.config;
    }, "$primevueConfig"),
    $name: /* @__PURE__ */ __name(function $name() {
      return this.$options.hostName || this.$.type.name;
    }, "$name"),
    $params: /* @__PURE__ */ __name(function $params() {
      var parentInstance = this._getHostInstance(this) || this.$parent;
      return {
        instance: this,
        props: this.$props,
        state: this.$data,
        attrs: this.$attrs,
        parent: {
          instance: parentInstance,
          props: parentInstance === null || parentInstance === void 0 ? void 0 : parentInstance.$props,
          state: parentInstance === null || parentInstance === void 0 ? void 0 : parentInstance.$data,
          attrs: parentInstance === null || parentInstance === void 0 ? void 0 : parentInstance.$attrs
        }
      };
    }, "$params"),
    $_attrsPT: /* @__PURE__ */ __name(function $_attrsPT() {
      return Object.entries(this.$attrs || {}).filter(function(_ref10) {
        var _ref11 = _slicedToArray$1(_ref10, 1), key = _ref11[0];
        return key === null || key === void 0 ? void 0 : key.startsWith("pt:");
      }).reduce(function(result, _ref12) {
        var _ref13 = _slicedToArray$1(_ref12, 2), key = _ref13[0], value3 = _ref13[1];
        var _key$split = key.split(":"), _key$split2 = _toArray(_key$split), rest = _key$split2.slice(1);
        rest === null || rest === void 0 || rest.reduce(function(currentObj, nestedKey, index2, array) {
          !currentObj[nestedKey] && (currentObj[nestedKey] = index2 === array.length - 1 ? value3 : {});
          return currentObj[nestedKey];
        }, result);
        return result;
      }, {});
    }, "$_attrsPT"),
    $_attrsWithoutPT: /* @__PURE__ */ __name(function $_attrsWithoutPT() {
      return Object.entries(this.$attrs || {}).filter(function(_ref14) {
        var _ref15 = _slicedToArray$1(_ref14, 1), key = _ref15[0];
        return !(key !== null && key !== void 0 && key.startsWith("pt:"));
      }).reduce(function(acc, _ref16) {
        var _ref17 = _slicedToArray$1(_ref16, 2), key = _ref17[0], value3 = _ref17[1];
        acc[key] = value3;
        return acc;
      }, {});
    }, "$_attrsWithoutPT"),
    $attrSelector: /* @__PURE__ */ __name(function $attrSelector() {
      return UniqueComponentId("pc");
    }, "$attrSelector")
  }
};
var theme$x = /* @__PURE__ */ __name(function theme4(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-blockui {\n    position: relative;\n}\n\n.p-blockui-mask {\n    border-radius: ".concat(dt3("blockui.border.radius"), ";\n}\n\n.p-blockui-mask.p-overlay-mask {\n    position: absolute;\n}\n\n.p-blockui-mask-document.p-overlay-mask {\n    position: fixed;\n}\n");
}, "theme");
var classes$A = {
  root: "p-blockui"
};
var BlockUIStyle = BaseStyle.extend({
  name: "blockui",
  theme: theme$x,
  classes: classes$A
});
var script$1$A = {
  name: "BaseBlockUI",
  "extends": script$X,
  props: {
    blocked: {
      type: Boolean,
      "default": false
    },
    fullScreen: {
      type: Boolean,
      "default": false
    },
    baseZIndex: {
      type: Number,
      "default": 0
    },
    autoZIndex: {
      type: Boolean,
      "default": true
    }
  },
  style: BlockUIStyle,
  provide: /* @__PURE__ */ __name(function provide2() {
    return {
      $pcBlockUI: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$W = {
  name: "BlockUI",
  "extends": script$1$A,
  inheritAttrs: false,
  emits: ["block", "unblock"],
  mask: null,
  data: /* @__PURE__ */ __name(function data() {
    return {
      isBlocked: false
    };
  }, "data"),
  watch: {
    blocked: /* @__PURE__ */ __name(function blocked(newValue) {
      if (newValue === true) this.block();
      else this.unblock();
    }, "blocked")
  },
  mounted: /* @__PURE__ */ __name(function mounted2() {
    if (this.blocked) {
      this.block();
    }
  }, "mounted"),
  methods: {
    block: /* @__PURE__ */ __name(function block() {
      var styleClass = "p-blockui-mask p-overlay-mask p-overlay-mask-enter";
      if (this.fullScreen) {
        styleClass += " p-blockui-mask-document";
        this.mask = createElement("div", {
          style: {
            position: "fixed",
            top: "0",
            left: "0",
            width: "100%",
            height: "100%"
          },
          "class": !this.isUnstyled && styleClass,
          "p-bind": this.ptm("mask")
        });
        document.body.appendChild(this.mask);
        blockBodyScroll();
        document.activeElement.blur();
      } else {
        this.mask = createElement("div", {
          style: {
            position: "absolute",
            top: "0",
            left: "0",
            width: "100%",
            height: "100%"
          },
          "class": !this.isUnstyled && styleClass,
          "p-bind": this.ptm("mask")
        });
        this.$refs.container.appendChild(this.mask);
      }
      if (this.autoZIndex) {
        ZIndex.set("modal", this.mask, this.baseZIndex + this.$primevue.config.zIndex.modal);
      }
      this.isBlocked = true;
      this.$emit("block");
    }, "block"),
    unblock: /* @__PURE__ */ __name(function unblock() {
      var _this = this;
      !this.isUnstyled && addClass(this.mask, "p-overlay-mask-leave");
      if (hasCSSAnimation(this.mask) > 0) {
        this.mask.addEventListener("animationend", function() {
          _this.removeMask();
        });
      } else {
        this.removeMask();
      }
    }, "unblock"),
    removeMask: /* @__PURE__ */ __name(function removeMask() {
      ZIndex.clear(this.mask);
      if (this.fullScreen) {
        document.body.removeChild(this.mask);
        unblockBodyScroll();
      } else {
        var _this$$refs$container;
        (_this$$refs$container = this.$refs.container) === null || _this$$refs$container === void 0 || _this$$refs$container.removeChild(this.mask);
      }
      this.isBlocked = false;
      this.$emit("unblock");
    }, "removeMask")
  }
};
var _hoisted_1$13 = ["aria-busy"];
function render$U(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    ref: "container",
    "class": _ctx.cx("root"),
    "aria-busy": $data.isBlocked
  }, _ctx.ptmi("root")), [renderSlot(_ctx.$slots, "default")], 16, _hoisted_1$13);
}
__name(render$U, "render$U");
script$W.render = render$U;
var theme$w = /* @__PURE__ */ __name(function theme5(_ref) {
  var dt3 = _ref.dt;
  return '\n.p-progressspinner {\n    position: relative;\n    margin: 0 auto;\n    width: 100px;\n    height: 100px;\n    display: inline-block;\n}\n\n.p-progressspinner::before {\n    content: "";\n    display: block;\n    padding-top: 100%;\n}\n\n.p-progressspinner-spin {\n    height: 100%;\n    transform-origin: center center;\n    width: 100%;\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    margin: auto;\n    animation: p-progressspinner-rotate 2s linear infinite;\n}\n\n.p-progressspinner-circle {\n    stroke-dasharray: 89, 200;\n    stroke-dashoffset: 0;\n    stroke: '.concat(dt3("progressspinner.color.1"), ";\n    animation: p-progressspinner-dash 1.5s ease-in-out infinite, p-progressspinner-color 6s ease-in-out infinite;\n    stroke-linecap: round;\n}\n\n@keyframes p-progressspinner-rotate {\n    100% {\n        transform: rotate(360deg);\n    }\n}\n@keyframes p-progressspinner-dash {\n    0% {\n        stroke-dasharray: 1, 200;\n        stroke-dashoffset: 0;\n    }\n    50% {\n        stroke-dasharray: 89, 200;\n        stroke-dashoffset: -35px;\n    }\n    100% {\n        stroke-dasharray: 89, 200;\n        stroke-dashoffset: -124px;\n    }\n}\n@keyframes p-progressspinner-color {\n    100%,\n    0% {\n        stroke: ").concat(dt3("progressspinner.color.1"), ";\n    }\n    40% {\n        stroke: ").concat(dt3("progressspinner.color.2"), ";\n    }\n    66% {\n        stroke: ").concat(dt3("progressspinner.color.3"), ";\n    }\n    80%,\n    90% {\n        stroke: ").concat(dt3("progressspinner.color.4"), ";\n    }\n}\n");
}, "theme");
var classes$z = {
  root: "p-progressspinner",
  spin: "p-progressspinner-spin",
  circle: "p-progressspinner-circle"
};
var ProgressSpinnerStyle = BaseStyle.extend({
  name: "progressspinner",
  theme: theme$w,
  classes: classes$z
});
var script$1$z = {
  name: "BaseProgressSpinner",
  "extends": script$X,
  props: {
    strokeWidth: {
      type: String,
      "default": "2"
    },
    fill: {
      type: String,
      "default": "none"
    },
    animationDuration: {
      type: String,
      "default": "2s"
    }
  },
  style: ProgressSpinnerStyle,
  provide: /* @__PURE__ */ __name(function provide3() {
    return {
      $pcProgressSpinner: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$V = {
  name: "ProgressSpinner",
  "extends": script$1$z,
  inheritAttrs: false,
  computed: {
    svgStyle: /* @__PURE__ */ __name(function svgStyle() {
      return {
        "animation-duration": this.animationDuration
      };
    }, "svgStyle")
  }
};
var _hoisted_1$12 = ["fill", "stroke-width"];
function render$T(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("root"),
    role: "progressbar"
  }, _ctx.ptmi("root")), [(openBlock(), createElementBlock("svg", mergeProps({
    "class": _ctx.cx("spin"),
    viewBox: "25 25 50 50",
    style: $options.svgStyle
  }, _ctx.ptm("spin")), [createBaseVNode("circle", mergeProps({
    "class": _ctx.cx("circle"),
    cx: "50",
    cy: "50",
    r: "20",
    fill: _ctx.fill,
    "stroke-width": _ctx.strokeWidth,
    strokeMiterlimit: "10"
  }, _ctx.ptm("circle")), null, 16, _hoisted_1$12)], 16))], 16);
}
__name(render$T, "render$T");
script$V.render = render$T;
const scriptRel = "modulepreload";
const assetsURL = /* @__PURE__ */ __name(function(dep, importerUrl) {
  return new URL(dep, importerUrl).href;
}, "assetsURL");
const seen = {};
const __vitePreload = /* @__PURE__ */ __name(function preload(baseModule, deps, importerUrl) {
  let promise = Promise.resolve();
  if (deps && deps.length > 0) {
    const links = document.getElementsByTagName("link");
    const cspNonceMeta = document.querySelector(
      "meta[property=csp-nonce]"
    );
    const cspNonce = cspNonceMeta?.nonce || cspNonceMeta?.getAttribute("nonce");
    promise = Promise.all(
      deps.map((dep) => {
        dep = assetsURL(dep, importerUrl);
        if (dep in seen) return;
        seen[dep] = true;
        const isCss = dep.endsWith(".css");
        const cssSelector = isCss ? '[rel="stylesheet"]' : "";
        const isBaseRelative = !!importerUrl;
        if (isBaseRelative) {
          for (let i2 = links.length - 1; i2 >= 0; i2--) {
            const link2 = links[i2];
            if (link2.href === dep && (!isCss || link2.rel === "stylesheet")) {
              return;
            }
          }
        } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
          return;
        }
        const link = document.createElement("link");
        link.rel = isCss ? "stylesheet" : scriptRel;
        if (!isCss) {
          link.as = "script";
          link.crossOrigin = "";
        }
        link.href = dep;
        if (cspNonce) {
          link.setAttribute("nonce", cspNonce);
        }
        document.head.appendChild(link);
        if (isCss) {
          return new Promise((res, rej) => {
            link.addEventListener("load", res);
            link.addEventListener(
              "error",
              () => rej(new Error(`Unable to preload CSS for ${dep}`))
            );
          });
        }
      })
    );
  }
  return promise.then(() => baseModule()).catch((err) => {
    const e = new Event("vite:preloadError", { cancelable: true });
    e.payload = err;
    window.dispatchEvent(e);
    if (!e.defaultPrevented) {
      throw err;
    }
  });
}, "preload");
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  __name(assertIs, "assertIs");
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  __name(assertNever, "assertNever");
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items2) => {
    const obj = {};
    for (const item2 of items2) {
      obj[item2] = item2;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys2 = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys2.push(key);
      }
    }
    return keys2;
  };
  util2.find = (arr, checker) => {
    for (const item2 of arr) {
      if (checker(item2))
        return item2;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  __name(joinValues, "joinValues");
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_2, value3) => {
    if (typeof value3 === "bigint") {
      return value3.toString();
    }
    return value3;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType = /* @__PURE__ */ __name((data24) => {
  const t = typeof data24;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data24) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data24)) {
        return ZodParsedType.array;
      }
      if (data24 === null) {
        return ZodParsedType.null;
      }
      if (data24.then && typeof data24.then === "function" && data24.catch && typeof data24.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data24 instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data24 instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data24 instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
}, "getParsedType");
const ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
const quotelessJson = /* @__PURE__ */ __name((obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
}, "quotelessJson");
class ZodError extends Error {
  static {
    __name(this, "ZodError");
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = /* @__PURE__ */ __name((error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i2 = 0;
          while (i2 < issue.path.length) {
            const el = issue.path[i2];
            const terminal = i2 === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i2++;
          }
        }
      }
    }, "processError");
    processError(this);
    return fieldErrors;
  }
  static assert(value3) {
    if (!(value3 instanceof ZodError)) {
      throw new Error(`Not a ZodError: ${value3}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
const errorMap$1 = /* @__PURE__ */ __name((issue, _ctx) => {
  let message3;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message3 = "Required";
      } else {
        message3 = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message3 = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message3 = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message3 = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message3 = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message3 = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message3 = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message3 = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message3 = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message3 = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message3 = `${message3} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message3 = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message3 = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message3 = `Invalid ${issue.validation}`;
      } else {
        message3 = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message3 = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message3 = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message3 = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message3 = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message3 = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message3 = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message3 = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message3 = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message3 = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message3 = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message3 = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message3 = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message3 = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message3 = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message3 = "Number must be finite";
      break;
    default:
      message3 = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message: message3 };
}, "errorMap$1");
let overrideErrorMap = errorMap$1;
function setErrorMap(map2) {
  overrideErrorMap = map2;
}
__name(setErrorMap, "setErrorMap");
function getErrorMap() {
  return overrideErrorMap;
}
__name(getErrorMap, "getErrorMap");
const makeIssue = /* @__PURE__ */ __name((params) => {
  const { data: data24, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map2 of maps) {
    errorMessage = map2(fullIssue, { data: data24, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
}, "makeIssue");
const EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      overrideMap,
      overrideMap === errorMap$1 ? void 0 : errorMap$1
      // then global default map
    ].filter((x2) => !!x2)
  });
  ctx.common.issues.push(issue);
}
__name(addIssueToContext, "addIssueToContext");
class ParseStatus {
  static {
    __name(this, "ParseStatus");
  }
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value3 = await pair.value;
      syncPairs.push({
        key,
        value: value3
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value: value3 } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value3.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value3.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value3.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value3.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
const INVALID = Object.freeze({
  status: "aborted"
});
const DIRTY = /* @__PURE__ */ __name((value3) => ({ status: "dirty", value: value3 }), "DIRTY");
const OK = /* @__PURE__ */ __name((value3) => ({ status: "valid", value: value3 }), "OK");
const isAborted = /* @__PURE__ */ __name((x2) => x2.status === "aborted", "isAborted");
const isDirty = /* @__PURE__ */ __name((x2) => x2.status === "dirty", "isDirty");
const isValid = /* @__PURE__ */ __name((x2) => x2.status === "valid", "isValid");
const isAsync = /* @__PURE__ */ __name((x2) => typeof Promise !== "undefined" && x2 instanceof Promise, "isAsync");
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
__name(__classPrivateFieldGet, "__classPrivateFieldGet");
function __classPrivateFieldSet(receiver, state, value3, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value3) : f ? f.value = value3 : state.set(receiver, value3), value3;
}
__name(__classPrivateFieldSet, "__classPrivateFieldSet");
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message3) {
  var e = new Error(message3);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message3) => typeof message3 === "string" ? { message: message3 } : message3 || {};
  errorUtil2.toString = (message3) => typeof message3 === "string" ? message3 : message3 === null || message3 === void 0 ? void 0 : message3.message;
})(errorUtil || (errorUtil = {}));
var _ZodEnum_cache, _ZodNativeEnum_cache;
class ParseInputLazyPath {
  static {
    __name(this, "ParseInputLazyPath");
  }
  constructor(parent, value3, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value3;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
const handleResult = /* @__PURE__ */ __name((ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
}, "handleResult");
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = /* @__PURE__ */ __name((iss, ctx) => {
    var _a, _b;
    const { message: message3 } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message3 !== null && message3 !== void 0 ? message3 : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a = message3 !== null && message3 !== void 0 ? message3 : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message3 !== null && message3 !== void 0 ? message3 : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
  }, "customMap");
  return { errorMap: customMap, description };
}
__name(processCreateParams, "processCreateParams");
class ZodType {
  static {
    __name(this, "ZodType");
  }
  constructor(def2) {
    this.spa = this.safeParseAsync;
    this._def = def2;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data24, params) {
    const result = this.safeParse(data24, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data24, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: data24,
      parsedType: getParsedType(data24)
    };
    const result = this._parseSync({ data: data24, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data24, params) {
    const result = await this.safeParseAsync(data24, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data24, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: data24,
      parsedType: getParsedType(data24)
    };
    const maybeAsyncResult = this._parse({ data: data24, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message3) {
    const getIssueProperties = /* @__PURE__ */ __name((val) => {
      if (typeof message3 === "string" || typeof message3 === "undefined") {
        return { message: message3 };
      } else if (typeof message3 === "function") {
        return message3(val);
      } else {
        return message3;
      }
    }, "getIssueProperties");
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = /* @__PURE__ */ __name(() => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      }), "setError");
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data24) => {
          if (!data24) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option4) {
    return ZodUnion.create([this, option4], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform2) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform: transform2 }
    });
  }
  default(def2) {
    const defaultValueFunc = typeof def2 === "function" ? def2 : () => def2;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def2) {
    const catchValueFunc = typeof def2 === "function" ? def2 : () => def2;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[0-9a-z]+$/;
const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex = /^[a-z0-9_-]{21}$/i;
const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex;
const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
  if (args.precision) {
    regex = `${regex}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    regex = `${regex}(\\.\\d+)?`;
  }
  return regex;
}
__name(timeRegexSource, "timeRegexSource");
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
__name(timeRegex, "timeRegex");
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
__name(datetimeRegex, "datetimeRegex");
function isValidIP(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
__name(isValidIP, "isValidIP");
class ZodString extends ZodType {
  static {
    __name(this, "ZodString");
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message3) {
    return this.refinement((data24) => regex.test(data24), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message3)
    });
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message3) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message3) });
  }
  url(message3) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message3) });
  }
  emoji(message3) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message3) });
  }
  uuid(message3) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message3) });
  }
  nanoid(message3) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message3) });
  }
  cuid(message3) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message3) });
  }
  cuid2(message3) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message3) });
  }
  ulid(message3) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message3) });
  }
  base64(message3) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message3) });
  }
  ip(options3) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options3) });
  }
  datetime(options3) {
    var _a, _b;
    if (typeof options3 === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options3
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options3 === null || options3 === void 0 ? void 0 : options3.precision) === "undefined" ? null : options3 === null || options3 === void 0 ? void 0 : options3.precision,
      offset: (_a = options3 === null || options3 === void 0 ? void 0 : options3.offset) !== null && _a !== void 0 ? _a : false,
      local: (_b = options3 === null || options3 === void 0 ? void 0 : options3.local) !== null && _b !== void 0 ? _b : false,
      ...errorUtil.errToObj(options3 === null || options3 === void 0 ? void 0 : options3.message)
    });
  }
  date(message3) {
    return this._addCheck({ kind: "date", message: message3 });
  }
  time(options3) {
    if (typeof options3 === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options3
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options3 === null || options3 === void 0 ? void 0 : options3.precision) === "undefined" ? null : options3 === null || options3 === void 0 ? void 0 : options3.precision,
      ...errorUtil.errToObj(options3 === null || options3 === void 0 ? void 0 : options3.message)
    });
  }
  duration(message3) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message3) });
  }
  regex(regex, message3) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message3)
    });
  }
  includes(value3, options3) {
    return this._addCheck({
      kind: "includes",
      value: value3,
      position: options3 === null || options3 === void 0 ? void 0 : options3.position,
      ...errorUtil.errToObj(options3 === null || options3 === void 0 ? void 0 : options3.message)
    });
  }
  startsWith(value3, message3) {
    return this._addCheck({
      kind: "startsWith",
      value: value3,
      ...errorUtil.errToObj(message3)
    });
  }
  endsWith(value3, message3) {
    return this._addCheck({
      kind: "endsWith",
      value: value3,
      ...errorUtil.errToObj(message3)
    });
  }
  min(minLength, message3) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message3)
    });
  }
  max(maxLength, message3) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message3)
    });
  }
  length(len, message3) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message3)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(message3) {
    return this.min(1, errorUtil.errToObj(message3));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodString.create = (params) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step2) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step2.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step2.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
__name(floatSafeRemainder, "floatSafeRemainder");
class ZodNumber extends ZodType {
  static {
    __name(this, "ZodNumber");
  }
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value3, message3) {
    return this.setLimit("min", value3, true, errorUtil.toString(message3));
  }
  gt(value3, message3) {
    return this.setLimit("min", value3, false, errorUtil.toString(message3));
  }
  lte(value3, message3) {
    return this.setLimit("max", value3, true, errorUtil.toString(message3));
  }
  lt(value3, message3) {
    return this.setLimit("max", value3, false, errorUtil.toString(message3));
  }
  setLimit(kind, value3, inclusive, message3) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value: value3,
          inclusive,
          message: errorUtil.toString(message3)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message3) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message3)
    });
  }
  positive(message3) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message3)
    });
  }
  negative(message3) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message3)
    });
  }
  nonpositive(message3) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message3)
    });
  }
  nonnegative(message3) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message3)
    });
  }
  multipleOf(value3, message3) {
    return this._addCheck({
      kind: "multipleOf",
      value: value3,
      message: errorUtil.toString(message3)
    });
  }
  finite(message3) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message3)
    });
  }
  safe(message3) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message3)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message3)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
class ZodBigInt extends ZodType {
  static {
    __name(this, "ZodBigInt");
  }
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value3, message3) {
    return this.setLimit("min", value3, true, errorUtil.toString(message3));
  }
  gt(value3, message3) {
    return this.setLimit("min", value3, false, errorUtil.toString(message3));
  }
  lte(value3, message3) {
    return this.setLimit("max", value3, true, errorUtil.toString(message3));
  }
  lt(value3, message3) {
    return this.setLimit("max", value3, false, errorUtil.toString(message3));
  }
  setLimit(kind, value3, inclusive, message3) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value: value3,
          inclusive,
          message: errorUtil.toString(message3)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message3) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message3)
    });
  }
  negative(message3) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message3)
    });
  }
  nonpositive(message3) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message3)
    });
  }
  nonnegative(message3) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message3)
    });
  }
  multipleOf(value3, message3) {
    return this._addCheck({
      kind: "multipleOf",
      value: value3,
      message: errorUtil.toString(message3)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodBigInt.create = (params) => {
  var _a;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
class ZodBoolean extends ZodType {
  static {
    __name(this, "ZodBoolean");
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
class ZodDate extends ZodType {
  static {
    __name(this, "ZodDate");
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message3) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message3)
    });
  }
  max(maxDate, message3) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message3)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
class ZodSymbol extends ZodType {
  static {
    __name(this, "ZodSymbol");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
class ZodUndefined extends ZodType {
  static {
    __name(this, "ZodUndefined");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
class ZodNull extends ZodType {
  static {
    __name(this, "ZodNull");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
class ZodAny extends ZodType {
  static {
    __name(this, "ZodAny");
  }
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
class ZodUnknown extends ZodType {
  static {
    __name(this, "ZodUnknown");
  }
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
class ZodNever extends ZodType {
  static {
    __name(this, "ZodNever");
  }
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
class ZodVoid extends ZodType {
  static {
    __name(this, "ZodVoid");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
class ZodArray extends ZodType {
  static {
    __name(this, "ZodArray");
  }
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def2 = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def2.exactLength !== null) {
      const tooBig = ctx.data.length > def2.exactLength.value;
      const tooSmall = ctx.data.length < def2.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def2.exactLength.value : void 0,
          maximum: tooBig ? def2.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def2.exactLength.message
        });
        status.dirty();
      }
    }
    if (def2.minLength !== null) {
      if (ctx.data.length < def2.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def2.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def2.minLength.message
        });
        status.dirty();
      }
    }
    if (def2.maxLength !== null) {
      if (ctx.data.length > def2.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def2.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def2.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item2, i2) => {
        return def2.type._parseAsync(new ParseInputLazyPath(ctx, item2, ctx.path, i2));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item2, i2) => {
      return def2.type._parseSync(new ParseInputLazyPath(ctx, item2, ctx.path, i2));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message3) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message3) }
    });
  }
  max(maxLength, message3) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message3) }
    });
  }
  length(len, message3) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message3) }
    });
  }
  nonempty(message3) {
    return this.min(1, message3);
  }
}
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: /* @__PURE__ */ __name(() => newShape, "shape")
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item2) => deepPartialify(item2)));
  } else {
    return schema;
  }
}
__name(deepPartialify, "deepPartialify");
class ZodObject extends ZodType {
  static {
    __name(this, "ZodObject");
  }
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys2 = util.objectKeys(shape);
    return this._cached = { shape, keys: keys2 };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value3 = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value3, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value3 = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value3, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value3 = await pair.value;
          syncPairs.push({
            key,
            value: value3,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message3) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message3 !== void 0 ? {
        errorMap: /* @__PURE__ */ __name((issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message3).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }, "errorMap")
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => ({
        ...this._def.shape(),
        ...augmentation
      }), "shape")
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: /* @__PURE__ */ __name(() => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }), "shape"),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index2) {
    return new ZodObject({
      ...this._def,
      catchall: index2
    });
  }
  pick(mask3) {
    const shape = {};
    util.objectKeys(mask3).forEach((key) => {
      if (mask3[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => shape, "shape")
    });
  }
  omit(mask3) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask3[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => shape, "shape")
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask3) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask3 && !mask3[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => newShape, "shape")
    });
  }
  required(mask3) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask3 && !mask3[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => newShape, "shape")
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: /* @__PURE__ */ __name(() => shape, "shape"),
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: /* @__PURE__ */ __name(() => shape, "shape"),
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
class ZodUnion extends ZodType {
  static {
    __name(this, "ZodUnion");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options3 = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    __name(handleResults, "handleResults");
    if (ctx.common.async) {
      return Promise.all(options3.map(async (option4) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option4._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option4 of options3) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option4._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
const getDiscriminator = /* @__PURE__ */ __name((type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
}, "getDiscriminator");
class ZodDiscriminatedUnion extends ZodType {
  static {
    __name(this, "ZodDiscriminatedUnion");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option4 = this.optionsMap.get(discriminatorValue);
    if (!option4) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option4._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option4._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options3, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options3) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value3 of discriminatorValues) {
        if (optionsMap.has(value3)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value3)}`);
        }
        optionsMap.set(value3, type);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options: options3,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index2 = 0; index2 < a.length; index2++) {
      const itemA = a[index2];
      const itemB = b[index2];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
__name(mergeValues, "mergeValues");
class ZodIntersection extends ZodType {
  static {
    __name(this, "ZodIntersection");
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = /* @__PURE__ */ __name((parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    }, "handleParsed");
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
class ZodTuple extends ZodType {
  static {
    __name(this, "ZodTuple");
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items2 = [...ctx.data].map((item2, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item2, ctx.path, itemIndex));
    }).filter((x2) => !!x2);
    if (ctx.common.async) {
      return Promise.all(items2).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items2);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
class ZodRecord extends ZodType {
  static {
    __name(this, "ZodRecord");
  }
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}
class ZodMap extends ZodType {
  static {
    __name(this, "ZodMap");
  }
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value3], index2) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index2, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value3, ctx.path, [index2, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value3 = await pair.value;
          if (key.status === "aborted" || value3.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value3.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value3.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value3 = pair.value;
        if (key.status === "aborted" || value3.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value3.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value3.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
class ZodSet extends ZodType {
  static {
    __name(this, "ZodSet");
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def2 = this._def;
    if (def2.minSize !== null) {
      if (ctx.data.size < def2.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def2.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def2.minSize.message
        });
        status.dirty();
      }
    }
    if (def2.maxSize !== null) {
      if (ctx.data.size > def2.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def2.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def2.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    __name(finalizeSet, "finalizeSet");
    const elements = [...ctx.data.values()].map((item2, i2) => valueType._parse(new ParseInputLazyPath(ctx, item2, ctx.path, i2)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message3) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message3) }
    });
  }
  max(maxSize, message3) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message3) }
    });
  }
  size(size2, message3) {
    return this.min(size2, message3).max(size2, message3);
  }
  nonempty(message3) {
    return this.min(1, message3);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
class ZodFunction extends ZodType {
  static {
    __name(this, "ZodFunction");
  }
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap$1
        ].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    __name(makeArgsIssue, "makeArgsIssue");
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap$1
        ].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    __name(makeReturnsIssue, "makeReturnsIssue");
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items2) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items2).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}
class ZodLazy extends ZodType {
  static {
    __name(this, "ZodLazy");
  }
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
class ZodLiteral extends ZodType {
  static {
    __name(this, "ZodLiteral");
  }
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value3, params) => {
  return new ZodLiteral({
    value: value3,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values2, params) {
  return new ZodEnum({
    values: values2,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
__name(createZodEnum, "createZodEnum");
class ZodEnum extends ZodType {
  static {
    __name(this, "ZodEnum");
  }
  constructor() {
    super(...arguments);
    _ZodEnum_cache.set(this, void 0);
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f").has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values2, newDef = this._def) {
    return ZodEnum.create(values2, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values2, newDef = this._def) {
    return ZodEnum.create(this.options.filter((opt) => !values2.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
}
_ZodEnum_cache = /* @__PURE__ */ new WeakMap();
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
  static {
    __name(this, "ZodNativeEnum");
  }
  constructor() {
    super(...arguments);
    _ZodNativeEnum_cache.set(this, void 0);
  }
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f").has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
_ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();
ZodNativeEnum.create = (values2, params) => {
  return new ZodNativeEnum({
    values: values2,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
class ZodPromise extends ZodType {
  static {
    __name(this, "ZodPromise");
  }
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data24) => {
      return this._def.type.parseAsync(data24, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
class ZodEffects extends ZodType {
  static {
    __name(this, "ZodEffects");
  }
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect2 = this._def.effect || null;
    const checkCtx = {
      addIssue: /* @__PURE__ */ __name((arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      }, "addIssue"),
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect2.type === "preprocess") {
      const processed = effect2.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect2.type === "refinement") {
      const executeRefinement = /* @__PURE__ */ __name((acc) => {
        const result = effect2.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      }, "executeRefinement");
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect2.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect2.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect2.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect2);
  }
}
ZodEffects.create = (schema, effect2, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect: effect2,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
class ZodOptional extends ZodType {
  static {
    __name(this, "ZodOptional");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
class ZodNullable extends ZodType {
  static {
    __name(this, "ZodNullable");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
class ZodDefault extends ZodType {
  static {
    __name(this, "ZodDefault");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data24 = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data24 = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data: data24,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
class ZodCatch extends ZodType {
  static {
    __name(this, "ZodCatch");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
class ZodNaN extends ZodType {
  static {
    __name(this, "ZodNaN");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
const BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
  static {
    __name(this, "ZodBranded");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data24 = ctx.data;
    return this._def.type._parse({
      data: data24,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class ZodPipeline extends ZodType {
  static {
    __name(this, "ZodPipeline");
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = /* @__PURE__ */ __name(async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }, "handleAsync");
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}
class ZodReadonly extends ZodType {
  static {
    __name(this, "ZodReadonly");
  }
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = /* @__PURE__ */ __name((data24) => {
      if (isValid(data24)) {
        data24.value = Object.freeze(data24.value);
      }
      return data24;
    }, "freeze");
    return isAsync(result) ? result.then((data24) => freeze(data24)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function custom(check, params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data24, ctx) => {
      var _a, _b;
      if (!check(data24)) {
        const p2 = typeof params === "function" ? params(data24) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b = (_a = p2.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
        const p22 = typeof p2 === "string" ? { message: p2 } : p2;
        ctx.addIssue({ code: "custom", ...p22, fatal: _fatal });
      }
    });
  return ZodAny.create();
}
__name(custom, "custom");
const late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const instanceOfType = /* @__PURE__ */ __name((cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data24) => data24 instanceof cls, params), "instanceOfType");
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const symbolType = ZodSymbol.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const pipelineType = ZodPipeline.create;
const ostring = /* @__PURE__ */ __name(() => stringType().optional(), "ostring");
const onumber = /* @__PURE__ */ __name(() => numberType().optional(), "onumber");
const oboolean = /* @__PURE__ */ __name(() => booleanType().optional(), "oboolean");
const coerce = {
  string: /* @__PURE__ */ __name((arg) => ZodString.create({ ...arg, coerce: true }), "string"),
  number: /* @__PURE__ */ __name((arg) => ZodNumber.create({ ...arg, coerce: true }), "number"),
  boolean: /* @__PURE__ */ __name((arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }), "boolean"),
  bigint: /* @__PURE__ */ __name((arg) => ZodBigInt.create({ ...arg, coerce: true }), "bigint"),
  date: /* @__PURE__ */ __name((arg) => ZodDate.create({ ...arg, coerce: true }), "date")
};
const NEVER = INVALID;
var z = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap$1,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  datetimeRegex,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});
function isZodErrorLike(err) {
  return err instanceof Error && err.name === "ZodError" && "issues" in err && Array.isArray(err.issues);
}
__name(isZodErrorLike, "isZodErrorLike");
var ValidationError = class extends Error {
  static {
    __name(this, "ValidationError");
  }
  name;
  details;
  constructor(message3, options3) {
    super(message3, options3);
    this.name = "ZodValidationError";
    this.details = getIssuesFromErrorOptions(options3);
  }
  toString() {
    return this.message;
  }
};
function getIssuesFromErrorOptions(options3) {
  if (options3) {
    const cause = options3.cause;
    if (isZodErrorLike(cause)) {
      return cause.issues;
    }
  }
  return [];
}
__name(getIssuesFromErrorOptions, "getIssuesFromErrorOptions");
function isValidationError(err) {
  return err instanceof ValidationError;
}
__name(isValidationError, "isValidationError");
function isValidationErrorLike(err) {
  return err instanceof Error && err.name === "ZodValidationError";
}
__name(isValidationErrorLike, "isValidationErrorLike");
var ISSUE_SEPARATOR = "; ";
var MAX_ISSUES_IN_MESSAGE = 99;
var PREFIX = "Validation error";
var PREFIX_SEPARATOR = ": ";
var UNION_SEPARATOR = ", or ";
function prefixMessage(message3, prefix2, prefixSeparator) {
  if (prefix2 !== null) {
    if (message3.length > 0) {
      return [prefix2, message3].join(prefixSeparator);
    }
    return prefix2;
  }
  if (message3.length > 0) {
    return message3;
  }
  return PREFIX;
}
__name(prefixMessage, "prefixMessage");
var identifierRegex = /[$_\p{ID_Start}][$\u200c\u200d\p{ID_Continue}]*/u;
function joinPath(path) {
  if (path.length === 1) {
    return path[0].toString();
  }
  return path.reduce((acc, item2) => {
    if (typeof item2 === "number") {
      return acc + "[" + item2.toString() + "]";
    }
    if (item2.includes('"')) {
      return acc + '["' + escapeQuotes(item2) + '"]';
    }
    if (!identifierRegex.test(item2)) {
      return acc + '["' + item2 + '"]';
    }
    const separator = acc.length === 0 ? "" : ".";
    return acc + separator + item2;
  }, "");
}
__name(joinPath, "joinPath");
function escapeQuotes(str) {
  return str.replace(/"/g, '\\"');
}
__name(escapeQuotes, "escapeQuotes");
function isNonEmptyArray(value3) {
  return value3.length !== 0;
}
__name(isNonEmptyArray, "isNonEmptyArray");
function getMessageFromZodIssue(props) {
  const { issue, issueSeparator, unionSeparator, includePath } = props;
  if (issue.code === "invalid_union") {
    return issue.unionErrors.reduce((acc, zodError) => {
      const newIssues = zodError.issues.map(
        (issue2) => getMessageFromZodIssue({
          issue: issue2,
          issueSeparator,
          unionSeparator,
          includePath
        })
      ).join(issueSeparator);
      if (!acc.includes(newIssues)) {
        acc.push(newIssues);
      }
      return acc;
    }, []).join(unionSeparator);
  }
  if (issue.code === "invalid_arguments") {
    return [
      issue.message,
      ...issue.argumentsError.issues.map(
        (issue2) => getMessageFromZodIssue({
          issue: issue2,
          issueSeparator,
          unionSeparator,
          includePath
        })
      )
    ].join(issueSeparator);
  }
  if (issue.code === "invalid_return_type") {
    return [
      issue.message,
      ...issue.returnTypeError.issues.map(
        (issue2) => getMessageFromZodIssue({
          issue: issue2,
          issueSeparator,
          unionSeparator,
          includePath
        })
      )
    ].join(issueSeparator);
  }
  if (includePath && isNonEmptyArray(issue.path)) {
    if (issue.path.length === 1) {
      const identifier = issue.path[0];
      if (typeof identifier === "number") {
        return `${issue.message} at index ${identifier}`;
      }
    }
    return `${issue.message} at "${joinPath(issue.path)}"`;
  }
  return issue.message;
}
__name(getMessageFromZodIssue, "getMessageFromZodIssue");
function fromZodIssue(issue, options3 = {}) {
  const {
    issueSeparator = ISSUE_SEPARATOR,
    unionSeparator = UNION_SEPARATOR,
    prefixSeparator = PREFIX_SEPARATOR,
    prefix: prefix2 = PREFIX,
    includePath = true
  } = options3;
  const reason = getMessageFromZodIssue({
    issue,
    issueSeparator,
    unionSeparator,
    includePath
  });
  const message3 = prefixMessage(reason, prefix2, prefixSeparator);
  return new ValidationError(message3, { cause: new ZodError([issue]) });
}
__name(fromZodIssue, "fromZodIssue");
var errorMap = /* @__PURE__ */ __name((issue, ctx) => {
  const error = fromZodIssue({
    ...issue,
    // fallback to the default error message
    // when issue does not have a message
    message: issue.message ?? ctx.defaultError
  });
  return {
    message: error.message
  };
}, "errorMap");
function fromZodError(zodError, options3 = {}) {
  if (!isZodErrorLike(zodError)) {
    throw new TypeError(
      `Invalid zodError param; expected instance of ZodError. Did you mean to use the "${fromError.name}" method instead?`
    );
  }
  return fromZodErrorWithoutRuntimeCheck(zodError, options3);
}
__name(fromZodError, "fromZodError");
function fromZodErrorWithoutRuntimeCheck(zodError, options3 = {}) {
  const {
    maxIssuesInMessage = MAX_ISSUES_IN_MESSAGE,
    issueSeparator = ISSUE_SEPARATOR,
    unionSeparator = UNION_SEPARATOR,
    prefixSeparator = PREFIX_SEPARATOR,
    prefix: prefix2 = PREFIX,
    includePath = true
  } = options3;
  const zodIssues = zodError.errors;
  const reason = zodIssues.length === 0 ? zodError.message : zodIssues.slice(0, maxIssuesInMessage).map(
    (issue) => getMessageFromZodIssue({
      issue,
      issueSeparator,
      unionSeparator,
      includePath
    })
  ).join(issueSeparator);
  const message3 = prefixMessage(reason, prefix2, prefixSeparator);
  return new ValidationError(message3, { cause: zodError });
}
__name(fromZodErrorWithoutRuntimeCheck, "fromZodErrorWithoutRuntimeCheck");
var toValidationError = /* @__PURE__ */ __name((options3 = {}) => (err) => {
  if (isZodErrorLike(err)) {
    return fromZodErrorWithoutRuntimeCheck(err, options3);
  }
  if (err instanceof Error) {
    return new ValidationError(err.message, { cause: err });
  }
  return new ValidationError("Unknown error");
}, "toValidationError");
function fromError(err, options3 = {}) {
  return toValidationError(options3)(err);
}
__name(fromError, "fromError");
const zNodeId = z.union([z.number().int(), z.string()]);
const zSlotIndex = z.union([
  z.number().int(),
  z.string().transform((val) => parseInt(val)).refine((val) => !isNaN(val), {
    message: "Invalid number"
  })
]);
const zDataType = z.union([z.string(), z.array(z.string()), z.number()]);
const zModelFile = z.object({
  name: z.string(),
  url: z.string().url(),
  hash: z.string().optional(),
  hash_type: z.string().optional(),
  directory: z.string()
});
const zComfyLink = z.tuple([
  z.number(),
  // Link id
  zNodeId,
  // Node id of source node
  zSlotIndex,
  // Output slot# of source node
  zNodeId,
  // Node id of destination node
  zSlotIndex,
  // Input slot# of destination node
  zDataType
  // Data type
]);
const zNodeOutput = z.object({
  name: z.string(),
  type: zDataType,
  links: z.array(z.number()).nullable().optional(),
  slot_index: zSlotIndex.optional()
}).passthrough();
const zNodeInput = z.object({
  name: z.string(),
  type: zDataType,
  link: z.number().nullable().optional(),
  slot_index: zSlotIndex.optional()
}).passthrough();
const zFlags = z.object({
  collapsed: z.boolean().optional(),
  pinned: z.boolean().optional(),
  allow_interaction: z.boolean().optional(),
  horizontal: z.boolean().optional(),
  skip_repeated_outputs: z.boolean().optional()
}).passthrough();
const zProperties = z.object({
  ["Node name for S&R"]: z.string().optional()
}).passthrough();
const zVector2 = z.union([
  z.object({ 0: z.number(), 1: z.number() }).passthrough().transform((v2) => [v2[0], v2[1]]),
  z.tuple([z.number(), z.number()])
]);
const zWidgetValues = z.union([z.array(z.any()), z.record(z.any())]);
const zComfyNode = z.object({
  id: zNodeId,
  type: z.string(),
  pos: zVector2,
  size: zVector2,
  flags: zFlags,
  order: z.number(),
  mode: z.number(),
  inputs: z.array(zNodeInput).optional(),
  outputs: z.array(zNodeOutput).optional(),
  properties: zProperties,
  widgets_values: zWidgetValues.optional(),
  color: z.string().optional(),
  bgcolor: z.string().optional()
}).passthrough();
const zGroup = z.object({
  title: z.string(),
  bounding: z.tuple([z.number(), z.number(), z.number(), z.number()]),
  color: z.string().optional(),
  font_size: z.number().optional(),
  locked: z.boolean().optional()
}).passthrough();
const zInfo = z.object({
  name: z.string(),
  author: z.string(),
  description: z.string(),
  version: z.string(),
  created: z.string(),
  modified: z.string(),
  software: z.string()
}).passthrough();
const zDS = z.object({
  scale: z.number(),
  offset: zVector2
}).passthrough();
const zConfig = z.object({
  links_ontop: z.boolean().optional(),
  align_to_grid: z.boolean().optional()
}).passthrough();
const zExtra = z.object({
  ds: zDS.optional(),
  info: zInfo.optional()
}).passthrough();
const zComfyWorkflow = z.object({
  last_node_id: zNodeId,
  last_link_id: z.number(),
  nodes: z.array(zComfyNode),
  links: z.array(zComfyLink),
  groups: z.array(zGroup).optional(),
  config: zConfig.optional().nullable(),
  extra: zExtra.optional().nullable(),
  version: z.number(),
  models: z.array(zModelFile).optional()
}).passthrough();
async function validateComfyWorkflow(data24, onError = console.warn) {
  const result = await zComfyWorkflow.safeParseAsync(data24);
  if (!result.success) {
    const error = fromZodError(result.error);
    onError(`Invalid workflow against zod schema:
${error}`);
    return null;
  }
  return result.data;
}
__name(validateComfyWorkflow, "validateComfyWorkflow");
const nodeSlotSchema = z.object({
  BOOLEAN: z.string().optional(),
  CLIP: z.string(),
  CLIP_VISION: z.string(),
  CLIP_VISION_OUTPUT: z.string(),
  CONDITIONING: z.string(),
  CONTROL_NET: z.string(),
  CONTROL_NET_WEIGHTS: z.string().optional(),
  FLOAT: z.string().optional(),
  GLIGEN: z.string().optional(),
  IMAGE: z.string(),
  IMAGEUPLOAD: z.string().optional(),
  INT: z.string().optional(),
  LATENT: z.string(),
  LATENT_KEYFRAME: z.string().optional(),
  MASK: z.string(),
  MODEL: z.string(),
  SAMPLER: z.string().optional(),
  SIGMAS: z.string().optional(),
  STRING: z.string().optional(),
  STYLE_MODEL: z.string(),
  T2I_ADAPTER_WEIGHTS: z.string().optional(),
  TAESD: z.string(),
  TIMESTEP_KEYFRAME: z.string().optional(),
  UPSCALE_MODEL: z.string().optional(),
  VAE: z.string()
}).passthrough();
const litegraphBaseSchema = z.object({
  BACKGROUND_IMAGE: z.string(),
  CLEAR_BACKGROUND_COLOR: z.string(),
  NODE_TITLE_COLOR: z.string(),
  NODE_SELECTED_TITLE_COLOR: z.string(),
  NODE_TEXT_SIZE: z.number(),
  NODE_TEXT_COLOR: z.string(),
  NODE_SUBTEXT_SIZE: z.number(),
  NODE_DEFAULT_COLOR: z.string(),
  NODE_DEFAULT_BGCOLOR: z.string(),
  NODE_DEFAULT_BOXCOLOR: z.string(),
  NODE_DEFAULT_SHAPE: z.string(),
  NODE_BOX_OUTLINE_COLOR: z.string(),
  DEFAULT_SHADOW_COLOR: z.string(),
  DEFAULT_GROUP_FONT: z.number(),
  WIDGET_BGCOLOR: z.string(),
  WIDGET_OUTLINE_COLOR: z.string(),
  WIDGET_TEXT_COLOR: z.string(),
  WIDGET_SECONDARY_TEXT_COLOR: z.string(),
  LINK_COLOR: z.string(),
  EVENT_LINK_COLOR: z.string(),
  CONNECTING_LINK_COLOR: z.string()
}).passthrough();
const comfyBaseSchema = z.object({
  ["fg-color"]: z.string(),
  ["bg-color"]: z.string(),
  ["bg-img"]: z.string().optional(),
  ["comfy-menu-bg"]: z.string(),
  ["comfy-input-bg"]: z.string(),
  ["input-text"]: z.string(),
  ["descrip-text"]: z.string(),
  ["drag-text"]: z.string(),
  ["error-text"]: z.string(),
  ["border-color"]: z.string(),
  ["tr-even-bg-color"]: z.string(),
  ["tr-odd-bg-color"]: z.string(),
  ["content-bg"]: z.string(),
  ["content-fg"]: z.string(),
  ["content-hover-bg"]: z.string(),
  ["content-hover-fg"]: z.string()
});
const colorsSchema = z.object({
  node_slot: nodeSlotSchema,
  litegraph_base: litegraphBaseSchema,
  comfy_base: comfyBaseSchema
}).passthrough();
const paletteSchema = z.object({
  id: z.string(),
  name: z.string(),
  colors: colorsSchema
});
const colorPalettesSchema = z.record(paletteSchema);
var LinkReleaseTriggerMode = /* @__PURE__ */ ((LinkReleaseTriggerMode2) => {
  LinkReleaseTriggerMode2["ALWAYS"] = "always";
  LinkReleaseTriggerMode2["HOLD_SHIFT"] = "hold shift";
  LinkReleaseTriggerMode2["NOT_HOLD_SHIFT"] = "NOT hold shift";
  return LinkReleaseTriggerMode2;
})(LinkReleaseTriggerMode || {});
var LinkReleaseTriggerAction = /* @__PURE__ */ ((LinkReleaseTriggerAction2) => {
  LinkReleaseTriggerAction2["CONTEXT_MENU"] = "context menu";
  LinkReleaseTriggerAction2["SEARCH_BOX"] = "search box";
  LinkReleaseTriggerAction2["NO_ACTION"] = "no action";
  return LinkReleaseTriggerAction2;
})(LinkReleaseTriggerAction || {});
const zNodeType = z.string();
const zQueueIndex = z.number();
const zPromptId = z.string();
const zResultItem = z.object({
  filename: z.string(),
  subfolder: z.string().optional(),
  type: z.string()
});
const zOutputs = z.object({
  audio: z.array(zResultItem).optional(),
  images: z.array(zResultItem).optional()
}).passthrough();
const zStatusWsMessageStatus = z.object({
  exec_info: z.object({
    queue_remaining: z.number().int()
  })
});
const zStatusWsMessage = z.object({
  status: zStatusWsMessageStatus.nullable().optional()
});
const zProgressWsMessage = z.object({
  value: z.number().int(),
  max: z.number().int(),
  prompt_id: zPromptId,
  node: zNodeId
});
const zExecutingWsMessage = z.object({
  node: zNodeId,
  display_node: zNodeId,
  prompt_id: zPromptId
});
const zExecutedWsMessage = zExecutingWsMessage.extend({
  outputs: zOutputs
});
const zExecutionWsMessageBase = z.object({
  prompt_id: zPromptId,
  timestamp: z.number().int()
});
const zExecutionStartWsMessage = zExecutionWsMessageBase;
const zExecutionSuccessWsMessage = zExecutionWsMessageBase;
const zExecutionCachedWsMessage = zExecutionWsMessageBase.extend({
  nodes: z.array(zNodeId)
});
const zExecutionInterruptedWsMessage = zExecutionWsMessageBase.extend({
  node_id: zNodeId,
  node_type: zNodeType,
  executed: z.array(zNodeId)
});
const zExecutionErrorWsMessage = zExecutionWsMessageBase.extend({
  node_id: zNodeId,
  node_type: zNodeType,
  executed: z.array(zNodeId),
  exception_message: z.string(),
  exception_type: z.string(),
  traceback: z.array(z.string()),
  current_inputs: z.any(),
  current_outputs: z.any()
});
const zDownloadModelStatus = z.object({
  status: z.string(),
  progress_percentage: z.number(),
  message: z.string(),
  download_path: z.string(),
  already_existed: z.boolean()
});
const zPromptInputItem = z.object({
  inputs: z.record(z.string(), z.any()),
  class_type: zNodeType
});
const zPromptInputs = z.record(zPromptInputItem);
const zExtraPngInfo = z.object({
  workflow: zComfyWorkflow
}).passthrough();
const zExtraData = z.object({
  extra_pnginfo: zExtraPngInfo,
  client_id: z.string()
});
const zOutputsToExecute = z.array(zNodeId);
const zExecutionStartMessage = z.tuple([
  z.literal("execution_start"),
  zExecutionStartWsMessage
]);
const zExecutionSuccessMessage = z.tuple([
  z.literal("execution_success"),
  zExecutionSuccessWsMessage
]);
const zExecutionCachedMessage = z.tuple([
  z.literal("execution_cached"),
  zExecutionCachedWsMessage
]);
const zExecutionInterruptedMessage = z.tuple([
  z.literal("execution_interrupted"),
  zExecutionInterruptedWsMessage
]);
const zExecutionErrorMessage = z.tuple([
  z.literal("execution_error"),
  zExecutionErrorWsMessage
]);
const zStatusMessage = z.union([
  zExecutionStartMessage,
  zExecutionSuccessMessage,
  zExecutionCachedMessage,
  zExecutionInterruptedMessage,
  zExecutionErrorMessage
]);
const zStatus = z.object({
  status_str: z.enum(["success", "error"]),
  completed: z.boolean(),
  messages: z.array(zStatusMessage)
});
const zTaskPrompt = z.tuple([
  zQueueIndex,
  zPromptId,
  zPromptInputs,
  zExtraData,
  zOutputsToExecute
]);
const zRunningTaskItem = z.object({
  taskType: z.literal("Running"),
  prompt: zTaskPrompt,
  // @Deprecated
  remove: z.object({
    name: z.literal("Cancel"),
    cb: z.function()
  })
});
const zPendingTaskItem = z.object({
  taskType: z.literal("Pending"),
  prompt: zTaskPrompt
});
const zTaskOutput = z.record(zNodeId, zOutputs);
const zHistoryTaskItem = z.object({
  taskType: z.literal("History"),
  prompt: zTaskPrompt,
  status: zStatus.optional(),
  outputs: zTaskOutput
});
const zTaskItem = z.union([
  zRunningTaskItem,
  zPendingTaskItem,
  zHistoryTaskItem
]);
const zTaskType = z.union([
  z.literal("Running"),
  z.literal("Pending"),
  z.literal("History")
]);
function validateTaskItem(taskItem) {
  const result = zTaskItem.safeParse(taskItem);
  if (!result.success) {
    const zodError = fromZodError(result.error);
    console.warn(
      `Invalid TaskItem: ${JSON.stringify(taskItem)}
${zodError.message}`
    );
  }
  return result;
}
__name(validateTaskItem, "validateTaskItem");
function inputSpec(spec, allowUpcast = true) {
  const [inputType, inputSpec2] = spec;
  const upcastTypes = allowUpcast ? [inputType.transform((type) => [type, {}])] : [];
  return z.union([
    z.tuple([inputType, inputSpec2]),
    z.tuple([inputType]).transform(([type]) => [type, {}]),
    ...upcastTypes
  ]);
}
__name(inputSpec, "inputSpec");
const zBaseInputSpecValue = z.object({
  default: z.any().optional(),
  forceInput: z.boolean().optional()
}).passthrough();
const zIntInputSpec = inputSpec([
  z.literal("INT"),
  zBaseInputSpecValue.extend({
    min: z.number().optional(),
    max: z.number().optional(),
    step: z.number().optional(),
    // Note: Many node authors are using INT to pass list of INT.
    // TODO: Add list of ints type.
    default: z.union([z.number(), z.array(z.number())]).optional()
  })
]);
const zFloatInputSpec = inputSpec([
  z.literal("FLOAT"),
  zBaseInputSpecValue.extend({
    min: z.number().optional(),
    max: z.number().optional(),
    step: z.number().optional(),
    round: z.union([z.number(), z.literal(false)]).optional(),
    // Note: Many node authors are using FLOAT to pass list of FLOAT.
    // TODO: Add list of floats type.
    default: z.union([z.number(), z.array(z.number())]).optional()
  })
]);
const zBooleanInputSpec = inputSpec([
  z.literal("BOOLEAN"),
  zBaseInputSpecValue.extend({
    label_on: z.string().optional(),
    label_off: z.string().optional(),
    default: z.boolean().optional()
  })
]);
const zStringInputSpec = inputSpec([
  z.literal("STRING"),
  zBaseInputSpecValue.extend({
    default: z.string().optional(),
    multiline: z.boolean().optional(),
    dynamicPrompts: z.boolean().optional(),
    // Multiline-only fields
    defaultVal: z.string().optional(),
    placeholder: z.string().optional()
  })
]);
const zComboInputSpec = inputSpec(
  [
    z.array(z.any()),
    zBaseInputSpecValue.extend({
      control_after_generate: z.boolean().optional(),
      image_upload: z.boolean().optional()
    })
  ],
  /* allowUpcast=*/
  false
);
const excludedLiterals = /* @__PURE__ */ new Set(["INT", "FLOAT", "BOOLEAN", "STRING", "COMBO"]);
const zCustomInputSpec = inputSpec([
  z.string().refine((value3) => !excludedLiterals.has(value3)),
  zBaseInputSpecValue
]);
const zInputSpec = z.union([
  zIntInputSpec,
  zFloatInputSpec,
  zBooleanInputSpec,
  zStringInputSpec,
  zComboInputSpec,
  zCustomInputSpec
]);
const zComfyInputsSpec = z.object({
  required: z.record(zInputSpec).optional(),
  optional: z.record(zInputSpec).optional(),
  // Frontend repo is not using it, but some custom nodes are using the
  // hidden field to pass various values.
  hidden: z.record(z.any()).optional()
});
const zComfyNodeDataType = z.string();
const zComfyComboOutput = z.array(z.any());
const zComfyOutputTypesSpec = z.array(
  z.union([zComfyNodeDataType, zComfyComboOutput])
);
const zComfyNodeDef = z.object({
  input: zComfyInputsSpec,
  output: zComfyOutputTypesSpec,
  output_is_list: z.array(z.boolean()),
  output_name: z.array(z.string()),
  output_tooltips: z.array(z.string()).optional(),
  name: z.string(),
  display_name: z.string(),
  description: z.string(),
  category: z.string(),
  output_node: z.boolean(),
  python_module: z.string(),
  deprecated: z.boolean().optional(),
  experimental: z.boolean().optional()
});
function validateComfyNodeDef(data24, onError = console.warn) {
  const result = zComfyNodeDef.safeParse(data24);
  if (!result.success) {
    const zodError = fromZodError(result.error);
    onError(
      `Invalid ComfyNodeDef: ${JSON.stringify(data24)}
${zodError.message}`
    );
    return null;
  }
  return result.data;
}
__name(validateComfyNodeDef, "validateComfyNodeDef");
const zEmbeddingsResponse = z.array(z.string());
const zExtensionsResponse = z.array(z.string());
const zPromptResponse = z.object({
  node_errors: z.array(z.string()).optional(),
  prompt_id: z.string().optional(),
  exec_info: z.object({
    queue_remaining: z.number().optional()
  }).optional()
});
const zSystemStats = z.object({
  system: z.object({
    os: z.string(),
    python_version: z.string(),
    embedded_python: z.boolean(),
    comfyui_version: z.string(),
    pytorch_version: z.string(),
    argv: z.array(z.string())
  }),
  devices: z.array(
    z.object({
      name: z.string(),
      type: z.string(),
      index: z.number().optional(),
      vram_total: z.number(),
      vram_free: z.number(),
      torch_vram_total: z.number(),
      torch_vram_free: z.number()
    })
  )
});
const zUser = z.object({
  storage: z.enum(["server", "browser"]),
  migrated: z.boolean(),
  users: z.record(z.string(), z.unknown())
});
const zUserData = z.array(z.array(z.string(), z.string()));
const zBookmarkCustomization = z.object({
  icon: z.string().optional(),
  color: z.string().optional()
});
const zLinkReleaseTriggerAction = z.enum(
  Object.values(LinkReleaseTriggerAction)
);
const zSettings = z.record(z.any()).and(
  z.object({
    "Comfy.ColorPalette": z.string(),
    "Comfy.CustomColorPalettes": colorPalettesSchema,
    "Comfy.ConfirmClear": z.boolean(),
    "Comfy.DevMode": z.boolean(),
    "Comfy.Workflow.ShowMissingNodesWarning": z.boolean(),
    "Comfy.Workflow.ShowMissingModelsWarning": z.boolean(),
    "Comfy.DisableFloatRounding": z.boolean(),
    "Comfy.DisableSliders": z.boolean(),
    "Comfy.DOMClippingEnabled": z.boolean(),
    "Comfy.EditAttention.Delta": z.number(),
    "Comfy.EnableTooltips": z.boolean(),
    "Comfy.EnableWorkflowViewRestore": z.boolean(),
    "Comfy.FloatRoundingPrecision": z.number(),
    "Comfy.Graph.CanvasInfo": z.boolean(),
    "Comfy.Graph.ZoomSpeed": z.number(),
    "Comfy.Group.DoubleClickTitleToEdit": z.boolean(),
    "Comfy.GroupSelectedNodes.Padding": z.number(),
    "Comfy.InvertMenuScrolling": z.boolean(),
    "Comfy.Locale": z.string(),
    "Comfy.Logging.Enabled": z.boolean(),
    "Comfy.NodeLibrary.Bookmarks": z.array(z.string()),
    "Comfy.NodeLibrary.Bookmarks.V2": z.array(z.string()),
    "Comfy.NodeLibrary.BookmarksCustomization": z.record(
      z.string(),
      zBookmarkCustomization
    ),
    "Comfy.NodeInputConversionSubmenus": z.boolean(),
    "Comfy.NodeSearchBoxImpl.LinkReleaseTrigger": z.enum([
      "always",
      "hold shift",
      "NOT hold shift"
    ]),
    "Comfy.LinkRelease.Action": zLinkReleaseTriggerAction,
    "Comfy.LinkRelease.ActionShift": zLinkReleaseTriggerAction,
    "Comfy.NodeSearchBoxImpl.NodePreview": z.boolean(),
    "Comfy.NodeSearchBoxImpl": z.enum(["default", "simple"]),
    "Comfy.NodeSearchBoxImpl.ShowCategory": z.boolean(),
    "Comfy.NodeSearchBoxImpl.ShowIdName": z.boolean(),
    "Comfy.NodeSuggestions.number": z.number(),
    "Comfy.Node.ShowDeprecated": z.boolean(),
    "Comfy.Node.ShowExperimental": z.boolean(),
    "Comfy.PreviewFormat": z.string(),
    "Comfy.PromptFilename": z.boolean(),
    "Comfy.Sidebar.Location": z.enum(["left", "right"]),
    "Comfy.Sidebar.Size": z.number(),
    "Comfy.SwitchUser": z.any(),
    "Comfy.SnapToGrid.GridSize": z.number(),
    "Comfy.TextareaWidget.FontSize": z.number(),
    "Comfy.TextareaWidget.Spellcheck": z.boolean(),
    "Comfy.TreeExplorer.ItemPadding": z.number(),
    "Comfy.UseNewMenu": z.any(),
    "Comfy.Validation.Workflows": z.boolean(),
    "Comfy.Workflow.SortNodeIdOnSave": z.boolean(),
    "Comfy.Queue.ImageFit": z.enum(["contain", "cover"]),
    "Comfy.Workflow.ModelDownload.AllowedSources": z.array(z.string()),
    "Comfy.Workflow.ModelDownload.AllowedSuffixes": z.array(z.string()),
    "Comfy.Node.DoubleClickTitleToEdit": z.boolean(),
    "Comfy.Window.UnloadConfirmation": z.boolean()
  }).optional()
);
"use strict";
function bind$2(fn, thisArg) {
  return /* @__PURE__ */ __name(function wrap() {
    return fn.apply(thisArg, arguments);
  }, "wrap");
}
__name(bind$2, "bind$2");
"use strict";
const { toString: toString$2 } = Object.prototype;
const { getPrototypeOf } = Object;
const kindOf = /* @__PURE__ */ ((cache2) => (thing) => {
  const str = toString$2.call(thing);
  return cache2[str] || (cache2[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
const kindOfTest = /* @__PURE__ */ __name((type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
}, "kindOfTest");
const typeOfTest = /* @__PURE__ */ __name((type) => (thing) => typeof thing === type, "typeOfTest");
const { isArray: isArray$2 } = Array;
const isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction$2(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
__name(isBuffer, "isBuffer");
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
__name(isArrayBufferView, "isArrayBufferView");
const isString$3 = typeOfTest("string");
const isFunction$2 = typeOfTest("function");
const isNumber$2 = typeOfTest("number");
const isObject$4 = /* @__PURE__ */ __name((thing) => thing !== null && typeof thing === "object", "isObject$4");
const isBoolean$2 = /* @__PURE__ */ __name((thing) => thing === true || thing === false, "isBoolean$2");
const isPlainObject$2 = /* @__PURE__ */ __name((val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype2 = getPrototypeOf(val);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
}, "isPlainObject$2");
const isDate$1 = kindOfTest("Date");
const isFile = kindOfTest("File");
const isBlob = kindOfTest("Blob");
const isFileList = kindOfTest("FileList");
const isStream = /* @__PURE__ */ __name((val) => isObject$4(val) && isFunction$2(val.pipe), "isStream");
const isFormData = /* @__PURE__ */ __name((thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction$2(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction$2(thing.toString) && thing.toString() === "[object FormData]"));
}, "isFormData");
const isURLSearchParams = kindOfTest("URLSearchParams");
const [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
const trim = /* @__PURE__ */ __name((str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""), "trim");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i2;
  let l;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray$2(obj)) {
    for (i2 = 0, l = obj.length; i2 < l; i2++) {
      fn.call(null, obj[i2], i2, obj);
    }
  } else {
    const keys2 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys2.length;
    let key;
    for (i2 = 0; i2 < len; i2++) {
      key = keys2[i2];
      fn.call(null, obj[key], key, obj);
    }
  }
}
__name(forEach, "forEach");
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys2 = Object.keys(obj);
  let i2 = keys2.length;
  let _key;
  while (i2-- > 0) {
    _key = keys2[i2];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
__name(findKey, "findKey");
const _global$2 = (() => {
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
const isContextDefined = /* @__PURE__ */ __name((context) => !isUndefined(context) && context !== _global$2, "isContextDefined");
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = /* @__PURE__ */ __name((val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject$2(result[targetKey]) && isPlainObject$2(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject$2(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray$2(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  }, "assignValue");
  for (let i2 = 0, l = arguments.length; i2 < l; i2++) {
    arguments[i2] && forEach(arguments[i2], assignValue);
  }
  return result;
}
__name(merge, "merge");
const extend = /* @__PURE__ */ __name((a, b, thisArg, { allOwnKeys } = {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction$2(val)) {
      a[key] = bind$2(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
}, "extend");
const stripBOM = /* @__PURE__ */ __name((content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
}, "stripBOM");
const inherits = /* @__PURE__ */ __name((constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
}, "inherits");
const toFlatObject = /* @__PURE__ */ __name((sourceObj, destObj, filter4, propFilter) => {
  let props;
  let i2;
  let prop2;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null) return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i2 = props.length;
    while (i2-- > 0) {
      prop2 = props[i2];
      if ((!propFilter || propFilter(prop2, sourceObj, destObj)) && !merged[prop2]) {
        destObj[prop2] = sourceObj[prop2];
        merged[prop2] = true;
      }
    }
    sourceObj = filter4 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter4 || filter4(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
}, "toFlatObject");
const endsWith = /* @__PURE__ */ __name((str, searchString, position2) => {
  str = String(str);
  if (position2 === void 0 || position2 > str.length) {
    position2 = str.length;
  }
  position2 -= searchString.length;
  const lastIndex = str.indexOf(searchString, position2);
  return lastIndex !== -1 && lastIndex === position2;
}, "endsWith");
const toArray = /* @__PURE__ */ __name((thing) => {
  if (!thing) return null;
  if (isArray$2(thing)) return thing;
  let i2 = thing.length;
  if (!isNumber$2(i2)) return null;
  const arr = new Array(i2);
  while (i2-- > 0) {
    arr[i2] = thing[i2];
  }
  return arr;
}, "toArray");
const isTypedArray = /* @__PURE__ */ ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
const forEachEntry = /* @__PURE__ */ __name((obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
}, "forEachEntry");
const matchAll = /* @__PURE__ */ __name((regExp, str) => {
  let matches2;
  const arr = [];
  while ((matches2 = regExp.exec(str)) !== null) {
    arr.push(matches2);
  }
  return arr;
}, "matchAll");
const isHTMLForm = kindOfTest("HTMLFormElement");
const toCamelCase = /* @__PURE__ */ __name((str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    /* @__PURE__ */ __name(function replacer2(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }, "replacer")
  );
}, "toCamelCase");
const hasOwnProperty$1 = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop2) => hasOwnProperty2.call(obj, prop2))(Object.prototype);
const isRegExp$1 = kindOfTest("RegExp");
const reduceDescriptors = /* @__PURE__ */ __name((obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
}, "reduceDescriptors");
const freezeMethods = /* @__PURE__ */ __name((obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction$2(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value3 = obj[name];
    if (!isFunction$2(value3)) return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
}, "freezeMethods");
const toObjectSet = /* @__PURE__ */ __name((arrayOrString, delimiter) => {
  const obj = {};
  const define = /* @__PURE__ */ __name((arr) => {
    arr.forEach((value3) => {
      obj[value3] = true;
    });
  }, "define");
  isArray$2(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
}, "toObjectSet");
const noop$2 = /* @__PURE__ */ __name(() => {
}, "noop$2");
const toFiniteNumber = /* @__PURE__ */ __name((value3, defaultValue) => {
  return value3 != null && Number.isFinite(value3 = +value3) ? value3 : defaultValue;
}, "toFiniteNumber");
const ALPHA = "abcdefghijklmnopqrstuvwxyz";
const DIGIT = "0123456789";
const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
const generateString = /* @__PURE__ */ __name((size2 = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length } = alphabet;
  while (size2--) {
    str += alphabet[Math.random() * length | 0];
  }
  return str;
}, "generateString");
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction$2(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
__name(isSpecCompliantForm, "isSpecCompliantForm");
const toJSONObject = /* @__PURE__ */ __name((obj) => {
  const stack2 = new Array(10);
  const visit = /* @__PURE__ */ __name((source, i2) => {
    if (isObject$4(source)) {
      if (stack2.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack2[i2] = source;
        const target = isArray$2(source) ? [] : {};
        forEach(source, (value3, key) => {
          const reducedValue = visit(value3, i2 + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack2[i2] = void 0;
        return target;
      }
    }
    return source;
  }, "visit");
  return visit(obj, 0);
}, "toJSONObject");
const isAsyncFn = kindOfTest("AsyncFunction");
const isThenable = /* @__PURE__ */ __name((thing) => thing && (isObject$4(thing) || isFunction$2(thing)) && isFunction$2(thing.then) && isFunction$2(thing.catch), "isThenable");
const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }
  return postMessageSupported ? ((token, callbacks) => {
    _global$2.addEventListener("message", ({ source, data: data24 }) => {
      if (source === _global$2 && data24 === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);
    return (cb) => {
      callbacks.push(cb);
      _global$2.postMessage(token, "*");
    };
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === "function",
  isFunction$2(_global$2.postMessage)
);
const asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global$2) : typeof process !== "undefined" && process.nextTick || _setImmediate;
const utils$1 = {
  isArray: isArray$2,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString: isString$3,
  isNumber: isNumber$2,
  isBoolean: isBoolean$2,
  isObject: isObject$4,
  isPlainObject: isPlainObject$2,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate: isDate$1,
  isFile,
  isBlob,
  isRegExp: isRegExp$1,
  isFunction: isFunction$2,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty: hasOwnProperty$1,
  hasOwnProp: hasOwnProperty$1,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop: noop$2,
  toFiniteNumber,
  findKey,
  global: _global$2,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap
};
"use strict";
function AxiosError$1(message3, code2, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message3;
  this.name = "AxiosError";
  code2 && (this.code = code2);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}
__name(AxiosError$1, "AxiosError$1");
utils$1.inherits(AxiosError$1, Error, {
  toJSON: /* @__PURE__ */ __name(function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils$1.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }, "toJSON")
});
const prototype$1 = AxiosError$1.prototype;
const descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code2) => {
  descriptors[code2] = { value: code2 };
});
Object.defineProperties(AxiosError$1, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: true });
AxiosError$1.from = (error, code2, config, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);
  utils$1.toFlatObject(error, axiosError, /* @__PURE__ */ __name(function filter4(obj) {
    return obj !== Error.prototype;
  }, "filter"), (prop2) => {
    return prop2 !== "isAxiosError";
  });
  AxiosError$1.call(axiosError, error.message, code2, config, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
const httpAdapter = null;
"use strict";
function isVisitable(thing) {
  return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
}
__name(isVisitable, "isVisitable");
function removeBrackets(key) {
  return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
__name(removeBrackets, "removeBrackets");
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(/* @__PURE__ */ __name(function each(token, i2) {
    token = removeBrackets(token);
    return !dots && i2 ? "[" + token + "]" : token;
  }, "each")).join(dots ? "." : "");
}
__name(renderKey, "renderKey");
function isFlatArray(arr) {
  return utils$1.isArray(arr) && !arr.some(isVisitable);
}
__name(isFlatArray, "isFlatArray");
const predicates = utils$1.toFlatObject(utils$1, {}, null, /* @__PURE__ */ __name(function filter3(prop2) {
  return /^is[A-Z]/.test(prop2);
}, "filter"));
function toFormData$1(obj, formData, options3) {
  if (!utils$1.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (httpAdapter || FormData)();
  options3 = utils$1.toFlatObject(options3, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, /* @__PURE__ */ __name(function defined(option4, source) {
    return !utils$1.isUndefined(source[option4]);
  }, "defined"));
  const metaTokens = options3.metaTokens;
  const visitor = options3.visitor || defaultVisitor;
  const dots = options3.dots;
  const indexes = options3.indexes;
  const _Blob = options3.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
  if (!utils$1.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value3) {
    if (value3 === null) return "";
    if (utils$1.isDate(value3)) {
      return value3.toISOString();
    }
    if (!useBlob && utils$1.isBlob(value3)) {
      throw new AxiosError$1("Blob is not supported. Use a Buffer instead.");
    }
    if (utils$1.isArrayBuffer(value3) || utils$1.isTypedArray(value3)) {
      return useBlob && typeof Blob === "function" ? new Blob([value3]) : Buffer.from(value3);
    }
    return value3;
  }
  __name(convertValue, "convertValue");
  function defaultVisitor(value3, key, path) {
    let arr = value3;
    if (value3 && !path && typeof value3 === "object") {
      if (utils$1.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value3 = JSON.stringify(value3);
      } else if (utils$1.isArray(value3) && isFlatArray(value3) || (utils$1.isFileList(value3) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value3))) {
        key = removeBrackets(key);
        arr.forEach(/* @__PURE__ */ __name(function each(el, index2) {
          !(utils$1.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        }, "each"));
        return false;
      }
    }
    if (isVisitable(value3)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value3));
    return false;
  }
  __name(defaultVisitor, "defaultVisitor");
  const stack2 = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value3, path) {
    if (utils$1.isUndefined(value3)) return;
    if (stack2.indexOf(value3) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack2.push(value3);
    utils$1.forEach(value3, /* @__PURE__ */ __name(function each(el, key) {
      const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils$1.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    }, "each"));
    stack2.pop();
  }
  __name(build, "build");
  if (!utils$1.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
__name(toFormData$1, "toFormData$1");
"use strict";
function encode$1(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, /* @__PURE__ */ __name(function replacer2(match) {
    return charMap[match];
  }, "replacer"));
}
__name(encode$1, "encode$1");
function AxiosURLSearchParams(params, options3) {
  this._pairs = [];
  params && toFormData$1(params, this, options3);
}
__name(AxiosURLSearchParams, "AxiosURLSearchParams");
const prototype = AxiosURLSearchParams.prototype;
prototype.append = /* @__PURE__ */ __name(function append(name, value3) {
  this._pairs.push([name, value3]);
}, "append");
prototype.toString = /* @__PURE__ */ __name(function toString2(encoder) {
  const _encode = encoder ? function(value3) {
    return encoder.call(this, value3, encode$1);
  } : encode$1;
  return this._pairs.map(/* @__PURE__ */ __name(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "each"), "").join("&");
}, "toString");
"use strict";
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
__name(encode, "encode");
function buildURL(url, params, options3) {
  if (!params) {
    return url;
  }
  const _encode = options3 && options3.encode || encode;
  const serializeFn = options3 && options3.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options3);
  } else {
    serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options3).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}
__name(buildURL, "buildURL");
"use strict";
class InterceptorManager {
  static {
    __name(this, "InterceptorManager");
  }
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options3) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options3 ? options3.synchronous : false,
      runWhen: options3 ? options3.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id2) {
    if (this.handlers[id2]) {
      this.handlers[id2] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils$1.forEach(this.handlers, /* @__PURE__ */ __name(function forEachHandler(h2) {
      if (h2 !== null) {
        fn(h2);
      }
    }, "forEachHandler"));
  }
}
"use strict";
const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
"use strict";
const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
"use strict";
const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
"use strict";
const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
const platform$1 = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
const hasStandardBrowserEnv = ((product) => {
  return hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(product) < 0;
})(typeof navigator !== "undefined" && navigator.product);
const hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
const origin = hasBrowserEnv && window.location.href || "http://localhost";
const utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv,
  hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv,
  origin
}, Symbol.toStringTag, { value: "Module" }));
const platform = {
  ...utils,
  ...platform$1
};
"use strict";
function toURLEncodedForm(data24, options3) {
  return toFormData$1(data24, new platform.classes.URLSearchParams(), Object.assign({
    visitor: /* @__PURE__ */ __name(function(value3, key, path, helpers) {
      if (platform.isNode && utils$1.isBuffer(value3)) {
        this.append(key, value3.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }, "visitor")
  }, options3));
}
__name(toURLEncodedForm, "toURLEncodedForm");
"use strict";
function parsePropPath(name) {
  return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
__name(parsePropPath, "parsePropPath");
function arrayToObject(arr) {
  const obj = {};
  const keys2 = Object.keys(arr);
  let i2;
  const len = keys2.length;
  let key;
  for (i2 = 0; i2 < len; i2++) {
    key = keys2[i2];
    obj[key] = arr[key];
  }
  return obj;
}
__name(arrayToObject, "arrayToObject");
function formDataToJSON(formData) {
  function buildPath(path, value3, target, index2) {
    let name = path[index2++];
    if (name === "__proto__") return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index2 >= path.length;
    name = !name && utils$1.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils$1.hasOwnProp(target, name)) {
        target[name] = [target[name], value3];
      } else {
        target[name] = value3;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils$1.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path, value3, target[name], index2);
    if (result && utils$1.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  __name(buildPath, "buildPath");
  if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
    const obj = {};
    utils$1.forEachEntry(formData, (name, value3) => {
      buildPath(parsePropPath(name), value3, obj, 0);
    });
    return obj;
  }
  return null;
}
__name(formDataToJSON, "formDataToJSON");
"use strict";
function stringifySafely(rawValue, parser, encoder) {
  if (utils$1.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$1.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
__name(stringifySafely, "stringifySafely");
const defaults$1 = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [/* @__PURE__ */ __name(function transformRequest(data24, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils$1.isObject(data24);
    if (isObjectPayload && utils$1.isHTMLForm(data24)) {
      data24 = new FormData(data24);
    }
    const isFormData2 = utils$1.isFormData(data24);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data24)) : data24;
    }
    if (utils$1.isArrayBuffer(data24) || utils$1.isBuffer(data24) || utils$1.isStream(data24) || utils$1.isFile(data24) || utils$1.isBlob(data24) || utils$1.isReadableStream(data24)) {
      return data24;
    }
    if (utils$1.isArrayBufferView(data24)) {
      return data24.buffer;
    }
    if (utils$1.isURLSearchParams(data24)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data24.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data24, this.formSerializer).toString();
      }
      if ((isFileList2 = utils$1.isFileList(data24)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData$1(
          isFileList2 ? { "files[]": data24 } : data24,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data24);
    }
    return data24;
  }, "transformRequest")],
  transformResponse: [/* @__PURE__ */ __name(function transformResponse(data24) {
    const transitional2 = this.transitional || defaults$1.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils$1.isResponse(data24) || utils$1.isReadableStream(data24)) {
      return data24;
    }
    if (data24 && utils$1.isString(data24) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data24);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw AxiosError$1.from(e, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data24;
  }, "transformResponse")],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },
  validateStatus: /* @__PURE__ */ __name(function validateStatus(status) {
    return status >= 200 && status < 300;
  }, "validateStatus"),
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults$1.headers[method] = {};
});
"use strict";
const ignoreDuplicateOf = utils$1.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
const parseHeaders = /* @__PURE__ */ __name((rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i2;
  rawHeaders && rawHeaders.split("\n").forEach(/* @__PURE__ */ __name(function parser(line) {
    i2 = line.indexOf(":");
    key = line.substring(0, i2).trim().toLowerCase();
    val = line.substring(i2 + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  }, "parser"));
  return parsed;
}, "parseHeaders");
"use strict";
const $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
__name(normalizeHeader, "normalizeHeader");
function normalizeValue(value3) {
  if (value3 === false || value3 == null) {
    return value3;
  }
  return utils$1.isArray(value3) ? value3.map(normalizeValue) : String(value3);
}
__name(normalizeValue, "normalizeValue");
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
__name(parseTokens, "parseTokens");
const isValidHeaderName = /* @__PURE__ */ __name((str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim()), "isValidHeaderName");
function matchHeaderValue(context, value3, header, filter4, isHeaderNameFilter) {
  if (utils$1.isFunction(filter4)) {
    return filter4.call(this, value3, header);
  }
  if (isHeaderNameFilter) {
    value3 = header;
  }
  if (!utils$1.isString(value3)) return;
  if (utils$1.isString(filter4)) {
    return value3.indexOf(filter4) !== -1;
  }
  if (utils$1.isRegExp(filter4)) {
    return filter4.test(value3);
  }
}
__name(matchHeaderValue, "matchHeaderValue");
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char, str) => {
    return char.toUpperCase() + str;
  });
}
__name(formatHeader, "formatHeader");
function buildAccessors(obj, header) {
  const accessorName = utils$1.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: /* @__PURE__ */ __name(function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      }, "value"),
      configurable: true
    });
  });
}
__name(buildAccessors, "buildAccessors");
let AxiosHeaders$1 = class AxiosHeaders2 {
  static {
    __name(this, "AxiosHeaders");
  }
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils$1.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    __name(setHeader, "setHeader");
    const setHeaders = /* @__PURE__ */ __name((headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite)), "setHeaders");
    if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else if (utils$1.isHeaders(header)) {
      for (const [key, value3] of header.entries()) {
        setHeader(value3, key, rewrite);
      }
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$1.findKey(this, header);
      if (key) {
        const value3 = this[key];
        if (!parser) {
          return value3;
        }
        if (parser === true) {
          return parseTokens(value3);
        }
        if (utils$1.isFunction(parser)) {
          return parser.call(this, value3, key);
        }
        if (utils$1.isRegExp(parser)) {
          return parser.exec(value3);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$1.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils$1.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    __name(deleteHeader, "deleteHeader");
    if (utils$1.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys2 = Object.keys(this);
    let i2 = keys2.length;
    let deleted = false;
    while (i2--) {
      const key = keys2[i2];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format2) {
    const self2 = this;
    const headers = {};
    utils$1.forEach(this, (value3, header) => {
      const key = utils$1.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value3);
        delete self2[header];
        return;
      }
      const normalized = format2 ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value3);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils$1.forEach(this, (value3, header) => {
      value3 != null && value3 !== false && (obj[header] = asStrings && utils$1.isArray(value3) ? value3.join(", ") : value3);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value3]) => header + ": " + value3).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed2 = new this(first);
    targets.forEach((target) => computed2.set(target));
    return computed2;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype2 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype2, _header);
        accessors[lHeader] = true;
      }
    }
    __name(defineAccessor, "defineAccessor");
    utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders$1.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils$1.reduceDescriptors(AxiosHeaders$1.prototype, ({ value: value3 }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: /* @__PURE__ */ __name(() => value3, "get"),
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils$1.freezeMethods(AxiosHeaders$1);
"use strict";
function transformData(fns, response) {
  const config = this || defaults$1;
  const context = response || config;
  const headers = AxiosHeaders$1.from(context.headers);
  let data24 = context.data;
  utils$1.forEach(fns, /* @__PURE__ */ __name(function transform2(fn) {
    data24 = fn.call(config, data24, headers.normalize(), response ? response.status : void 0);
  }, "transform"));
  headers.normalize();
  return data24;
}
__name(transformData, "transformData");
"use strict";
function isCancel$1(value3) {
  return !!(value3 && value3.__CANCEL__);
}
__name(isCancel$1, "isCancel$1");
"use strict";
function CanceledError$1(message3, config, request) {
  AxiosError$1.call(this, message3 == null ? "canceled" : message3, AxiosError$1.ERR_CANCELED, config, request);
  this.name = "CanceledError";
}
__name(CanceledError$1, "CanceledError$1");
utils$1.inherits(CanceledError$1, AxiosError$1, {
  __CANCEL__: true
});
"use strict";
function settle(resolve8, reject2, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve8(response);
  } else {
    reject2(new AxiosError$1(
      "Request failed with status code " + response.status,
      [AxiosError$1.ERR_BAD_REQUEST, AxiosError$1.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}
__name(settle, "settle");
"use strict";
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || "";
}
__name(parseProtocol, "parseProtocol");
"use strict";
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return /* @__PURE__ */ __name(function push(chunkLength) {
    const now2 = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now2;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now2;
    let i2 = tail;
    let bytesCount = 0;
    while (i2 !== head) {
      bytesCount += bytes[i2++];
      i2 = i2 % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now2 - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now2 - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  }, "push");
}
__name(speedometer, "speedometer");
function throttle(fn, freq) {
  let timestamp2 = 0;
  let threshold = 1e3 / freq;
  let lastArgs;
  let timer;
  const invoke2 = /* @__PURE__ */ __name((args, now2 = Date.now()) => {
    timestamp2 = now2;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn.apply(null, args);
  }, "invoke");
  const throttled = /* @__PURE__ */ __name((...args) => {
    const now2 = Date.now();
    const passed = now2 - timestamp2;
    if (passed >= threshold) {
      invoke2(args, now2);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke2(lastArgs);
        }, threshold - passed);
      }
    }
  }, "throttled");
  const flush = /* @__PURE__ */ __name(() => lastArgs && invoke2(lastArgs), "flush");
  return [throttled, flush];
}
__name(throttle, "throttle");
const progressEventReducer = /* @__PURE__ */ __name((listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);
  return throttle((e) => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data24 = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e,
      lengthComputable: total != null,
      [isDownloadStream ? "download" : "upload"]: true
    };
    listener(data24);
  }, freq);
}, "progressEventReducer");
const progressEventDecorator = /* @__PURE__ */ __name((total, throttled) => {
  const lengthComputable = total != null;
  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
}, "progressEventDecorator");
const asyncDecorator = /* @__PURE__ */ __name((fn) => (...args) => utils$1.asap(() => fn(...args)), "asyncDecorator");
"use strict";
const isURLSameOrigin = platform.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  (/* @__PURE__ */ __name(function standardBrowserEnv() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement("a");
    let originURL;
    function resolveURL(url) {
      let href = url;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    __name(resolveURL, "resolveURL");
    originURL = resolveURL(window.location.href);
    return /* @__PURE__ */ __name(function isURLSameOrigin2(requestURL) {
      const parsed = utils$1.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    }, "isURLSameOrigin");
  }, "standardBrowserEnv"))()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  (/* @__PURE__ */ __name(function nonStandardBrowserEnv() {
    return /* @__PURE__ */ __name(function isURLSameOrigin2() {
      return true;
    }, "isURLSameOrigin");
  }, "nonStandardBrowserEnv"))()
);
const cookies = platform.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name, value3, expires, path, domain, secure) {
      const cookie = [name + "=" + encodeURIComponent(value3)];
      utils$1.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils$1.isString(path) && cookie.push("path=" + path);
      utils$1.isString(domain) && cookie.push("domain=" + domain);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
    },
    read(name) {
      const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove(name) {
      this.write(name, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
"use strict";
function isAbsoluteURL$1(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}
__name(isAbsoluteURL$1, "isAbsoluteURL$1");
"use strict";
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
__name(combineURLs, "combineURLs");
"use strict";
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL$1(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
__name(buildFullPath, "buildFullPath");
"use strict";
const headersToObject$1 = /* @__PURE__ */ __name((thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing, "headersToObject$1");
function mergeConfig$1(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, caseless) {
    if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
      return utils$1.merge.call({ caseless }, target, source);
    } else if (utils$1.isPlainObject(source)) {
      return utils$1.merge({}, source);
    } else if (utils$1.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  __name(getMergedValue, "getMergedValue");
  function mergeDeepProperties(a, b, caseless) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(a, b, caseless);
    } else if (!utils$1.isUndefined(a)) {
      return getMergedValue(void 0, a, caseless);
    }
  }
  __name(mergeDeepProperties, "mergeDeepProperties");
  function valueFromConfig2(a, b) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(void 0, b);
    }
  }
  __name(valueFromConfig2, "valueFromConfig2");
  function defaultToConfig2(a, b) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(void 0, b);
    } else if (!utils$1.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
  }
  __name(defaultToConfig2, "defaultToConfig2");
  function mergeDirectKeys(a, b, prop2) {
    if (prop2 in config2) {
      return getMergedValue(a, b);
    } else if (prop2 in config1) {
      return getMergedValue(void 0, a);
    }
  }
  __name(mergeDirectKeys, "mergeDirectKeys");
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: /* @__PURE__ */ __name((a, b) => mergeDeepProperties(headersToObject$1(a), headersToObject$1(b), true), "headers")
  };
  utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), /* @__PURE__ */ __name(function computeConfigValue(prop2) {
    const merge3 = mergeMap[prop2] || mergeDeepProperties;
    const configValue = merge3(config1[prop2], config2[prop2], prop2);
    utils$1.isUndefined(configValue) && merge3 !== mergeDirectKeys || (config[prop2] = configValue);
  }, "computeConfigValue"));
  return config;
}
__name(mergeConfig$1, "mergeConfig$1");
const resolveConfig = /* @__PURE__ */ __name((config) => {
  const newConfig = mergeConfig$1({}, config);
  let { data: data24, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
  newConfig.headers = headers = AxiosHeaders$1.from(headers);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url), config.params, config.paramsSerializer);
  if (auth) {
    headers.set(
      "Authorization",
      "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
    );
  }
  let contentType;
  if (utils$1.isFormData(data24)) {
    if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(void 0);
    } else if ((contentType = headers.getContentType()) !== false) {
      const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
      headers.setContentType([type || "multipart/form-data", ...tokens].join("; "));
    }
  }
  if (platform.hasStandardBrowserEnv) {
    withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
}, "resolveConfig");
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
const xhrAdapter = isXHRAdapterSupported && function(config) {
  return new Promise(/* @__PURE__ */ __name(function dispatchXhrRequest(resolve8, reject2) {
    const _config = resolveConfig(config);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
    let { responseType, onUploadProgress, onDownloadProgress } = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;
    function done() {
      flushUpload && flushUpload();
      flushDownload && flushDownload();
      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
      _config.signal && _config.signal.removeEventListener("abort", onCanceled);
    }
    __name(done, "done");
    let request = new XMLHttpRequest();
    request.open(_config.method.toUpperCase(), _config.url, true);
    request.timeout = _config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders$1.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(/* @__PURE__ */ __name(function _resolve(value3) {
        resolve8(value3);
        done();
      }, "_resolve"), /* @__PURE__ */ __name(function _reject(err) {
        reject2(err);
        done();
      }, "_reject"), response);
      request = null;
    }
    __name(onloadend, "onloadend");
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = /* @__PURE__ */ __name(function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      }, "handleLoad");
    }
    request.onabort = /* @__PURE__ */ __name(function handleAbort() {
      if (!request) {
        return;
      }
      reject2(new AxiosError$1("Request aborted", AxiosError$1.ECONNABORTED, config, request));
      request = null;
    }, "handleAbort");
    request.onerror = /* @__PURE__ */ __name(function handleError2() {
      reject2(new AxiosError$1("Network Error", AxiosError$1.ERR_NETWORK, config, request));
      request = null;
    }, "handleError");
    request.ontimeout = /* @__PURE__ */ __name(function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = _config.transitional || transitionalDefaults;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject2(new AxiosError$1(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError$1.ETIMEDOUT : AxiosError$1.ECONNABORTED,
        config,
        request
      ));
      request = null;
    }, "handleTimeout");
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils$1.forEach(requestHeaders.toJSON(), /* @__PURE__ */ __name(function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      }, "setRequestHeader"));
    }
    if (!utils$1.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = _config.responseType;
    }
    if (onDownloadProgress) {
      [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
      request.addEventListener("progress", downloadThrottled);
    }
    if (onUploadProgress && request.upload) {
      [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
      request.upload.addEventListener("progress", uploadThrottled);
      request.upload.addEventListener("loadend", flushUpload);
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = /* @__PURE__ */ __name((cancel) => {
        if (!request) {
          return;
        }
        reject2(!cancel || cancel.type ? new CanceledError$1(null, config, request) : cancel);
        request.abort();
        request = null;
      }, "onCanceled");
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(_config.url);
    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject2(new AxiosError$1("Unsupported protocol " + protocol + ":", AxiosError$1.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  }, "dispatchXhrRequest"));
};
const composeSignals = /* @__PURE__ */ __name((signals, timeout) => {
  let controller = new AbortController();
  let aborted;
  const onabort = /* @__PURE__ */ __name(function(cancel) {
    if (!aborted) {
      aborted = true;
      unsubscribe();
      const err = cancel instanceof Error ? cancel : this.reason;
      controller.abort(err instanceof AxiosError$1 ? err : new CanceledError$1(err instanceof Error ? err.message : err));
    }
  }, "onabort");
  let timer = timeout && setTimeout(() => {
    onabort(new AxiosError$1(`timeout ${timeout} of ms exceeded`, AxiosError$1.ETIMEDOUT));
  }, timeout);
  const unsubscribe = /* @__PURE__ */ __name(() => {
    if (signals) {
      timer && clearTimeout(timer);
      timer = null;
      signals.forEach((signal2) => {
        signal2 && (signal2.removeEventListener ? signal2.removeEventListener("abort", onabort) : signal2.unsubscribe(onabort));
      });
      signals = null;
    }
  }, "unsubscribe");
  signals.forEach((signal2) => signal2 && signal2.addEventListener && signal2.addEventListener("abort", onabort));
  const { signal } = controller;
  signal.unsubscribe = unsubscribe;
  return [signal, () => {
    timer && clearTimeout(timer);
    timer = null;
  }];
}, "composeSignals");
const streamChunk = /* @__PURE__ */ __name(function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }
  let pos2 = 0;
  let end;
  while (pos2 < len) {
    end = pos2 + chunkSize;
    yield chunk.slice(pos2, end);
    pos2 = end;
  }
}, "streamChunk");
const readBytes = /* @__PURE__ */ __name(async function* (iterable, chunkSize, encode2) {
  for await (const chunk of iterable) {
    yield* streamChunk(ArrayBuffer.isView(chunk) ? chunk : await encode2(String(chunk)), chunkSize);
  }
}, "readBytes");
const trackStream = /* @__PURE__ */ __name((stream, chunkSize, onProgress, onFinish, encode2) => {
  const iterator = readBytes(stream, chunkSize, encode2);
  let bytes = 0;
  let done;
  let _onFinish = /* @__PURE__ */ __name((e) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e);
    }
  }, "_onFinish");
  return new ReadableStream({
    async pull(controller) {
      try {
        const { done: done2, value: value3 } = await iterator.next();
        if (done2) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value3.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value3));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator.return();
    }
  }, {
    highWaterMark: 2
  });
}, "trackStream");
const isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
const encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
const test = /* @__PURE__ */ __name((fn, ...args) => {
  try {
    return !!fn(...args);
  } catch (e) {
    return false;
  }
}, "test");
const supportsRequestStream = isReadableStreamSupported && test(() => {
  let duplexAccessed = false;
  const hasContentType = new Request(platform.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      duplexAccessed = true;
      return "half";
    }
  }).headers.has("Content-Type");
  return duplexAccessed && !hasContentType;
});
const DEFAULT_CHUNK_SIZE = 64 * 1024;
const supportsResponseStream = isReadableStreamSupported && test(() => utils$1.isReadableStream(new Response("").body));
const resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};
isFetchSupported && ((res) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
    !resolvers[type] && (resolvers[type] = utils$1.isFunction(res[type]) ? (res2) => res2[type]() : (_2, config) => {
      throw new AxiosError$1(`Response type '${type}' is not supported`, AxiosError$1.ERR_NOT_SUPPORT, config);
    });
  });
})(new Response());
const getBodyLength = /* @__PURE__ */ __name(async (body) => {
  if (body == null) {
    return 0;
  }
  if (utils$1.isBlob(body)) {
    return body.size;
  }
  if (utils$1.isSpecCompliantForm(body)) {
    return (await new Request(body).arrayBuffer()).byteLength;
  }
  if (utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
    return body.byteLength;
  }
  if (utils$1.isURLSearchParams(body)) {
    body = body + "";
  }
  if (utils$1.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
}, "getBodyLength");
const resolveBodyLength = /* @__PURE__ */ __name(async (headers, body) => {
  const length = utils$1.toFiniteNumber(headers.getContentLength());
  return length == null ? getBodyLength(body) : length;
}, "resolveBodyLength");
const fetchAdapter = isFetchSupported && (async (config) => {
  let {
    url,
    method,
    data: data24,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = "same-origin",
    fetchOptions
  } = resolveConfig(config);
  responseType = responseType ? (responseType + "").toLowerCase() : "text";
  let [composedSignal, stopTimeout] = signal || cancelToken || timeout ? composeSignals([signal, cancelToken], timeout) : [];
  let finished, request;
  const onFinish = /* @__PURE__ */ __name(() => {
    !finished && setTimeout(() => {
      composedSignal && composedSignal.unsubscribe();
    });
    finished = true;
  }, "onFinish");
  let requestContentLength;
  try {
    if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data24)) !== 0) {
      let _request = new Request(url, {
        method: "POST",
        body: data24,
        duplex: "half"
      });
      let contentTypeHeader;
      if (utils$1.isFormData(data24) && (contentTypeHeader = _request.headers.get("content-type"))) {
        headers.setContentType(contentTypeHeader);
      }
      if (_request.body) {
        const [onProgress, flush] = progressEventDecorator(
          requestContentLength,
          progressEventReducer(asyncDecorator(onUploadProgress))
        );
        data24 = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush, encodeText);
      }
    }
    if (!utils$1.isString(withCredentials)) {
      withCredentials = withCredentials ? "include" : "omit";
    }
    request = new Request(url, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data24,
      duplex: "half",
      credentials: withCredentials
    });
    let response = await fetch(request);
    const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
    if (supportsResponseStream && (onDownloadProgress || isStreamResponse)) {
      const options3 = {};
      ["status", "statusText", "headers"].forEach((prop2) => {
        options3[prop2] = response[prop2];
      });
      const responseContentLength = utils$1.toFiniteNumber(response.headers.get("content-length"));
      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
        responseContentLength,
        progressEventReducer(asyncDecorator(onDownloadProgress), true)
      ) || [];
      response = new Response(
        trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
          flush && flush();
          isStreamResponse && onFinish();
        }, encodeText),
        options3
      );
    }
    responseType = responseType || "text";
    let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || "text"](response, config);
    !isStreamResponse && onFinish();
    stopTimeout && stopTimeout();
    return await new Promise((resolve8, reject2) => {
      settle(resolve8, reject2, {
        data: responseData,
        headers: AxiosHeaders$1.from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config,
        request
      });
    });
  } catch (err) {
    onFinish();
    if (err && err.name === "TypeError" && /fetch/i.test(err.message)) {
      throw Object.assign(
        new AxiosError$1("Network Error", AxiosError$1.ERR_NETWORK, config, request),
        {
          cause: err.cause || err
        }
      );
    }
    throw AxiosError$1.from(err, err && err.code, config, request);
  }
});
const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter,
  fetch: fetchAdapter
};
utils$1.forEach(knownAdapters, (fn, value3) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value: value3 });
    } catch (e) {
    }
    Object.defineProperty(fn, "adapterName", { value: value3 });
  }
});
const renderReason = /* @__PURE__ */ __name((reason) => `- ${reason}`, "renderReason");
const isResolvedHandle = /* @__PURE__ */ __name((adapter2) => utils$1.isFunction(adapter2) || adapter2 === null || adapter2 === false, "isResolvedHandle");
const adapters = {
  getAdapter: /* @__PURE__ */ __name((adapters2) => {
    adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
    const { length } = adapters2;
    let nameOrAdapter;
    let adapter2;
    const rejectedReasons = {};
    for (let i2 = 0; i2 < length; i2++) {
      nameOrAdapter = adapters2[i2];
      let id2;
      adapter2 = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter2 = knownAdapters[(id2 = String(nameOrAdapter)).toLowerCase()];
        if (adapter2 === void 0) {
          throw new AxiosError$1(`Unknown adapter '${id2}'`);
        }
      }
      if (adapter2) {
        break;
      }
      rejectedReasons[id2 || "#" + i2] = adapter2;
    }
    if (!adapter2) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id2, state]) => `adapter ${id2} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError$1(
        `There is no suitable adapter to dispatch the request ` + s,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter2;
  }, "getAdapter"),
  adapters: knownAdapters
};
"use strict";
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError$1(null, config);
  }
}
__name(throwIfCancellationRequested, "throwIfCancellationRequested");
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders$1.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter2 = adapters.getAdapter(config.adapter || defaults$1.adapter);
  return adapter2(config).then(/* @__PURE__ */ __name(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders$1.from(response.headers);
    return response;
  }, "onAdapterResolution"), /* @__PURE__ */ __name(function onAdapterRejection(reason) {
    if (!isCancel$1(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  }, "onAdapterRejection"));
}
__name(dispatchRequest, "dispatchRequest");
const VERSION$3 = "1.7.4";
"use strict";
const validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i2) => {
  validators$1[type] = /* @__PURE__ */ __name(function validator3(thing) {
    return typeof thing === type || "a" + (i2 < 1 ? "n " : " ") + type;
  }, "validator");
});
const deprecatedWarnings = {};
validators$1.transitional = /* @__PURE__ */ __name(function transitional(validator3, version2, message3) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION$3 + "] Transitional option '" + opt + "'" + desc + (message3 ? ". " + message3 : "");
  }
  __name(formatMessage, "formatMessage");
  return (value3, opt, opts) => {
    if (validator3 === false) {
      throw new AxiosError$1(
        formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
        AxiosError$1.ERR_DEPRECATED
      );
    }
    if (version2 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version2 + " and will be removed in the near future"
        )
      );
    }
    return validator3 ? validator3(value3, opt, opts) : true;
  };
}, "transitional");
function assertOptions(options3, schema, allowUnknown) {
  if (typeof options3 !== "object") {
    throw new AxiosError$1("options must be an object", AxiosError$1.ERR_BAD_OPTION_VALUE);
  }
  const keys2 = Object.keys(options3);
  let i2 = keys2.length;
  while (i2-- > 0) {
    const opt = keys2[i2];
    const validator3 = schema[opt];
    if (validator3) {
      const value3 = options3[opt];
      const result = value3 === void 0 || validator3(value3, opt, options3);
      if (result !== true) {
        throw new AxiosError$1("option " + opt + " must be " + result, AxiosError$1.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError$1("Unknown option " + opt, AxiosError$1.ERR_BAD_OPTION);
    }
  }
}
__name(assertOptions, "assertOptions");
const validator = {
  assertOptions,
  validators: validators$1
};
"use strict";
const validators = validator.validators;
let Axios$1 = class Axios2 {
  static {
    __name(this, "Axios");
  }
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy;
        Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : dummy = new Error();
        const stack2 = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err.stack) {
            err.stack = stack2;
          } else if (stack2 && !String(err.stack).endsWith(stack2.replace(/^.+\n.+\n/, ""))) {
            err.stack += "\n" + stack2;
          }
        } catch (e) {
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig$1(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== void 0) {
      validator.assertOptions(transitional2, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils$1.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils$1.merge(
      headers.common,
      headers[config.method]
    );
    headers && utils$1.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(/* @__PURE__ */ __name(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    }, "unshiftRequestInterceptors"));
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(/* @__PURE__ */ __name(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    }, "pushResponseInterceptors"));
    let promise;
    let i2 = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i2 < len) {
        promise = promise.then(chain[i2++], chain[i2++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i2 = 0;
    while (i2 < len) {
      const onFulfilled = requestInterceptorChain[i2++];
      const onRejected = requestInterceptorChain[i2++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i2 = 0;
    len = responseInterceptorChain.length;
    while (i2 < len) {
      promise = promise.then(responseInterceptorChain[i2++], responseInterceptorChain[i2++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig$1(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
};
utils$1.forEach(["delete", "get", "head", "options"], /* @__PURE__ */ __name(function forEachMethodNoData(method) {
  Axios$1.prototype[method] = function(url, config) {
    return this.request(mergeConfig$1(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
}, "forEachMethodNoData"));
utils$1.forEach(["post", "put", "patch"], /* @__PURE__ */ __name(function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return /* @__PURE__ */ __name(function httpMethod(url, data24, config) {
      return this.request(mergeConfig$1(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data: data24
      }));
    }, "httpMethod");
  }
  __name(generateHTTPMethod, "generateHTTPMethod");
  Axios$1.prototype[method] = generateHTTPMethod();
  Axios$1.prototype[method + "Form"] = generateHTTPMethod(true);
}, "forEachMethodWithData"));
"use strict";
let CancelToken$1 = class CancelToken2 {
  static {
    __name(this, "CancelToken");
  }
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(/* @__PURE__ */ __name(function promiseExecutor(resolve8) {
      resolvePromise = resolve8;
    }, "promiseExecutor"));
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners) return;
      let i2 = token._listeners.length;
      while (i2-- > 0) {
        token._listeners[i2](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve8) => {
        token.subscribe(resolve8);
        _resolve = resolve8;
      }).then(onfulfilled);
      promise.cancel = /* @__PURE__ */ __name(function reject2() {
        token.unsubscribe(_resolve);
      }, "reject");
      return promise;
    };
    executor(/* @__PURE__ */ __name(function cancel(message3, config, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError$1(message3, config, request);
      resolvePromise(token.reason);
    }, "cancel"));
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index2 = this._listeners.indexOf(listener);
    if (index2 !== -1) {
      this._listeners.splice(index2, 1);
    }
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken2(/* @__PURE__ */ __name(function executor(c) {
      cancel = c;
    }, "executor"));
    return {
      token,
      cancel
    };
  }
};
"use strict";
function spread$1(callback) {
  return /* @__PURE__ */ __name(function wrap(arr) {
    return callback.apply(null, arr);
  }, "wrap");
}
__name(spread$1, "spread$1");
"use strict";
function isAxiosError$1(payload) {
  return utils$1.isObject(payload) && payload.isAxiosError === true;
}
__name(isAxiosError$1, "isAxiosError$1");
const HttpStatusCode$1 = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode$1).forEach(([key, value3]) => {
  HttpStatusCode$1[value3] = key;
});
"use strict";
function createInstance(defaultConfig) {
  const context = new Axios$1(defaultConfig);
  const instance = bind$2(Axios$1.prototype.request, context);
  utils$1.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
  utils$1.extend(instance, context, null, { allOwnKeys: true });
  instance.create = /* @__PURE__ */ __name(function create2(instanceConfig) {
    return createInstance(mergeConfig$1(defaultConfig, instanceConfig));
  }, "create");
  return instance;
}
__name(createInstance, "createInstance");
const axios = createInstance(defaults$1);
axios.Axios = Axios$1;
axios.CanceledError = CanceledError$1;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel$1;
axios.VERSION = VERSION$3;
axios.toFormData = toFormData$1;
axios.AxiosError = AxiosError$1;
axios.Cancel = axios.CanceledError;
axios.all = /* @__PURE__ */ __name(function all2(promises) {
  return Promise.all(promises);
}, "all");
axios.spread = spread$1;
axios.isAxiosError = isAxiosError$1;
axios.mergeConfig = mergeConfig$1;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters.getAdapter;
axios.HttpStatusCode = HttpStatusCode$1;
axios.default = axios;
const {
  Axios,
  AxiosError,
  CanceledError,
  isCancel,
  CancelToken,
  VERSION: VERSION$2,
  all,
  Cancel,
  isAxiosError,
  spread,
  toFormData,
  AxiosHeaders,
  HttpStatusCode,
  formToJSON,
  getAdapter,
  mergeConfig
} = axios;
class ComfyApi extends EventTarget {
  static {
    __name(this, "ComfyApi");
  }
  #registered = /* @__PURE__ */ new Set();
  api_host;
  api_base;
  initialClientId;
  user;
  socket;
  clientId;
  reportedUnknownMessageTypes = /* @__PURE__ */ new Set();
  constructor() {
    super();
    this.api_host = location.host;
    this.api_base = location.pathname.split("/").slice(0, -1).join("/");
    this.initialClientId = sessionStorage.getItem("clientId");
  }
  internalURL(route) {
    return this.api_base + "/internal" + route;
  }
  apiURL(route) {
    return this.api_base + "/api" + route;
  }
  fileURL(route) {
    return this.api_base + route;
  }
  fetchApi(route, options3) {
    if (!options3) {
      options3 = {};
    }
    if (!options3.headers) {
      options3.headers = {};
    }
    if (!options3.cache) {
      options3.cache = "no-cache";
    }
    options3.headers["Comfy-User"] = this.user;
    return fetch(this.apiURL(route), options3);
  }
  addEventListener(type, callback, options3) {
    super.addEventListener(type, callback, options3);
    this.#registered.add(type);
  }
  /**
   * Poll status  for colab and other things that don't support websockets.
   */
  #pollQueue() {
    setInterval(async () => {
      try {
        const resp = await this.fetchApi("/prompt");
        const status = await resp.json();
        this.dispatchEvent(new CustomEvent("status", { detail: status }));
      } catch (error) {
        this.dispatchEvent(new CustomEvent("status", { detail: null }));
      }
    }, 1e3);
  }
  /**
   * Creates and connects a WebSocket for realtime updates
   * @param {boolean} isReconnect If the socket is connection is a reconnect attempt
   */
  #createSocket(isReconnect) {
    if (this.socket) {
      return;
    }
    let opened = false;
    let existingSession = window.name;
    if (existingSession) {
      existingSession = "?clientId=" + existingSession;
    }
    this.socket = new WebSocket(
      `ws${window.location.protocol === "https:" ? "s" : ""}://${this.api_host}${this.api_base}/ws${existingSession}`
    );
    this.socket.binaryType = "arraybuffer";
    this.socket.addEventListener("open", () => {
      opened = true;
      if (isReconnect) {
        this.dispatchEvent(new CustomEvent("reconnected"));
      }
    });
    this.socket.addEventListener("error", () => {
      if (this.socket) this.socket.close();
      if (!isReconnect && !opened) {
        this.#pollQueue();
      }
    });
    this.socket.addEventListener("close", () => {
      setTimeout(() => {
        this.socket = null;
        this.#createSocket(true);
      }, 300);
      if (opened) {
        this.dispatchEvent(new CustomEvent("status", { detail: null }));
        this.dispatchEvent(new CustomEvent("reconnecting"));
      }
    });
    this.socket.addEventListener("message", (event2) => {
      try {
        if (event2.data instanceof ArrayBuffer) {
          const view = new DataView(event2.data);
          const eventType = view.getUint32(0);
          const buffer2 = event2.data.slice(4);
          switch (eventType) {
            case 1:
              const view2 = new DataView(event2.data);
              const imageType = view2.getUint32(0);
              let imageMime;
              switch (imageType) {
                case 1:
                default:
                  imageMime = "image/jpeg";
                  break;
                case 2:
                  imageMime = "image/png";
              }
              const imageBlob = new Blob([buffer2.slice(4)], {
                type: imageMime
              });
              this.dispatchEvent(
                new CustomEvent("b_preview", { detail: imageBlob })
              );
              break;
            default:
              throw new Error(
                `Unknown binary websocket message of type ${eventType}`
              );
          }
        } else {
          const msg = JSON.parse(event2.data);
          switch (msg.type) {
            case "status":
              if (msg.data.sid) {
                this.clientId = msg.data.sid;
                window.name = this.clientId;
                sessionStorage.setItem("clientId", this.clientId);
              }
              this.dispatchEvent(
                new CustomEvent("status", { detail: msg.data.status })
              );
              break;
            case "progress":
              this.dispatchEvent(
                new CustomEvent("progress", { detail: msg.data })
              );
              break;
            case "executing":
              this.dispatchEvent(
                new CustomEvent("executing", {
                  detail: msg.data.display_node || msg.data.node
                })
              );
              break;
            case "executed":
              this.dispatchEvent(
                new CustomEvent("executed", { detail: msg.data })
              );
              break;
            case "execution_start":
              this.dispatchEvent(
                new CustomEvent("execution_start", { detail: msg.data })
              );
              break;
            case "execution_success":
              this.dispatchEvent(
                new CustomEvent("execution_success", { detail: msg.data })
              );
              break;
            case "execution_error":
              this.dispatchEvent(
                new CustomEvent("execution_error", { detail: msg.data })
              );
              break;
            case "execution_cached":
              this.dispatchEvent(
                new CustomEvent("execution_cached", { detail: msg.data })
              );
              break;
            case "download_progress":
              this.dispatchEvent(
                new CustomEvent("download_progress", { detail: msg.data })
              );
              break;
            default:
              if (this.#registered.has(msg.type)) {
                this.dispatchEvent(
                  new CustomEvent(msg.type, { detail: msg.data })
                );
              } else if (!this.reportedUnknownMessageTypes.has(msg.type)) {
                this.reportedUnknownMessageTypes.add(msg.type);
                throw new Error(`Unknown message type ${msg.type}`);
              }
          }
        }
      } catch (error) {
        console.warn("Unhandled message:", event2.data, error);
      }
    });
  }
  /**
   * Initialises sockets and realtime updates
   */
  init() {
    this.#createSocket();
  }
  /**
   * Gets a list of extension urls
   */
  async getExtensions() {
    const resp = await this.fetchApi("/extensions", { cache: "no-store" });
    return await resp.json();
  }
  /**
   * Gets a list of embedding names
   */
  async getEmbeddings() {
    const resp = await this.fetchApi("/embeddings", { cache: "no-store" });
    return await resp.json();
  }
  /**
   * Loads node object definitions for the graph
   * @returns The node definitions
   */
  async getNodeDefs() {
    const resp = await this.fetchApi("/object_info", { cache: "no-store" });
    const objectInfoUnsafe = await resp.json();
    const objectInfo = {};
    for (const key in objectInfoUnsafe) {
      const validatedDef = validateComfyNodeDef(
        objectInfoUnsafe[key],
        /* onError=*/
        (errorMessage) => {
          console.warn(
            `Skipping invalid node definition: ${key}. See debug log for more information.`
          );
          console.debug(errorMessage);
        }
      );
      if (validatedDef !== null) {
        objectInfo[key] = validatedDef;
      }
    }
    return objectInfo;
  }
  /**
   *
   * @param {number} number The index at which to queue the prompt, passing -1 will insert the prompt at the front of the queue
   * @param {object} prompt The prompt data to queue
   */
  async queuePrompt(number2, { output, workflow }) {
    const body = {
      client_id: this.clientId,
      prompt: output,
      extra_data: { extra_pnginfo: { workflow } }
    };
    if (number2 === -1) {
      body.front = true;
    } else if (number2 != 0) {
      body.number = number2;
    }
    const res = await this.fetchApi("/prompt", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(body)
    });
    if (res.status !== 200) {
      throw {
        response: await res.json()
      };
    }
    return await res.json();
  }
  /**
   * Gets a list of models in the specified folder
   * @param {string} folder The folder to list models from, such as 'checkpoints'
   * @returns The list of model filenames within the specified folder
   */
  async getModels(folder) {
    const res = await this.fetchApi(`/models/${folder}`);
    if (res.status === 404) {
      return null;
    }
    return await res.json();
  }
  /**
   * Gets the metadata for a model
   * @param {string} folder The folder containing the model
   * @param {string} model The model to get metadata for
   * @returns The metadata for the model
   */
  async viewMetadata(folder, model) {
    const res = await this.fetchApi(
      `/view_metadata/${folder}?filename=${encodeURIComponent(model)}`
    );
    return await res.json();
  }
  /**
   * Tells the server to download a model from the specified URL to the specified directory and filename
   * @param {string} url The URL to download the model from
   * @param {string} model_directory The main directory (eg 'checkpoints') to save the model to
   * @param {string} model_filename The filename to save the model as
   * @param {number} progress_interval The interval in seconds at which to report download progress (via 'download_progress' event)
   */
  async internalDownloadModel(url, model_directory, model_filename, progress_interval) {
    const res = await this.fetchApi("/internal/models/download", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        url,
        model_directory,
        model_filename,
        progress_interval
      })
    });
    return await res.json();
  }
  /**
   * Loads a list of items (queue or history)
   * @param {string} type The type of items to load, queue or history
   * @returns The items of the specified type grouped by their status
   */
  async getItems(type) {
    if (type === "queue") {
      return this.getQueue();
    }
    return this.getHistory();
  }
  /**
   * Gets the current state of the queue
   * @returns The currently running and queued items
   */
  async getQueue() {
    try {
      const res = await this.fetchApi("/queue");
      const data24 = await res.json();
      return {
        // Running action uses a different endpoint for cancelling
        Running: data24.queue_running.map((prompt2) => ({
          taskType: "Running",
          prompt: prompt2,
          remove: { name: "Cancel", cb: /* @__PURE__ */ __name(() => api.interrupt(), "cb") }
        })),
        Pending: data24.queue_pending.map((prompt2) => ({
          taskType: "Pending",
          prompt: prompt2
        }))
      };
    } catch (error) {
      console.error(error);
      return { Running: [], Pending: [] };
    }
  }
  /**
   * Gets the prompt execution history
   * @returns Prompt history including node outputs
   */
  async getHistory(max_items = 200) {
    try {
      const res = await this.fetchApi(`/history?max_items=${max_items}`);
      const json = await res.json();
      return {
        History: Object.values(json).map((item2) => ({
          ...item2,
          taskType: "History"
        }))
      };
    } catch (error) {
      console.error(error);
      return { History: [] };
    }
  }
  /**
   * Gets system & device stats
   * @returns System stats such as python version, OS, per device info
   */
  async getSystemStats() {
    const res = await this.fetchApi("/system_stats");
    return await res.json();
  }
  /**
   * Sends a POST request to the API
   * @param {*} type The endpoint to post to
   * @param {*} body Optional POST data
   */
  async #postItem(type, body) {
    try {
      await this.fetchApi("/" + type, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: body ? JSON.stringify(body) : void 0
      });
    } catch (error) {
      console.error(error);
    }
  }
  /**
   * Deletes an item from the specified list
   * @param {string} type The type of item to delete, queue or history
   * @param {number} id The id of the item to delete
   */
  async deleteItem(type, id2) {
    await this.#postItem(type, { delete: [id2] });
  }
  /**
   * Clears the specified list
   * @param {string} type The type of list to clear, queue or history
   */
  async clearItems(type) {
    await this.#postItem(type, { clear: true });
  }
  /**
   * Interrupts the execution of the running prompt
   */
  async interrupt() {
    await this.#postItem("interrupt", null);
  }
  /**
   * Gets user configuration data and where data should be stored
   */
  async getUserConfig() {
    return (await this.fetchApi("/users")).json();
  }
  /**
   * Creates a new user
   * @param { string } username
   * @returns The fetch response
   */
  createUser(username) {
    return this.fetchApi("/users", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ username })
    });
  }
  /**
   * Gets all setting values for the current user
   * @returns { Promise<string, unknown> } A dictionary of id -> value
   */
  async getSettings() {
    return (await this.fetchApi("/settings")).json();
  }
  /**
   * Gets a setting for the current user
   * @param { string } id The id of the setting to fetch
   * @returns { Promise<unknown> } The setting value
   */
  async getSetting(id2) {
    return (await this.fetchApi(`/settings/${encodeURIComponent(id2)}`)).json();
  }
  /**
   * Stores a dictionary of settings for the current user
   */
  async storeSettings(settings) {
    return this.fetchApi(`/settings`, {
      method: "POST",
      body: JSON.stringify(settings)
    });
  }
  /**
   * Stores a setting for the current user
   */
  async storeSetting(id2, value3) {
    return this.fetchApi(`/settings/${encodeURIComponent(id2)}`, {
      method: "POST",
      body: JSON.stringify(value3)
    });
  }
  /**
   * Gets a user data file for the current user
   */
  async getUserData(file, options3) {
    return this.fetchApi(`/userdata/${encodeURIComponent(file)}`, options3);
  }
  /**
   * Stores a user data file for the current user
   * @param { string } file The name of the userdata file to save
   * @param { unknown } data The data to save to the file
   * @param { RequestInit & { stringify?: boolean, throwOnError?: boolean } } [options]
   * @returns { Promise<Response> }
   */
  async storeUserData(file, data24, options3 = { overwrite: true, stringify: true, throwOnError: true }) {
    const resp = await this.fetchApi(
      `/userdata/${encodeURIComponent(file)}?overwrite=${options3.overwrite}`,
      {
        method: "POST",
        body: options3?.stringify ? JSON.stringify(data24) : data24,
        ...options3
      }
    );
    if (resp.status !== 200 && options3.throwOnError !== false) {
      throw new Error(
        `Error storing user data file '${file}': ${resp.status} ${(await resp).statusText}`
      );
    }
    return resp;
  }
  /**
   * Deletes a user data file for the current user
   * @param { string } file The name of the userdata file to delete
   */
  async deleteUserData(file) {
    const resp = await this.fetchApi(`/userdata/${encodeURIComponent(file)}`, {
      method: "DELETE"
    });
    return resp;
  }
  /**
   * Move a user data file for the current user
   * @param { string } source The userdata file to move
   * @param { string } dest The destination for the file
   */
  async moveUserData(source, dest, options3 = { overwrite: false }) {
    const resp = await this.fetchApi(
      `/userdata/${encodeURIComponent(source)}/move/${encodeURIComponent(dest)}?overwrite=${options3?.overwrite}`,
      {
        method: "POST"
      }
    );
    return resp;
  }
  async listUserData(dir, recurse, split) {
    const resp = await this.fetchApi(
      `/userdata?${new URLSearchParams({
        recurse,
        dir,
        split
      })}`
    );
    if (resp.status === 404) return [];
    if (resp.status !== 200) {
      throw new Error(
        `Error getting user data list '${dir}': ${resp.status} ${resp.statusText}`
      );
    }
    return resp.json();
  }
  async getLogs() {
    return (await axios.get(this.internalURL("/logs"))).data;
  }
}
const api = new ComfyApi();
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.api = window.comfyAPI.api || {};
window.comfyAPI.api.api = api;
let ComfyDialog$1 = class ComfyDialog2 extends EventTarget {
  static {
    __name(this, "ComfyDialog");
  }
  element;
  textElement;
  #buttons;
  constructor(type = "div", buttons = null) {
    super();
    this.#buttons = buttons;
    this.element = $el(type + ".comfy-modal", { parent: document.body }, [
      $el("div.comfy-modal-content", [
        $el("p", { $: /* @__PURE__ */ __name((p2) => this.textElement = p2, "$") }),
        ...this.createButtons()
      ])
    ]);
  }
  createButtons() {
    return this.#buttons ?? [
      $el("button", {
        type: "button",
        textContent: "Close",
        onclick: /* @__PURE__ */ __name(() => this.close(), "onclick")
      })
    ];
  }
  close() {
    this.element.style.display = "none";
  }
  show(html) {
    if (typeof html === "string") {
      this.textElement.innerHTML = html;
    } else {
      this.textElement.replaceChildren(
        ...html instanceof Array ? html : [html]
      );
    }
    this.element.style.display = "flex";
  }
};
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.dialog = window.comfyAPI.dialog || {};
window.comfyAPI.dialog.ComfyDialog = ComfyDialog$1;
function toggleSwitch(name, items2, e) {
  const onChange5 = e?.onChange;
  let selectedIndex;
  let elements;
  function updateSelected(index2) {
    if (selectedIndex != null) {
      elements[selectedIndex].classList.remove("comfy-toggle-selected");
    }
    onChange5?.({
      item: items2[index2],
      prev: selectedIndex == null ? void 0 : items2[selectedIndex]
    });
    selectedIndex = index2;
    elements[selectedIndex].classList.add("comfy-toggle-selected");
  }
  __name(updateSelected, "updateSelected");
  elements = items2.map((item2, i2) => {
    if (typeof item2 === "string") item2 = { text: item2 };
    if (!item2.value) item2.value = item2.text;
    const toggle4 = $el(
      "label",
      {
        textContent: item2.text,
        title: item2.tooltip ?? ""
      },
      $el("input", {
        name,
        type: "radio",
        value: item2.value ?? item2.text,
        checked: item2.selected,
        onchange: /* @__PURE__ */ __name(() => {
          updateSelected(i2);
        }, "onchange")
      })
    );
    if (item2.selected) {
      updateSelected(i2);
    }
    return toggle4;
  });
  const container = $el("div.comfy-toggle-switch", elements);
  if (selectedIndex == null) {
    elements[0].children[0].checked = true;
    updateSelected(0);
  }
  return container;
}
__name(toggleSwitch, "toggleSwitch");
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.toggleSwitch = window.comfyAPI.toggleSwitch || {};
window.comfyAPI.toggleSwitch.toggleSwitch = toggleSwitch;
function buildTree(items2, key) {
  const root26 = {
    key: "root",
    label: "root",
    children: []
  };
  const map2 = {
    root: root26
  };
  for (const item2 of items2) {
    const keys2 = typeof key === "string" ? item2[key] : key(item2);
    let parent = root26;
    for (let i2 = 0; i2 < keys2.length; i2++) {
      const k = keys2[i2];
      if (k === "" && i2 === keys2.length - 1) break;
      const id2 = parent.key + "/" + k;
      if (!map2[id2]) {
        const node3 = {
          key: id2,
          label: k,
          leaf: false,
          children: []
        };
        map2[id2] = node3;
        parent.children.push(node3);
      }
      parent = map2[id2];
    }
    parent.leaf = keys2[keys2.length - 1] !== "";
    parent.data = item2;
  }
  return root26;
}
__name(buildTree, "buildTree");
function flattenTree(tree) {
  const result = [];
  const stack2 = [tree];
  while (stack2.length) {
    const node3 = stack2.pop();
    if (node3.leaf && node3.data) result.push(node3.data);
    stack2.push(...node3.children || []);
  }
  return result;
}
__name(flattenTree, "flattenTree");
function sortedTree(node3) {
  const newNode = {
    ...node3
  };
  if (node3.children) {
    const sortedChildren = [...node3.children].sort(
      (a, b) => a.label.localeCompare(b.label)
    );
    newNode.children = [];
    for (const child of sortedChildren) {
      newNode.children.push(sortedTree(child));
    }
  }
  return newNode;
}
__name(sortedTree, "sortedTree");
const findNodeByKey = /* @__PURE__ */ __name((root26, key) => {
  if (root26.key === key) {
    return root26;
  }
  if (!root26.children) {
    return null;
  }
  for (const child of root26.children) {
    const result = findNodeByKey(child, key);
    if (result) {
      return result;
    }
  }
  return null;
}, "findNodeByKey");
var isVue2$2 = false;
var isVue3$2 = true;
var Vue2$2 = void 0;
function install$2() {
}
__name(install$2, "install$2");
function set$3(target, key, val) {
  if (Array.isArray(target)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val;
  }
  target[key] = val;
  return val;
}
__name(set$3, "set$3");
function del$2(target, key) {
  if (Array.isArray(target)) {
    target.splice(key, 1);
    return;
  }
  delete target[key];
}
__name(del$2, "del$2");
function getDevtoolsGlobalHook() {
  return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
__name(getDevtoolsGlobalHook, "getDevtoolsGlobalHook");
function getTarget() {
  return typeof navigator !== "undefined" && typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : {};
}
__name(getTarget, "getTarget");
const isProxyAvailable = typeof Proxy === "function";
const HOOK_SETUP = "devtools-plugin:setup";
const HOOK_PLUGIN_SETTINGS_SET = "plugin:settings:set";
let supported;
let perf;
function isPerformanceSupported() {
  var _a;
  if (supported !== void 0) {
    return supported;
  }
  if (typeof window !== "undefined" && window.performance) {
    supported = true;
    perf = window.performance;
  } else if (typeof globalThis !== "undefined" && ((_a = globalThis.perf_hooks) === null || _a === void 0 ? void 0 : _a.performance)) {
    supported = true;
    perf = globalThis.perf_hooks.performance;
  } else {
    supported = false;
  }
  return supported;
}
__name(isPerformanceSupported, "isPerformanceSupported");
function now$1() {
  return isPerformanceSupported() ? perf.now() : Date.now();
}
__name(now$1, "now$1");
class ApiProxy {
  static {
    __name(this, "ApiProxy");
  }
  constructor(plugin, hook) {
    this.target = null;
    this.targetQueue = [];
    this.onQueue = [];
    this.plugin = plugin;
    this.hook = hook;
    const defaultSettings = {};
    if (plugin.settings) {
      for (const id2 in plugin.settings) {
        const item2 = plugin.settings[id2];
        defaultSettings[id2] = item2.defaultValue;
      }
    }
    const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin.id}`;
    let currentSettings = Object.assign({}, defaultSettings);
    try {
      const raw = localStorage.getItem(localSettingsSaveId);
      const data24 = JSON.parse(raw);
      Object.assign(currentSettings, data24);
    } catch (e) {
    }
    this.fallbacks = {
      getSettings() {
        return currentSettings;
      },
      setSettings(value3) {
        try {
          localStorage.setItem(localSettingsSaveId, JSON.stringify(value3));
        } catch (e) {
        }
        currentSettings = value3;
      },
      now() {
        return now$1();
      }
    };
    if (hook) {
      hook.on(HOOK_PLUGIN_SETTINGS_SET, (pluginId, value3) => {
        if (pluginId === this.plugin.id) {
          this.fallbacks.setSettings(value3);
        }
      });
    }
    this.proxiedOn = new Proxy({}, {
      get: /* @__PURE__ */ __name((_target, prop2) => {
        if (this.target) {
          return this.target.on[prop2];
        } else {
          return (...args) => {
            this.onQueue.push({
              method: prop2,
              args
            });
          };
        }
      }, "get")
    });
    this.proxiedTarget = new Proxy({}, {
      get: /* @__PURE__ */ __name((_target, prop2) => {
        if (this.target) {
          return this.target[prop2];
        } else if (prop2 === "on") {
          return this.proxiedOn;
        } else if (Object.keys(this.fallbacks).includes(prop2)) {
          return (...args) => {
            this.targetQueue.push({
              method: prop2,
              args,
              resolve: /* @__PURE__ */ __name(() => {
              }, "resolve")
            });
            return this.fallbacks[prop2](...args);
          };
        } else {
          return (...args) => {
            return new Promise((resolve8) => {
              this.targetQueue.push({
                method: prop2,
                args,
                resolve: resolve8
              });
            });
          };
        }
      }, "get")
    });
  }
  async setRealTarget(target) {
    this.target = target;
    for (const item2 of this.onQueue) {
      this.target.on[item2.method](...item2.args);
    }
    for (const item2 of this.targetQueue) {
      item2.resolve(await this.target[item2.method](...item2.args));
    }
  }
}
function setupDevtoolsPlugin(pluginDescriptor, setupFn) {
  const descriptor = pluginDescriptor;
  const target = getTarget();
  const hook = getDevtoolsGlobalHook();
  const enableProxy = isProxyAvailable && descriptor.enableEarlyProxy;
  if (hook && (target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {
    hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);
  } else {
    const proxy = enableProxy ? new ApiProxy(descriptor, hook) : null;
    const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];
    list.push({
      pluginDescriptor: descriptor,
      setupFn,
      proxy
    });
    if (proxy) {
      setupFn(proxy.proxiedTarget);
    }
  }
}
__name(setupDevtoolsPlugin, "setupDevtoolsPlugin");
/*!
 * pinia v2.1.7
 * (c) 2023 Eduardo San Martin Morote
 * @license MIT
 */
let activePinia;
const setActivePinia = /* @__PURE__ */ __name((pinia2) => activePinia = pinia2, "setActivePinia");
const getActivePinia = /* @__PURE__ */ __name(() => hasInjectionContext() && inject(piniaSymbol) || activePinia, "getActivePinia");
const piniaSymbol = false ? Symbol("pinia") : (
  /* istanbul ignore next */
  Symbol()
);
function isPlainObject$1(o) {
  return o && typeof o === "object" && Object.prototype.toString.call(o) === "[object Object]" && typeof o.toJSON !== "function";
}
__name(isPlainObject$1, "isPlainObject$1");
var MutationType;
(function(MutationType2) {
  MutationType2["direct"] = "direct";
  MutationType2["patchObject"] = "patch object";
  MutationType2["patchFunction"] = "patch function";
})(MutationType || (MutationType = {}));
const IS_CLIENT = typeof window !== "undefined";
const USE_DEVTOOLS = false;
const _global$1 = /* @__PURE__ */ (() => typeof window === "object" && window.window === window ? window : typeof self === "object" && self.self === self ? self : typeof global === "object" && global.global === global ? global : typeof globalThis === "object" ? globalThis : { HTMLElement: null })();
function bom(blob, { autoBom = false } = {}) {
  if (autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
    return new Blob([String.fromCharCode(65279), blob], { type: blob.type });
  }
  return blob;
}
__name(bom, "bom");
function download(url, name, opts) {
  const xhr = new XMLHttpRequest();
  xhr.open("GET", url);
  xhr.responseType = "blob";
  xhr.onload = function() {
    saveAs(xhr.response, name, opts);
  };
  xhr.onerror = function() {
    console.error("could not download file");
  };
  xhr.send();
}
__name(download, "download");
function corsEnabled(url) {
  const xhr = new XMLHttpRequest();
  xhr.open("HEAD", url, false);
  try {
    xhr.send();
  } catch (e) {
  }
  return xhr.status >= 200 && xhr.status <= 299;
}
__name(corsEnabled, "corsEnabled");
function click(node3) {
  try {
    node3.dispatchEvent(new MouseEvent("click"));
  } catch (e) {
    const evt = document.createEvent("MouseEvents");
    evt.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null);
    node3.dispatchEvent(evt);
  }
}
__name(click, "click");
const _navigator = typeof navigator === "object" ? navigator : { userAgent: "" };
const isMacOSWebView = /* @__PURE__ */ (() => /Macintosh/.test(_navigator.userAgent) && /AppleWebKit/.test(_navigator.userAgent) && !/Safari/.test(_navigator.userAgent))();
const saveAs = !IS_CLIENT ? () => {
} : (
  // Use download attribute first if possible (#193 Lumia mobile) unless this is a macOS WebView or mini program
  typeof HTMLAnchorElement !== "undefined" && "download" in HTMLAnchorElement.prototype && !isMacOSWebView ? downloadSaveAs : (
    // Use msSaveOrOpenBlob as a second approach
    "msSaveOrOpenBlob" in _navigator ? msSaveAs : (
      // Fallback to using FileReader and a popup
      fileSaverSaveAs
    )
  )
);
function downloadSaveAs(blob, name = "download", opts) {
  const a = document.createElement("a");
  a.download = name;
  a.rel = "noopener";
  if (typeof blob === "string") {
    a.href = blob;
    if (a.origin !== location.origin) {
      if (corsEnabled(a.href)) {
        download(blob, name, opts);
      } else {
        a.target = "_blank";
        click(a);
      }
    } else {
      click(a);
    }
  } else {
    a.href = URL.createObjectURL(blob);
    setTimeout(function() {
      URL.revokeObjectURL(a.href);
    }, 4e4);
    setTimeout(function() {
      click(a);
    }, 0);
  }
}
__name(downloadSaveAs, "downloadSaveAs");
function msSaveAs(blob, name = "download", opts) {
  if (typeof blob === "string") {
    if (corsEnabled(blob)) {
      download(blob, name, opts);
    } else {
      const a = document.createElement("a");
      a.href = blob;
      a.target = "_blank";
      setTimeout(function() {
        click(a);
      });
    }
  } else {
    navigator.msSaveOrOpenBlob(bom(blob, opts), name);
  }
}
__name(msSaveAs, "msSaveAs");
function fileSaverSaveAs(blob, name, opts, popup) {
  popup = popup || open("", "_blank");
  if (popup) {
    popup.document.title = popup.document.body.innerText = "downloading...";
  }
  if (typeof blob === "string")
    return download(blob, name, opts);
  const force = blob.type === "application/octet-stream";
  const isSafari3 = /constructor/i.test(String(_global$1.HTMLElement)) || "safari" in _global$1;
  const isChromeIOS = /CriOS\/[\d]+/.test(navigator.userAgent);
  if ((isChromeIOS || force && isSafari3 || isMacOSWebView) && typeof FileReader !== "undefined") {
    const reader = new FileReader();
    reader.onloadend = function() {
      let url = reader.result;
      if (typeof url !== "string") {
        popup = null;
        throw new Error("Wrong reader.result type");
      }
      url = isChromeIOS ? url : url.replace(/^data:[^;]*;/, "data:attachment/file;");
      if (popup) {
        popup.location.href = url;
      } else {
        location.assign(url);
      }
      popup = null;
    };
    reader.readAsDataURL(blob);
  } else {
    const url = URL.createObjectURL(blob);
    if (popup)
      popup.location.assign(url);
    else
      location.href = url;
    popup = null;
    setTimeout(function() {
      URL.revokeObjectURL(url);
    }, 4e4);
  }
}
__name(fileSaverSaveAs, "fileSaverSaveAs");
function toastMessage(message3, type) {
  const piniaMessage = " " + message3;
  if (typeof __VUE_DEVTOOLS_TOAST__ === "function") {
    __VUE_DEVTOOLS_TOAST__(piniaMessage, type);
  } else if (type === "error") {
    console.error(piniaMessage);
  } else if (type === "warn") {
    console.warn(piniaMessage);
  } else {
    console.log(piniaMessage);
  }
}
__name(toastMessage, "toastMessage");
function isPinia(o) {
  return "_a" in o && "install" in o;
}
__name(isPinia, "isPinia");
function checkClipboardAccess() {
  if (!("clipboard" in navigator)) {
    toastMessage(`Your browser doesn't support the Clipboard API`, "error");
    return true;
  }
}
__name(checkClipboardAccess, "checkClipboardAccess");
function checkNotFocusedError(error) {
  if (error instanceof Error && error.message.toLowerCase().includes("document is not focused")) {
    toastMessage('You need to activate the "Emulate a focused page" setting in the "Rendering" panel of devtools.', "warn");
    return true;
  }
  return false;
}
__name(checkNotFocusedError, "checkNotFocusedError");
async function actionGlobalCopyState(pinia2) {
  if (checkClipboardAccess())
    return;
  try {
    await navigator.clipboard.writeText(JSON.stringify(pinia2.state.value));
    toastMessage("Global state copied to clipboard.");
  } catch (error) {
    if (checkNotFocusedError(error))
      return;
    toastMessage(`Failed to serialize the state. Check the console for more details.`, "error");
    console.error(error);
  }
}
__name(actionGlobalCopyState, "actionGlobalCopyState");
async function actionGlobalPasteState(pinia2) {
  if (checkClipboardAccess())
    return;
  try {
    loadStoresState(pinia2, JSON.parse(await navigator.clipboard.readText()));
    toastMessage("Global state pasted from clipboard.");
  } catch (error) {
    if (checkNotFocusedError(error))
      return;
    toastMessage(`Failed to deserialize the state from clipboard. Check the console for more details.`, "error");
    console.error(error);
  }
}
__name(actionGlobalPasteState, "actionGlobalPasteState");
async function actionGlobalSaveState(pinia2) {
  try {
    saveAs(new Blob([JSON.stringify(pinia2.state.value)], {
      type: "text/plain;charset=utf-8"
    }), "pinia-state.json");
  } catch (error) {
    toastMessage(`Failed to export the state as JSON. Check the console for more details.`, "error");
    console.error(error);
  }
}
__name(actionGlobalSaveState, "actionGlobalSaveState");
let fileInput$1;
function getFileOpener() {
  if (!fileInput$1) {
    fileInput$1 = document.createElement("input");
    fileInput$1.type = "file";
    fileInput$1.accept = ".json";
  }
  function openFile() {
    return new Promise((resolve8, reject2) => {
      fileInput$1.onchange = async () => {
        const files = fileInput$1.files;
        if (!files)
          return resolve8(null);
        const file = files.item(0);
        if (!file)
          return resolve8(null);
        return resolve8({ text: await file.text(), file });
      };
      fileInput$1.oncancel = () => resolve8(null);
      fileInput$1.onerror = reject2;
      fileInput$1.click();
    });
  }
  __name(openFile, "openFile");
  return openFile;
}
__name(getFileOpener, "getFileOpener");
async function actionGlobalOpenStateFile(pinia2) {
  try {
    const open2 = getFileOpener();
    const result = await open2();
    if (!result)
      return;
    const { text, file } = result;
    loadStoresState(pinia2, JSON.parse(text));
    toastMessage(`Global state imported from "${file.name}".`);
  } catch (error) {
    toastMessage(`Failed to import the state from JSON. Check the console for more details.`, "error");
    console.error(error);
  }
}
__name(actionGlobalOpenStateFile, "actionGlobalOpenStateFile");
function loadStoresState(pinia2, state) {
  for (const key in state) {
    const storeState = pinia2.state.value[key];
    if (storeState) {
      Object.assign(storeState, state[key]);
    } else {
      pinia2.state.value[key] = state[key];
    }
  }
}
__name(loadStoresState, "loadStoresState");
function formatDisplay(display) {
  return {
    _custom: {
      display
    }
  };
}
__name(formatDisplay, "formatDisplay");
const PINIA_ROOT_LABEL = " Pinia (root)";
const PINIA_ROOT_ID = "_root";
function formatStoreForInspectorTree(store) {
  return isPinia(store) ? {
    id: PINIA_ROOT_ID,
    label: PINIA_ROOT_LABEL
  } : {
    id: store.$id,
    label: store.$id
  };
}
__name(formatStoreForInspectorTree, "formatStoreForInspectorTree");
function formatStoreForInspectorState(store) {
  if (isPinia(store)) {
    const storeNames = Array.from(store._s.keys());
    const storeMap = store._s;
    const state2 = {
      state: storeNames.map((storeId) => ({
        editable: true,
        key: storeId,
        value: store.state.value[storeId]
      })),
      getters: storeNames.filter((id2) => storeMap.get(id2)._getters).map((id2) => {
        const store2 = storeMap.get(id2);
        return {
          editable: false,
          key: id2,
          value: store2._getters.reduce((getters, key) => {
            getters[key] = store2[key];
            return getters;
          }, {})
        };
      })
    };
    return state2;
  }
  const state = {
    state: Object.keys(store.$state).map((key) => ({
      editable: true,
      key,
      value: store.$state[key]
    }))
  };
  if (store._getters && store._getters.length) {
    state.getters = store._getters.map((getterName) => ({
      editable: false,
      key: getterName,
      value: store[getterName]
    }));
  }
  if (store._customProperties.size) {
    state.customProperties = Array.from(store._customProperties).map((key) => ({
      editable: true,
      key,
      value: store[key]
    }));
  }
  return state;
}
__name(formatStoreForInspectorState, "formatStoreForInspectorState");
function formatEventData(events2) {
  if (!events2)
    return {};
  if (Array.isArray(events2)) {
    return events2.reduce((data24, event2) => {
      data24.keys.push(event2.key);
      data24.operations.push(event2.type);
      data24.oldValue[event2.key] = event2.oldValue;
      data24.newValue[event2.key] = event2.newValue;
      return data24;
    }, {
      oldValue: {},
      keys: [],
      operations: [],
      newValue: {}
    });
  } else {
    return {
      operation: formatDisplay(events2.type),
      key: formatDisplay(events2.key),
      oldValue: events2.oldValue,
      newValue: events2.newValue
    };
  }
}
__name(formatEventData, "formatEventData");
function formatMutationType(type) {
  switch (type) {
    case MutationType.direct:
      return "mutation";
    case MutationType.patchFunction:
      return "$patch";
    case MutationType.patchObject:
      return "$patch";
    default:
      return "unknown";
  }
}
__name(formatMutationType, "formatMutationType");
let isTimelineActive = true;
const componentStateTypes = [];
const MUTATIONS_LAYER_ID = "pinia:mutations";
const INSPECTOR_ID = "pinia";
const { assign: assign$1$1 } = Object;
const getStoreType = /* @__PURE__ */ __name((id2) => " " + id2, "getStoreType");
function registerPiniaDevtools(app2, pinia2) {
  setupDevtoolsPlugin({
    id: "dev.esm.pinia",
    label: "Pinia ",
    logo: "https://pinia.vuejs.org/logo.svg",
    packageName: "pinia",
    homepage: "https://pinia.vuejs.org",
    componentStateTypes,
    app: app2
  }, (api2) => {
    if (typeof api2.now !== "function") {
      toastMessage("You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html.");
    }
    api2.addTimelineLayer({
      id: MUTATIONS_LAYER_ID,
      label: `Pinia `,
      color: 15064968
    });
    api2.addInspector({
      id: INSPECTOR_ID,
      label: "Pinia ",
      icon: "storage",
      treeFilterPlaceholder: "Search stores",
      actions: [
        {
          icon: "content_copy",
          action: /* @__PURE__ */ __name(() => {
            actionGlobalCopyState(pinia2);
          }, "action"),
          tooltip: "Serialize and copy the state"
        },
        {
          icon: "content_paste",
          action: /* @__PURE__ */ __name(async () => {
            await actionGlobalPasteState(pinia2);
            api2.sendInspectorTree(INSPECTOR_ID);
            api2.sendInspectorState(INSPECTOR_ID);
          }, "action"),
          tooltip: "Replace the state with the content of your clipboard"
        },
        {
          icon: "save",
          action: /* @__PURE__ */ __name(() => {
            actionGlobalSaveState(pinia2);
          }, "action"),
          tooltip: "Save the state as a JSON file"
        },
        {
          icon: "folder_open",
          action: /* @__PURE__ */ __name(async () => {
            await actionGlobalOpenStateFile(pinia2);
            api2.sendInspectorTree(INSPECTOR_ID);
            api2.sendInspectorState(INSPECTOR_ID);
          }, "action"),
          tooltip: "Import the state from a JSON file"
        }
      ],
      nodeActions: [
        {
          icon: "restore",
          tooltip: 'Reset the state (with "$reset")',
          action: /* @__PURE__ */ __name((nodeId) => {
            const store = pinia2._s.get(nodeId);
            if (!store) {
              toastMessage(`Cannot reset "${nodeId}" store because it wasn't found.`, "warn");
            } else if (typeof store.$reset !== "function") {
              toastMessage(`Cannot reset "${nodeId}" store because it doesn't have a "$reset" method implemented.`, "warn");
            } else {
              store.$reset();
              toastMessage(`Store "${nodeId}" reset.`);
            }
          }, "action")
        }
      ]
    });
    api2.on.inspectComponent((payload, ctx) => {
      const proxy = payload.componentInstance && payload.componentInstance.proxy;
      if (proxy && proxy._pStores) {
        const piniaStores = payload.componentInstance.proxy._pStores;
        Object.values(piniaStores).forEach((store) => {
          payload.instanceData.state.push({
            type: getStoreType(store.$id),
            key: "state",
            editable: true,
            value: store._isOptionsAPI ? {
              _custom: {
                value: toRaw(store.$state),
                actions: [
                  {
                    icon: "restore",
                    tooltip: "Reset the state of this store",
                    action: /* @__PURE__ */ __name(() => store.$reset(), "action")
                  }
                ]
              }
            } : (
              // NOTE: workaround to unwrap transferred refs
              Object.keys(store.$state).reduce((state, key) => {
                state[key] = store.$state[key];
                return state;
              }, {})
            )
          });
          if (store._getters && store._getters.length) {
            payload.instanceData.state.push({
              type: getStoreType(store.$id),
              key: "getters",
              editable: false,
              value: store._getters.reduce((getters, key) => {
                try {
                  getters[key] = store[key];
                } catch (error) {
                  getters[key] = error;
                }
                return getters;
              }, {})
            });
          }
        });
      }
    });
    api2.on.getInspectorTree((payload) => {
      if (payload.app === app2 && payload.inspectorId === INSPECTOR_ID) {
        let stores = [pinia2];
        stores = stores.concat(Array.from(pinia2._s.values()));
        payload.rootNodes = (payload.filter ? stores.filter((store) => "$id" in store ? store.$id.toLowerCase().includes(payload.filter.toLowerCase()) : PINIA_ROOT_LABEL.toLowerCase().includes(payload.filter.toLowerCase())) : stores).map(formatStoreForInspectorTree);
      }
    });
    api2.on.getInspectorState((payload) => {
      if (payload.app === app2 && payload.inspectorId === INSPECTOR_ID) {
        const inspectedStore = payload.nodeId === PINIA_ROOT_ID ? pinia2 : pinia2._s.get(payload.nodeId);
        if (!inspectedStore) {
          return;
        }
        if (inspectedStore) {
          payload.state = formatStoreForInspectorState(inspectedStore);
        }
      }
    });
    api2.on.editInspectorState((payload, ctx) => {
      if (payload.app === app2 && payload.inspectorId === INSPECTOR_ID) {
        const inspectedStore = payload.nodeId === PINIA_ROOT_ID ? pinia2 : pinia2._s.get(payload.nodeId);
        if (!inspectedStore) {
          return toastMessage(`store "${payload.nodeId}" not found`, "error");
        }
        const { path } = payload;
        if (!isPinia(inspectedStore)) {
          if (path.length !== 1 || !inspectedStore._customProperties.has(path[0]) || path[0] in inspectedStore.$state) {
            path.unshift("$state");
          }
        } else {
          path.unshift("state");
        }
        isTimelineActive = false;
        payload.set(inspectedStore, path, payload.state.value);
        isTimelineActive = true;
      }
    });
    api2.on.editComponentState((payload) => {
      if (payload.type.startsWith("")) {
        const storeId = payload.type.replace(/^\s*/, "");
        const store = pinia2._s.get(storeId);
        if (!store) {
          return toastMessage(`store "${storeId}" not found`, "error");
        }
        const { path } = payload;
        if (path[0] !== "state") {
          return toastMessage(`Invalid path for store "${storeId}":
${path}
Only state can be modified.`);
        }
        path[0] = "$state";
        isTimelineActive = false;
        payload.set(store, path, payload.state.value);
        isTimelineActive = true;
      }
    });
  });
}
__name(registerPiniaDevtools, "registerPiniaDevtools");
function addStoreToDevtools(app2, store) {
  if (!componentStateTypes.includes(getStoreType(store.$id))) {
    componentStateTypes.push(getStoreType(store.$id));
  }
  setupDevtoolsPlugin({
    id: "dev.esm.pinia",
    label: "Pinia ",
    logo: "https://pinia.vuejs.org/logo.svg",
    packageName: "pinia",
    homepage: "https://pinia.vuejs.org",
    componentStateTypes,
    app: app2,
    settings: {
      logStoreChanges: {
        label: "Notify about new/deleted stores",
        type: "boolean",
        defaultValue: true
      }
      // useEmojis: {
      //   label: 'Use emojis in messages ',
      //   type: 'boolean',
      //   defaultValue: true,
      // },
    }
  }, (api2) => {
    const now2 = typeof api2.now === "function" ? api2.now.bind(api2) : Date.now;
    store.$onAction(({ after, onError, name, args }) => {
      const groupId = runningActionId++;
      api2.addTimelineEvent({
        layerId: MUTATIONS_LAYER_ID,
        event: {
          time: now2(),
          title: " " + name,
          subtitle: "start",
          data: {
            store: formatDisplay(store.$id),
            action: formatDisplay(name),
            args
          },
          groupId
        }
      });
      after((result) => {
        activeAction = void 0;
        api2.addTimelineEvent({
          layerId: MUTATIONS_LAYER_ID,
          event: {
            time: now2(),
            title: " " + name,
            subtitle: "end",
            data: {
              store: formatDisplay(store.$id),
              action: formatDisplay(name),
              args,
              result
            },
            groupId
          }
        });
      });
      onError((error) => {
        activeAction = void 0;
        api2.addTimelineEvent({
          layerId: MUTATIONS_LAYER_ID,
          event: {
            time: now2(),
            logType: "error",
            title: " " + name,
            subtitle: "end",
            data: {
              store: formatDisplay(store.$id),
              action: formatDisplay(name),
              args,
              error
            },
            groupId
          }
        });
      });
    }, true);
    store._customProperties.forEach((name) => {
      watch(() => unref(store[name]), (newValue, oldValue) => {
        api2.notifyComponentUpdate();
        api2.sendInspectorState(INSPECTOR_ID);
        if (isTimelineActive) {
          api2.addTimelineEvent({
            layerId: MUTATIONS_LAYER_ID,
            event: {
              time: now2(),
              title: "Change",
              subtitle: name,
              data: {
                newValue,
                oldValue
              },
              groupId: activeAction
            }
          });
        }
      }, { deep: true });
    });
    store.$subscribe(({ events: events2, type }, state) => {
      api2.notifyComponentUpdate();
      api2.sendInspectorState(INSPECTOR_ID);
      if (!isTimelineActive)
        return;
      const eventData = {
        time: now2(),
        title: formatMutationType(type),
        data: assign$1$1({ store: formatDisplay(store.$id) }, formatEventData(events2)),
        groupId: activeAction
      };
      if (type === MutationType.patchFunction) {
        eventData.subtitle = "";
      } else if (type === MutationType.patchObject) {
        eventData.subtitle = "";
      } else if (events2 && !Array.isArray(events2)) {
        eventData.subtitle = events2.type;
      }
      if (events2) {
        eventData.data["rawEvent(s)"] = {
          _custom: {
            display: "DebuggerEvent",
            type: "object",
            tooltip: "raw DebuggerEvent[]",
            value: events2
          }
        };
      }
      api2.addTimelineEvent({
        layerId: MUTATIONS_LAYER_ID,
        event: eventData
      });
    }, { detached: true, flush: "sync" });
    const hotUpdate = store._hotUpdate;
    store._hotUpdate = markRaw((newStore) => {
      hotUpdate(newStore);
      api2.addTimelineEvent({
        layerId: MUTATIONS_LAYER_ID,
        event: {
          time: now2(),
          title: " " + store.$id,
          subtitle: "HMR update",
          data: {
            store: formatDisplay(store.$id),
            info: formatDisplay(`HMR update`)
          }
        }
      });
      api2.notifyComponentUpdate();
      api2.sendInspectorTree(INSPECTOR_ID);
      api2.sendInspectorState(INSPECTOR_ID);
    });
    const { $dispose } = store;
    store.$dispose = () => {
      $dispose();
      api2.notifyComponentUpdate();
      api2.sendInspectorTree(INSPECTOR_ID);
      api2.sendInspectorState(INSPECTOR_ID);
      api2.getSettings().logStoreChanges && toastMessage(`Disposed "${store.$id}" store `);
    };
    api2.notifyComponentUpdate();
    api2.sendInspectorTree(INSPECTOR_ID);
    api2.sendInspectorState(INSPECTOR_ID);
    api2.getSettings().logStoreChanges && toastMessage(`"${store.$id}" store installed `);
  });
}
__name(addStoreToDevtools, "addStoreToDevtools");
let runningActionId = 0;
let activeAction;
function patchActionForGrouping(store, actionNames, wrapWithProxy) {
  const actions = actionNames.reduce((storeActions, actionName) => {
    storeActions[actionName] = toRaw(store)[actionName];
    return storeActions;
  }, {});
  for (const actionName in actions) {
    store[actionName] = function() {
      const _actionId = runningActionId;
      const trackedStore = wrapWithProxy ? new Proxy(store, {
        get(...args) {
          activeAction = _actionId;
          return Reflect.get(...args);
        },
        set(...args) {
          activeAction = _actionId;
          return Reflect.set(...args);
        }
      }) : store;
      activeAction = _actionId;
      const retValue = actions[actionName].apply(trackedStore, arguments);
      activeAction = void 0;
      return retValue;
    };
  }
}
__name(patchActionForGrouping, "patchActionForGrouping");
function devtoolsPlugin({ app: app2, store, options: options3 }) {
  if (store.$id.startsWith("__hot:")) {
    return;
  }
  store._isOptionsAPI = !!options3.state;
  patchActionForGrouping(store, Object.keys(options3.actions), store._isOptionsAPI);
  const originalHotUpdate = store._hotUpdate;
  toRaw(store)._hotUpdate = function(newStore) {
    originalHotUpdate.apply(this, arguments);
    patchActionForGrouping(store, Object.keys(newStore._hmrPayload.actions), !!store._isOptionsAPI);
  };
  addStoreToDevtools(
    app2,
    // FIXME: is there a way to allow the assignment from Store<Id, S, G, A> to StoreGeneric?
    store
  );
}
__name(devtoolsPlugin, "devtoolsPlugin");
function createPinia() {
  const scope = effectScope(true);
  const state = scope.run(() => ref({}));
  let _p = [];
  let toBeInstalled = [];
  const pinia2 = markRaw({
    install(app2) {
      setActivePinia(pinia2);
      if (!isVue2$2) {
        pinia2._a = app2;
        app2.provide(piniaSymbol, pinia2);
        app2.config.globalProperties.$pinia = pinia2;
        if (USE_DEVTOOLS) {
          registerPiniaDevtools(app2, pinia2);
        }
        toBeInstalled.forEach((plugin) => _p.push(plugin));
        toBeInstalled = [];
      }
    },
    use(plugin) {
      if (!this._a && !isVue2$2) {
        toBeInstalled.push(plugin);
      } else {
        _p.push(plugin);
      }
      return this;
    },
    _p,
    // it's actually undefined here
    // @ts-expect-error
    _a: null,
    _e: scope,
    _s: /* @__PURE__ */ new Map(),
    state
  });
  if (USE_DEVTOOLS && typeof Proxy !== "undefined") {
    pinia2.use(devtoolsPlugin);
  }
  return pinia2;
}
__name(createPinia, "createPinia");
const isUseStore = /* @__PURE__ */ __name((fn) => {
  return typeof fn === "function" && typeof fn.$id === "string";
}, "isUseStore");
function patchObject(newState, oldState) {
  for (const key in oldState) {
    const subPatch = oldState[key];
    if (!(key in newState)) {
      continue;
    }
    const targetValue = newState[key];
    if (isPlainObject$1(targetValue) && isPlainObject$1(subPatch) && !isRef(subPatch) && !isReactive(subPatch)) {
      newState[key] = patchObject(targetValue, subPatch);
    } else {
      if (isVue2$2) {
        set$3(newState, key, subPatch);
      } else {
        newState[key] = subPatch;
      }
    }
  }
  return newState;
}
__name(patchObject, "patchObject");
function acceptHMRUpdate(initialUseStore, hot) {
  if (true) {
    return () => {
    };
  }
  return (newModule) => {
    const pinia2 = hot.data.pinia || initialUseStore._pinia;
    if (!pinia2) {
      return;
    }
    hot.data.pinia = pinia2;
    for (const exportName in newModule) {
      const useStore = newModule[exportName];
      if (isUseStore(useStore) && pinia2._s.has(useStore.$id)) {
        const id2 = useStore.$id;
        if (id2 !== initialUseStore.$id) {
          console.warn(`The id of the store changed from "${initialUseStore.$id}" to "${id2}". Reloading.`);
          return hot.invalidate();
        }
        const existingStore = pinia2._s.get(id2);
        if (!existingStore) {
          console.log(`[Pinia]: skipping hmr because store doesn't exist yet`);
          return;
        }
        useStore(pinia2, existingStore);
      }
    }
  };
}
__name(acceptHMRUpdate, "acceptHMRUpdate");
const noop$1 = /* @__PURE__ */ __name(() => {
}, "noop$1");
function addSubscription(subscriptions, callback, detached, onCleanup = noop$1) {
  subscriptions.push(callback);
  const removeSubscription = /* @__PURE__ */ __name(() => {
    const idx = subscriptions.indexOf(callback);
    if (idx > -1) {
      subscriptions.splice(idx, 1);
      onCleanup();
    }
  }, "removeSubscription");
  if (!detached && getCurrentScope()) {
    onScopeDispose(removeSubscription);
  }
  return removeSubscription;
}
__name(addSubscription, "addSubscription");
function triggerSubscriptions(subscriptions, ...args) {
  subscriptions.slice().forEach((callback) => {
    callback(...args);
  });
}
__name(triggerSubscriptions, "triggerSubscriptions");
const fallbackRunWithContext = /* @__PURE__ */ __name((fn) => fn(), "fallbackRunWithContext");
function mergeReactiveObjects(target, patchToApply) {
  if (target instanceof Map && patchToApply instanceof Map) {
    patchToApply.forEach((value3, key) => target.set(key, value3));
  }
  if (target instanceof Set && patchToApply instanceof Set) {
    patchToApply.forEach(target.add, target);
  }
  for (const key in patchToApply) {
    if (!patchToApply.hasOwnProperty(key))
      continue;
    const subPatch = patchToApply[key];
    const targetValue = target[key];
    if (isPlainObject$1(targetValue) && isPlainObject$1(subPatch) && target.hasOwnProperty(key) && !isRef(subPatch) && !isReactive(subPatch)) {
      target[key] = mergeReactiveObjects(targetValue, subPatch);
    } else {
      target[key] = subPatch;
    }
  }
  return target;
}
__name(mergeReactiveObjects, "mergeReactiveObjects");
const skipHydrateSymbol = false ? Symbol("pinia:skipHydration") : (
  /* istanbul ignore next */
  Symbol()
);
const skipHydrateMap = /* @__PURE__ */ new WeakMap();
function skipHydrate(obj) {
  return isVue2$2 ? (
    // in @vue/composition-api, the refs are sealed so defineProperty doesn't work...
    /* istanbul ignore next */
    skipHydrateMap.set(obj, 1) && obj
  ) : Object.defineProperty(obj, skipHydrateSymbol, {});
}
__name(skipHydrate, "skipHydrate");
function shouldHydrate(obj) {
  return isVue2$2 ? (
    /* istanbul ignore next */
    !skipHydrateMap.has(obj)
  ) : !isPlainObject$1(obj) || !obj.hasOwnProperty(skipHydrateSymbol);
}
__name(shouldHydrate, "shouldHydrate");
const { assign: assign$2 } = Object;
function isComputed(o) {
  return !!(isRef(o) && o.effect);
}
__name(isComputed, "isComputed");
function createOptionsStore(id2, options3, pinia2, hot) {
  const { state, actions, getters } = options3;
  const initialState = pinia2.state.value[id2];
  let store;
  function setup2() {
    if (!initialState && true) {
      if (isVue2$2) {
        set$3(pinia2.state.value, id2, state ? state() : {});
      } else {
        pinia2.state.value[id2] = state ? state() : {};
      }
    }
    const localState = false ? (
      // use ref() to unwrap refs inside state TODO: check if this is still necessary
      toRefs$1(ref(state ? state() : {}).value)
    ) : toRefs$1(pinia2.state.value[id2]);
    return assign$2(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {
      if (false) {
        console.warn(`[]: A getter cannot have the same name as another state property. Rename one of them. Found with "${name}" in store "${id2}".`);
      }
      computedGetters[name] = markRaw(computed(() => {
        setActivePinia(pinia2);
        const store2 = pinia2._s.get(id2);
        if (isVue2$2 && !store2._r)
          return;
        return getters[name].call(store2, store2);
      }));
      return computedGetters;
    }, {}));
  }
  __name(setup2, "setup");
  store = createSetupStore(id2, setup2, options3, pinia2, hot, true);
  return store;
}
__name(createOptionsStore, "createOptionsStore");
function createSetupStore($id, setup2, options3 = {}, pinia2, hot, isOptionsStore) {
  let scope;
  const optionsForPlugin = assign$2({ actions: {} }, options3);
  if (false) {
    throw new Error("Pinia destroyed");
  }
  const $subscribeOptions = {
    deep: true
    // flush: 'post',
  };
  if (false) {
    $subscribeOptions.onTrigger = (event2) => {
      if (isListening) {
        debuggerEvents = event2;
      } else if (isListening == false && !store._hotUpdating) {
        if (Array.isArray(debuggerEvents)) {
          debuggerEvents.push(event2);
        } else {
          console.error(" debuggerEvents should be an array. This is most likely an internal Pinia bug.");
        }
      }
    };
  }
  let isListening;
  let isSyncListening;
  let subscriptions = [];
  let actionSubscriptions = [];
  let debuggerEvents;
  const initialState = pinia2.state.value[$id];
  if (!isOptionsStore && !initialState && true) {
    if (isVue2$2) {
      set$3(pinia2.state.value, $id, {});
    } else {
      pinia2.state.value[$id] = {};
    }
  }
  const hotState = ref({});
  let activeListener;
  function $patch(partialStateOrMutator) {
    let subscriptionMutation;
    isListening = isSyncListening = false;
    if (false) {
      debuggerEvents = [];
    }
    if (typeof partialStateOrMutator === "function") {
      partialStateOrMutator(pinia2.state.value[$id]);
      subscriptionMutation = {
        type: MutationType.patchFunction,
        storeId: $id,
        events: debuggerEvents
      };
    } else {
      mergeReactiveObjects(pinia2.state.value[$id], partialStateOrMutator);
      subscriptionMutation = {
        type: MutationType.patchObject,
        payload: partialStateOrMutator,
        storeId: $id,
        events: debuggerEvents
      };
    }
    const myListenerId = activeListener = Symbol();
    nextTick().then(() => {
      if (activeListener === myListenerId) {
        isListening = true;
      }
    });
    isSyncListening = true;
    triggerSubscriptions(subscriptions, subscriptionMutation, pinia2.state.value[$id]);
  }
  __name($patch, "$patch");
  const $reset = isOptionsStore ? /* @__PURE__ */ __name(function $reset2() {
    const { state } = options3;
    const newState = state ? state() : {};
    this.$patch(($state) => {
      assign$2($state, newState);
    });
  }, "$reset2") : (
    /* istanbul ignore next */
    false ? () => {
      throw new Error(`: Store "${$id}" is built using the setup syntax and does not implement $reset().`);
    } : noop$1
  );
  function $dispose() {
    scope.stop();
    subscriptions = [];
    actionSubscriptions = [];
    pinia2._s.delete($id);
  }
  __name($dispose, "$dispose");
  function wrapAction(name, action) {
    return function() {
      setActivePinia(pinia2);
      const args = Array.from(arguments);
      const afterCallbackList = [];
      const onErrorCallbackList = [];
      function after(callback) {
        afterCallbackList.push(callback);
      }
      __name(after, "after");
      function onError(callback) {
        onErrorCallbackList.push(callback);
      }
      __name(onError, "onError");
      triggerSubscriptions(actionSubscriptions, {
        args,
        name,
        store,
        after,
        onError
      });
      let ret;
      try {
        ret = action.apply(this && this.$id === $id ? this : store, args);
      } catch (error) {
        triggerSubscriptions(onErrorCallbackList, error);
        throw error;
      }
      if (ret instanceof Promise) {
        return ret.then((value3) => {
          triggerSubscriptions(afterCallbackList, value3);
          return value3;
        }).catch((error) => {
          triggerSubscriptions(onErrorCallbackList, error);
          return Promise.reject(error);
        });
      }
      triggerSubscriptions(afterCallbackList, ret);
      return ret;
    };
  }
  __name(wrapAction, "wrapAction");
  const _hmrPayload = /* @__PURE__ */ markRaw({
    actions: {},
    getters: {},
    state: [],
    hotState
  });
  const partialStore = {
    _p: pinia2,
    // _s: scope,
    $id,
    $onAction: addSubscription.bind(null, actionSubscriptions),
    $patch,
    $reset,
    $subscribe(callback, options22 = {}) {
      const removeSubscription = addSubscription(subscriptions, callback, options22.detached, () => stopWatcher());
      const stopWatcher = scope.run(() => watch(() => pinia2.state.value[$id], (state) => {
        if (options22.flush === "sync" ? isSyncListening : isListening) {
          callback({
            storeId: $id,
            type: MutationType.direct,
            events: debuggerEvents
          }, state);
        }
      }, assign$2({}, $subscribeOptions, options22)));
      return removeSubscription;
    },
    $dispose
  };
  if (isVue2$2) {
    partialStore._r = false;
  }
  const store = reactive(USE_DEVTOOLS ? assign$2(
    {
      _hmrPayload,
      _customProperties: markRaw(/* @__PURE__ */ new Set())
      // devtools custom properties
    },
    partialStore
    // must be added later
    // setupStore
  ) : partialStore);
  pinia2._s.set($id, store);
  const runWithContext = pinia2._a && pinia2._a.runWithContext || fallbackRunWithContext;
  const setupStore = runWithContext(() => pinia2._e.run(() => (scope = effectScope()).run(setup2)));
  for (const key in setupStore) {
    const prop2 = setupStore[key];
    if (isRef(prop2) && !isComputed(prop2) || isReactive(prop2)) {
      if (false) {
        set$3(hotState.value, key, toRef$1(setupStore, key));
      } else if (!isOptionsStore) {
        if (initialState && shouldHydrate(prop2)) {
          if (isRef(prop2)) {
            prop2.value = initialState[key];
          } else {
            mergeReactiveObjects(prop2, initialState[key]);
          }
        }
        if (isVue2$2) {
          set$3(pinia2.state.value[$id], key, prop2);
        } else {
          pinia2.state.value[$id][key] = prop2;
        }
      }
      if (false) {
        _hmrPayload.state.push(key);
      }
    } else if (typeof prop2 === "function") {
      const actionValue = false ? prop2 : wrapAction(key, prop2);
      if (isVue2$2) {
        set$3(setupStore, key, actionValue);
      } else {
        setupStore[key] = actionValue;
      }
      if (false) {
        _hmrPayload.actions[key] = prop2;
      }
      optionsForPlugin.actions[key] = prop2;
    } else if (false) {
      if (isComputed(prop2)) {
        _hmrPayload.getters[key] = isOptionsStore ? (
          // @ts-expect-error
          options3.getters[key]
        ) : prop2;
        if (IS_CLIENT) {
          const getters = setupStore._getters || // @ts-expect-error: same
          (setupStore._getters = markRaw([]));
          getters.push(key);
        }
      }
    }
  }
  if (isVue2$2) {
    Object.keys(setupStore).forEach((key) => {
      set$3(store, key, setupStore[key]);
    });
  } else {
    assign$2(store, setupStore);
    assign$2(toRaw(store), setupStore);
  }
  Object.defineProperty(store, "$state", {
    get: /* @__PURE__ */ __name(() => false ? hotState.value : pinia2.state.value[$id], "get"),
    set: /* @__PURE__ */ __name((state) => {
      if (false) {
        throw new Error("cannot set hotState");
      }
      $patch(($state) => {
        assign$2($state, state);
      });
    }, "set")
  });
  if (false) {
    store._hotUpdate = markRaw((newStore) => {
      store._hotUpdating = true;
      newStore._hmrPayload.state.forEach((stateKey) => {
        if (stateKey in store.$state) {
          const newStateTarget = newStore.$state[stateKey];
          const oldStateSource = store.$state[stateKey];
          if (typeof newStateTarget === "object" && isPlainObject$1(newStateTarget) && isPlainObject$1(oldStateSource)) {
            patchObject(newStateTarget, oldStateSource);
          } else {
            newStore.$state[stateKey] = oldStateSource;
          }
        }
        set$3(store, stateKey, toRef$1(newStore.$state, stateKey));
      });
      Object.keys(store.$state).forEach((stateKey) => {
        if (!(stateKey in newStore.$state)) {
          del$2(store, stateKey);
        }
      });
      isListening = false;
      isSyncListening = false;
      pinia2.state.value[$id] = toRef$1(newStore._hmrPayload, "hotState");
      isSyncListening = true;
      nextTick().then(() => {
        isListening = true;
      });
      for (const actionName in newStore._hmrPayload.actions) {
        const action = newStore[actionName];
        set$3(store, actionName, wrapAction(actionName, action));
      }
      for (const getterName in newStore._hmrPayload.getters) {
        const getter = newStore._hmrPayload.getters[getterName];
        const getterValue = isOptionsStore ? (
          // special handling of options api
          computed(() => {
            setActivePinia(pinia2);
            return getter.call(store, store);
          })
        ) : getter;
        set$3(store, getterName, getterValue);
      }
      Object.keys(store._hmrPayload.getters).forEach((key) => {
        if (!(key in newStore._hmrPayload.getters)) {
          del$2(store, key);
        }
      });
      Object.keys(store._hmrPayload.actions).forEach((key) => {
        if (!(key in newStore._hmrPayload.actions)) {
          del$2(store, key);
        }
      });
      store._hmrPayload = newStore._hmrPayload;
      store._getters = newStore._getters;
      store._hotUpdating = false;
    });
  }
  if (USE_DEVTOOLS) {
    const nonEnumerable = {
      writable: true,
      configurable: true,
      // avoid warning on devtools trying to display this property
      enumerable: false
    };
    ["_p", "_hmrPayload", "_getters", "_customProperties"].forEach((p2) => {
      Object.defineProperty(store, p2, assign$2({ value: store[p2] }, nonEnumerable));
    });
  }
  if (isVue2$2) {
    store._r = true;
  }
  pinia2._p.forEach((extender) => {
    if (USE_DEVTOOLS) {
      const extensions = scope.run(() => extender({
        store,
        app: pinia2._a,
        pinia: pinia2,
        options: optionsForPlugin
      }));
      Object.keys(extensions || {}).forEach((key) => store._customProperties.add(key));
      assign$2(store, extensions);
    } else {
      assign$2(store, scope.run(() => extender({
        store,
        app: pinia2._a,
        pinia: pinia2,
        options: optionsForPlugin
      })));
    }
  });
  if (false) {
    console.warn(`[]: The "state" must be a plain object. It cannot be
	state: () => new MyClass()
Found in store "${store.$id}".`);
  }
  if (initialState && isOptionsStore && options3.hydrate) {
    options3.hydrate(store.$state, initialState);
  }
  isListening = true;
  isSyncListening = true;
  return store;
}
__name(createSetupStore, "createSetupStore");
function defineStore(idOrOptions, setup2, setupOptions) {
  let id2;
  let options3;
  const isSetupStore = typeof setup2 === "function";
  if (typeof idOrOptions === "string") {
    id2 = idOrOptions;
    options3 = isSetupStore ? setupOptions : setup2;
  } else {
    options3 = idOrOptions;
    id2 = idOrOptions.id;
    if (false) {
      throw new Error(`[]: "defineStore()" must be passed a store id as its first argument.`);
    }
  }
  function useStore(pinia2, hot) {
    const hasContext = hasInjectionContext();
    pinia2 = // in test mode, ignore the argument provided as we can always retrieve a
    // pinia instance with getActivePinia()
    (false ? null : pinia2) || (hasContext ? inject(piniaSymbol, null) : null);
    if (pinia2)
      setActivePinia(pinia2);
    if (false) {
      throw new Error(`[]: "getActivePinia()" was called but there was no active Pinia. Are you trying to use a store before calling "app.use(pinia)"?
See https://pinia.vuejs.org/core-concepts/outside-component-usage.html for help.
This will fail in production.`);
    }
    pinia2 = activePinia;
    if (!pinia2._s.has(id2)) {
      if (isSetupStore) {
        createSetupStore(id2, setup2, options3, pinia2);
      } else {
        createOptionsStore(id2, options3, pinia2);
      }
      if (false) {
        useStore._pinia = pinia2;
      }
    }
    const store = pinia2._s.get(id2);
    if (false) {
      const hotId = "__hot:" + id2;
      const newStore = isSetupStore ? createSetupStore(hotId, setup2, options3, pinia2, true) : createOptionsStore(hotId, assign$2({}, options3), pinia2, true);
      hot._hotUpdate(newStore);
      delete pinia2.state.value[hotId];
      pinia2._s.delete(hotId);
    }
    if (false) {
      const currentInstance2 = getCurrentInstance();
      if (currentInstance2 && currentInstance2.proxy && // avoid adding stores that are just built for hot module replacement
      !hot) {
        const vm = currentInstance2.proxy;
        const cache2 = "_pStores" in vm ? vm._pStores : vm._pStores = {};
        cache2[id2] = store;
      }
    }
    return store;
  }
  __name(useStore, "useStore");
  useStore.$id = id2;
  return useStore;
}
__name(defineStore, "defineStore");
let mapStoreSuffix = "Store";
function setMapStoreSuffix(suffix2) {
  mapStoreSuffix = suffix2;
}
__name(setMapStoreSuffix, "setMapStoreSuffix");
function mapStores(...stores) {
  if (false) {
    console.warn(`[]: Directly pass all stores to "mapStores()" without putting them in an array:
Replace
	mapStores([useAuthStore, useCartStore])
with
	mapStores(useAuthStore, useCartStore)
This will fail in production if not fixed.`);
    stores = stores[0];
  }
  return stores.reduce((reduced, useStore) => {
    reduced[useStore.$id + mapStoreSuffix] = function() {
      return useStore(this.$pinia);
    };
    return reduced;
  }, {});
}
__name(mapStores, "mapStores");
function mapState(useStore, keysOrMapper) {
  return Array.isArray(keysOrMapper) ? keysOrMapper.reduce((reduced, key) => {
    reduced[key] = function() {
      return useStore(this.$pinia)[key];
    };
    return reduced;
  }, {}) : Object.keys(keysOrMapper).reduce((reduced, key) => {
    reduced[key] = function() {
      const store = useStore(this.$pinia);
      const storeKey = keysOrMapper[key];
      return typeof storeKey === "function" ? storeKey.call(this, store) : store[storeKey];
    };
    return reduced;
  }, {});
}
__name(mapState, "mapState");
const mapGetters = mapState;
function mapActions(useStore, keysOrMapper) {
  return Array.isArray(keysOrMapper) ? keysOrMapper.reduce((reduced, key) => {
    reduced[key] = function(...args) {
      return useStore(this.$pinia)[key](...args);
    };
    return reduced;
  }, {}) : Object.keys(keysOrMapper).reduce((reduced, key) => {
    reduced[key] = function(...args) {
      return useStore(this.$pinia)[keysOrMapper[key]](...args);
    };
    return reduced;
  }, {});
}
__name(mapActions, "mapActions");
function mapWritableState(useStore, keysOrMapper) {
  return Array.isArray(keysOrMapper) ? keysOrMapper.reduce((reduced, key) => {
    reduced[key] = {
      get() {
        return useStore(this.$pinia)[key];
      },
      set(value3) {
        return useStore(this.$pinia)[key] = value3;
      }
    };
    return reduced;
  }, {}) : Object.keys(keysOrMapper).reduce((reduced, key) => {
    reduced[key] = {
      get() {
        return useStore(this.$pinia)[keysOrMapper[key]];
      },
      set(value3) {
        return useStore(this.$pinia)[keysOrMapper[key]] = value3;
      }
    };
    return reduced;
  }, {});
}
__name(mapWritableState, "mapWritableState");
function storeToRefs(store) {
  if (isVue2$2) {
    return toRefs$1(store);
  } else {
    store = toRaw(store);
    const refs = {};
    for (const key in store) {
      const value3 = store[key];
      if (isRef(value3) || isReactive(value3)) {
        refs[key] = // ---
        toRef$1(store, key);
      }
    }
    return refs;
  }
}
__name(storeToRefs, "storeToRefs");
const PiniaVuePlugin = /* @__PURE__ */ __name(function(_Vue) {
  _Vue.mixin({
    beforeCreate() {
      const options3 = this.$options;
      if (options3.pinia) {
        const pinia2 = options3.pinia;
        if (!this._provided) {
          const provideCache = {};
          Object.defineProperty(this, "_provided", {
            get: /* @__PURE__ */ __name(() => provideCache, "get"),
            set: /* @__PURE__ */ __name((v2) => Object.assign(provideCache, v2), "set")
          });
        }
        this._provided[piniaSymbol] = pinia2;
        if (!this.$pinia) {
          this.$pinia = pinia2;
        }
        pinia2._a = this;
        if (IS_CLIENT) {
          setActivePinia(pinia2);
        }
        if (USE_DEVTOOLS) {
          registerPiniaDevtools(pinia2._a, pinia2);
        }
      } else if (!this.$pinia && options3.parent && options3.parent.$pinia) {
        this.$pinia = options3.parent.$pinia;
      }
    },
    destroyed() {
      delete this._pStores;
    }
  });
}, "PiniaVuePlugin");
const useSettingStore = defineStore("setting", {
  state: /* @__PURE__ */ __name(() => ({
    settingValues: {},
    settings: {}
  }), "state"),
  getters: {
    // Setting tree structure used for the settings dialog display.
    settingTree() {
      const root26 = buildTree(
        Object.values(this.settings).filter(
          (setting) => setting.type !== "hidden"
        ),
        (setting) => setting.category || setting.id.split(".")
      );
      const floatingSettings = root26.children.filter((node3) => node3.leaf);
      if (floatingSettings.length) {
        root26.children = root26.children.filter((node3) => !node3.leaf);
        root26.children.push({
          key: "Other",
          label: "Other",
          leaf: false,
          children: floatingSettings
        });
      }
      return root26;
    }
  },
  actions: {
    addSettings(settings) {
      for (const id2 in settings.settingsLookup) {
        const value3 = settings.getSettingValue(id2);
        this.settingValues[id2] = value3;
      }
      this.settings = settings.settingsParamLookup;
      app$1.ui.settings.addSetting({
        id: "Comfy.Validation.Workflows",
        name: "Validate workflows",
        type: "boolean",
        defaultValue: true
      });
      app$1.ui.settings.addSetting({
        id: "Comfy.NodeSearchBoxImpl",
        category: ["Comfy", "Node Search Box", "Implementation"],
        experimental: true,
        name: "Node search box implementation",
        type: "combo",
        options: ["default", "litegraph (legacy)"],
        defaultValue: "default"
      });
      app$1.ui.settings.addSetting({
        id: "Comfy.NodeSearchBoxImpl.LinkReleaseTrigger",
        category: ["Comfy", "Node Search Box", "LinkReleaseTrigger"],
        name: "Trigger on link release",
        type: "hidden",
        options: Object.values(LinkReleaseTriggerMode),
        defaultValue: LinkReleaseTriggerMode.ALWAYS,
        deprecated: true
      });
      app$1.ui.settings.addSetting({
        id: "Comfy.LinkRelease.Action",
        name: "Action on link release (No modifier)",
        type: "combo",
        options: Object.values(LinkReleaseTriggerAction),
        defaultValue: LinkReleaseTriggerAction.CONTEXT_MENU
      });
      app$1.ui.settings.addSetting({
        id: "Comfy.LinkRelease.ActionShift",
        name: "Action on link release (Shift)",
        type: "combo",
        options: Object.values(LinkReleaseTriggerAction),
        defaultValue: LinkReleaseTriggerAction.SEARCH_BOX
      });
      app$1.ui.settings.addSetting({
        id: "Comfy.NodeSearchBoxImpl.NodePreview",
        category: ["Comfy", "Node Search Box", "NodePreview"],
        name: "Node preview",
        tooltip: "Only applies to the default implementation",
        type: "boolean",
        defaultValue: true
      });
      app$1.ui.settings.addSetting({
        id: "Comfy.NodeSearchBoxImpl.ShowCategory",
        category: ["Comfy", "Node Search Box", "ShowCategory"],
        name: "Show node category in search results",
        tooltip: "Only applies to the default implementation",
        type: "boolean",
        defaultValue: true
      });
      app$1.ui.settings.addSetting({
        id: "Comfy.NodeSearchBoxImpl.ShowIdName",
        category: ["Comfy", "Node Search Box", "ShowIdName"],
        name: "Show node id name in search results",
        tooltip: "Only applies to the default implementation",
        type: "boolean",
        defaultValue: false
      });
      app$1.ui.settings.addSetting({
        id: "Comfy.Sidebar.Location",
        category: ["Comfy", "Sidebar", "Location"],
        name: "Sidebar location",
        type: "combo",
        options: ["left", "right"],
        defaultValue: "left"
      });
      app$1.ui.settings.addSetting({
        id: "Comfy.Sidebar.Size",
        category: ["Comfy", "Sidebar", "Size"],
        name: "Sidebar size",
        type: "combo",
        options: ["normal", "small"],
        defaultValue: window.innerWidth < 1600 ? "small" : "normal"
      });
      app$1.ui.settings.addSetting({
        id: "Comfy.TextareaWidget.FontSize",
        category: ["Comfy", "Node Widget", "TextareaWidget", "FontSize"],
        name: "Textarea widget font size",
        type: "slider",
        defaultValue: 10,
        attrs: {
          min: 8,
          max: 24
        }
      });
      app$1.ui.settings.addSetting({
        id: "Comfy.TextareaWidget.Spellcheck",
        category: ["Comfy", "Node Widget", "TextareaWidget", "Spellcheck"],
        name: "Textarea widget spellcheck",
        type: "boolean",
        defaultValue: false
      });
      app$1.ui.settings.addSetting({
        id: "Comfy.Workflow.SortNodeIdOnSave",
        name: "Sort node IDs when saving workflow",
        type: "boolean",
        defaultValue: false
      });
      app$1.ui.settings.addSetting({
        id: "Comfy.Graph.CanvasInfo",
        name: "Show canvas info (fps, etc.)",
        type: "boolean",
        defaultValue: true
      });
      app$1.ui.settings.addSetting({
        id: "Comfy.Node.ShowDeprecated",
        name: "Show deprecated nodes in search",
        tooltip: "Deprecated nodes are hidden by default in the UI, but remain functional in existing workflows that use them.",
        type: "boolean",
        defaultValue: false
      });
      app$1.ui.settings.addSetting({
        id: "Comfy.Node.ShowExperimental",
        name: "Show experimental nodes in search",
        tooltip: "Experimental nodes are marked as such in the UI and may be subject to significant changes or removal in future versions. Use with caution in production workflows",
        type: "boolean",
        defaultValue: true
      });
      app$1.ui.settings.addSetting({
        id: "Comfy.Workflow.ShowMissingNodesWarning",
        name: "Show missing nodes warning",
        type: "boolean",
        defaultValue: true
      });
      app$1.ui.settings.addSetting({
        id: "Comfy.Workflow.ShowMissingModelsWarning",
        name: "Show missing models warning",
        type: "boolean",
        defaultValue: false,
        experimental: true
      });
      app$1.ui.settings.addSetting({
        id: "Comfy.Graph.ZoomSpeed",
        name: "Canvas zoom speed",
        type: "slider",
        defaultValue: 1.1,
        attrs: {
          min: 1.01,
          max: 2.5,
          step: 0.01
        }
      });
      app$1.ui.settings.addSetting({
        id: "Comfy.NodeLibrary.Bookmarks",
        name: "Node library bookmarks with display name (deprecated)",
        type: "hidden",
        defaultValue: [],
        deprecated: true
      });
      app$1.ui.settings.addSetting({
        id: "Comfy.NodeLibrary.Bookmarks.V2",
        name: "Node library bookmarks v2 with unique name",
        type: "hidden",
        defaultValue: []
      });
      app$1.ui.settings.addSetting({
        id: "Comfy.NodeLibrary.BookmarksCustomization",
        name: "Node library bookmarks customization",
        type: "hidden",
        defaultValue: {}
      });
      app$1.ui.settings.addSetting({
        id: "Comfy.Queue.ImageFit",
        name: "Queue image fit",
        type: "hidden",
        defaultValue: "cover"
      });
      app$1.ui.settings.addSetting({
        id: "Comfy.Workflow.ModelDownload.AllowedSources",
        name: "Allowed model download sources",
        type: "hidden",
        defaultValue: ["https://huggingface.co/", "https://civitai.com/"]
      });
      app$1.ui.settings.addSetting({
        id: "Comfy.Workflow.ModelDownload.AllowedSuffixes",
        name: "Allowed model download suffixes",
        type: "hidden",
        defaultValue: [".safetensors", ".sft"]
      });
      app$1.ui.settings.addSetting({
        id: "Comfy.GroupSelectedNodes.Padding",
        name: "Group selected nodes padding",
        type: "slider",
        defaultValue: 10,
        attrs: {
          min: 0,
          max: 100
        }
      });
      app$1.ui.settings.addSetting({
        id: "Comfy.Node.DoubleClickTitleToEdit",
        name: "Double click node title to edit",
        type: "boolean",
        defaultValue: true
      });
      app$1.ui.settings.addSetting({
        id: "Comfy.Group.DoubleClickTitleToEdit",
        name: "Double click group title to edit",
        type: "boolean",
        defaultValue: true
      });
      app$1.ui.settings.addSetting({
        id: "Comfy.Window.UnloadConfirmation",
        name: "Show confirmation when closing window",
        type: "boolean",
        defaultValue: false
      });
      app$1.ui.settings.addSetting({
        id: "Comfy.TreeExplorer.ItemPadding",
        name: "Tree explorer item padding",
        type: "slider",
        defaultValue: 2,
        attrs: {
          min: 0,
          max: 8,
          step: 1
        }
      });
      app$1.ui.settings.addSetting({
        id: "Comfy.Locale",
        name: "Locale",
        type: "combo",
        options: ["en", "zh"],
        defaultValue: navigator.language.split("-")[0] || "en"
      });
    },
    set(key, value3) {
      this.settingValues[key] = value3;
      app$1.ui.settings.setSettingValue(key, value3);
    },
    get(key) {
      return this.settingValues[key] ?? app$1.ui.settings.getSettingDefaultValue(key);
    }
  }
});
class ComfySettingsDialog extends ComfyDialog$1 {
  static {
    __name(this, "ComfySettingsDialog");
  }
  app;
  settingsValues;
  settingsLookup;
  settingsParamLookup;
  constructor(app2) {
    super();
    const frontendVersion = window["__COMFYUI_FRONTEND_VERSION__"];
    this.app = app2;
    this.settingsValues = {};
    this.settingsLookup = {};
    this.settingsParamLookup = {};
    this.element = $el(
      "dialog",
      {
        id: "comfy-settings-dialog",
        parent: document.body
      },
      [
        $el("table.comfy-modal-content.comfy-table", [
          $el(
            "caption",
            { textContent: `Settings (v${frontendVersion})` },
            $el("button.comfy-btn", {
              type: "button",
              textContent: "",
              onclick: /* @__PURE__ */ __name(() => {
                this.element.close();
              }, "onclick")
            })
          ),
          $el("tbody", { $: /* @__PURE__ */ __name((tbody) => this.textElement = tbody, "$") }),
          $el("button", {
            type: "button",
            textContent: "Close",
            style: {
              cursor: "pointer"
            },
            onclick: /* @__PURE__ */ __name(() => {
              this.element.close();
            }, "onclick")
          })
        ])
      ]
    );
  }
  get settings() {
    return Object.values(this.settingsLookup);
  }
  #dispatchChange(id2, value3, oldValue) {
    if (this.app.vueAppReady) {
      useSettingStore().settingValues[id2] = value3;
    }
    this.dispatchEvent(
      new CustomEvent(id2 + ".change", {
        detail: {
          value: value3,
          oldValue
        }
      })
    );
  }
  async load() {
    if (this.app.storageLocation === "browser") {
      this.settingsValues = localStorage;
    } else {
      this.settingsValues = await api.getSettings();
    }
    for (const id2 in this.settingsLookup) {
      const value3 = this.settingsValues[this.getId(id2)];
      this.settingsLookup[id2].onChange?.(value3);
      this.#dispatchChange(id2, value3);
    }
  }
  getId(id2) {
    if (this.app.storageLocation === "browser") {
      id2 = "Comfy.Settings." + id2;
    }
    return id2;
  }
  getSettingValue(id2, defaultValue) {
    let value3 = this.settingsValues[this.getId(id2)];
    if (value3 != null) {
      if (this.app.storageLocation === "browser") {
        try {
          value3 = JSON.parse(value3);
        } catch (error) {
        }
      }
    }
    return value3 ?? defaultValue;
  }
  getSettingDefaultValue(id2) {
    const param = this.settingsParamLookup[id2];
    return param?.defaultValue;
  }
  async setSettingValueAsync(id2, value3) {
    const json = JSON.stringify(value3);
    localStorage["Comfy.Settings." + id2] = json;
    let oldValue = this.getSettingValue(id2, void 0);
    this.settingsValues[this.getId(id2)] = value3;
    if (id2 in this.settingsLookup) {
      this.settingsLookup[id2].onChange?.(value3, oldValue);
    }
    this.#dispatchChange(id2, value3, oldValue);
    await api.storeSetting(id2, value3);
  }
  setSettingValue(id2, value3) {
    this.setSettingValueAsync(id2, value3).catch((err) => {
      alert(`Error saving setting '${id2}'`);
      console.error(err);
    });
  }
  refreshSetting(id2) {
    const value3 = this.getSettingValue(id2);
    this.settingsLookup[id2].onChange?.(value3);
    this.#dispatchChange(id2, value3);
  }
  addSetting(params) {
    const {
      id: id2,
      name,
      type,
      defaultValue,
      onChange: onChange5,
      attrs: attrs3 = {},
      tooltip = "",
      options: options3 = void 0
    } = params;
    if (!id2) {
      throw new Error("Settings must have an ID");
    }
    if (id2 in this.settingsLookup) {
      throw new Error(`Setting ${id2} of type ${type} must have a unique ID.`);
    }
    let skipOnChange = false;
    let value3 = this.getSettingValue(id2);
    if (value3 == null) {
      if (this.app.isNewUserSession) {
        const localValue = localStorage["Comfy.Settings." + id2];
        if (localValue) {
          value3 = JSON.parse(localValue);
          this.setSettingValue(id2, value3);
        }
      }
      if (value3 == null) {
        value3 = defaultValue;
      }
    }
    if (!skipOnChange) {
      onChange5?.(value3, void 0);
      this.#dispatchChange(id2, value3);
    }
    this.settingsParamLookup[id2] = params;
    if (this.app.vueAppReady) {
      useSettingStore().settings[id2] = params;
    }
    this.settingsLookup[id2] = {
      id: id2,
      onChange: onChange5,
      name,
      render: /* @__PURE__ */ __name(() => {
        if (type === "hidden") return;
        const setter = /* @__PURE__ */ __name((v2) => {
          if (onChange5) {
            onChange5(v2, value3);
          }
          this.setSettingValue(id2, v2);
          value3 = v2;
        }, "setter");
        value3 = this.getSettingValue(id2, defaultValue);
        let element;
        const htmlID = id2.replaceAll(".", "-");
        const labelCell = $el("td", [
          $el("label", {
            for: htmlID,
            classList: [tooltip !== "" ? "comfy-tooltip-indicator" : ""],
            textContent: name
          })
        ]);
        if (typeof type === "function") {
          element = type(name, setter, value3, attrs3);
        } else {
          switch (type) {
            case "boolean":
              element = $el("tr", [
                labelCell,
                $el("td", [
                  $el("input", {
                    id: htmlID,
                    type: "checkbox",
                    checked: value3,
                    onchange: /* @__PURE__ */ __name((event2) => {
                      const isChecked2 = event2.target.checked;
                      if (onChange5 !== void 0) {
                        onChange5(isChecked2);
                      }
                      this.setSettingValue(id2, isChecked2);
                    }, "onchange")
                  })
                ])
              ]);
              break;
            case "number":
              element = $el("tr", [
                labelCell,
                $el("td", [
                  $el("input", {
                    type,
                    value: value3,
                    id: htmlID,
                    oninput: /* @__PURE__ */ __name((e) => {
                      setter(e.target.value);
                    }, "oninput"),
                    ...attrs3
                  })
                ])
              ]);
              break;
            case "slider":
              element = $el("tr", [
                labelCell,
                $el("td", [
                  $el(
                    "div",
                    {
                      style: {
                        display: "grid",
                        gridAutoFlow: "column"
                      }
                    },
                    [
                      $el("input", {
                        ...attrs3,
                        value: value3,
                        type: "range",
                        oninput: /* @__PURE__ */ __name((e) => {
                          setter(e.target.value);
                          e.target.nextElementSibling.value = e.target.value;
                        }, "oninput")
                      }),
                      $el("input", {
                        ...attrs3,
                        value: value3,
                        id: htmlID,
                        type: "number",
                        style: { maxWidth: "4rem" },
                        oninput: /* @__PURE__ */ __name((e) => {
                          setter(e.target.value);
                          e.target.previousElementSibling.value = e.target.value;
                        }, "oninput")
                      })
                    ]
                  )
                ])
              ]);
              break;
            case "combo":
              element = $el("tr", [
                labelCell,
                $el("td", [
                  $el(
                    "select",
                    {
                      oninput: /* @__PURE__ */ __name((e) => {
                        setter(e.target.value);
                      }, "oninput")
                    },
                    (typeof options3 === "function" ? options3(value3) : options3 || []).map((opt) => {
                      if (typeof opt === "string") {
                        opt = { text: opt };
                      }
                      const v2 = opt.value ?? opt.text;
                      return $el("option", {
                        value: v2,
                        textContent: opt.text,
                        selected: value3 + "" === v2 + ""
                      });
                    })
                  )
                ])
              ]);
              break;
            case "text":
            default:
              if (type !== "text") {
                console.warn(
                  `Unsupported setting type '${type}, defaulting to text`
                );
              }
              element = $el("tr", [
                labelCell,
                $el("td", [
                  $el("input", {
                    value: value3,
                    id: htmlID,
                    oninput: /* @__PURE__ */ __name((e) => {
                      setter(e.target.value);
                    }, "oninput"),
                    ...attrs3
                  })
                ])
              ]);
              break;
          }
        }
        if (tooltip) {
          element.title = tooltip;
        }
        return element;
      }, "render")
    };
    const self2 = this;
    return {
      get value() {
        return self2.getSettingValue(id2, defaultValue);
      },
      set value(v2) {
        self2.setSettingValue(id2, v2);
      }
    };
  }
  show() {
    this.textElement.replaceChildren(
      $el(
        "tr",
        {
          style: { display: "none" }
        },
        [$el("th"), $el("th", { style: { width: "33%" } })]
      ),
      ...this.settings.sort((a, b) => a.name.localeCompare(b.name)).map((s) => s.render()).filter(Boolean)
    );
    this.element.showModal();
  }
}
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.settings = window.comfyAPI.settings || {};
window.comfyAPI.settings.ComfySettingsDialog = ComfySettingsDialog;
const useDialogStore = defineStore("dialog", {
  state: /* @__PURE__ */ __name(() => ({
    isVisible: false,
    title: "",
    headerComponent: null,
    component: null,
    props: {}
  }), "state"),
  actions: {
    showDialog(options3) {
      this.title = options3.title;
      this.headerComponent = markRaw(options3.headerComponent);
      this.component = markRaw(options3.component);
      this.props = options3.props || {};
      this.isVisible = true;
    },
    closeDialog() {
      this.isVisible = false;
    }
  }
});
var css = "\n.p-icon {\n    display: inline-block;\n}\n\n.p-icon-spin {\n    -webkit-animation: p-icon-spin 2s infinite linear;\n    animation: p-icon-spin 2s infinite linear;\n}\n\n@-webkit-keyframes p-icon-spin {\n    0% {\n        -webkit-transform: rotate(0deg);\n        transform: rotate(0deg);\n    }\n    100% {\n        -webkit-transform: rotate(359deg);\n        transform: rotate(359deg);\n    }\n}\n\n@keyframes p-icon-spin {\n    0% {\n        -webkit-transform: rotate(0deg);\n        transform: rotate(0deg);\n    }\n    100% {\n        -webkit-transform: rotate(359deg);\n        transform: rotate(359deg);\n    }\n}\n";
var BaseIconStyle = BaseStyle.extend({
  name: "baseicon",
  css
});
function _typeof$e(o) {
  "@babel/helpers - typeof";
  return _typeof$e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$e(o);
}
__name(_typeof$e, "_typeof$e");
function ownKeys$d(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
__name(ownKeys$d, "ownKeys$d");
function _objectSpread$d(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$d(Object(t), true).forEach(function(r2) {
      _defineProperty$e(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$d(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
__name(_objectSpread$d, "_objectSpread$d");
function _defineProperty$e(e, r, t) {
  return (r = _toPropertyKey$d(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty$e, "_defineProperty$e");
function _toPropertyKey$d(t) {
  var i2 = _toPrimitive$d(t, "string");
  return "symbol" == _typeof$e(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$d, "_toPropertyKey$d");
function _toPrimitive$d(t, r) {
  if ("object" != _typeof$e(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$e(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive$d, "_toPrimitive$d");
var script$U = {
  name: "BaseIcon",
  "extends": script$X,
  props: {
    label: {
      type: String,
      "default": void 0
    },
    spin: {
      type: Boolean,
      "default": false
    }
  },
  style: BaseIconStyle,
  provide: /* @__PURE__ */ __name(function provide4() {
    return {
      $pcIcon: this,
      $parentInstance: this
    };
  }, "provide"),
  methods: {
    pti: /* @__PURE__ */ __name(function pti() {
      var isLabelEmpty = isEmpty(this.label);
      return _objectSpread$d(_objectSpread$d({}, !this.isUnstyled && {
        "class": ["p-icon", {
          "p-icon-spin": this.spin
        }]
      }), {}, {
        role: !isLabelEmpty ? "img" : void 0,
        "aria-label": !isLabelEmpty ? this.label : void 0,
        "aria-hidden": isLabelEmpty
      });
    }, "pti")
  }
};
var script$T = {
  name: "BlankIcon",
  "extends": script$U
};
var _hoisted_1$11 = /* @__PURE__ */ createBaseVNode("rect", {
  width: "1",
  height: "1",
  fill: "currentColor",
  "fill-opacity": "0"
}, null, -1);
var _hoisted_2$N = [_hoisted_1$11];
function render$S(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$N, 16);
}
__name(render$S, "render$S");
script$T.render = render$S;
var script$S = {
  name: "CheckIcon",
  "extends": script$U
};
var _hoisted_1$10 = /* @__PURE__ */ createBaseVNode("path", {
  d: "M4.86199 11.5948C4.78717 11.5923 4.71366 11.5745 4.64596 11.5426C4.57826 11.5107 4.51779 11.4652 4.46827 11.4091L0.753985 7.69483C0.683167 7.64891 0.623706 7.58751 0.580092 7.51525C0.536478 7.44299 0.509851 7.36177 0.502221 7.27771C0.49459 7.19366 0.506156 7.10897 0.536046 7.03004C0.565935 6.95111 0.613367 6.88 0.674759 6.82208C0.736151 6.76416 0.8099 6.72095 0.890436 6.69571C0.970973 6.67046 1.05619 6.66385 1.13966 6.67635C1.22313 6.68886 1.30266 6.72017 1.37226 6.76792C1.44186 6.81567 1.4997 6.8786 1.54141 6.95197L4.86199 10.2503L12.6397 2.49483C12.7444 2.42694 12.8689 2.39617 12.9932 2.40745C13.1174 2.41873 13.2343 2.47141 13.3251 2.55705C13.4159 2.64268 13.4753 2.75632 13.4938 2.87973C13.5123 3.00315 13.4888 3.1292 13.4271 3.23768L5.2557 11.4091C5.20618 11.4652 5.14571 11.5107 5.07801 11.5426C5.01031 11.5745 4.9368 11.5923 4.86199 11.5948Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$M = [_hoisted_1$10];
function render$R(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$M, 16);
}
__name(render$R, "render$R");
script$S.render = render$R;
var script$R = {
  name: "SearchIcon",
  "extends": script$U
};
var _hoisted_1$$ = /* @__PURE__ */ createBaseVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M2.67602 11.0265C3.6661 11.688 4.83011 12.0411 6.02086 12.0411C6.81149 12.0411 7.59438 11.8854 8.32483 11.5828C8.87005 11.357 9.37808 11.0526 9.83317 10.6803L12.9769 13.8241C13.0323 13.8801 13.0983 13.9245 13.171 13.9548C13.2438 13.985 13.3219 14.0003 13.4007 14C13.4795 14.0003 13.5575 13.985 13.6303 13.9548C13.7031 13.9245 13.7691 13.8801 13.8244 13.8241C13.9367 13.7116 13.9998 13.5592 13.9998 13.4003C13.9998 13.2414 13.9367 13.089 13.8244 12.9765L10.6807 9.8328C11.053 9.37773 11.3573 8.86972 11.5831 8.32452C11.8857 7.59408 12.0414 6.81119 12.0414 6.02056C12.0414 4.8298 11.6883 3.66579 11.0268 2.67572C10.3652 1.68564 9.42494 0.913972 8.32483 0.45829C7.22472 0.00260857 6.01418 -0.116618 4.84631 0.115686C3.67844 0.34799 2.60568 0.921393 1.76369 1.76338C0.921698 2.60537 0.348296 3.67813 0.115991 4.84601C-0.116313 6.01388 0.00291375 7.22441 0.458595 8.32452C0.914277 9.42464 1.68595 10.3649 2.67602 11.0265ZM3.35565 2.0158C4.14456 1.48867 5.07206 1.20731 6.02086 1.20731C7.29317 1.20731 8.51338 1.71274 9.41304 2.6124C10.3127 3.51206 10.8181 4.73226 10.8181 6.00457C10.8181 6.95337 10.5368 7.88088 10.0096 8.66978C9.48251 9.45868 8.73328 10.0736 7.85669 10.4367C6.98011 10.7997 6.01554 10.8947 5.08496 10.7096C4.15439 10.5245 3.2996 10.0676 2.62869 9.39674C1.95778 8.72583 1.50089 7.87104 1.31579 6.94046C1.13068 6.00989 1.22568 5.04532 1.58878 4.16874C1.95187 3.29215 2.56675 2.54292 3.35565 2.0158Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$L = [_hoisted_1$$];
function render$Q(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$L, 16);
}
__name(render$Q, "render$Q");
script$R.render = render$Q;
var theme$v = /* @__PURE__ */ __name(function theme6(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-iconfield {\n    position: relative;\n}\n\n.p-inputicon {\n    position: absolute;\n    top: 50%;\n    margin-top: calc(-1 * (".concat(dt3("icon.size"), " / 2));\n    color: ").concat(dt3("iconfield.icon.color"), ";\n}\n\n.p-iconfield .p-inputicon:first-child {\n    left: ").concat(dt3("form.field.padding.x"), ";\n}\n\n.p-iconfield .p-inputicon:last-child {\n    right: ").concat(dt3("form.field.padding.x"), ";\n}\n\n.p-iconfield .p-inputtext:last-child {\n    padding-left: calc((").concat(dt3("form.field.padding.x"), " * 2) + ").concat(dt3("icon.size"), ");\n}\n\n.p-iconfield .p-inputtext:first-child {\n    padding-right: calc((").concat(dt3("form.field.padding.x"), " * 2) + ").concat(dt3("icon.size"), ");\n}\n");
}, "theme");
var classes$y = {
  root: "p-iconfield"
};
var IconFieldStyle = BaseStyle.extend({
  name: "iconfield",
  theme: theme$v,
  classes: classes$y
});
var script$1$y = {
  name: "BaseIconField",
  "extends": script$X,
  style: IconFieldStyle,
  provide: /* @__PURE__ */ __name(function provide5() {
    return {
      $pcIconField: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$Q = {
  name: "IconField",
  "extends": script$1$y,
  inheritAttrs: false
};
function render$P(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("root")
  }, _ctx.ptmi("root")), [renderSlot(_ctx.$slots, "default")], 16);
}
__name(render$P, "render$P");
script$Q.render = render$P;
var classes$x = {
  root: "p-inputicon"
};
var InputIconStyle = BaseStyle.extend({
  name: "inputicon",
  classes: classes$x
});
var script$1$x = {
  name: "BaseInputIcon",
  "extends": script$X,
  style: InputIconStyle,
  props: {
    "class": null
  },
  provide: /* @__PURE__ */ __name(function provide6() {
    return {
      $pcInputIcon: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$P = {
  name: "InputIcon",
  "extends": script$1$x,
  inheritAttrs: false,
  computed: {
    containerClass: /* @__PURE__ */ __name(function containerClass() {
      return [this.cx("root"), this["class"]];
    }, "containerClass")
  }
};
function render$O(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps({
    "class": $options.containerClass
  }, _ctx.ptmi("root")), [renderSlot(_ctx.$slots, "default")], 16);
}
__name(render$O, "render$O");
script$P.render = render$O;
var theme$u = /* @__PURE__ */ __name(function theme7(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-inputtext {\n    font-family: inherit;\n    font-feature-settings: inherit;\n    font-size: 1rem;\n    color: ".concat(dt3("inputtext.color"), ";\n    background: ").concat(dt3("inputtext.background"), ";\n    padding: ").concat(dt3("inputtext.padding.y"), " ").concat(dt3("inputtext.padding.x"), ";\n    border: 1px solid ").concat(dt3("inputtext.border.color"), ";\n    transition: background ").concat(dt3("inputtext.transition.duration"), ", color ").concat(dt3("inputtext.transition.duration"), ", border-color ").concat(dt3("inputtext.transition.duration"), ", outline-color ").concat(dt3("inputtext.transition.duration"), ", box-shadow ").concat(dt3("inputtext.transition.duration"), ";\n    appearance: none;\n    border-radius: ").concat(dt3("inputtext.border.radius"), ";\n    outline-color: transparent;\n    box-shadow: ").concat(dt3("inputtext.shadow"), ";\n}\n\n.p-inputtext:enabled:hover {\n    border-color: ").concat(dt3("inputtext.hover.border.color"), ";\n}\n\n.p-inputtext:enabled:focus {\n    border-color: ").concat(dt3("inputtext.focus.border.color"), ";\n    box-shadow: ").concat(dt3("inputtext.focus.ring.shadow"), ";\n    outline: ").concat(dt3("inputtext.focus.ring.width"), " ").concat(dt3("inputtext.focus.ring.style"), " ").concat(dt3("inputtext.focus.ring.color"), ";\n    outline-offset: ").concat(dt3("inputtext.focus.ring.offset"), ";\n}\n\n.p-inputtext.p-invalid {\n    border-color: ").concat(dt3("inputtext.invalid.border.color"), ";\n}\n\n.p-inputtext.p-variant-filled {\n    background: ").concat(dt3("inputtext.filled.background"), ";\n}\n\n.p-inputtext.p-variant-filled:enabled:focus {\n    background: ").concat(dt3("inputtext.filled.focus.background"), ";\n}\n\n.p-inputtext:disabled {\n    opacity: 1;\n    background: ").concat(dt3("inputtext.disabled.background"), ";\n    color: ").concat(dt3("inputtext.disabled.color"), ";\n}\n\n.p-inputtext::placeholder {\n    color: ").concat(dt3("inputtext.placeholder.color"), ";\n}\n\n.p-inputtext-sm {\n    font-size: ").concat(dt3("inputtext.sm.font.size"), ";\n    padding: ").concat(dt3("inputtext.sm.padding.y"), " ").concat(dt3("inputtext.sm.padding.x"), ";\n}\n\n.p-inputtext-lg {\n    font-size: ").concat(dt3("inputtext.lg.font.size"), ";\n    padding: ").concat(dt3("inputtext.lg.padding.y"), " ").concat(dt3("inputtext.lg.padding.x"), ";\n}\n\n.p-inputtext-fluid {\n    width: 100%;\n}\n");
}, "theme");
var classes$w = {
  root: /* @__PURE__ */ __name(function root(_ref2) {
    var instance = _ref2.instance, props = _ref2.props;
    return ["p-inputtext p-component", {
      "p-filled": instance.filled,
      "p-inputtext-sm": props.size === "small",
      "p-inputtext-lg": props.size === "large",
      "p-invalid": props.invalid,
      "p-variant-filled": props.variant ? props.variant === "filled" : instance.$primevue.config.inputStyle === "filled" || instance.$primevue.config.inputVariant === "filled",
      "p-inputtext-fluid": props.fluid
    }];
  }, "root")
};
var InputTextStyle = BaseStyle.extend({
  name: "inputtext",
  theme: theme$u,
  classes: classes$w
});
var script$1$w = {
  name: "BaseInputText",
  "extends": script$X,
  props: {
    modelValue: null,
    size: {
      type: String,
      "default": null
    },
    invalid: {
      type: Boolean,
      "default": false
    },
    variant: {
      type: String,
      "default": null
    },
    fluid: {
      type: Boolean,
      "default": false
    }
  },
  style: InputTextStyle,
  provide: /* @__PURE__ */ __name(function provide7() {
    return {
      $pcInputText: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$O = {
  name: "InputText",
  "extends": script$1$w,
  inheritAttrs: false,
  emits: ["update:modelValue"],
  methods: {
    getPTOptions: /* @__PURE__ */ __name(function getPTOptions(key) {
      var _ptm = key === "root" ? this.ptmi : this.ptm;
      return _ptm(key, {
        context: {
          filled: this.filled,
          disabled: this.$attrs.disabled || this.$attrs.disabled === ""
        }
      });
    }, "getPTOptions"),
    onInput: /* @__PURE__ */ __name(function onInput(event2) {
      this.$emit("update:modelValue", event2.target.value);
    }, "onInput")
  },
  computed: {
    filled: /* @__PURE__ */ __name(function filled() {
      return this.modelValue != null && this.modelValue.toString().length > 0;
    }, "filled")
  }
};
var _hoisted_1$_ = ["value", "aria-invalid"];
function render$N(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("input", mergeProps({
    type: "text",
    "class": _ctx.cx("root"),
    value: _ctx.modelValue,
    "aria-invalid": _ctx.invalid || void 0,
    onInput: _cache[0] || (_cache[0] = function() {
      return $options.onInput && $options.onInput.apply($options, arguments);
    })
  }, $options.getPTOptions("root")), null, 16, _hoisted_1$_);
}
__name(render$N, "render$N");
script$O.render = render$N;
var theme$t = /* @__PURE__ */ __name(function theme8(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-ink {\n    display: block;\n    position: absolute;\n    background: ".concat(dt3("ripple.background"), ";\n    border-radius: 100%;\n    transform: scale(0);\n    pointer-events: none;\n}\n\n.p-ink-active {\n    animation: ripple 0.4s linear;\n}\n\n@keyframes ripple {\n    100% {\n        opacity: 0;\n        transform: scale(2.5);\n    }\n}\n");
}, "theme");
var classes$v = {
  root: "p-ink"
};
var RippleStyle = BaseStyle.extend({
  name: "ripple-directive",
  theme: theme$t,
  classes: classes$v
});
var BaseRipple = BaseDirective.extend({
  style: RippleStyle
});
function _typeof$d(o) {
  "@babel/helpers - typeof";
  return _typeof$d = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$d(o);
}
__name(_typeof$d, "_typeof$d");
function _toConsumableArray$d(r) {
  return _arrayWithoutHoles$d(r) || _iterableToArray$d(r) || _unsupportedIterableToArray$f(r) || _nonIterableSpread$d();
}
__name(_toConsumableArray$d, "_toConsumableArray$d");
function _nonIterableSpread$d() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableSpread$d, "_nonIterableSpread$d");
function _unsupportedIterableToArray$f(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$f(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$f(r, a) : void 0;
  }
}
__name(_unsupportedIterableToArray$f, "_unsupportedIterableToArray$f");
function _iterableToArray$d(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
__name(_iterableToArray$d, "_iterableToArray$d");
function _arrayWithoutHoles$d(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$f(r);
}
__name(_arrayWithoutHoles$d, "_arrayWithoutHoles$d");
function _arrayLikeToArray$f(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
__name(_arrayLikeToArray$f, "_arrayLikeToArray$f");
function _defineProperty$d(e, r, t) {
  return (r = _toPropertyKey$c(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty$d, "_defineProperty$d");
function _toPropertyKey$c(t) {
  var i2 = _toPrimitive$c(t, "string");
  return "symbol" == _typeof$d(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$c, "_toPropertyKey$c");
function _toPrimitive$c(t, r) {
  if ("object" != _typeof$d(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$d(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive$c, "_toPrimitive$c");
var Ripple = BaseRipple.extend("ripple", {
  watch: {
    "config.ripple": /* @__PURE__ */ __name(function configRipple(newValue) {
      if (newValue) {
        this.createRipple(this.$host);
        this.bindEvents(this.$host);
        this.$host.setAttribute("data-pd-ripple", true);
        this.$host.style["overflow"] = "hidden";
        this.$host.style["position"] = "relative";
      } else {
        this.remove(this.$host);
        this.$host.removeAttribute("data-pd-ripple");
      }
    }, "configRipple")
  },
  unmounted: /* @__PURE__ */ __name(function unmounted3(el) {
    this.remove(el);
  }, "unmounted"),
  timeout: void 0,
  methods: {
    bindEvents: /* @__PURE__ */ __name(function bindEvents2(el) {
      el.addEventListener("mousedown", this.onMouseDown.bind(this));
    }, "bindEvents"),
    unbindEvents: /* @__PURE__ */ __name(function unbindEvents2(el) {
      el.removeEventListener("mousedown", this.onMouseDown.bind(this));
    }, "unbindEvents"),
    createRipple: /* @__PURE__ */ __name(function createRipple(el) {
      var ink = createElement("span", _defineProperty$d(_defineProperty$d({
        role: "presentation",
        "aria-hidden": true,
        "data-p-ink": true,
        "data-p-ink-active": false,
        "class": !this.isUnstyled() && this.cx("root"),
        onAnimationEnd: this.onAnimationEnd.bind(this)
      }, this.$attrSelector, ""), "p-bind", this.ptm("root")));
      el.appendChild(ink);
      this.$el = ink;
    }, "createRipple"),
    remove: /* @__PURE__ */ __name(function remove3(el) {
      var ink = this.getInk(el);
      if (ink) {
        this.$host.style["overflow"] = "";
        this.$host.style["position"] = "";
        this.unbindEvents(el);
        ink.removeEventListener("animationend", this.onAnimationEnd);
        ink.remove();
      }
    }, "remove"),
    onMouseDown: /* @__PURE__ */ __name(function onMouseDown(event2) {
      var _this = this;
      var target = event2.currentTarget;
      var ink = this.getInk(target);
      if (!ink || getComputedStyle(ink, null).display === "none") {
        return;
      }
      !this.isUnstyled() && removeClass(ink, "p-ink-active");
      ink.setAttribute("data-p-ink-active", "false");
      if (!getHeight(ink) && !getWidth(ink)) {
        var d = Math.max(getOuterWidth(target), getOuterHeight(target));
        ink.style.height = d + "px";
        ink.style.width = d + "px";
      }
      var offset = getOffset(target);
      var x2 = event2.pageX - offset.left + document.body.scrollTop - getWidth(ink) / 2;
      var y2 = event2.pageY - offset.top + document.body.scrollLeft - getHeight(ink) / 2;
      ink.style.top = y2 + "px";
      ink.style.left = x2 + "px";
      !this.isUnstyled() && addClass(ink, "p-ink-active");
      ink.setAttribute("data-p-ink-active", "true");
      this.timeout = setTimeout(function() {
        if (ink) {
          !_this.isUnstyled() && removeClass(ink, "p-ink-active");
          ink.setAttribute("data-p-ink-active", "false");
        }
      }, 401);
    }, "onMouseDown"),
    onAnimationEnd: /* @__PURE__ */ __name(function onAnimationEnd(event2) {
      if (this.timeout) {
        clearTimeout(this.timeout);
      }
      !this.isUnstyled() && removeClass(event2.currentTarget, "p-ink-active");
      event2.currentTarget.setAttribute("data-p-ink-active", "false");
    }, "onAnimationEnd"),
    getInk: /* @__PURE__ */ __name(function getInk(el) {
      return el && el.children ? _toConsumableArray$d(el.children).find(function(child) {
        return getAttribute(child, "data-pc-name") === "ripple";
      }) : void 0;
    }, "getInk")
  }
});
var script$N = {
  name: "SpinnerIcon",
  "extends": script$U
};
var _hoisted_1$Z = /* @__PURE__ */ createBaseVNode("path", {
  d: "M6.99701 14C5.85441 13.999 4.72939 13.7186 3.72012 13.1832C2.71084 12.6478 1.84795 11.8737 1.20673 10.9284C0.565504 9.98305 0.165424 8.89526 0.041387 7.75989C-0.0826496 6.62453 0.073125 5.47607 0.495122 4.4147C0.917119 3.35333 1.59252 2.4113 2.46241 1.67077C3.33229 0.930247 4.37024 0.413729 5.4857 0.166275C6.60117 -0.0811796 7.76026 -0.0520535 8.86188 0.251112C9.9635 0.554278 10.9742 1.12227 11.8057 1.90555C11.915 2.01493 11.9764 2.16319 11.9764 2.31778C11.9764 2.47236 11.915 2.62062 11.8057 2.73C11.7521 2.78503 11.688 2.82877 11.6171 2.85864C11.5463 2.8885 11.4702 2.90389 11.3933 2.90389C11.3165 2.90389 11.2404 2.8885 11.1695 2.85864C11.0987 2.82877 11.0346 2.78503 10.9809 2.73C9.9998 1.81273 8.73246 1.26138 7.39226 1.16876C6.05206 1.07615 4.72086 1.44794 3.62279 2.22152C2.52471 2.99511 1.72683 4.12325 1.36345 5.41602C1.00008 6.70879 1.09342 8.08723 1.62775 9.31926C2.16209 10.5513 3.10478 11.5617 4.29713 12.1803C5.48947 12.7989 6.85865 12.988 8.17414 12.7157C9.48963 12.4435 10.6711 11.7264 11.5196 10.6854C12.3681 9.64432 12.8319 8.34282 12.8328 7C12.8328 6.84529 12.8943 6.69692 13.0038 6.58752C13.1132 6.47812 13.2616 6.41667 13.4164 6.41667C13.5712 6.41667 13.7196 6.47812 13.8291 6.58752C13.9385 6.69692 14 6.84529 14 7C14 8.85651 13.2622 10.637 11.9489 11.9497C10.6356 13.2625 8.85432 14 6.99701 14Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$K = [_hoisted_1$Z];
function render$M(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$K, 16);
}
__name(render$M, "render$M");
script$N.render = render$M;
var theme$s = /* @__PURE__ */ __name(function theme9(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-virtualscroller {\n    position: relative;\n    overflow: auto;\n    contain: strict;\n    transform: translateZ(0);\n    will-change: scroll-position;\n    outline: 0 none;\n}\n\n.p-virtualscroller-content {\n    position: absolute;\n    top: 0;\n    left: 0;\n    min-height: 100%;\n    min-width: 100%;\n    will-change: transform;\n}\n\n.p-virtualscroller-spacer {\n    position: absolute;\n    top: 0;\n    left: 0;\n    height: 1px;\n    width: 1px;\n    transform-origin: 0 0;\n    pointer-events: none;\n}\n\n.p-virtualscroller-loader {\n    position: sticky;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background: ".concat(dt3("virtualscroller.loader.mask.background"), ";\n    color: ").concat(dt3("virtualscroller.loader.mask.color"), ";\n}\n\n.p-virtualscroller-loader-mask {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.p-virtualscroller-loading-icon {\n    font-size: ").concat(dt3("virtualscroller.loader.icon.size"), ";\n    width: ").concat(dt3("virtualscroller.loader.icon.size"), ";\n    height: ").concat(dt3("virtualscroller.loader.icon.size"), ";\n}\n\n.p-virtualscroller-horizontal > .p-virtualscroller-content {\n    display: flex;\n}\n\n.p-virtualscroller-inline .p-virtualscroller-content {\n    position: static;\n}\n");
}, "theme");
var VirtualScrollerStyle = BaseStyle.extend({
  name: "virtualscroller",
  theme: theme$s
});
var script$1$v = {
  name: "BaseVirtualScroller",
  "extends": script$X,
  props: {
    id: {
      type: String,
      "default": null
    },
    style: null,
    "class": null,
    items: {
      type: Array,
      "default": null
    },
    itemSize: {
      type: [Number, Array],
      "default": 0
    },
    scrollHeight: null,
    scrollWidth: null,
    orientation: {
      type: String,
      "default": "vertical"
    },
    numToleratedItems: {
      type: Number,
      "default": null
    },
    delay: {
      type: Number,
      "default": 0
    },
    resizeDelay: {
      type: Number,
      "default": 10
    },
    lazy: {
      type: Boolean,
      "default": false
    },
    disabled: {
      type: Boolean,
      "default": false
    },
    loaderDisabled: {
      type: Boolean,
      "default": false
    },
    columns: {
      type: Array,
      "default": null
    },
    loading: {
      type: Boolean,
      "default": false
    },
    showSpacer: {
      type: Boolean,
      "default": true
    },
    showLoader: {
      type: Boolean,
      "default": false
    },
    tabindex: {
      type: Number,
      "default": 0
    },
    inline: {
      type: Boolean,
      "default": false
    },
    step: {
      type: Number,
      "default": 0
    },
    appendOnly: {
      type: Boolean,
      "default": false
    },
    autoSize: {
      type: Boolean,
      "default": false
    }
  },
  style: VirtualScrollerStyle,
  provide: /* @__PURE__ */ __name(function provide8() {
    return {
      $pcVirtualScroller: this,
      $parentInstance: this
    };
  }, "provide"),
  beforeMount: /* @__PURE__ */ __name(function beforeMount3() {
    var _this$$primevueConfig;
    VirtualScrollerStyle.loadCSS({
      nonce: (_this$$primevueConfig = this.$primevueConfig) === null || _this$$primevueConfig === void 0 || (_this$$primevueConfig = _this$$primevueConfig.csp) === null || _this$$primevueConfig === void 0 ? void 0 : _this$$primevueConfig.nonce
    });
  }, "beforeMount")
};
function _typeof$c(o) {
  "@babel/helpers - typeof";
  return _typeof$c = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$c(o);
}
__name(_typeof$c, "_typeof$c");
function ownKeys$c(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
__name(ownKeys$c, "ownKeys$c");
function _objectSpread$c(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$c(Object(t), true).forEach(function(r2) {
      _defineProperty$c(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$c(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
__name(_objectSpread$c, "_objectSpread$c");
function _defineProperty$c(e, r, t) {
  return (r = _toPropertyKey$b(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty$c, "_defineProperty$c");
function _toPropertyKey$b(t) {
  var i2 = _toPrimitive$b(t, "string");
  return "symbol" == _typeof$c(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$b, "_toPropertyKey$b");
function _toPrimitive$b(t, r) {
  if ("object" != _typeof$c(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$c(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive$b, "_toPrimitive$b");
var script$M = {
  name: "VirtualScroller",
  "extends": script$1$v,
  inheritAttrs: false,
  emits: ["update:numToleratedItems", "scroll", "scroll-index-change", "lazy-load"],
  data: /* @__PURE__ */ __name(function data2() {
    var both = this.isBoth();
    return {
      first: both ? {
        rows: 0,
        cols: 0
      } : 0,
      last: both ? {
        rows: 0,
        cols: 0
      } : 0,
      page: both ? {
        rows: 0,
        cols: 0
      } : 0,
      numItemsInViewport: both ? {
        rows: 0,
        cols: 0
      } : 0,
      lastScrollPos: both ? {
        top: 0,
        left: 0
      } : 0,
      d_numToleratedItems: this.numToleratedItems,
      d_loading: this.loading,
      loaderArr: [],
      spacerStyle: {},
      contentStyle: {}
    };
  }, "data"),
  element: null,
  content: null,
  lastScrollPos: null,
  scrollTimeout: null,
  resizeTimeout: null,
  defaultWidth: 0,
  defaultHeight: 0,
  defaultContentWidth: 0,
  defaultContentHeight: 0,
  isRangeChanged: false,
  lazyLoadState: {},
  resizeListener: null,
  initialized: false,
  watch: {
    numToleratedItems: /* @__PURE__ */ __name(function numToleratedItems(newValue) {
      this.d_numToleratedItems = newValue;
    }, "numToleratedItems"),
    loading: /* @__PURE__ */ __name(function loading(newValue, oldValue) {
      if (this.lazy && newValue !== oldValue && newValue !== this.d_loading) {
        this.d_loading = newValue;
      }
    }, "loading"),
    items: /* @__PURE__ */ __name(function items(newValue, oldValue) {
      if (!oldValue || oldValue.length !== (newValue || []).length) {
        this.init();
        this.calculateAutoSize();
      }
    }, "items"),
    itemSize: /* @__PURE__ */ __name(function itemSize() {
      this.init();
      this.calculateAutoSize();
    }, "itemSize"),
    orientation: /* @__PURE__ */ __name(function orientation() {
      this.lastScrollPos = this.isBoth() ? {
        top: 0,
        left: 0
      } : 0;
    }, "orientation"),
    scrollHeight: /* @__PURE__ */ __name(function scrollHeight() {
      this.init();
      this.calculateAutoSize();
    }, "scrollHeight"),
    scrollWidth: /* @__PURE__ */ __name(function scrollWidth() {
      this.init();
      this.calculateAutoSize();
    }, "scrollWidth")
  },
  mounted: /* @__PURE__ */ __name(function mounted3() {
    this.viewInit();
    this.lastScrollPos = this.isBoth() ? {
      top: 0,
      left: 0
    } : 0;
    this.lazyLoadState = this.lazyLoadState || {};
  }, "mounted"),
  updated: /* @__PURE__ */ __name(function updated3() {
    !this.initialized && this.viewInit();
  }, "updated"),
  unmounted: /* @__PURE__ */ __name(function unmounted4() {
    this.unbindResizeListener();
    this.initialized = false;
  }, "unmounted"),
  methods: {
    viewInit: /* @__PURE__ */ __name(function viewInit() {
      if (isVisible(this.element)) {
        this.setContentEl(this.content);
        this.init();
        this.calculateAutoSize();
        this.bindResizeListener();
        this.defaultWidth = getWidth(this.element);
        this.defaultHeight = getHeight(this.element);
        this.defaultContentWidth = getWidth(this.content);
        this.defaultContentHeight = getHeight(this.content);
        this.initialized = true;
      }
    }, "viewInit"),
    init: /* @__PURE__ */ __name(function init() {
      if (!this.disabled) {
        this.setSize();
        this.calculateOptions();
        this.setSpacerSize();
      }
    }, "init"),
    isVertical: /* @__PURE__ */ __name(function isVertical() {
      return this.orientation === "vertical";
    }, "isVertical"),
    isHorizontal: /* @__PURE__ */ __name(function isHorizontal() {
      return this.orientation === "horizontal";
    }, "isHorizontal"),
    isBoth: /* @__PURE__ */ __name(function isBoth() {
      return this.orientation === "both";
    }, "isBoth"),
    scrollTo: /* @__PURE__ */ __name(function scrollTo2(options3) {
      this.element && this.element.scrollTo(options3);
    }, "scrollTo"),
    scrollToIndex: /* @__PURE__ */ __name(function scrollToIndex(index2) {
      var _this = this;
      var behavior = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "auto";
      var both = this.isBoth();
      var horizontal3 = this.isHorizontal();
      var valid = both ? index2.every(function(i2) {
        return i2 > -1;
      }) : index2 > -1;
      if (valid) {
        var first = this.first;
        var _this$element = this.element, _this$element$scrollT = _this$element.scrollTop, scrollTop2 = _this$element$scrollT === void 0 ? 0 : _this$element$scrollT, _this$element$scrollL = _this$element.scrollLeft, scrollLeft = _this$element$scrollL === void 0 ? 0 : _this$element$scrollL;
        var _this$calculateNumIte = this.calculateNumItems(), numToleratedItems2 = _this$calculateNumIte.numToleratedItems;
        var contentPos = this.getContentPosition();
        var itemSize2 = this.itemSize;
        var calculateFirst = /* @__PURE__ */ __name(function calculateFirst2() {
          var _index = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
          var _numT = arguments.length > 1 ? arguments[1] : void 0;
          return _index <= _numT ? 0 : _index;
        }, "calculateFirst");
        var calculateCoord = /* @__PURE__ */ __name(function calculateCoord2(_first, _size, _cpos) {
          return _first * _size + _cpos;
        }, "calculateCoord");
        var scrollTo3 = /* @__PURE__ */ __name(function scrollTo4() {
          var left = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
          var top = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
          return _this.scrollTo({
            left,
            top,
            behavior
          });
        }, "scrollTo");
        var newFirst = both ? {
          rows: 0,
          cols: 0
        } : 0;
        var isRangeChanged = false, isScrollChanged = false;
        if (both) {
          newFirst = {
            rows: calculateFirst(index2[0], numToleratedItems2[0]),
            cols: calculateFirst(index2[1], numToleratedItems2[1])
          };
          scrollTo3(calculateCoord(newFirst.cols, itemSize2[1], contentPos.left), calculateCoord(newFirst.rows, itemSize2[0], contentPos.top));
          isScrollChanged = this.lastScrollPos.top !== scrollTop2 || this.lastScrollPos.left !== scrollLeft;
          isRangeChanged = newFirst.rows !== first.rows || newFirst.cols !== first.cols;
        } else {
          newFirst = calculateFirst(index2, numToleratedItems2);
          horizontal3 ? scrollTo3(calculateCoord(newFirst, itemSize2, contentPos.left), scrollTop2) : scrollTo3(scrollLeft, calculateCoord(newFirst, itemSize2, contentPos.top));
          isScrollChanged = this.lastScrollPos !== (horizontal3 ? scrollLeft : scrollTop2);
          isRangeChanged = newFirst !== first;
        }
        this.isRangeChanged = isRangeChanged;
        isScrollChanged && (this.first = newFirst);
      }
    }, "scrollToIndex"),
    scrollInView: /* @__PURE__ */ __name(function scrollInView2(index2, to) {
      var _this2 = this;
      var behavior = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "auto";
      if (to) {
        var both = this.isBoth();
        var horizontal3 = this.isHorizontal();
        var valid = both ? index2.every(function(i2) {
          return i2 > -1;
        }) : index2 > -1;
        if (valid) {
          var _this$getRenderedRang = this.getRenderedRange(), first = _this$getRenderedRang.first, viewport = _this$getRenderedRang.viewport;
          var scrollTo3 = /* @__PURE__ */ __name(function scrollTo4() {
            var left = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            var top = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            return _this2.scrollTo({
              left,
              top,
              behavior
            });
          }, "scrollTo");
          var isToStart = to === "to-start";
          var isToEnd = to === "to-end";
          if (isToStart) {
            if (both) {
              if (viewport.first.rows - first.rows > index2[0]) {
                scrollTo3(viewport.first.cols * this.itemSize[1], (viewport.first.rows - 1) * this.itemSize[0]);
              } else if (viewport.first.cols - first.cols > index2[1]) {
                scrollTo3((viewport.first.cols - 1) * this.itemSize[1], viewport.first.rows * this.itemSize[0]);
              }
            } else {
              if (viewport.first - first > index2) {
                var pos2 = (viewport.first - 1) * this.itemSize;
                horizontal3 ? scrollTo3(pos2, 0) : scrollTo3(0, pos2);
              }
            }
          } else if (isToEnd) {
            if (both) {
              if (viewport.last.rows - first.rows <= index2[0] + 1) {
                scrollTo3(viewport.first.cols * this.itemSize[1], (viewport.first.rows + 1) * this.itemSize[0]);
              } else if (viewport.last.cols - first.cols <= index2[1] + 1) {
                scrollTo3((viewport.first.cols + 1) * this.itemSize[1], viewport.first.rows * this.itemSize[0]);
              }
            } else {
              if (viewport.last - first <= index2 + 1) {
                var _pos2 = (viewport.first + 1) * this.itemSize;
                horizontal3 ? scrollTo3(_pos2, 0) : scrollTo3(0, _pos2);
              }
            }
          }
        }
      } else {
        this.scrollToIndex(index2, behavior);
      }
    }, "scrollInView"),
    getRenderedRange: /* @__PURE__ */ __name(function getRenderedRange() {
      var calculateFirstInViewport = /* @__PURE__ */ __name(function calculateFirstInViewport2(_pos, _size) {
        return Math.floor(_pos / (_size || _pos));
      }, "calculateFirstInViewport");
      var firstInViewport = this.first;
      var lastInViewport = 0;
      if (this.element) {
        var both = this.isBoth();
        var horizontal3 = this.isHorizontal();
        var _this$element2 = this.element, scrollTop2 = _this$element2.scrollTop, scrollLeft = _this$element2.scrollLeft;
        if (both) {
          firstInViewport = {
            rows: calculateFirstInViewport(scrollTop2, this.itemSize[0]),
            cols: calculateFirstInViewport(scrollLeft, this.itemSize[1])
          };
          lastInViewport = {
            rows: firstInViewport.rows + this.numItemsInViewport.rows,
            cols: firstInViewport.cols + this.numItemsInViewport.cols
          };
        } else {
          var scrollPos = horizontal3 ? scrollLeft : scrollTop2;
          firstInViewport = calculateFirstInViewport(scrollPos, this.itemSize);
          lastInViewport = firstInViewport + this.numItemsInViewport;
        }
      }
      return {
        first: this.first,
        last: this.last,
        viewport: {
          first: firstInViewport,
          last: lastInViewport
        }
      };
    }, "getRenderedRange"),
    calculateNumItems: /* @__PURE__ */ __name(function calculateNumItems() {
      var both = this.isBoth();
      var horizontal3 = this.isHorizontal();
      var itemSize2 = this.itemSize;
      var contentPos = this.getContentPosition();
      var contentWidth = this.element ? this.element.offsetWidth - contentPos.left : 0;
      var contentHeight = this.element ? this.element.offsetHeight - contentPos.top : 0;
      var calculateNumItemsInViewport = /* @__PURE__ */ __name(function calculateNumItemsInViewport2(_contentSize, _itemSize) {
        return Math.ceil(_contentSize / (_itemSize || _contentSize));
      }, "calculateNumItemsInViewport");
      var calculateNumToleratedItems = /* @__PURE__ */ __name(function calculateNumToleratedItems2(_numItems) {
        return Math.ceil(_numItems / 2);
      }, "calculateNumToleratedItems");
      var numItemsInViewport = both ? {
        rows: calculateNumItemsInViewport(contentHeight, itemSize2[0]),
        cols: calculateNumItemsInViewport(contentWidth, itemSize2[1])
      } : calculateNumItemsInViewport(horizontal3 ? contentWidth : contentHeight, itemSize2);
      var numToleratedItems2 = this.d_numToleratedItems || (both ? [calculateNumToleratedItems(numItemsInViewport.rows), calculateNumToleratedItems(numItemsInViewport.cols)] : calculateNumToleratedItems(numItemsInViewport));
      return {
        numItemsInViewport,
        numToleratedItems: numToleratedItems2
      };
    }, "calculateNumItems"),
    calculateOptions: /* @__PURE__ */ __name(function calculateOptions() {
      var _this3 = this;
      var both = this.isBoth();
      var first = this.first;
      var _this$calculateNumIte2 = this.calculateNumItems(), numItemsInViewport = _this$calculateNumIte2.numItemsInViewport, numToleratedItems2 = _this$calculateNumIte2.numToleratedItems;
      var calculateLast = /* @__PURE__ */ __name(function calculateLast2(_first, _num, _numT) {
        var _isCols = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
        return _this3.getLast(_first + _num + (_first < _numT ? 2 : 3) * _numT, _isCols);
      }, "calculateLast");
      var last = both ? {
        rows: calculateLast(first.rows, numItemsInViewport.rows, numToleratedItems2[0]),
        cols: calculateLast(first.cols, numItemsInViewport.cols, numToleratedItems2[1], true)
      } : calculateLast(first, numItemsInViewport, numToleratedItems2);
      this.last = last;
      this.numItemsInViewport = numItemsInViewport;
      this.d_numToleratedItems = numToleratedItems2;
      this.$emit("update:numToleratedItems", this.d_numToleratedItems);
      if (this.showLoader) {
        this.loaderArr = both ? Array.from({
          length: numItemsInViewport.rows
        }).map(function() {
          return Array.from({
            length: numItemsInViewport.cols
          });
        }) : Array.from({
          length: numItemsInViewport
        });
      }
      if (this.lazy) {
        Promise.resolve().then(function() {
          var _this3$items;
          _this3.lazyLoadState = {
            first: _this3.step ? both ? {
              rows: 0,
              cols: first.cols
            } : 0 : first,
            last: Math.min(_this3.step ? _this3.step : last, ((_this3$items = _this3.items) === null || _this3$items === void 0 ? void 0 : _this3$items.length) || 0)
          };
          _this3.$emit("lazy-load", _this3.lazyLoadState);
        });
      }
    }, "calculateOptions"),
    calculateAutoSize: /* @__PURE__ */ __name(function calculateAutoSize() {
      var _this4 = this;
      if (this.autoSize && !this.d_loading) {
        Promise.resolve().then(function() {
          if (_this4.content) {
            var both = _this4.isBoth();
            var horizontal3 = _this4.isHorizontal();
            var vertical2 = _this4.isVertical();
            _this4.content.style.minHeight = _this4.content.style.minWidth = "auto";
            _this4.content.style.position = "relative";
            _this4.element.style.contain = "none";
            var _ref = [getWidth(_this4.element), getHeight(_this4.element)], width2 = _ref[0], height = _ref[1];
            (both || horizontal3) && (_this4.element.style.width = width2 < _this4.defaultWidth ? width2 + "px" : _this4.scrollWidth || _this4.defaultWidth + "px");
            (both || vertical2) && (_this4.element.style.height = height < _this4.defaultHeight ? height + "px" : _this4.scrollHeight || _this4.defaultHeight + "px");
            _this4.content.style.minHeight = _this4.content.style.minWidth = "";
            _this4.content.style.position = "";
            _this4.element.style.contain = "";
          }
        });
      }
    }, "calculateAutoSize"),
    getLast: /* @__PURE__ */ __name(function getLast() {
      var _ref2, _this$items;
      var last = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      var isCols = arguments.length > 1 ? arguments[1] : void 0;
      return this.items ? Math.min(isCols ? ((_ref2 = this.columns || this.items[0]) === null || _ref2 === void 0 ? void 0 : _ref2.length) || 0 : ((_this$items = this.items) === null || _this$items === void 0 ? void 0 : _this$items.length) || 0, last) : 0;
    }, "getLast"),
    getContentPosition: /* @__PURE__ */ __name(function getContentPosition() {
      if (this.content) {
        var style = getComputedStyle(this.content);
        var left = parseFloat(style.paddingLeft) + Math.max(parseFloat(style.left) || 0, 0);
        var right = parseFloat(style.paddingRight) + Math.max(parseFloat(style.right) || 0, 0);
        var top = parseFloat(style.paddingTop) + Math.max(parseFloat(style.top) || 0, 0);
        var bottom = parseFloat(style.paddingBottom) + Math.max(parseFloat(style.bottom) || 0, 0);
        return {
          left,
          right,
          top,
          bottom,
          x: left + right,
          y: top + bottom
        };
      }
      return {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0,
        x: 0,
        y: 0
      };
    }, "getContentPosition"),
    setSize: /* @__PURE__ */ __name(function setSize() {
      var _this5 = this;
      if (this.element) {
        var both = this.isBoth();
        var horizontal3 = this.isHorizontal();
        var parentElement = this.element.parentElement;
        var width2 = this.scrollWidth || "".concat(this.element.offsetWidth || parentElement.offsetWidth, "px");
        var height = this.scrollHeight || "".concat(this.element.offsetHeight || parentElement.offsetHeight, "px");
        var setProp = /* @__PURE__ */ __name(function setProp2(_name, _value) {
          return _this5.element.style[_name] = _value;
        }, "setProp");
        if (both || horizontal3) {
          setProp("height", height);
          setProp("width", width2);
        } else {
          setProp("height", height);
        }
      }
    }, "setSize"),
    setSpacerSize: /* @__PURE__ */ __name(function setSpacerSize() {
      var _this6 = this;
      var items2 = this.items;
      if (items2) {
        var both = this.isBoth();
        var horizontal3 = this.isHorizontal();
        var contentPos = this.getContentPosition();
        var setProp = /* @__PURE__ */ __name(function setProp2(_name, _value, _size) {
          var _cpos = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
          return _this6.spacerStyle = _objectSpread$c(_objectSpread$c({}, _this6.spacerStyle), _defineProperty$c({}, "".concat(_name), (_value || []).length * _size + _cpos + "px"));
        }, "setProp");
        if (both) {
          setProp("height", items2, this.itemSize[0], contentPos.y);
          setProp("width", this.columns || items2[1], this.itemSize[1], contentPos.x);
        } else {
          horizontal3 ? setProp("width", this.columns || items2, this.itemSize, contentPos.x) : setProp("height", items2, this.itemSize, contentPos.y);
        }
      }
    }, "setSpacerSize"),
    setContentPosition: /* @__PURE__ */ __name(function setContentPosition(pos2) {
      var _this7 = this;
      if (this.content && !this.appendOnly) {
        var both = this.isBoth();
        var horizontal3 = this.isHorizontal();
        var first = pos2 ? pos2.first : this.first;
        var calculateTranslateVal = /* @__PURE__ */ __name(function calculateTranslateVal2(_first, _size) {
          return _first * _size;
        }, "calculateTranslateVal");
        var setTransform = /* @__PURE__ */ __name(function setTransform2() {
          var _x = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
          var _y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
          return _this7.contentStyle = _objectSpread$c(_objectSpread$c({}, _this7.contentStyle), {
            transform: "translate3d(".concat(_x, "px, ").concat(_y, "px, 0)")
          });
        }, "setTransform");
        if (both) {
          setTransform(calculateTranslateVal(first.cols, this.itemSize[1]), calculateTranslateVal(first.rows, this.itemSize[0]));
        } else {
          var translateVal = calculateTranslateVal(first, this.itemSize);
          horizontal3 ? setTransform(translateVal, 0) : setTransform(0, translateVal);
        }
      }
    }, "setContentPosition"),
    onScrollPositionChange: /* @__PURE__ */ __name(function onScrollPositionChange(event2) {
      var _this8 = this;
      var target = event2.target;
      var both = this.isBoth();
      var horizontal3 = this.isHorizontal();
      var contentPos = this.getContentPosition();
      var calculateScrollPos = /* @__PURE__ */ __name(function calculateScrollPos2(_pos, _cpos) {
        return _pos ? _pos > _cpos ? _pos - _cpos : _pos : 0;
      }, "calculateScrollPos");
      var calculateCurrentIndex = /* @__PURE__ */ __name(function calculateCurrentIndex2(_pos, _size) {
        return Math.floor(_pos / (_size || _pos));
      }, "calculateCurrentIndex");
      var calculateTriggerIndex = /* @__PURE__ */ __name(function calculateTriggerIndex2(_currentIndex, _first, _last, _num, _numT, _isScrollDownOrRight) {
        return _currentIndex <= _numT ? _numT : _isScrollDownOrRight ? _last - _num - _numT : _first + _numT - 1;
      }, "calculateTriggerIndex");
      var calculateFirst = /* @__PURE__ */ __name(function calculateFirst2(_currentIndex, _triggerIndex, _first, _last, _num, _numT, _isScrollDownOrRight) {
        if (_currentIndex <= _numT) return 0;
        else return Math.max(0, _isScrollDownOrRight ? _currentIndex < _triggerIndex ? _first : _currentIndex - _numT : _currentIndex > _triggerIndex ? _first : _currentIndex - 2 * _numT);
      }, "calculateFirst");
      var calculateLast = /* @__PURE__ */ __name(function calculateLast2(_currentIndex, _first, _last, _num, _numT, _isCols) {
        var lastValue = _first + _num + 2 * _numT;
        if (_currentIndex >= _numT) {
          lastValue += _numT + 1;
        }
        return _this8.getLast(lastValue, _isCols);
      }, "calculateLast");
      var scrollTop2 = calculateScrollPos(target.scrollTop, contentPos.top);
      var scrollLeft = calculateScrollPos(target.scrollLeft, contentPos.left);
      var newFirst = both ? {
        rows: 0,
        cols: 0
      } : 0;
      var newLast = this.last;
      var isRangeChanged = false;
      var newScrollPos = this.lastScrollPos;
      if (both) {
        var isScrollDown = this.lastScrollPos.top <= scrollTop2;
        var isScrollRight = this.lastScrollPos.left <= scrollLeft;
        if (!this.appendOnly || this.appendOnly && (isScrollDown || isScrollRight)) {
          var currentIndex = {
            rows: calculateCurrentIndex(scrollTop2, this.itemSize[0]),
            cols: calculateCurrentIndex(scrollLeft, this.itemSize[1])
          };
          var triggerIndex = {
            rows: calculateTriggerIndex(currentIndex.rows, this.first.rows, this.last.rows, this.numItemsInViewport.rows, this.d_numToleratedItems[0], isScrollDown),
            cols: calculateTriggerIndex(currentIndex.cols, this.first.cols, this.last.cols, this.numItemsInViewport.cols, this.d_numToleratedItems[1], isScrollRight)
          };
          newFirst = {
            rows: calculateFirst(currentIndex.rows, triggerIndex.rows, this.first.rows, this.last.rows, this.numItemsInViewport.rows, this.d_numToleratedItems[0], isScrollDown),
            cols: calculateFirst(currentIndex.cols, triggerIndex.cols, this.first.cols, this.last.cols, this.numItemsInViewport.cols, this.d_numToleratedItems[1], isScrollRight)
          };
          newLast = {
            rows: calculateLast(currentIndex.rows, newFirst.rows, this.last.rows, this.numItemsInViewport.rows, this.d_numToleratedItems[0]),
            cols: calculateLast(currentIndex.cols, newFirst.cols, this.last.cols, this.numItemsInViewport.cols, this.d_numToleratedItems[1], true)
          };
          isRangeChanged = newFirst.rows !== this.first.rows || newLast.rows !== this.last.rows || newFirst.cols !== this.first.cols || newLast.cols !== this.last.cols || this.isRangeChanged;
          newScrollPos = {
            top: scrollTop2,
            left: scrollLeft
          };
        }
      } else {
        var scrollPos = horizontal3 ? scrollLeft : scrollTop2;
        var isScrollDownOrRight = this.lastScrollPos <= scrollPos;
        if (!this.appendOnly || this.appendOnly && isScrollDownOrRight) {
          var _currentIndex2 = calculateCurrentIndex(scrollPos, this.itemSize);
          var _triggerIndex2 = calculateTriggerIndex(_currentIndex2, this.first, this.last, this.numItemsInViewport, this.d_numToleratedItems, isScrollDownOrRight);
          newFirst = calculateFirst(_currentIndex2, _triggerIndex2, this.first, this.last, this.numItemsInViewport, this.d_numToleratedItems, isScrollDownOrRight);
          newLast = calculateLast(_currentIndex2, newFirst, this.last, this.numItemsInViewport, this.d_numToleratedItems);
          isRangeChanged = newFirst !== this.first || newLast !== this.last || this.isRangeChanged;
          newScrollPos = scrollPos;
        }
      }
      return {
        first: newFirst,
        last: newLast,
        isRangeChanged,
        scrollPos: newScrollPos
      };
    }, "onScrollPositionChange"),
    onScrollChange: /* @__PURE__ */ __name(function onScrollChange(event2) {
      var _this$onScrollPositio = this.onScrollPositionChange(event2), first = _this$onScrollPositio.first, last = _this$onScrollPositio.last, isRangeChanged = _this$onScrollPositio.isRangeChanged, scrollPos = _this$onScrollPositio.scrollPos;
      if (isRangeChanged) {
        var newState = {
          first,
          last
        };
        this.setContentPosition(newState);
        this.first = first;
        this.last = last;
        this.lastScrollPos = scrollPos;
        this.$emit("scroll-index-change", newState);
        if (this.lazy && this.isPageChanged(first)) {
          var _this$items2, _this$items3;
          var lazyLoadState = {
            first: this.step ? Math.min(this.getPageByFirst(first) * this.step, (((_this$items2 = this.items) === null || _this$items2 === void 0 ? void 0 : _this$items2.length) || 0) - this.step) : first,
            last: Math.min(this.step ? (this.getPageByFirst(first) + 1) * this.step : last, ((_this$items3 = this.items) === null || _this$items3 === void 0 ? void 0 : _this$items3.length) || 0)
          };
          var isLazyStateChanged = this.lazyLoadState.first !== lazyLoadState.first || this.lazyLoadState.last !== lazyLoadState.last;
          isLazyStateChanged && this.$emit("lazy-load", lazyLoadState);
          this.lazyLoadState = lazyLoadState;
        }
      }
    }, "onScrollChange"),
    onScroll: /* @__PURE__ */ __name(function onScroll(event2) {
      var _this9 = this;
      this.$emit("scroll", event2);
      if (this.delay) {
        if (this.scrollTimeout) {
          clearTimeout(this.scrollTimeout);
        }
        if (this.isPageChanged()) {
          if (!this.d_loading && this.showLoader) {
            var _this$onScrollPositio2 = this.onScrollPositionChange(event2), isRangeChanged = _this$onScrollPositio2.isRangeChanged;
            var changed = isRangeChanged || (this.step ? this.isPageChanged() : false);
            changed && (this.d_loading = true);
          }
          this.scrollTimeout = setTimeout(function() {
            _this9.onScrollChange(event2);
            if (_this9.d_loading && _this9.showLoader && (!_this9.lazy || _this9.loading === void 0)) {
              _this9.d_loading = false;
              _this9.page = _this9.getPageByFirst();
            }
          }, this.delay);
        }
      } else {
        this.onScrollChange(event2);
      }
    }, "onScroll"),
    onResize: /* @__PURE__ */ __name(function onResize() {
      var _this10 = this;
      if (this.resizeTimeout) {
        clearTimeout(this.resizeTimeout);
      }
      this.resizeTimeout = setTimeout(function() {
        if (isVisible(_this10.element)) {
          var both = _this10.isBoth();
          var vertical2 = _this10.isVertical();
          var horizontal3 = _this10.isHorizontal();
          var _ref3 = [getWidth(_this10.element), getHeight(_this10.element)], width2 = _ref3[0], height = _ref3[1];
          var isDiffWidth = width2 !== _this10.defaultWidth, isDiffHeight = height !== _this10.defaultHeight;
          var reinit = both ? isDiffWidth || isDiffHeight : horizontal3 ? isDiffWidth : vertical2 ? isDiffHeight : false;
          if (reinit) {
            _this10.d_numToleratedItems = _this10.numToleratedItems;
            _this10.defaultWidth = width2;
            _this10.defaultHeight = height;
            _this10.defaultContentWidth = getWidth(_this10.content);
            _this10.defaultContentHeight = getHeight(_this10.content);
            _this10.init();
          }
        }
      }, this.resizeDelay);
    }, "onResize"),
    bindResizeListener: /* @__PURE__ */ __name(function bindResizeListener() {
      if (!this.resizeListener) {
        this.resizeListener = this.onResize.bind(this);
        window.addEventListener("resize", this.resizeListener);
        window.addEventListener("orientationchange", this.resizeListener);
      }
    }, "bindResizeListener"),
    unbindResizeListener: /* @__PURE__ */ __name(function unbindResizeListener() {
      if (this.resizeListener) {
        window.removeEventListener("resize", this.resizeListener);
        window.removeEventListener("orientationchange", this.resizeListener);
        this.resizeListener = null;
      }
    }, "unbindResizeListener"),
    getOptions: /* @__PURE__ */ __name(function getOptions2(renderedIndex) {
      var count = (this.items || []).length;
      var index2 = this.isBoth() ? this.first.rows + renderedIndex : this.first + renderedIndex;
      return {
        index: index2,
        count,
        first: index2 === 0,
        last: index2 === count - 1,
        even: index2 % 2 === 0,
        odd: index2 % 2 !== 0
      };
    }, "getOptions"),
    getLoaderOptions: /* @__PURE__ */ __name(function getLoaderOptions(index2, extOptions) {
      var count = this.loaderArr.length;
      return _objectSpread$c({
        index: index2,
        count,
        first: index2 === 0,
        last: index2 === count - 1,
        even: index2 % 2 === 0,
        odd: index2 % 2 !== 0
      }, extOptions);
    }, "getLoaderOptions"),
    getPageByFirst: /* @__PURE__ */ __name(function getPageByFirst(first) {
      return Math.floor(((first !== null && first !== void 0 ? first : this.first) + this.d_numToleratedItems * 4) / (this.step || 1));
    }, "getPageByFirst"),
    isPageChanged: /* @__PURE__ */ __name(function isPageChanged(first) {
      return this.step ? this.page !== this.getPageByFirst(first !== null && first !== void 0 ? first : this.first) : true;
    }, "isPageChanged"),
    setContentEl: /* @__PURE__ */ __name(function setContentEl(el) {
      this.content = el || this.content || findSingle(this.element, '[data-pc-section="content"]');
    }, "setContentEl"),
    elementRef: /* @__PURE__ */ __name(function elementRef(el) {
      this.element = el;
    }, "elementRef"),
    contentRef: /* @__PURE__ */ __name(function contentRef(el) {
      this.content = el;
    }, "contentRef")
  },
  computed: {
    containerClass: /* @__PURE__ */ __name(function containerClass2() {
      return ["p-virtualscroller", this["class"], {
        "p-virtualscroller-inline": this.inline,
        "p-virtualscroller-both p-both-scroll": this.isBoth(),
        "p-virtualscroller-horizontal p-horizontal-scroll": this.isHorizontal()
      }];
    }, "containerClass"),
    contentClass: /* @__PURE__ */ __name(function contentClass() {
      return ["p-virtualscroller-content", {
        "p-virtualscroller-loading": this.d_loading
      }];
    }, "contentClass"),
    loaderClass: /* @__PURE__ */ __name(function loaderClass() {
      return ["p-virtualscroller-loader", {
        "p-virtualscroller-loader-mask": !this.$slots.loader
      }];
    }, "loaderClass"),
    loadedItems: /* @__PURE__ */ __name(function loadedItems() {
      var _this11 = this;
      if (this.items && !this.d_loading) {
        if (this.isBoth()) return this.items.slice(this.appendOnly ? 0 : this.first.rows, this.last.rows).map(function(item2) {
          return _this11.columns ? item2 : item2.slice(_this11.appendOnly ? 0 : _this11.first.cols, _this11.last.cols);
        });
        else if (this.isHorizontal() && this.columns) return this.items;
        else return this.items.slice(this.appendOnly ? 0 : this.first, this.last);
      }
      return [];
    }, "loadedItems"),
    loadedRows: /* @__PURE__ */ __name(function loadedRows() {
      return this.d_loading ? this.loaderDisabled ? this.loaderArr : [] : this.loadedItems;
    }, "loadedRows"),
    loadedColumns: /* @__PURE__ */ __name(function loadedColumns() {
      if (this.columns) {
        var both = this.isBoth();
        var horizontal3 = this.isHorizontal();
        if (both || horizontal3) {
          return this.d_loading && this.loaderDisabled ? both ? this.loaderArr[0] : this.loaderArr : this.columns.slice(both ? this.first.cols : this.first, both ? this.last.cols : this.last);
        }
      }
      return this.columns;
    }, "loadedColumns")
  },
  components: {
    SpinnerIcon: script$N
  }
};
var _hoisted_1$Y = ["tabindex"];
function render$L(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_SpinnerIcon = resolveComponent("SpinnerIcon");
  return !_ctx.disabled ? (openBlock(), createElementBlock("div", mergeProps({
    key: 0,
    ref: $options.elementRef,
    "class": $options.containerClass,
    tabindex: _ctx.tabindex,
    style: _ctx.style,
    onScroll: _cache[0] || (_cache[0] = function() {
      return $options.onScroll && $options.onScroll.apply($options, arguments);
    })
  }, _ctx.ptmi("root")), [renderSlot(_ctx.$slots, "content", {
    styleClass: $options.contentClass,
    items: $options.loadedItems,
    getItemOptions: $options.getOptions,
    loading: $data.d_loading,
    getLoaderOptions: $options.getLoaderOptions,
    itemSize: _ctx.itemSize,
    rows: $options.loadedRows,
    columns: $options.loadedColumns,
    contentRef: $options.contentRef,
    spacerStyle: $data.spacerStyle,
    contentStyle: $data.contentStyle,
    vertical: $options.isVertical(),
    horizontal: $options.isHorizontal(),
    both: $options.isBoth()
  }, function() {
    return [createBaseVNode("div", mergeProps({
      ref: $options.contentRef,
      "class": $options.contentClass,
      style: $data.contentStyle
    }, _ctx.ptm("content")), [(openBlock(true), createElementBlock(Fragment, null, renderList($options.loadedItems, function(item2, index2) {
      return renderSlot(_ctx.$slots, "item", {
        key: index2,
        item: item2,
        options: $options.getOptions(index2)
      });
    }), 128))], 16)];
  }), _ctx.showSpacer ? (openBlock(), createElementBlock("div", mergeProps({
    key: 0,
    "class": "p-virtualscroller-spacer",
    style: $data.spacerStyle
  }, _ctx.ptm("spacer")), null, 16)) : createCommentVNode("", true), !_ctx.loaderDisabled && _ctx.showLoader && $data.d_loading ? (openBlock(), createElementBlock("div", mergeProps({
    key: 1,
    "class": $options.loaderClass
  }, _ctx.ptm("loader")), [_ctx.$slots && _ctx.$slots.loader ? (openBlock(true), createElementBlock(Fragment, {
    key: 0
  }, renderList($data.loaderArr, function(_2, index2) {
    return renderSlot(_ctx.$slots, "loader", {
      key: index2,
      options: $options.getLoaderOptions(index2, $options.isBoth() && {
        numCols: _ctx.d_numItemsInViewport.cols
      })
    });
  }), 128)) : createCommentVNode("", true), renderSlot(_ctx.$slots, "loadingicon", {}, function() {
    return [createVNode(_component_SpinnerIcon, mergeProps({
      spin: "",
      "class": "p-virtualscroller-loading-icon"
    }, _ctx.ptm("loadingIcon")), null, 16)];
  })], 16)) : createCommentVNode("", true)], 16, _hoisted_1$Y)) : (openBlock(), createElementBlock(Fragment, {
    key: 1
  }, [renderSlot(_ctx.$slots, "default"), renderSlot(_ctx.$slots, "content", {
    items: _ctx.items,
    rows: _ctx.items,
    columns: $options.loadedColumns
  })], 64));
}
__name(render$L, "render$L");
script$M.render = render$L;
var theme$r = /* @__PURE__ */ __name(function theme10(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-listbox {\n    background: ".concat(dt3("listbox.background"), ";\n    color: ").concat(dt3("listbox.color"), ";\n    border: 1px solid ").concat(dt3("listbox.border.color"), ";\n    border-radius: ").concat(dt3("listbox.border.radius"), ";\n    transition: background ").concat(dt3("listbox.transition.duration"), ", color ").concat(dt3("listbox.transition.duration"), ", border-color ").concat(dt3("listbox.transition.duration"), ",\n            box-shadow ").concat(dt3("listbox.transition.duration"), ", outline-color ").concat(dt3("listbox.transition.duration"), ";\n    outline-color: transparent;\n    box-shadow: ").concat(dt3("listbox.shadow"), ";\n}\n\n.p-listbox.p-focus {\n    border-color: ").concat(dt3("listbox.focus.border.color"), ";\n    box-shadow: ").concat(dt3("listbox.focus.ring.shadow"), ";\n    outline: ").concat(dt3("listbox.focus.ring.width"), " ").concat(dt3("listbox.focus.ring.style"), " ").concat(dt3("listbox.focus.ring.color"), ";\n    outline-offset: ").concat(dt3("listbox.focus.ring.offset"), ";\n}\n\n.p-listbox.p-disabled {\n    opacity: 1;\n    background: ").concat(dt3("listbox.disabled.background"), ";\n    color: ").concat(dt3("listbox.disabled.color"), ";\n}\n\n.p-listbox.p-disabled .p-listbox-option {\n    color: ").concat(dt3("listbox.disabled.color"), ";\n}\n\n.p-listbox.p-invalid {\n    border-color: ").concat(dt3("listbox.invalid.border.color"), ";\n}\n\n.p-listbox-header {\n    padding: ").concat(dt3("listbox.list.header.padding"), ";\n}\n\n.p-listbox-filter {\n    width: 100%;\n}\n\n.p-listbox-list-container {\n    overflow: auto;\n}\n\n.p-listbox-list {\n    list-style-type: none;\n    margin: 0;\n    padding: ").concat(dt3("listbox.list.padding"), ";\n    outline: 0 none;\n    display: flex;\n    flex-direction: column;\n    gap: ").concat(dt3("listbox.list.gap"), ";\n}\n\n.p-listbox-option {\n    display: flex;\n    align-items: center;\n    cursor: pointer;\n    position: relative;\n    overflow: hidden;\n    padding: ").concat(dt3("listbox.option.padding"), ";\n    border: 0 none;\n    border-radius: ").concat(dt3("listbox.option.border.radius"), ";\n    color: ").concat(dt3("listbox.option.color"), ";\n    transition: background ").concat(dt3("listbox.transition.duration"), ", color ").concat(dt3("listbox.transition.duration"), ", border-color ").concat(dt3("listbox.transition.duration"), ",\n            box-shadow ").concat(dt3("listbox.transition.duration"), ", outline-color ").concat(dt3("listbox.transition.duration"), ";\n}\n\n.p-listbox-striped li:nth-child(even of .p-listbox-option) {\n    background: ").concat(dt3("listbox.option.striped.background"), ";\n}\n\n.p-listbox .p-listbox-list .p-listbox-option.p-listbox-option-selected {\n    background: ").concat(dt3("listbox.option.selected.background"), ";\n    color: ").concat(dt3("listbox.option.selected.color"), ";\n}\n\n.p-listbox:not(.p-disabled) .p-listbox-option.p-listbox-option-selected.p-focus {\n    background: ").concat(dt3("listbox.option.selected.focus.background"), ";\n    color: ").concat(dt3("listbox.option.selected.focus.color"), ";\n}\n\n.p-listbox:not(.p-disabled) .p-listbox-option:not(.p-listbox-option-selected):not(.p-disabled).p-focus {\n    background: ").concat(dt3("listbox.option.focus.background"), ";\n    color: ").concat(dt3("listbox.option.focus.color"), ";\n}\n\n.p-listbox:not(.p-disabled) .p-listbox-option:not(.p-listbox-option-selected):not(.p-disabled):hover {\n    background: ").concat(dt3("listbox.option.focus.background"), ";\n    color: ").concat(dt3("listbox.option.focus.color"), ";\n}\n\n.p-listbox-option-check-icon {\n    position: relative;\n    margin-inline-start: ").concat(dt3("listbox.checkmark.gutter.start"), ";\n    margin-inline-end: ").concat(dt3("listbox.checkmark.gutter.end"), ";\n    color: ").concat(dt3("listbox.checkmark.color"), ";\n}\n\n.p-listbox-option-group {\n    margin: 0;\n    padding: ").concat(dt3("listbox.option.group.padding"), ";\n    color: ").concat(dt3("listbox.option.group.color"), ";\n    background: ").concat(dt3("listbox.option.group.background"), ";\n    font-weight: ").concat(dt3("listbox.option.group.font.weight"), ";\n}\n\n.p-listbox-empty-message {\n    padding: ").concat(dt3("listbox.empty.message.padding"), ";\n}\n");
}, "theme");
var classes$u = {
  root: /* @__PURE__ */ __name(function root2(_ref2) {
    var props = _ref2.props;
    return ["p-listbox p-component", {
      "p-listbox-striped": props.striped,
      "p-disabled": props.disabled,
      "p-invalid": props.invalid
    }];
  }, "root"),
  header: "p-listbox-header",
  pcFilter: "p-listbox-filter",
  listContainer: "p-listbox-list-container",
  list: "p-listbox-list",
  optionGroup: "p-listbox-option-group",
  option: /* @__PURE__ */ __name(function option(_ref3) {
    var instance = _ref3.instance, props = _ref3.props, _option = _ref3.option, index2 = _ref3.index, getItemOptions = _ref3.getItemOptions;
    return ["p-listbox-option", {
      "p-listbox-option-selected": instance.isSelected(_option) && props.highlightOnSelect,
      "p-focus": instance.focusedOptionIndex === instance.getOptionIndex(index2, getItemOptions),
      "p-disabled": instance.isOptionDisabled(_option)
    }];
  }, "option"),
  optionCheckIcon: "p-listbox-option-check-icon",
  optionBlankIcon: "p-listbox-option-blank-icon",
  emptyMessage: "p-listbox-empty-message"
};
var ListboxStyle = BaseStyle.extend({
  name: "listbox",
  theme: theme$r,
  classes: classes$u
});
var script$1$u = {
  name: "BaseListbox",
  "extends": script$X,
  props: {
    modelValue: null,
    options: Array,
    optionLabel: null,
    optionValue: null,
    optionDisabled: null,
    optionGroupLabel: null,
    optionGroupChildren: null,
    listStyle: null,
    scrollHeight: {
      type: String,
      "default": "14rem"
    },
    invalid: {
      type: Boolean,
      "default": false
    },
    disabled: {
      type: Boolean,
      "default": false
    },
    dataKey: null,
    multiple: {
      type: Boolean,
      "default": false
    },
    metaKeySelection: {
      type: Boolean,
      "default": false
    },
    filter: Boolean,
    filterPlaceholder: String,
    filterLocale: String,
    filterMatchMode: {
      type: String,
      "default": "contains"
    },
    filterFields: {
      type: Array,
      "default": null
    },
    virtualScrollerOptions: {
      type: Object,
      "default": null
    },
    autoOptionFocus: {
      type: Boolean,
      "default": true
    },
    selectOnFocus: {
      type: Boolean,
      "default": false
    },
    focusOnHover: {
      type: Boolean,
      "default": true
    },
    highlightOnSelect: {
      type: Boolean,
      "default": true
    },
    checkmark: {
      type: Boolean,
      "default": false
    },
    filterMessage: {
      type: String,
      "default": null
    },
    selectionMessage: {
      type: String,
      "default": null
    },
    emptySelectionMessage: {
      type: String,
      "default": null
    },
    emptyFilterMessage: {
      type: String,
      "default": null
    },
    emptyMessage: {
      type: String,
      "default": null
    },
    filterIcon: {
      type: String,
      "default": void 0
    },
    striped: {
      type: Boolean,
      "default": false
    },
    tabindex: {
      type: Number,
      "default": 0
    },
    ariaLabel: {
      type: String,
      "default": null
    },
    ariaLabelledby: {
      type: String,
      "default": null
    }
  },
  style: ListboxStyle,
  provide: /* @__PURE__ */ __name(function provide9() {
    return {
      $pcListbox: this,
      $parentInstance: this
    };
  }, "provide")
};
function _toConsumableArray$c(r) {
  return _arrayWithoutHoles$c(r) || _iterableToArray$c(r) || _unsupportedIterableToArray$e(r) || _nonIterableSpread$c();
}
__name(_toConsumableArray$c, "_toConsumableArray$c");
function _nonIterableSpread$c() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableSpread$c, "_nonIterableSpread$c");
function _unsupportedIterableToArray$e(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$e(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$e(r, a) : void 0;
  }
}
__name(_unsupportedIterableToArray$e, "_unsupportedIterableToArray$e");
function _iterableToArray$c(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
__name(_iterableToArray$c, "_iterableToArray$c");
function _arrayWithoutHoles$c(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$e(r);
}
__name(_arrayWithoutHoles$c, "_arrayWithoutHoles$c");
function _arrayLikeToArray$e(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
__name(_arrayLikeToArray$e, "_arrayLikeToArray$e");
var script$L = {
  name: "Listbox",
  "extends": script$1$u,
  inheritAttrs: false,
  emits: ["update:modelValue", "change", "focus", "blur", "filter", "item-dblclick", "option-dblclick"],
  list: null,
  virtualScroller: null,
  optionTouched: false,
  startRangeIndex: -1,
  searchTimeout: null,
  searchValue: "",
  data: /* @__PURE__ */ __name(function data3() {
    return {
      id: this.$attrs.id,
      filterValue: null,
      focused: false,
      focusedOptionIndex: -1
    };
  }, "data"),
  watch: {
    "$attrs.id": /* @__PURE__ */ __name(function $attrsId(newValue) {
      this.id = newValue || UniqueComponentId();
    }, "$attrsId"),
    options: /* @__PURE__ */ __name(function options() {
      this.autoUpdateModel();
    }, "options")
  },
  mounted: /* @__PURE__ */ __name(function mounted4() {
    this.id = this.id || UniqueComponentId();
    this.autoUpdateModel();
  }, "mounted"),
  methods: {
    getOptionIndex: /* @__PURE__ */ __name(function getOptionIndex(index2, fn) {
      return this.virtualScrollerDisabled ? index2 : fn && fn(index2)["index"];
    }, "getOptionIndex"),
    getOptionLabel: /* @__PURE__ */ __name(function getOptionLabel(option4) {
      return this.optionLabel ? resolveFieldData(option4, this.optionLabel) : typeof option4 === "string" ? option4 : null;
    }, "getOptionLabel"),
    getOptionValue: /* @__PURE__ */ __name(function getOptionValue2(option4) {
      return this.optionValue ? resolveFieldData(option4, this.optionValue) : option4;
    }, "getOptionValue"),
    getOptionRenderKey: /* @__PURE__ */ __name(function getOptionRenderKey(option4, index2) {
      return (this.dataKey ? resolveFieldData(option4, this.dataKey) : this.getOptionLabel(option4)) + "_" + index2;
    }, "getOptionRenderKey"),
    getPTOptions: /* @__PURE__ */ __name(function getPTOptions2(option4, itemOptions, index2, key) {
      return this.ptm(key, {
        context: {
          selected: this.isSelected(option4),
          focused: this.focusedOptionIndex === this.getOptionIndex(index2, itemOptions),
          disabled: this.isOptionDisabled(option4)
        }
      });
    }, "getPTOptions"),
    isOptionDisabled: /* @__PURE__ */ __name(function isOptionDisabled(option4) {
      return this.optionDisabled ? resolveFieldData(option4, this.optionDisabled) : false;
    }, "isOptionDisabled"),
    isOptionGroup: /* @__PURE__ */ __name(function isOptionGroup(option4) {
      return this.optionGroupLabel && option4.optionGroup && option4.group;
    }, "isOptionGroup"),
    getOptionGroupLabel: /* @__PURE__ */ __name(function getOptionGroupLabel(optionGroup) {
      return resolveFieldData(optionGroup, this.optionGroupLabel);
    }, "getOptionGroupLabel"),
    getOptionGroupChildren: /* @__PURE__ */ __name(function getOptionGroupChildren(optionGroup) {
      return resolveFieldData(optionGroup, this.optionGroupChildren);
    }, "getOptionGroupChildren"),
    getAriaPosInset: /* @__PURE__ */ __name(function getAriaPosInset(index2) {
      var _this = this;
      return (this.optionGroupLabel ? index2 - this.visibleOptions.slice(0, index2).filter(function(option4) {
        return _this.isOptionGroup(option4);
      }).length : index2) + 1;
    }, "getAriaPosInset"),
    onFirstHiddenFocus: /* @__PURE__ */ __name(function onFirstHiddenFocus() {
      focus(this.list);
      var firstFocusableEl = getFirstFocusableElement(this.$el, ':not([data-p-hidden-focusable="true"])');
      this.$refs.lastHiddenFocusableElement.tabIndex = isElement(firstFocusableEl) ? void 0 : -1;
      this.$refs.firstHiddenFocusableElement.tabIndex = -1;
    }, "onFirstHiddenFocus"),
    onLastHiddenFocus: /* @__PURE__ */ __name(function onLastHiddenFocus(event2) {
      var relatedTarget = event2.relatedTarget;
      if (relatedTarget === this.list) {
        var firstFocusableEl = getFirstFocusableElement(this.$el, ':not([data-p-hidden-focusable="true"])');
        focus(firstFocusableEl);
        this.$refs.firstHiddenFocusableElement.tabIndex = void 0;
      } else {
        focus(this.$refs.firstHiddenFocusableElement);
      }
      this.$refs.lastHiddenFocusableElement.tabIndex = -1;
    }, "onLastHiddenFocus"),
    onFocusout: /* @__PURE__ */ __name(function onFocusout(event2) {
      if (!this.$el.contains(event2.relatedTarget) && this.$refs.lastHiddenFocusableElement && this.$refs.firstHiddenFocusableElement) {
        this.$refs.lastHiddenFocusableElement.tabIndex = this.$refs.firstHiddenFocusableElement.tabIndex = void 0;
      }
    }, "onFocusout"),
    onListFocus: /* @__PURE__ */ __name(function onListFocus(event2) {
      this.focused = true;
      this.focusedOptionIndex = this.focusedOptionIndex !== -1 ? this.focusedOptionIndex : this.autoOptionFocus ? this.findFirstFocusedOptionIndex() : this.findSelectedOptionIndex();
      this.autoUpdateModel();
      this.$emit("focus", event2);
    }, "onListFocus"),
    onListBlur: /* @__PURE__ */ __name(function onListBlur(event2) {
      this.focused = false;
      this.focusedOptionIndex = this.startRangeIndex = -1;
      this.searchValue = "";
      this.$emit("blur", event2);
    }, "onListBlur"),
    onListKeyDown: /* @__PURE__ */ __name(function onListKeyDown(event2) {
      var _this2 = this;
      var metaKey = event2.metaKey || event2.ctrlKey;
      switch (event2.code) {
        case "ArrowDown":
          this.onArrowDownKey(event2);
          break;
        case "ArrowUp":
          this.onArrowUpKey(event2);
          break;
        case "Home":
          this.onHomeKey(event2);
          break;
        case "End":
          this.onEndKey(event2);
          break;
        case "PageDown":
          this.onPageDownKey(event2);
          break;
        case "PageUp":
          this.onPageUpKey(event2);
          break;
        case "Enter":
        case "NumpadEnter":
        case "Space":
          this.onSpaceKey(event2);
          break;
        case "Tab":
          break;
        case "ShiftLeft":
        case "ShiftRight":
          this.onShiftKey(event2);
          break;
        default:
          if (this.multiple && event2.code === "KeyA" && metaKey) {
            var value3 = this.visibleOptions.filter(function(option4) {
              return _this2.isValidOption(option4);
            }).map(function(option4) {
              return _this2.getOptionValue(option4);
            });
            this.updateModel(event2, value3);
            event2.preventDefault();
            break;
          }
          if (!metaKey && isPrintableCharacter(event2.key)) {
            this.searchOptions(event2, event2.key);
            event2.preventDefault();
          }
          break;
      }
    }, "onListKeyDown"),
    onOptionSelect: /* @__PURE__ */ __name(function onOptionSelect(event2, option4) {
      var index2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;
      if (this.disabled || this.isOptionDisabled(option4)) {
        return;
      }
      this.multiple ? this.onOptionSelectMultiple(event2, option4) : this.onOptionSelectSingle(event2, option4);
      this.optionTouched = false;
      index2 !== -1 && (this.focusedOptionIndex = index2);
    }, "onOptionSelect"),
    onOptionMouseDown: /* @__PURE__ */ __name(function onOptionMouseDown(event2, index2) {
      this.changeFocusedOptionIndex(event2, index2);
    }, "onOptionMouseDown"),
    onOptionMouseMove: /* @__PURE__ */ __name(function onOptionMouseMove(event2, index2) {
      if (this.focusOnHover && this.focused) {
        this.changeFocusedOptionIndex(event2, index2);
      }
    }, "onOptionMouseMove"),
    onOptionTouchEnd: /* @__PURE__ */ __name(function onOptionTouchEnd() {
      if (this.disabled) {
        return;
      }
      this.optionTouched = true;
    }, "onOptionTouchEnd"),
    onOptionDblClick: /* @__PURE__ */ __name(function onOptionDblClick(event2, item2) {
      this.$emit("item-dblclick", {
        originalEvent: event2,
        value: item2
      });
      this.$emit("option-dblclick", {
        originalEvent: event2,
        value: item2
      });
    }, "onOptionDblClick"),
    onOptionSelectSingle: /* @__PURE__ */ __name(function onOptionSelectSingle(event2, option4) {
      var selected2 = this.isSelected(option4);
      var valueChanged = false;
      var value3 = null;
      var metaSelection = this.optionTouched ? false : this.metaKeySelection;
      if (metaSelection) {
        var metaKey = event2 && (event2.metaKey || event2.ctrlKey);
        if (selected2) {
          if (metaKey) {
            value3 = null;
            valueChanged = true;
          }
        } else {
          value3 = this.getOptionValue(option4);
          valueChanged = true;
        }
      } else {
        value3 = selected2 ? null : this.getOptionValue(option4);
        valueChanged = true;
      }
      if (valueChanged) {
        this.updateModel(event2, value3);
      }
    }, "onOptionSelectSingle"),
    onOptionSelectMultiple: /* @__PURE__ */ __name(function onOptionSelectMultiple(event2, option4) {
      var selected2 = this.isSelected(option4);
      var value3 = null;
      var metaSelection = this.optionTouched ? false : this.metaKeySelection;
      if (metaSelection) {
        var metaKey = event2.metaKey || event2.ctrlKey;
        if (selected2) {
          value3 = metaKey ? this.removeOption(option4) : [this.getOptionValue(option4)];
        } else {
          value3 = metaKey ? this.modelValue || [] : [];
          value3 = [].concat(_toConsumableArray$c(value3), [this.getOptionValue(option4)]);
        }
      } else {
        value3 = selected2 ? this.removeOption(option4) : [].concat(_toConsumableArray$c(this.modelValue || []), [this.getOptionValue(option4)]);
      }
      this.updateModel(event2, value3);
    }, "onOptionSelectMultiple"),
    onOptionSelectRange: /* @__PURE__ */ __name(function onOptionSelectRange(event2) {
      var _this3 = this;
      var start2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1;
      var end = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;
      start2 === -1 && (start2 = this.findNearestSelectedOptionIndex(end, true));
      end === -1 && (end = this.findNearestSelectedOptionIndex(start2));
      if (start2 !== -1 && end !== -1) {
        var rangeStart = Math.min(start2, end);
        var rangeEnd = Math.max(start2, end);
        var value3 = this.visibleOptions.slice(rangeStart, rangeEnd + 1).filter(function(option4) {
          return _this3.isValidOption(option4);
        }).map(function(option4) {
          return _this3.getOptionValue(option4);
        });
        this.updateModel(event2, value3);
      }
    }, "onOptionSelectRange"),
    onFilterChange: /* @__PURE__ */ __name(function onFilterChange(event2) {
      this.$emit("filter", {
        originalEvent: event2,
        value: event2.target.value
      });
      this.focusedOptionIndex = this.startRangeIndex = -1;
    }, "onFilterChange"),
    onFilterBlur: /* @__PURE__ */ __name(function onFilterBlur() {
      this.focusedOptionIndex = this.startRangeIndex = -1;
    }, "onFilterBlur"),
    onFilterKeyDown: /* @__PURE__ */ __name(function onFilterKeyDown(event2) {
      switch (event2.code) {
        case "ArrowDown":
          this.onArrowDownKey(event2);
          break;
        case "ArrowUp":
          this.onArrowUpKey(event2);
          break;
        case "ArrowLeft":
        case "ArrowRight":
          this.onArrowLeftKey(event2, true);
          break;
        case "Home":
          this.onHomeKey(event2, true);
          break;
        case "End":
          this.onEndKey(event2, true);
          break;
        case "Enter":
        case "NumpadEnter":
          this.onEnterKey(event2);
          break;
        case "ShiftLeft":
        case "ShiftRight":
          this.onShiftKey(event2);
          break;
      }
    }, "onFilterKeyDown"),
    onArrowDownKey: /* @__PURE__ */ __name(function onArrowDownKey(event2) {
      var optionIndex = this.focusedOptionIndex !== -1 ? this.findNextOptionIndex(this.focusedOptionIndex) : this.findFirstFocusedOptionIndex();
      if (this.multiple && event2.shiftKey) {
        this.onOptionSelectRange(event2, this.startRangeIndex, optionIndex);
      }
      this.changeFocusedOptionIndex(event2, optionIndex);
      event2.preventDefault();
    }, "onArrowDownKey"),
    onArrowUpKey: /* @__PURE__ */ __name(function onArrowUpKey(event2) {
      var optionIndex = this.focusedOptionIndex !== -1 ? this.findPrevOptionIndex(this.focusedOptionIndex) : this.findLastFocusedOptionIndex();
      if (this.multiple && event2.shiftKey) {
        this.onOptionSelectRange(event2, optionIndex, this.startRangeIndex);
      }
      this.changeFocusedOptionIndex(event2, optionIndex);
      event2.preventDefault();
    }, "onArrowUpKey"),
    onArrowLeftKey: /* @__PURE__ */ __name(function onArrowLeftKey(event2) {
      var pressedInInputText = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      pressedInInputText && (this.focusedOptionIndex = -1);
    }, "onArrowLeftKey"),
    onHomeKey: /* @__PURE__ */ __name(function onHomeKey(event2) {
      var pressedInInputText = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (pressedInInputText) {
        var target = event2.currentTarget;
        if (event2.shiftKey) {
          target.setSelectionRange(0, event2.target.selectionStart);
        } else {
          target.setSelectionRange(0, 0);
          this.focusedOptionIndex = -1;
        }
      } else {
        var metaKey = event2.metaKey || event2.ctrlKey;
        var optionIndex = this.findFirstOptionIndex();
        if (this.multiple && event2.shiftKey && metaKey) {
          this.onOptionSelectRange(event2, optionIndex, this.startRangeIndex);
        }
        this.changeFocusedOptionIndex(event2, optionIndex);
      }
      event2.preventDefault();
    }, "onHomeKey"),
    onEndKey: /* @__PURE__ */ __name(function onEndKey(event2) {
      var pressedInInputText = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (pressedInInputText) {
        var target = event2.currentTarget;
        if (event2.shiftKey) {
          target.setSelectionRange(event2.target.selectionStart, target.value.length);
        } else {
          var len = target.value.length;
          target.setSelectionRange(len, len);
          this.focusedOptionIndex = -1;
        }
      } else {
        var metaKey = event2.metaKey || event2.ctrlKey;
        var optionIndex = this.findLastOptionIndex();
        if (this.multiple && event2.shiftKey && metaKey) {
          this.onOptionSelectRange(event2, this.startRangeIndex, optionIndex);
        }
        this.changeFocusedOptionIndex(event2, optionIndex);
      }
      event2.preventDefault();
    }, "onEndKey"),
    onPageUpKey: /* @__PURE__ */ __name(function onPageUpKey(event2) {
      this.scrollInView(0);
      event2.preventDefault();
    }, "onPageUpKey"),
    onPageDownKey: /* @__PURE__ */ __name(function onPageDownKey(event2) {
      this.scrollInView(this.visibleOptions.length - 1);
      event2.preventDefault();
    }, "onPageDownKey"),
    onEnterKey: /* @__PURE__ */ __name(function onEnterKey(event2) {
      if (this.focusedOptionIndex !== -1) {
        if (this.multiple && event2.shiftKey) this.onOptionSelectRange(event2, this.focusedOptionIndex);
        else this.onOptionSelect(event2, this.visibleOptions[this.focusedOptionIndex]);
      }
    }, "onEnterKey"),
    onSpaceKey: /* @__PURE__ */ __name(function onSpaceKey(event2) {
      event2.preventDefault();
      this.onEnterKey(event2);
    }, "onSpaceKey"),
    onShiftKey: /* @__PURE__ */ __name(function onShiftKey() {
      this.startRangeIndex = this.focusedOptionIndex;
    }, "onShiftKey"),
    isOptionMatched: /* @__PURE__ */ __name(function isOptionMatched(option4) {
      var _this$getOptionLabel;
      return this.isValidOption(option4) && typeof this.getOptionLabel(option4) === "string" && ((_this$getOptionLabel = this.getOptionLabel(option4)) === null || _this$getOptionLabel === void 0 ? void 0 : _this$getOptionLabel.toLocaleLowerCase(this.filterLocale).startsWith(this.searchValue.toLocaleLowerCase(this.filterLocale)));
    }, "isOptionMatched"),
    isValidOption: /* @__PURE__ */ __name(function isValidOption(option4) {
      return isNotEmpty(option4) && !(this.isOptionDisabled(option4) || this.isOptionGroup(option4));
    }, "isValidOption"),
    isValidSelectedOption: /* @__PURE__ */ __name(function isValidSelectedOption(option4) {
      return this.isValidOption(option4) && this.isSelected(option4);
    }, "isValidSelectedOption"),
    isEquals: /* @__PURE__ */ __name(function isEquals(value1, value22) {
      return equals(value1, value22, this.equalityKey);
    }, "isEquals"),
    isSelected: /* @__PURE__ */ __name(function isSelected(option4) {
      var _this4 = this;
      var optionValue = this.getOptionValue(option4);
      if (this.multiple) return (this.modelValue || []).some(function(value3) {
        return _this4.isEquals(value3, optionValue);
      });
      else return this.isEquals(this.modelValue, optionValue);
    }, "isSelected"),
    findFirstOptionIndex: /* @__PURE__ */ __name(function findFirstOptionIndex() {
      var _this5 = this;
      return this.visibleOptions.findIndex(function(option4) {
        return _this5.isValidOption(option4);
      });
    }, "findFirstOptionIndex"),
    findLastOptionIndex: /* @__PURE__ */ __name(function findLastOptionIndex() {
      var _this6 = this;
      return findLastIndex(this.visibleOptions, function(option4) {
        return _this6.isValidOption(option4);
      });
    }, "findLastOptionIndex"),
    findNextOptionIndex: /* @__PURE__ */ __name(function findNextOptionIndex(index2) {
      var _this7 = this;
      var matchedOptionIndex = index2 < this.visibleOptions.length - 1 ? this.visibleOptions.slice(index2 + 1).findIndex(function(option4) {
        return _this7.isValidOption(option4);
      }) : -1;
      return matchedOptionIndex > -1 ? matchedOptionIndex + index2 + 1 : index2;
    }, "findNextOptionIndex"),
    findPrevOptionIndex: /* @__PURE__ */ __name(function findPrevOptionIndex(index2) {
      var _this8 = this;
      var matchedOptionIndex = index2 > 0 ? findLastIndex(this.visibleOptions.slice(0, index2), function(option4) {
        return _this8.isValidOption(option4);
      }) : -1;
      return matchedOptionIndex > -1 ? matchedOptionIndex : index2;
    }, "findPrevOptionIndex"),
    findSelectedOptionIndex: /* @__PURE__ */ __name(function findSelectedOptionIndex() {
      var _this9 = this;
      if (this.hasSelectedOption) {
        if (this.multiple) {
          var _loop = /* @__PURE__ */ __name(function _loop2() {
            var value3 = _this9.modelValue[index2];
            var matchedOptionIndex = _this9.visibleOptions.findIndex(function(option4) {
              return _this9.isValidSelectedOption(option4) && _this9.isEquals(value3, _this9.getOptionValue(option4));
            });
            if (matchedOptionIndex > -1) return {
              v: matchedOptionIndex
            };
          }, "_loop"), _ret;
          for (var index2 = this.modelValue.length - 1; index2 >= 0; index2--) {
            _ret = _loop();
            if (_ret) return _ret.v;
          }
        } else {
          return this.visibleOptions.findIndex(function(option4) {
            return _this9.isValidSelectedOption(option4);
          });
        }
      }
      return -1;
    }, "findSelectedOptionIndex"),
    findFirstSelectedOptionIndex: /* @__PURE__ */ __name(function findFirstSelectedOptionIndex() {
      var _this10 = this;
      return this.hasSelectedOption ? this.visibleOptions.findIndex(function(option4) {
        return _this10.isValidSelectedOption(option4);
      }) : -1;
    }, "findFirstSelectedOptionIndex"),
    findLastSelectedOptionIndex: /* @__PURE__ */ __name(function findLastSelectedOptionIndex() {
      var _this11 = this;
      return this.hasSelectedOption ? findLastIndex(this.visibleOptions, function(option4) {
        return _this11.isValidSelectedOption(option4);
      }) : -1;
    }, "findLastSelectedOptionIndex"),
    findNextSelectedOptionIndex: /* @__PURE__ */ __name(function findNextSelectedOptionIndex(index2) {
      var _this12 = this;
      var matchedOptionIndex = this.hasSelectedOption && index2 < this.visibleOptions.length - 1 ? this.visibleOptions.slice(index2 + 1).findIndex(function(option4) {
        return _this12.isValidSelectedOption(option4);
      }) : -1;
      return matchedOptionIndex > -1 ? matchedOptionIndex + index2 + 1 : -1;
    }, "findNextSelectedOptionIndex"),
    findPrevSelectedOptionIndex: /* @__PURE__ */ __name(function findPrevSelectedOptionIndex(index2) {
      var _this13 = this;
      var matchedOptionIndex = this.hasSelectedOption && index2 > 0 ? findLastIndex(this.visibleOptions.slice(0, index2), function(option4) {
        return _this13.isValidSelectedOption(option4);
      }) : -1;
      return matchedOptionIndex > -1 ? matchedOptionIndex : -1;
    }, "findPrevSelectedOptionIndex"),
    findNearestSelectedOptionIndex: /* @__PURE__ */ __name(function findNearestSelectedOptionIndex(index2) {
      var firstCheckUp = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var matchedOptionIndex = -1;
      if (this.hasSelectedOption) {
        if (firstCheckUp) {
          matchedOptionIndex = this.findPrevSelectedOptionIndex(index2);
          matchedOptionIndex = matchedOptionIndex === -1 ? this.findNextSelectedOptionIndex(index2) : matchedOptionIndex;
        } else {
          matchedOptionIndex = this.findNextSelectedOptionIndex(index2);
          matchedOptionIndex = matchedOptionIndex === -1 ? this.findPrevSelectedOptionIndex(index2) : matchedOptionIndex;
        }
      }
      return matchedOptionIndex > -1 ? matchedOptionIndex : index2;
    }, "findNearestSelectedOptionIndex"),
    findFirstFocusedOptionIndex: /* @__PURE__ */ __name(function findFirstFocusedOptionIndex() {
      var selectedIndex = this.findFirstSelectedOptionIndex();
      return selectedIndex < 0 ? this.findFirstOptionIndex() : selectedIndex;
    }, "findFirstFocusedOptionIndex"),
    findLastFocusedOptionIndex: /* @__PURE__ */ __name(function findLastFocusedOptionIndex() {
      var selectedIndex = this.findLastSelectedOptionIndex();
      return selectedIndex < 0 ? this.findLastOptionIndex() : selectedIndex;
    }, "findLastFocusedOptionIndex"),
    searchOptions: /* @__PURE__ */ __name(function searchOptions(event2, _char) {
      var _this14 = this;
      this.searchValue = (this.searchValue || "") + _char;
      var optionIndex = -1;
      if (isNotEmpty(this.searchValue)) {
        if (this.focusedOptionIndex !== -1) {
          optionIndex = this.visibleOptions.slice(this.focusedOptionIndex).findIndex(function(option4) {
            return _this14.isOptionMatched(option4);
          });
          optionIndex = optionIndex === -1 ? this.visibleOptions.slice(0, this.focusedOptionIndex).findIndex(function(option4) {
            return _this14.isOptionMatched(option4);
          }) : optionIndex + this.focusedOptionIndex;
        } else {
          optionIndex = this.visibleOptions.findIndex(function(option4) {
            return _this14.isOptionMatched(option4);
          });
        }
        if (optionIndex === -1 && this.focusedOptionIndex === -1) {
          optionIndex = this.findFirstFocusedOptionIndex();
        }
        if (optionIndex !== -1) {
          this.changeFocusedOptionIndex(event2, optionIndex);
        }
      }
      if (this.searchTimeout) {
        clearTimeout(this.searchTimeout);
      }
      this.searchTimeout = setTimeout(function() {
        _this14.searchValue = "";
        _this14.searchTimeout = null;
      }, 500);
    }, "searchOptions"),
    removeOption: /* @__PURE__ */ __name(function removeOption(option4) {
      var _this15 = this;
      return this.modelValue.filter(function(val) {
        return !equals(val, _this15.getOptionValue(option4), _this15.equalityKey);
      });
    }, "removeOption"),
    changeFocusedOptionIndex: /* @__PURE__ */ __name(function changeFocusedOptionIndex(event2, index2) {
      if (this.focusedOptionIndex !== index2) {
        this.focusedOptionIndex = index2;
        this.scrollInView();
        if (this.selectOnFocus && !this.multiple) {
          this.onOptionSelect(event2, this.visibleOptions[index2]);
        }
      }
    }, "changeFocusedOptionIndex"),
    scrollInView: /* @__PURE__ */ __name(function scrollInView3() {
      var _this16 = this;
      var index2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : -1;
      this.$nextTick(function() {
        var id2 = index2 !== -1 ? "".concat(_this16.id, "_").concat(index2) : _this16.focusedOptionId;
        var element = findSingle(_this16.list, 'li[id="'.concat(id2, '"]'));
        if (element) {
          element.scrollIntoView && element.scrollIntoView({
            block: "nearest",
            inline: "nearest",
            behavior: "smooth"
          });
        } else if (!_this16.virtualScrollerDisabled) {
          _this16.virtualScroller && _this16.virtualScroller.scrollToIndex(index2 !== -1 ? index2 : _this16.focusedOptionIndex);
        }
      });
    }, "scrollInView"),
    autoUpdateModel: /* @__PURE__ */ __name(function autoUpdateModel() {
      if (this.selectOnFocus && this.autoOptionFocus && !this.hasSelectedOption && !this.multiple && this.focused) {
        this.focusedOptionIndex = this.findFirstFocusedOptionIndex();
        this.onOptionSelect(null, this.visibleOptions[this.focusedOptionIndex]);
      }
    }, "autoUpdateModel"),
    updateModel: /* @__PURE__ */ __name(function updateModel(event2, value3) {
      this.$emit("update:modelValue", value3);
      this.$emit("change", {
        originalEvent: event2,
        value: value3
      });
    }, "updateModel"),
    flatOptions: /* @__PURE__ */ __name(function flatOptions(options3) {
      var _this17 = this;
      return (options3 || []).reduce(function(result, option4, index2) {
        result.push({
          optionGroup: option4,
          group: true,
          index: index2
        });
        var optionGroupChildren = _this17.getOptionGroupChildren(option4);
        optionGroupChildren && optionGroupChildren.forEach(function(o) {
          return result.push(o);
        });
        return result;
      }, []);
    }, "flatOptions"),
    listRef: /* @__PURE__ */ __name(function listRef(el, contentRef3) {
      this.list = el;
      contentRef3 && contentRef3(el);
    }, "listRef"),
    virtualScrollerRef: /* @__PURE__ */ __name(function virtualScrollerRef(el) {
      this.virtualScroller = el;
    }, "virtualScrollerRef")
  },
  computed: {
    visibleOptions: /* @__PURE__ */ __name(function visibleOptions() {
      var options3 = this.optionGroupLabel ? this.flatOptions(this.options) : this.options || [];
      return this.filterValue ? FilterService.filter(options3, this.searchFields, this.filterValue, this.filterMatchMode, this.filterLocale) : options3;
    }, "visibleOptions"),
    hasSelectedOption: /* @__PURE__ */ __name(function hasSelectedOption() {
      return isNotEmpty(this.modelValue);
    }, "hasSelectedOption"),
    equalityKey: /* @__PURE__ */ __name(function equalityKey() {
      return this.optionValue ? null : this.dataKey;
    }, "equalityKey"),
    searchFields: /* @__PURE__ */ __name(function searchFields() {
      return this.filterFields || [this.optionLabel];
    }, "searchFields"),
    filterResultMessageText: /* @__PURE__ */ __name(function filterResultMessageText() {
      return isNotEmpty(this.visibleOptions) ? this.filterMessageText.replaceAll("{0}", this.visibleOptions.length) : this.emptyFilterMessageText;
    }, "filterResultMessageText"),
    filterMessageText: /* @__PURE__ */ __name(function filterMessageText() {
      return this.filterMessage || this.$primevue.config.locale.searchMessage || "";
    }, "filterMessageText"),
    emptyFilterMessageText: /* @__PURE__ */ __name(function emptyFilterMessageText() {
      return this.emptyFilterMessage || this.$primevue.config.locale.emptySearchMessage || this.$primevue.config.locale.emptyFilterMessage || "";
    }, "emptyFilterMessageText"),
    emptyMessageText: /* @__PURE__ */ __name(function emptyMessageText() {
      return this.emptyMessage || this.$primevue.config.locale.emptyMessage || "";
    }, "emptyMessageText"),
    selectionMessageText: /* @__PURE__ */ __name(function selectionMessageText() {
      return this.selectionMessage || this.$primevue.config.locale.selectionMessage || "";
    }, "selectionMessageText"),
    emptySelectionMessageText: /* @__PURE__ */ __name(function emptySelectionMessageText() {
      return this.emptySelectionMessage || this.$primevue.config.locale.emptySelectionMessage || "";
    }, "emptySelectionMessageText"),
    selectedMessageText: /* @__PURE__ */ __name(function selectedMessageText() {
      return this.hasSelectedOption ? this.selectionMessageText.replaceAll("{0}", this.multiple ? this.modelValue.length : "1") : this.emptySelectionMessageText;
    }, "selectedMessageText"),
    focusedOptionId: /* @__PURE__ */ __name(function focusedOptionId() {
      return this.focusedOptionIndex !== -1 ? "".concat(this.id, "_").concat(this.focusedOptionIndex) : null;
    }, "focusedOptionId"),
    ariaSetSize: /* @__PURE__ */ __name(function ariaSetSize() {
      var _this18 = this;
      return this.visibleOptions.filter(function(option4) {
        return !_this18.isOptionGroup(option4);
      }).length;
    }, "ariaSetSize"),
    virtualScrollerDisabled: /* @__PURE__ */ __name(function virtualScrollerDisabled() {
      return !this.virtualScrollerOptions;
    }, "virtualScrollerDisabled")
  },
  directives: {
    ripple: Ripple
  },
  components: {
    InputText: script$O,
    VirtualScroller: script$M,
    InputIcon: script$P,
    IconField: script$Q,
    SearchIcon: script$R,
    CheckIcon: script$S,
    BlankIcon: script$T
  }
};
var _hoisted_1$X = ["id"];
var _hoisted_2$J = ["tabindex"];
var _hoisted_3$m = ["id", "aria-multiselectable", "aria-label", "aria-labelledby", "aria-activedescendant", "aria-disabled"];
var _hoisted_4$f = ["id"];
var _hoisted_5$a = ["id", "aria-label", "aria-selected", "aria-disabled", "aria-setsize", "aria-posinset", "onClick", "onMousedown", "onMousemove", "onDblclick", "data-p-selected", "data-p-focused", "data-p-disabled"];
var _hoisted_6$9 = ["tabindex"];
function render$K(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_InputText = resolveComponent("InputText");
  var _component_SearchIcon = resolveComponent("SearchIcon");
  var _component_InputIcon = resolveComponent("InputIcon");
  var _component_IconField = resolveComponent("IconField");
  var _component_CheckIcon = resolveComponent("CheckIcon");
  var _component_BlankIcon = resolveComponent("BlankIcon");
  var _component_VirtualScroller = resolveComponent("VirtualScroller");
  var _directive_ripple = resolveDirective("ripple");
  return openBlock(), createElementBlock("div", mergeProps({
    id: $data.id,
    "class": _ctx.cx("root"),
    onFocusout: _cache[7] || (_cache[7] = function() {
      return $options.onFocusout && $options.onFocusout.apply($options, arguments);
    })
  }, _ctx.ptmi("root")), [createBaseVNode("span", mergeProps({
    ref: "firstHiddenFocusableElement",
    role: "presentation",
    "aria-hidden": "true",
    "class": "p-hidden-accessible p-hidden-focusable",
    tabindex: !_ctx.disabled ? _ctx.tabindex : -1,
    onFocus: _cache[0] || (_cache[0] = function() {
      return $options.onFirstHiddenFocus && $options.onFirstHiddenFocus.apply($options, arguments);
    })
  }, _ctx.ptm("hiddenFirstFocusableEl"), {
    "data-p-hidden-accessible": true,
    "data-p-hidden-focusable": true
  }), null, 16, _hoisted_2$J), _ctx.$slots.header ? (openBlock(), createElementBlock("div", {
    key: 0,
    "class": normalizeClass(_ctx.cx("header"))
  }, [renderSlot(_ctx.$slots, "header", {
    value: _ctx.modelValue,
    options: $options.visibleOptions
  })], 2)) : createCommentVNode("", true), _ctx.filter ? (openBlock(), createElementBlock("div", mergeProps({
    key: 1,
    "class": _ctx.cx("header")
  }, _ctx.ptm("header")), [createVNode(_component_IconField, mergeProps({
    unstyled: _ctx.unstyled
  }, _ctx.ptm("pcFilterContainer")), {
    "default": withCtx(function() {
      return [createVNode(_component_InputText, {
        modelValue: $data.filterValue,
        "onUpdate:modelValue": _cache[1] || (_cache[1] = function($event) {
          return $data.filterValue = $event;
        }),
        type: "text",
        "class": normalizeClass(_ctx.cx("pcFilter")),
        placeholder: _ctx.filterPlaceholder,
        role: "searchbox",
        autocomplete: "off",
        disabled: _ctx.disabled,
        unstyled: _ctx.unstyled,
        "aria-owns": $data.id + "_list",
        "aria-activedescendant": $options.focusedOptionId,
        tabindex: !_ctx.disabled && !$data.focused ? _ctx.tabindex : -1,
        onInput: $options.onFilterChange,
        onBlur: $options.onFilterBlur,
        onKeydown: $options.onFilterKeyDown,
        pt: _ctx.ptm("pcFilter")
      }, null, 8, ["modelValue", "class", "placeholder", "disabled", "unstyled", "aria-owns", "aria-activedescendant", "tabindex", "onInput", "onBlur", "onKeydown", "pt"]), createVNode(_component_InputIcon, mergeProps({
        unstyled: _ctx.unstyled
      }, _ctx.ptm("pcFilterIconContainer")), {
        "default": withCtx(function() {
          return [renderSlot(_ctx.$slots, "filtericon", {}, function() {
            return [_ctx.filterIcon ? (openBlock(), createElementBlock("span", mergeProps({
              key: 0,
              "class": _ctx.filterIcon
            }, _ctx.ptm("filterIcon")), null, 16)) : (openBlock(), createBlock(_component_SearchIcon, normalizeProps(mergeProps({
              key: 1
            }, _ctx.ptm("filterIcon"))), null, 16))];
          })];
        }),
        _: 3
      }, 16, ["unstyled"])];
    }),
    _: 3
  }, 16, ["unstyled"]), createBaseVNode("span", mergeProps({
    role: "status",
    "aria-live": "polite",
    "class": "p-hidden-accessible"
  }, _ctx.ptm("hiddenFilterResult"), {
    "data-p-hidden-accessible": true
  }), toDisplayString$1($options.filterResultMessageText), 17)], 16)) : createCommentVNode("", true), createBaseVNode("div", mergeProps({
    "class": _ctx.cx("listContainer"),
    style: [{
      "max-height": $options.virtualScrollerDisabled ? _ctx.scrollHeight : ""
    }, _ctx.listStyle]
  }, _ctx.ptm("listContainer")), [createVNode(_component_VirtualScroller, mergeProps({
    ref: $options.virtualScrollerRef
  }, _ctx.virtualScrollerOptions, {
    items: $options.visibleOptions,
    style: [{
      height: _ctx.scrollHeight
    }, _ctx.listStyle],
    tabindex: -1,
    disabled: $options.virtualScrollerDisabled,
    pt: _ctx.ptm("virtualScroller")
  }), createSlots({
    content: withCtx(function(_ref) {
      var styleClass = _ref.styleClass, contentRef3 = _ref.contentRef, items2 = _ref.items, getItemOptions = _ref.getItemOptions, contentStyle = _ref.contentStyle, itemSize2 = _ref.itemSize;
      return [createBaseVNode("ul", mergeProps({
        ref: /* @__PURE__ */ __name(function ref2(el) {
          return $options.listRef(el, contentRef3);
        }, "ref"),
        id: $data.id + "_list",
        "class": [_ctx.cx("list"), styleClass],
        style: contentStyle,
        tabindex: -1,
        role: "listbox",
        "aria-multiselectable": _ctx.multiple,
        "aria-label": _ctx.ariaLabel,
        "aria-labelledby": _ctx.ariaLabelledby,
        "aria-activedescendant": $data.focused ? $options.focusedOptionId : void 0,
        "aria-disabled": _ctx.disabled,
        onFocus: _cache[3] || (_cache[3] = function() {
          return $options.onListFocus && $options.onListFocus.apply($options, arguments);
        }),
        onBlur: _cache[4] || (_cache[4] = function() {
          return $options.onListBlur && $options.onListBlur.apply($options, arguments);
        }),
        onKeydown: _cache[5] || (_cache[5] = function() {
          return $options.onListKeyDown && $options.onListKeyDown.apply($options, arguments);
        })
      }, _ctx.ptm("list")), [(openBlock(true), createElementBlock(Fragment, null, renderList(items2, function(option4, i2) {
        return openBlock(), createElementBlock(Fragment, {
          key: $options.getOptionRenderKey(option4, $options.getOptionIndex(i2, getItemOptions))
        }, [$options.isOptionGroup(option4) ? (openBlock(), createElementBlock("li", mergeProps({
          key: 0,
          id: $data.id + "_" + $options.getOptionIndex(i2, getItemOptions),
          style: {
            height: itemSize2 ? itemSize2 + "px" : void 0
          },
          "class": _ctx.cx("optionGroup"),
          role: "option",
          ref_for: true
        }, _ctx.ptm("optionGroup")), [renderSlot(_ctx.$slots, "optiongroup", {
          option: option4.optionGroup,
          index: $options.getOptionIndex(i2, getItemOptions)
        }, function() {
          return [createTextVNode(toDisplayString$1($options.getOptionGroupLabel(option4.optionGroup)), 1)];
        })], 16, _hoisted_4$f)) : withDirectives((openBlock(), createElementBlock("li", mergeProps({
          key: 1,
          id: $data.id + "_" + $options.getOptionIndex(i2, getItemOptions),
          style: {
            height: itemSize2 ? itemSize2 + "px" : void 0
          },
          "class": _ctx.cx("option", {
            option: option4,
            index: i2,
            getItemOptions
          }),
          role: "option",
          "aria-label": $options.getOptionLabel(option4),
          "aria-selected": $options.isSelected(option4),
          "aria-disabled": $options.isOptionDisabled(option4),
          "aria-setsize": $options.ariaSetSize,
          "aria-posinset": $options.getAriaPosInset($options.getOptionIndex(i2, getItemOptions)),
          onClick: /* @__PURE__ */ __name(function onClick3($event) {
            return $options.onOptionSelect($event, option4, $options.getOptionIndex(i2, getItemOptions));
          }, "onClick"),
          onMousedown: /* @__PURE__ */ __name(function onMousedown($event) {
            return $options.onOptionMouseDown($event, $options.getOptionIndex(i2, getItemOptions));
          }, "onMousedown"),
          onMousemove: /* @__PURE__ */ __name(function onMousemove($event) {
            return $options.onOptionMouseMove($event, $options.getOptionIndex(i2, getItemOptions));
          }, "onMousemove"),
          onTouchend: _cache[2] || (_cache[2] = function($event) {
            return $options.onOptionTouchEnd();
          }),
          onDblclick: /* @__PURE__ */ __name(function onDblclick($event) {
            return $options.onOptionDblClick($event, option4);
          }, "onDblclick"),
          ref_for: true
        }, $options.getPTOptions(option4, getItemOptions, i2, "option"), {
          "data-p-selected": $options.isSelected(option4),
          "data-p-focused": $data.focusedOptionIndex === $options.getOptionIndex(i2, getItemOptions),
          "data-p-disabled": $options.isOptionDisabled(option4)
        }), [_ctx.checkmark ? (openBlock(), createElementBlock(Fragment, {
          key: 0
        }, [$options.isSelected(option4) ? (openBlock(), createBlock(_component_CheckIcon, mergeProps({
          key: 0,
          "class": _ctx.cx("optionCheckIcon"),
          ref_for: true
        }, _ctx.ptm("optionCheckIcon")), null, 16, ["class"])) : (openBlock(), createBlock(_component_BlankIcon, mergeProps({
          key: 1,
          "class": _ctx.cx("optionBlankIcon"),
          ref_for: true
        }, _ctx.ptm("optionBlankIcon")), null, 16, ["class"]))], 64)) : createCommentVNode("", true), renderSlot(_ctx.$slots, "option", {
          option: option4,
          selected: $options.isSelected(option4),
          index: $options.getOptionIndex(i2, getItemOptions)
        }, function() {
          return [createTextVNode(toDisplayString$1($options.getOptionLabel(option4)), 1)];
        })], 16, _hoisted_5$a)), [[_directive_ripple]])], 64);
      }), 128)), $data.filterValue && (!items2 || items2 && items2.length === 0) ? (openBlock(), createElementBlock("li", mergeProps({
        key: 0,
        "class": _ctx.cx("emptyMessage"),
        role: "option"
      }, _ctx.ptm("emptyMessage")), [renderSlot(_ctx.$slots, "emptyfilter", {}, function() {
        return [createTextVNode(toDisplayString$1($options.emptyFilterMessageText), 1)];
      })], 16)) : !_ctx.options || _ctx.options && _ctx.options.length === 0 ? (openBlock(), createElementBlock("li", mergeProps({
        key: 1,
        "class": _ctx.cx("emptyMessage"),
        role: "option"
      }, _ctx.ptm("emptyMessage")), [renderSlot(_ctx.$slots, "empty", {}, function() {
        return [createTextVNode(toDisplayString$1($options.emptyMessageText), 1)];
      })], 16)) : createCommentVNode("", true)], 16, _hoisted_3$m)];
    }),
    _: 2
  }, [_ctx.$slots.loader ? {
    name: "loader",
    fn: withCtx(function(_ref2) {
      var options3 = _ref2.options;
      return [renderSlot(_ctx.$slots, "loader", {
        options: options3
      })];
    }),
    key: "0"
  } : void 0]), 1040, ["items", "style", "disabled", "pt"])], 16), renderSlot(_ctx.$slots, "footer", {
    value: _ctx.modelValue,
    options: $options.visibleOptions
  }), !_ctx.options || _ctx.options && _ctx.options.length === 0 ? (openBlock(), createElementBlock("span", mergeProps({
    key: 2,
    role: "status",
    "aria-live": "polite",
    "class": "p-hidden-accessible"
  }, _ctx.ptm("hiddenEmptyMessage"), {
    "data-p-hidden-accessible": true
  }), toDisplayString$1($options.emptyMessageText), 17)) : createCommentVNode("", true), createBaseVNode("span", mergeProps({
    role: "status",
    "aria-live": "polite",
    "class": "p-hidden-accessible"
  }, _ctx.ptm("hiddenSelectedMessage"), {
    "data-p-hidden-accessible": true
  }), toDisplayString$1($options.selectedMessageText), 17), createBaseVNode("span", mergeProps({
    ref: "lastHiddenFocusableElement",
    role: "presentation",
    "aria-hidden": "true",
    "class": "p-hidden-accessible p-hidden-focusable",
    tabindex: !_ctx.disabled ? _ctx.tabindex : -1,
    onFocus: _cache[6] || (_cache[6] = function() {
      return $options.onLastHiddenFocus && $options.onLastHiddenFocus.apply($options, arguments);
    })
  }, _ctx.ptm("hiddenLastFocusableEl"), {
    "data-p-hidden-accessible": true,
    "data-p-hidden-focusable": true
  }), null, 16, _hoisted_6$9)], 16, _hoisted_1$X);
}
__name(render$K, "render$K");
script$L.render = render$K;
var theme$q = /* @__PURE__ */ __name(function theme11(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-badge {\n    display: inline-flex;\n    border-radius: ".concat(dt3("badge.border.radius"), ";\n    align-items: center;\n    justify-content: center;\n    padding: ").concat(dt3("badge.padding"), ";\n    background: ").concat(dt3("badge.primary.background"), ";\n    color: ").concat(dt3("badge.primary.color"), ";\n    font-size: ").concat(dt3("badge.font.size"), ";\n    font-weight: ").concat(dt3("badge.font.weight"), ";\n    min-width: ").concat(dt3("badge.min.width"), ";\n    height: ").concat(dt3("badge.height"), ";\n}\n\n.p-badge-dot {\n    width: ").concat(dt3("badge.dot.size"), ";\n    min-width: ").concat(dt3("badge.dot.size"), ";\n    height: ").concat(dt3("badge.dot.size"), ";\n    border-radius: 50%;\n    padding: 0;\n}\n\n.p-badge-circle {\n    padding: 0;\n    border-radius: 50%;\n}\n\n.p-badge-secondary {\n    background: ").concat(dt3("badge.secondary.background"), ";\n    color: ").concat(dt3("badge.secondary.color"), ";\n}\n\n.p-badge-success {\n    background: ").concat(dt3("badge.success.background"), ";\n    color: ").concat(dt3("badge.success.color"), ";\n}\n\n.p-badge-info {\n    background: ").concat(dt3("badge.info.background"), ";\n    color: ").concat(dt3("badge.info.color"), ";\n}\n\n.p-badge-warn {\n    background: ").concat(dt3("badge.warn.background"), ";\n    color: ").concat(dt3("badge.warn.color"), ";\n}\n\n.p-badge-danger {\n    background: ").concat(dt3("badge.danger.background"), ";\n    color: ").concat(dt3("badge.danger.color"), ";\n}\n\n.p-badge-contrast {\n    background: ").concat(dt3("badge.contrast.background"), ";\n    color: ").concat(dt3("badge.contrast.color"), ";\n}\n\n.p-badge-sm {\n    font-size: ").concat(dt3("badge.sm.font.size"), ";\n    min-width: ").concat(dt3("badge.sm.min.width"), ";\n    height: ").concat(dt3("badge.sm.height"), ";\n}\n\n.p-badge-lg {\n    font-size: ").concat(dt3("badge.lg.font.size"), ";\n    min-width: ").concat(dt3("badge.lg.min.width"), ";\n    height: ").concat(dt3("badge.lg.height"), ";\n}\n\n.p-badge-xl {\n    font-size: ").concat(dt3("badge.xl.font.size"), ";\n    min-width: ").concat(dt3("badge.xl.min.width"), ";\n    height: ").concat(dt3("badge.xl.height"), ";\n}\n");
}, "theme");
var classes$t = {
  root: /* @__PURE__ */ __name(function root3(_ref2) {
    var props = _ref2.props, instance = _ref2.instance;
    return ["p-badge p-component", {
      "p-badge-circle": isNotEmpty(props.value) && String(props.value).length === 1,
      "p-badge-dot": isEmpty(props.value) && !instance.$slots["default"],
      "p-badge-sm": props.size === "small",
      "p-badge-lg": props.size === "large",
      "p-badge-xl": props.size === "xlarge",
      "p-badge-info": props.severity === "info",
      "p-badge-success": props.severity === "success",
      "p-badge-warn": props.severity === "warn",
      "p-badge-danger": props.severity === "danger",
      "p-badge-secondary": props.severity === "secondary",
      "p-badge-contrast": props.severity === "contrast"
    }];
  }, "root")
};
var BadgeStyle = BaseStyle.extend({
  name: "badge",
  theme: theme$q,
  classes: classes$t
});
var script$1$t = {
  name: "BaseBadge",
  "extends": script$X,
  props: {
    value: {
      type: [String, Number],
      "default": null
    },
    severity: {
      type: String,
      "default": null
    },
    size: {
      type: String,
      "default": null
    }
  },
  style: BadgeStyle,
  provide: /* @__PURE__ */ __name(function provide10() {
    return {
      $pcBadge: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$K = {
  name: "Badge",
  "extends": script$1$t,
  inheritAttrs: false
};
function render$J(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps({
    "class": _ctx.cx("root")
  }, _ctx.ptmi("root")), [renderSlot(_ctx.$slots, "default", {}, function() {
    return [createTextVNode(toDisplayString$1(_ctx.value), 1)];
  })], 16);
}
__name(render$J, "render$J");
script$K.render = render$J;
function _typeof$b(o) {
  "@babel/helpers - typeof";
  return _typeof$b = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$b(o);
}
__name(_typeof$b, "_typeof$b");
function _defineProperty$b(e, r, t) {
  return (r = _toPropertyKey$a(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty$b, "_defineProperty$b");
function _toPropertyKey$a(t) {
  var i2 = _toPrimitive$a(t, "string");
  return "symbol" == _typeof$b(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$a, "_toPropertyKey$a");
function _toPrimitive$a(t, r) {
  if ("object" != _typeof$b(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$b(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive$a, "_toPrimitive$a");
var theme$p = /* @__PURE__ */ __name(function theme12(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-button {\n    display: inline-flex;\n    cursor: pointer;\n    user-select: none;\n    align-items: center;\n    justify-content: center;\n    overflow: hidden;\n    position: relative;\n    color: ".concat(dt3("button.primary.color"), ";\n    background: ").concat(dt3("button.primary.background"), ";\n    border: 1px solid ").concat(dt3("button.primary.border.color"), ";\n    padding: ").concat(dt3("button.padding.y"), " ").concat(dt3("button.padding.x"), ";\n    font-size: 1rem;\n    font-family: inherit;\n    font-feature-settings: inherit;\n    transition: background ").concat(dt3("button.transition.duration"), ", color ").concat(dt3("button.transition.duration"), ", border-color ").concat(dt3("button.transition.duration"), ",\n            outline-color ").concat(dt3("button.transition.duration"), ", box-shadow ").concat(dt3("button.transition.duration"), ";\n    border-radius: ").concat(dt3("button.border.radius"), ";\n    outline-color: transparent;\n    gap: ").concat(dt3("button.gap"), ";\n}\n\n.p-button:disabled {\n    cursor: default;\n}\n\n.p-button-icon-right {\n    order: 1;\n}\n\n.p-button-icon-bottom {\n    order: 2;\n}\n\n.p-button-icon-only {\n    width: ").concat(dt3("button.icon.only.width"), ";\n    padding-left: 0;\n    padding-right: 0;\n    gap: 0;\n}\n\n.p-button-icon-only.p-button-rounded {\n    border-radius: 50%;\n    height: ").concat(dt3("button.icon.only.width"), ";\n}\n\n.p-button-icon-only .p-button-label {\n    visibility: hidden;\n    width: 0;\n}\n\n.p-button-sm {\n    font-size: ").concat(dt3("button.sm.font.size"), ";\n    padding: ").concat(dt3("button.sm.padding.y"), " ").concat(dt3("button.sm.padding.x"), ";\n}\n\n.p-button-sm .p-button-icon {\n    font-size: ").concat(dt3("button.sm.font.size"), ";\n}\n\n.p-button-lg {\n    font-size: ").concat(dt3("button.lg.font.size"), ";\n    padding: ").concat(dt3("button.lg.padding.y"), " ").concat(dt3("button.lg.padding.x"), ";\n}\n\n.p-button-lg .p-button-icon {\n    font-size: ").concat(dt3("button.lg.font.size"), ";\n}\n\n.p-button-vertical {\n    flex-direction: column;\n}\n\n.p-button-label {\n    font-weight: ").concat(dt3("button.label.font.weight"), ";\n}\n\n.p-button-fluid {\n    width: 100%;\n}\n\n.p-button-fluid.p-button-icon-only {\n    width: ").concat(dt3("button.icon.only.width"), ";\n}\n\n.p-button:not(:disabled):hover {\n    background: ").concat(dt3("button.primary.hover.background"), ";\n    border: 1px solid ").concat(dt3("button.primary.hover.border.color"), ";\n    color: ").concat(dt3("button.primary.hover.color"), ";\n}\n\n.p-button:not(:disabled):active {\n    background: ").concat(dt3("button.primary.active.background"), ";\n    border: 1px solid ").concat(dt3("button.primary.active.border.color"), ";\n    color: ").concat(dt3("button.primary.active.color"), ";\n}\n\n.p-button:focus-visible {\n    box-shadow: ").concat(dt3("button.primary.focus.ring.shadow"), ";\n    outline: ").concat(dt3("button.focus.ring.width"), " ").concat(dt3("button.focus.ring.style"), " ").concat(dt3("button.primary.focus.ring.color"), ";\n    outline-offset: ").concat(dt3("button.focus.ring.offset"), ";\n}\n\n.p-button .p-badge {\n    min-width: ").concat(dt3("button.badge.size"), ";\n    height: ").concat(dt3("button.badge.size"), ";\n    line-height: ").concat(dt3("button.badge.size"), ";\n}\n\n.p-button-raised {\n    box-shadow: ").concat(dt3("button.raised.shadow"), ";\n}\n\n.p-button-rounded {\n    border-radius: ").concat(dt3("button.rounded.border.radius"), ";\n}\n\n.p-button-secondary {\n    background: ").concat(dt3("button.secondary.background"), ";\n    border: 1px solid ").concat(dt3("button.secondary.border.color"), ";\n    color: ").concat(dt3("button.secondary.color"), ";\n}\n\n.p-button-secondary:not(:disabled):hover {\n    background: ").concat(dt3("button.secondary.hover.background"), ";\n    border: 1px solid ").concat(dt3("button.secondary.hover.border.color"), ";\n    color: ").concat(dt3("button.secondary.hover.color"), ";\n}\n\n.p-button-secondary:not(:disabled):active {\n    background: ").concat(dt3("button.secondary.active.background"), ";\n    border: 1px solid ").concat(dt3("button.secondary.active.border.color"), ";\n    color: ").concat(dt3("button.secondary.active.color"), ";\n}\n\n.p-button-secondary:focus-visible {\n    outline-color: ").concat(dt3("button.secondary.focus.ring.color"), ";\n    box-shadow: ").concat(dt3("button.secondary.focus.ring.shadow"), ";\n}\n\n.p-button-success {\n    background: ").concat(dt3("button.success.background"), ";\n    border: 1px solid ").concat(dt3("button.success.border.color"), ";\n    color: ").concat(dt3("button.success.color"), ";\n}\n\n.p-button-success:not(:disabled):hover {\n    background: ").concat(dt3("button.success.hover.background"), ";\n    border: 1px solid ").concat(dt3("button.success.hover.border.color"), ";\n    color: ").concat(dt3("button.success.hover.color"), ";\n}\n\n.p-button-success:not(:disabled):active {\n    background: ").concat(dt3("button.success.active.background"), ";\n    border: 1px solid ").concat(dt3("button.success.active.border.color"), ";\n    color: ").concat(dt3("button.success.active.color"), ";\n}\n\n.p-button-success:focus-visible {\n    outline-color: ").concat(dt3("button.success.focus.ring.color"), ";\n    box-shadow: ").concat(dt3("button.success.focus.ring.shadow"), ";\n}\n\n.p-button-info {\n    background: ").concat(dt3("button.info.background"), ";\n    border: 1px solid ").concat(dt3("button.info.border.color"), ";\n    color: ").concat(dt3("button.info.color"), ";\n}\n\n.p-button-info:not(:disabled):hover {\n    background: ").concat(dt3("button.info.hover.background"), ";\n    border: 1px solid ").concat(dt3("button.info.hover.border.color"), ";\n    color: ").concat(dt3("button.info.hover.color"), ";\n}\n\n.p-button-info:not(:disabled):active {\n    background: ").concat(dt3("button.info.active.background"), ";\n    border: 1px solid ").concat(dt3("button.info.active.border.color"), ";\n    color: ").concat(dt3("button.info.active.color"), ";\n}\n\n.p-button-info:focus-visible {\n    outline-color: ").concat(dt3("button.info.focus.ring.color"), ";\n    box-shadow: ").concat(dt3("button.info.focus.ring.shadow"), ";\n}\n\n.p-button-warn {\n    background: ").concat(dt3("button.warn.background"), ";\n    border: 1px solid ").concat(dt3("button.warn.border.color"), ";\n    color: ").concat(dt3("button.warn.color"), ";\n}\n\n.p-button-warn:not(:disabled):hover {\n    background: ").concat(dt3("button.warn.hover.background"), ";\n    border: 1px solid ").concat(dt3("button.warn.hover.border.color"), ";\n    color: ").concat(dt3("button.warn.hover.color"), ";\n}\n\n.p-button-warn:not(:disabled):active {\n    background: ").concat(dt3("button.warn.active.background"), ";\n    border: 1px solid ").concat(dt3("button.warn.active.border.color"), ";\n    color: ").concat(dt3("button.warn.active.color"), ";\n}\n\n.p-button-warn:focus-visible {\n    outline-color: ").concat(dt3("button.warn.focus.ring.color"), ";\n    box-shadow: ").concat(dt3("button.warn.focus.ring.shadow"), ";\n}\n\n.p-button-help {\n    background: ").concat(dt3("button.help.background"), ";\n    border: 1px solid ").concat(dt3("button.help.border.color"), ";\n    color: ").concat(dt3("button.help.color"), ";\n}\n\n.p-button-help:not(:disabled):hover {\n    background: ").concat(dt3("button.help.hover.background"), ";\n    border: 1px solid ").concat(dt3("button.help.hover.border.color"), ";\n    color: ").concat(dt3("button.help.hover.color"), ";\n}\n\n.p-button-help:not(:disabled):active {\n    background: ").concat(dt3("button.help.active.background"), ";\n    border: 1px solid ").concat(dt3("button.help.active.border.color"), ";\n    color: ").concat(dt3("button.help.active.color"), ";\n}\n\n.p-button-help:focus-visible {\n    outline-color: ").concat(dt3("button.help.focus.ring.color"), ";\n    box-shadow: ").concat(dt3("button.help.focus.ring.shadow"), ";\n}\n\n.p-button-danger {\n    background: ").concat(dt3("button.danger.background"), ";\n    border: 1px solid ").concat(dt3("button.danger.border.color"), ";\n    color: ").concat(dt3("button.danger.color"), ";\n}\n\n.p-button-danger:not(:disabled):hover {\n    background: ").concat(dt3("button.danger.hover.background"), ";\n    border: 1px solid ").concat(dt3("button.danger.hover.border.color"), ";\n    color: ").concat(dt3("button.danger.hover.color"), ";\n}\n\n.p-button-danger:not(:disabled):active {\n    background: ").concat(dt3("button.danger.active.background"), ";\n    border: 1px solid ").concat(dt3("button.danger.active.border.color"), ";\n    color: ").concat(dt3("button.danger.active.color"), ";\n}\n\n.p-button-danger:focus-visible {\n    outline-color: ").concat(dt3("button.danger.focus.ring.color"), ";\n    box-shadow: ").concat(dt3("button.danger.focus.ring.shadow"), ";\n}\n\n.p-button-contrast {\n    background: ").concat(dt3("button.contrast.background"), ";\n    border: 1px solid ").concat(dt3("button.contrast.border.color"), ";\n    color: ").concat(dt3("button.contrast.color"), ";\n}\n\n.p-button-contrast:not(:disabled):hover {\n    background: ").concat(dt3("button.contrast.hover.background"), ";\n    border: 1px solid ").concat(dt3("button.contrast.hover.border.color"), ";\n    color: ").concat(dt3("button.contrast.hover.color"), ";\n}\n\n.p-button-contrast:not(:disabled):active {\n    background: ").concat(dt3("button.contrast.active.background"), ";\n    border: 1px solid ").concat(dt3("button.contrast.active.border.color"), ";\n    color: ").concat(dt3("button.contrast.active.color"), ";\n}\n\n.p-button-contrast:focus-visible {\n    outline-color: ").concat(dt3("button.contrast.focus.ring.color"), ";\n    box-shadow: ").concat(dt3("button.contrast.focus.ring.shadow"), ";\n}\n\n.p-button-outlined {\n    background: transparent;\n    border-color: ").concat(dt3("button.outlined.primary.border.color"), ";\n    color: ").concat(dt3("button.outlined.primary.color"), ";\n}\n\n.p-button-outlined:not(:disabled):hover {\n    background: ").concat(dt3("button.outlined.primary.hover.background"), ";\n    border-color: ").concat(dt3("button.outlined.primary.border.color"), ";\n    color: ").concat(dt3("button.outlined.primary.color"), ";\n}\n\n.p-button-outlined:not(:disabled):active {\n    background: ").concat(dt3("button.outlined.primary.active.background"), ";\n    border-color: ").concat(dt3("button.outlined.primary.border.color"), ";\n    color: ").concat(dt3("button.outlined.primary.color"), ";\n}\n\n.p-button-outlined.p-button-secondary {\n    border-color: ").concat(dt3("button.outlined.secondary.border.color"), ";\n    color: ").concat(dt3("button.outlined.secondary.color"), ";\n}\n\n.p-button-outlined.p-button-secondary:not(:disabled):hover {\n    background: ").concat(dt3("button.outlined.secondary.hover.background"), ";\n    border-color: ").concat(dt3("button.outlined.secondary.border.color"), ";\n    color: ").concat(dt3("button.outlined.secondary.color"), ";\n}\n\n.p-button-outlined.p-button-secondary:not(:disabled):active {\n    background: ").concat(dt3("button.outlined.secondary.active.background"), ";\n    border-color: ").concat(dt3("button.outlined.secondary.border.color"), ";\n    color: ").concat(dt3("button.outlined.secondary.color"), ";\n}\n\n.p-button-outlined.p-button-success {\n    border-color: ").concat(dt3("button.outlined.success.border.color"), ";\n    color: ").concat(dt3("button.outlined.success.color"), ";\n}\n\n.p-button-outlined.p-button-success:not(:disabled):hover {\n    background: ").concat(dt3("button.outlined.success.hover.background"), ";\n    border-color: ").concat(dt3("button.outlined.success.border.color"), ";\n    color: ").concat(dt3("button.outlined.success.color"), ";\n}\n\n.p-button-outlined.p-button-success:not(:disabled):active {\n    background: ").concat(dt3("button.outlined.success.active.background"), ";\n    border-color: ").concat(dt3("button.outlined.success.border.color"), ";\n    color: ").concat(dt3("button.outlined.success.color"), ";\n}\n\n.p-button-outlined.p-button-info {\n    border-color: ").concat(dt3("button.outlined.info.border.color"), ";\n    color: ").concat(dt3("button.outlined.info.color"), ";\n}\n\n.p-button-outlined.p-button-info:not(:disabled):hover {\n    background: ").concat(dt3("button.outlined.info.hover.background"), ";\n    border-color: ").concat(dt3("button.outlined.info.border.color"), ";\n    color: ").concat(dt3("button.outlined.info.color"), ";\n}\n\n.p-button-outlined.p-button-info:not(:disabled):active {\n    background: ").concat(dt3("button.outlined.info.active.background"), ";\n    border-color: ").concat(dt3("button.outlined.info.border.color"), ";\n    color: ").concat(dt3("button.outlined.info.color"), ";\n}\n\n.p-button-outlined.p-button-warn {\n    border-color: ").concat(dt3("button.outlined.warn.border.color"), ";\n    color: ").concat(dt3("button.outlined.warn.color"), ";\n}\n\n.p-button-outlined.p-button-warn:not(:disabled):hover {\n    background: ").concat(dt3("button.outlined.warn.hover.background"), ";\n    border-color: ").concat(dt3("button.outlined.warn.border.color"), ";\n    color: ").concat(dt3("button.outlined.warn.color"), ";\n}\n\n.p-button-outlined.p-button-warn:not(:disabled):active {\n    background: ").concat(dt3("button.outlined.warn.active.background"), ";\n    border-color: ").concat(dt3("button.outlined.warn.border.color"), ";\n    color: ").concat(dt3("button.outlined.warn.color"), ";\n}\n\n.p-button-outlined.p-button-help {\n    border-color: ").concat(dt3("button.outlined.help.border.color"), ";\n    color: ").concat(dt3("button.outlined.help.color"), ";\n}\n\n.p-button-outlined.p-button-help:not(:disabled):hover {\n    background: ").concat(dt3("button.outlined.help.hover.background"), ";\n    border-color: ").concat(dt3("button.outlined.help.border.color"), ";\n    color: ").concat(dt3("button.outlined.help.color"), ";\n}\n\n.p-button-outlined.p-button-help:not(:disabled):active {\n    background: ").concat(dt3("button.outlined.help.active.background"), ";\n    border-color: ").concat(dt3("button.outlined.help.border.color"), ";\n    color: ").concat(dt3("button.outlined.help.color"), ";\n}\n\n.p-button-outlined.p-button-danger {\n    border-color: ").concat(dt3("button.outlined.danger.border.color"), ";\n    color: ").concat(dt3("button.outlined.danger.color"), ";\n}\n\n.p-button-outlined.p-button-danger:not(:disabled):hover {\n    background: ").concat(dt3("button.outlined.danger.hover.background"), ";\n    border-color: ").concat(dt3("button.outlined.danger.border.color"), ";\n    color: ").concat(dt3("button.outlined.danger.color"), ";\n}\n\n.p-button-outlined.p-button-danger:not(:disabled):active {\n    background: ").concat(dt3("button.outlined.danger.active.background"), ";\n    border-color: ").concat(dt3("button.outlined.danger.border.color"), ";\n    color: ").concat(dt3("button.outlined.danger.color"), ";\n}\n\n.p-button-outlined.p-button-contrast {\n    border-color: ").concat(dt3("button.outlined.contrast.border.color"), ";\n    color: ").concat(dt3("button.outlined.contrast.color"), ";\n}\n\n.p-button-outlined.p-button-contrast:not(:disabled):hover {\n    background: ").concat(dt3("button.outlined.contrast.hover.background"), ";\n    border-color: ").concat(dt3("button.outlined.contrast.border.color"), ";\n    color: ").concat(dt3("button.outlined.contrast.color"), ";\n}\n\n.p-button-outlined.p-button-contrast:not(:disabled):active {\n    background: ").concat(dt3("button.outlined.contrast.active.background"), ";\n    border-color: ").concat(dt3("button.outlined.contrast.border.color"), ";\n    color: ").concat(dt3("button.outlined.contrast.color"), ";\n}\n\n.p-button-outlined.p-button-plain {\n    border-color: ").concat(dt3("button.outlined.plain.border.color"), ";\n    color: ").concat(dt3("button.outlined.plain.color"), ";\n}\n\n.p-button-outlined.p-button-plain:not(:disabled):hover {\n    background: ").concat(dt3("button.outlined.plain.hover.background"), ";\n    border-color: ").concat(dt3("button.outlined.plain.border.color"), ";\n    color: ").concat(dt3("button.outlined.plain.color"), ";\n}\n\n.p-button-outlined.p-button-plain:not(:disabled):active {\n    background: ").concat(dt3("button.outlined.plain.active.background"), ";\n    border-color: ").concat(dt3("button.outlined.plain.border.color"), ";\n    color: ").concat(dt3("button.outlined.plain.color"), ";\n}\n\n.p-button-text {\n    background: transparent;\n    border-color: transparent;\n    color: ").concat(dt3("button.text.primary.color"), ";\n}\n\n.p-button-text:not(:disabled):hover {\n    background: ").concat(dt3("button.text.primary.hover.background"), ";\n    border-color: transparent;\n    color: ").concat(dt3("button.text.primary.color"), ";\n}\n\n.p-button-text:not(:disabled):active {\n    background: ").concat(dt3("button.text.primary.active.background"), ";\n    border-color: transparent;\n    color: ").concat(dt3("button.text.primary.color"), ";\n}\n\n.p-button-text.p-button-secondary {\n    background: transparent;\n    border-color: transparent;\n    color: ").concat(dt3("button.text.secondary.color"), ";\n}\n\n.p-button-text.p-button-secondary:not(:disabled):hover {\n    background: ").concat(dt3("button.text.secondary.hover.background"), ";\n    border-color: transparent;\n    color: ").concat(dt3("button.text.secondary.color"), ";\n}\n\n.p-button-text.p-button-secondary:not(:disabled):active {\n    background: ").concat(dt3("button.text.secondary.active.background"), ";\n    border-color: transparent;\n    color: ").concat(dt3("button.text.secondary.color"), ";\n}\n\n.p-button-text.p-button-success {\n    background: transparent;\n    border-color: transparent;\n    color: ").concat(dt3("button.text.success.color"), ";\n}\n\n.p-button-text.p-button-success:not(:disabled):hover {\n    background: ").concat(dt3("button.text.success.hover.background"), ";\n    border-color: transparent;\n    color: ").concat(dt3("button.text.success.color"), ";\n}\n\n.p-button-text.p-button-success:not(:disabled):active {\n    background: ").concat(dt3("button.text.success.active.background"), ";\n    border-color: transparent;\n    color: ").concat(dt3("button.text.success.color"), ";\n}\n\n.p-button-text.p-button-info {\n    background: transparent;\n    border-color: transparent;\n    color: ").concat(dt3("button.text.info.color"), ";\n}\n\n.p-button-text.p-button-info:not(:disabled):hover {\n    background: ").concat(dt3("button.text.info.hover.background"), ";\n    border-color: transparent;\n    color: ").concat(dt3("button.text.info.color"), ";\n}\n\n.p-button-text.p-button-info:not(:disabled):active {\n    background: ").concat(dt3("button.text.info.active.background"), ";\n    border-color: transparent;\n    color: ").concat(dt3("button.text.info.color"), ";\n}\n\n.p-button-text.p-button-warn {\n    background: transparent;\n    border-color: transparent;\n    color: ").concat(dt3("button.text.warn.color"), ";\n}\n\n.p-button-text.p-button-warn:not(:disabled):hover {\n    background: ").concat(dt3("button.text.warn.hover.background"), ";\n    border-color: transparent;\n    color: ").concat(dt3("button.text.warn.color"), ";\n}\n\n.p-button-text.p-button-warn:not(:disabled):active {\n    background: ").concat(dt3("button.text.warn.active.background"), ";\n    border-color: transparent;\n    color: ").concat(dt3("button.text.warn.color"), ";\n}\n\n.p-button-text.p-button-help {\n    background: transparent;\n    border-color: transparent;\n    color: ").concat(dt3("button.text.help.color"), ";\n}\n\n.p-button-text.p-button-help:not(:disabled):hover {\n    background: ").concat(dt3("button.text.help.hover.background"), ";\n    border-color: transparent;\n    color: ").concat(dt3("button.text.help.color"), ";\n}\n\n.p-button-text.p-button-help:not(:disabled):active {\n    background: ").concat(dt3("button.text.help.active.background"), ";\n    border-color: transparent;\n    color: ").concat(dt3("button.text.help.color"), ";\n}\n\n.p-button-text.p-button-danger {\n    background: transparent;\n    border-color: transparent;\n    color: ").concat(dt3("button.text.danger.color"), ";\n}\n\n.p-button-text.p-button-danger:not(:disabled):hover {\n    background: ").concat(dt3("button.text.danger.hover.background"), ";\n    border-color: transparent;\n    color: ").concat(dt3("button.text.danger.color"), ";\n}\n\n.p-button-text.p-button-danger:not(:disabled):active {\n    background: ").concat(dt3("button.text.danger.active.background"), ";\n    border-color: transparent;\n    color: ").concat(dt3("button.text.danger.color"), ";\n}\n\n.p-button-text.p-button-plain {\n    background: transparent;\n    border-color: transparent;\n    color: ").concat(dt3("button.text.plain.color"), ";\n}\n\n.p-button-text.p-button-plain:not(:disabled):hover {\n    background: ").concat(dt3("button.text.plain.hover.background"), ";\n    border-color: transparent;\n    color: ").concat(dt3("button.text.plain.color"), ";\n}\n\n.p-button-text.p-button-plain:not(:disabled):active {\n    background: ").concat(dt3("button.text.plain.active.background"), ";\n    border-color: transparent;\n    color: ").concat(dt3("button.text.plain.color"), ";\n}\n\n.p-button-link {\n    background: transparent;\n    border-color: transparent;\n    color: ").concat(dt3("button.link.color"), ";\n}\n\n.p-button-link:not(:disabled):hover {\n    background: transparent;\n    border-color: transparent;\n    color: ").concat(dt3("button.link.hover.color"), ";\n}\n\n.p-button-link:not(:disabled):hover .p-button-label {\n    text-decoration: underline;\n}\n\n.p-button-link:not(:disabled):active {\n    background: transparent;\n    border-color: transparent;\n    color: ").concat(dt3("button.link.active.color"), ";\n}\n");
}, "theme");
var classes$s = {
  root: /* @__PURE__ */ __name(function root4(_ref2) {
    var instance = _ref2.instance, props = _ref2.props;
    return ["p-button p-component", _defineProperty$b(_defineProperty$b(_defineProperty$b(_defineProperty$b(_defineProperty$b(_defineProperty$b(_defineProperty$b(_defineProperty$b(_defineProperty$b({
      "p-button-icon-only": instance.hasIcon && !props.label && !props.badge,
      "p-button-vertical": (props.iconPos === "top" || props.iconPos === "bottom") && props.label,
      "p-button-loading": props.loading,
      "p-button-link": props.link
    }, "p-button-".concat(props.severity), props.severity), "p-button-raised", props.raised), "p-button-rounded", props.rounded), "p-button-text", props.text), "p-button-outlined", props.outlined), "p-button-sm", props.size === "small"), "p-button-lg", props.size === "large"), "p-button-plain", props.plain), "p-button-fluid", props.fluid)];
  }, "root"),
  loadingIcon: "p-button-loading-icon",
  icon: /* @__PURE__ */ __name(function icon(_ref4) {
    var props = _ref4.props;
    return ["p-button-icon", _defineProperty$b({}, "p-button-icon-".concat(props.iconPos), props.label)];
  }, "icon"),
  label: "p-button-label"
};
var ButtonStyle = BaseStyle.extend({
  name: "button",
  theme: theme$p,
  classes: classes$s
});
var script$1$s = {
  name: "BaseButton",
  "extends": script$X,
  props: {
    label: {
      type: String,
      "default": null
    },
    icon: {
      type: String,
      "default": null
    },
    iconPos: {
      type: String,
      "default": "left"
    },
    iconClass: {
      type: String,
      "default": null
    },
    badge: {
      type: String,
      "default": null
    },
    badgeClass: {
      type: String,
      "default": null
    },
    badgeSeverity: {
      type: String,
      "default": "secondary"
    },
    loading: {
      type: Boolean,
      "default": false
    },
    loadingIcon: {
      type: String,
      "default": void 0
    },
    as: {
      type: String,
      "default": "BUTTON"
    },
    asChild: {
      type: Boolean,
      "default": false
    },
    link: {
      type: Boolean,
      "default": false
    },
    severity: {
      type: String,
      "default": null
    },
    raised: {
      type: Boolean,
      "default": false
    },
    rounded: {
      type: Boolean,
      "default": false
    },
    text: {
      type: Boolean,
      "default": false
    },
    outlined: {
      type: Boolean,
      "default": false
    },
    size: {
      type: String,
      "default": null
    },
    plain: {
      type: Boolean,
      "default": false
    },
    fluid: {
      type: Boolean,
      "default": false
    }
  },
  style: ButtonStyle,
  provide: /* @__PURE__ */ __name(function provide11() {
    return {
      $pcButton: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$J = {
  name: "Button",
  "extends": script$1$s,
  inheritAttrs: false,
  methods: {
    getPTOptions: /* @__PURE__ */ __name(function getPTOptions3(key) {
      var _ptm = key === "root" ? this.ptmi : this.ptm;
      return _ptm(key, {
        context: {
          disabled: this.disabled
        }
      });
    }, "getPTOptions")
  },
  computed: {
    disabled: /* @__PURE__ */ __name(function disabled() {
      return this.$attrs.disabled || this.$attrs.disabled === "" || this.loading;
    }, "disabled"),
    defaultAriaLabel: /* @__PURE__ */ __name(function defaultAriaLabel() {
      return this.label ? this.label + (this.badge ? " " + this.badge : "") : this.$attrs.ariaLabel;
    }, "defaultAriaLabel"),
    hasIcon: /* @__PURE__ */ __name(function hasIcon() {
      return this.icon || this.$slots.icon;
    }, "hasIcon"),
    attrs: /* @__PURE__ */ __name(function attrs() {
      return mergeProps(this.asAttrs, this.a11yAttrs, this.getPTOptions("root"));
    }, "attrs"),
    asAttrs: /* @__PURE__ */ __name(function asAttrs() {
      return this.as === "BUTTON" ? {
        type: "button",
        disabled: this.disabled
      } : void 0;
    }, "asAttrs"),
    a11yAttrs: /* @__PURE__ */ __name(function a11yAttrs() {
      return {
        "aria-label": this.defaultAriaLabel,
        "data-pc-name": "button",
        "data-p-disabled": this.disabled,
        "data-p-severity": this.severity
      };
    }, "a11yAttrs")
  },
  components: {
    SpinnerIcon: script$N,
    Badge: script$K
  },
  directives: {
    ripple: Ripple
  }
};
function render$I(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_SpinnerIcon = resolveComponent("SpinnerIcon");
  var _component_Badge = resolveComponent("Badge");
  var _directive_ripple = resolveDirective("ripple");
  return !_ctx.asChild ? withDirectives((openBlock(), createBlock(resolveDynamicComponent(_ctx.as), mergeProps({
    key: 0,
    "class": _ctx.cx("root")
  }, $options.attrs), {
    "default": withCtx(function() {
      return [renderSlot(_ctx.$slots, "default", {}, function() {
        return [_ctx.loading ? renderSlot(_ctx.$slots, "loadingicon", {
          key: 0,
          "class": normalizeClass([_ctx.cx("loadingIcon"), _ctx.cx("icon")])
        }, function() {
          return [_ctx.loadingIcon ? (openBlock(), createElementBlock("span", mergeProps({
            key: 0,
            "class": [_ctx.cx("loadingIcon"), _ctx.cx("icon"), _ctx.loadingIcon]
          }, _ctx.ptm("loadingIcon")), null, 16)) : (openBlock(), createBlock(_component_SpinnerIcon, mergeProps({
            key: 1,
            "class": [_ctx.cx("loadingIcon"), _ctx.cx("icon")],
            spin: ""
          }, _ctx.ptm("loadingIcon")), null, 16, ["class"]))];
        }) : renderSlot(_ctx.$slots, "icon", {
          key: 1,
          "class": normalizeClass([_ctx.cx("icon")])
        }, function() {
          return [_ctx.icon ? (openBlock(), createElementBlock("span", mergeProps({
            key: 0,
            "class": [_ctx.cx("icon"), _ctx.icon, _ctx.iconClass]
          }, _ctx.ptm("icon")), null, 16)) : createCommentVNode("", true)];
        }), createBaseVNode("span", mergeProps({
          "class": _ctx.cx("label")
        }, _ctx.ptm("label")), toDisplayString$1(_ctx.label || ""), 17), _ctx.badge ? (openBlock(), createBlock(_component_Badge, mergeProps({
          key: 2,
          value: _ctx.badge,
          "class": _ctx.badgeClass,
          severity: _ctx.badgeSeverity,
          unstyled: _ctx.unstyled
        }, _ctx.ptm("pcBadge")), null, 16, ["value", "class", "severity", "unstyled"])) : createCommentVNode("", true)];
      })];
    }),
    _: 3
  }, 16, ["class"])), [[_directive_ripple]]) : renderSlot(_ctx.$slots, "default", {
    key: 1,
    "class": normalizeClass(_ctx.cx("root")),
    a11yAttrs: $options.a11yAttrs
  });
}
__name(render$I, "render$I");
script$J.render = render$I;
const _withScopeId$m = /* @__PURE__ */ __name((n) => (pushScopeId("data-v-0a88b934"), n = n(), popScopeId(), n), "_withScopeId$m");
const _hoisted_1$W = { class: "comfy-missing-nodes" };
const _hoisted_2$I = /* @__PURE__ */ _withScopeId$m(() => /* @__PURE__ */ createBaseVNode("h4", { class: "warning-title" }, "Warning: Missing Node Types", -1));
const _hoisted_3$l = /* @__PURE__ */ _withScopeId$m(() => /* @__PURE__ */ createBaseVNode("p", { class: "warning-description" }, " When loading the graph, the following node types were not found: ", -1));
const _hoisted_4$e = { class: "missing-node-item" };
const _hoisted_5$9 = { class: "node-type" };
const _hoisted_6$8 = {
  key: 0,
  class: "node-hint"
};
const _hoisted_7$6 = {
  key: 0,
  class: "added-nodes-warning"
};
const _sfc_main$H = /* @__PURE__ */ defineComponent({
  __name: "LoadWorkflowWarning",
  props: {
    missingNodeTypes: {},
    hasAddedNodes: { type: Boolean },
    maximized: { type: Boolean }
  },
  setup(__props) {
    const props = __props;
    const uniqueNodes = computed(() => {
      const seenTypes = /* @__PURE__ */ new Set();
      return props.missingNodeTypes.filter((node3) => {
        const type = typeof node3 === "object" ? node3.type : node3;
        if (seenTypes.has(type)) return false;
        seenTypes.add(type);
        return true;
      }).map((node3) => {
        if (typeof node3 === "object") {
          return {
            label: node3.type,
            hint: node3.hint,
            action: node3.action
          };
        }
        return { label: node3 };
      });
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$W, [
        _hoisted_2$I,
        _hoisted_3$l,
        createVNode(unref(script$L), {
          options: uniqueNodes.value,
          optionLabel: "label",
          scrollHeight: "100%",
          class: normalizeClass("missing-nodes-list" + (props.maximized ? " maximized" : "")),
          pt: {
            list: { class: "border-none" }
          }
        }, {
          option: withCtx((slotProps) => [
            createBaseVNode("div", _hoisted_4$e, [
              createBaseVNode("span", _hoisted_5$9, toDisplayString$1(slotProps.option.label), 1),
              slotProps.option.hint ? (openBlock(), createElementBlock("span", _hoisted_6$8, toDisplayString$1(slotProps.option.hint), 1)) : createCommentVNode("", true),
              slotProps.option.action ? (openBlock(), createBlock(unref(script$J), {
                key: 1,
                onClick: slotProps.option.action.callback,
                label: slotProps.option.action.text,
                class: "p-button-sm p-button-outlined"
              }, null, 8, ["onClick", "label"])) : createCommentVNode("", true)
            ])
          ]),
          _: 1
        }, 8, ["options", "class"]),
        _ctx.hasAddedNodes ? (openBlock(), createElementBlock("p", _hoisted_7$6, " Nodes that have failed to load will show as red on the graph. ")) : createCommentVNode("", true)
      ]);
    };
  }
});
const _export_sfc = /* @__PURE__ */ __name((sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
}, "_export_sfc");
const LoadWorkflowWarning = /* @__PURE__ */ _export_sfc(_sfc_main$H, [["__scopeId", "data-v-0a88b934"]]);
const _withScopeId$l = /* @__PURE__ */ __name((n) => (pushScopeId("data-v-a71fe7ef"), n = n(), popScopeId(), n), "_withScopeId$l");
const _hoisted_1$V = { class: "comfy-missing-models" };
const _hoisted_2$H = /* @__PURE__ */ _withScopeId$l(() => /* @__PURE__ */ createBaseVNode("h4", { class: "warning-title" }, "Warning: Missing Models", -1));
const _hoisted_3$k = /* @__PURE__ */ _withScopeId$l(() => /* @__PURE__ */ createBaseVNode("p", { class: "warning-description" }, " When loading the graph, the following models were not found: ", -1));
const _hoisted_4$d = { class: "model-info" };
const _hoisted_5$8 = { class: "model-details" };
const _hoisted_6$7 = ["title"];
const _hoisted_7$5 = {
  key: 0,
  class: "model-error"
};
const _hoisted_8$4 = { class: "model-action" };
const _hoisted_9$3 = {
  key: 1,
  class: "download-progress"
};
const _hoisted_10$3 = { class: "progress-text" };
const _hoisted_11$3 = {
  key: 2,
  class: "download-complete"
};
const _hoisted_12$2 = /* @__PURE__ */ _withScopeId$l(() => /* @__PURE__ */ createBaseVNode("i", {
  class: "pi pi-check",
  style: { "color": "var(--green-500)" }
}, null, -1));
const _hoisted_13$1 = [
  _hoisted_12$2
];
const _hoisted_14$1 = {
  key: 3,
  class: "download-error"
};
const _hoisted_15$1 = /* @__PURE__ */ _withScopeId$l(() => /* @__PURE__ */ createBaseVNode("i", {
  class: "pi pi-times",
  style: { "color": "var(--red-600)" }
}, null, -1));
const _hoisted_16$1 = [
  _hoisted_15$1
];
const _sfc_main$G = /* @__PURE__ */ defineComponent({
  __name: "MissingModelsWarning",
  props: {
    missingModels: {},
    maximized: { type: Boolean }
  },
  setup(__props) {
    const settingStore = useSettingStore();
    const allowedSources = settingStore.get(
      "Comfy.Workflow.ModelDownload.AllowedSources"
    );
    const allowedSuffixes = settingStore.get(
      "Comfy.Workflow.ModelDownload.AllowedSuffixes"
    );
    const props = __props;
    const modelDownloads = ref({});
    let lastModel = null;
    const handleDownloadProgress = /* @__PURE__ */ __name((detail) => {
      if (detail.download_path) {
        lastModel = detail.download_path.split("/", 2)[1];
      }
      if (!lastModel) return;
      if (detail.status === "in_progress") {
        modelDownloads.value[lastModel] = {
          ...modelDownloads.value[lastModel],
          downloading: true,
          progress: detail.progress_percentage,
          completed: false
        };
      } else if (detail.status === "pending") {
        modelDownloads.value[lastModel] = {
          ...modelDownloads.value[lastModel],
          downloading: true,
          progress: 0,
          completed: false
        };
      } else if (detail.status === "completed") {
        modelDownloads.value[lastModel] = {
          ...modelDownloads.value[lastModel],
          downloading: false,
          progress: 100,
          completed: true
        };
      } else if (detail.status === "error") {
        modelDownloads.value[lastModel] = {
          ...modelDownloads.value[lastModel],
          downloading: false,
          progress: 0,
          error: detail.message,
          completed: false
        };
      }
    }, "handleDownloadProgress");
    const triggerDownload = /* @__PURE__ */ __name(async (url, directory, filename) => {
      modelDownloads.value[filename] = {
        name: filename,
        directory,
        url,
        downloading: true,
        progress: 0
      };
      const download2 = await api.internalDownloadModel(url, directory, filename, 1);
      handleDownloadProgress(download2);
    }, "triggerDownload");
    api.addEventListener("download_progress", (event2) => {
      handleDownloadProgress(event2.detail);
    });
    const missingModels = computed(() => {
      return props.missingModels.map((model) => {
        const downloadInfo = modelDownloads.value[model.name];
        if (!allowedSources.some((source) => model.url.startsWith(source))) {
          return {
            label: `${model.directory} / ${model.name}`,
            hint: model.url,
            error: "Download not allowed from this source: " + allowedSources.join(", ")
          };
        }
        if (!allowedSuffixes.some((suffix2) => model.name.endsWith(suffix2))) {
          return {
            label: `${model.directory} / ${model.name}`,
            hint: model.url,
            error: "Only allowed suffixes are " + allowedSuffixes.join(", ")
          };
        }
        if (model.directory_invalid) {
          return {
            label: `${model.directory} / ${model.name}`,
            hint: model.url,
            error: "Invalid directory specified (does this require custom nodes?)"
          };
        }
        return {
          label: `${model.directory} / ${model.name}`,
          hint: model.url,
          downloading: downloadInfo?.downloading ?? false,
          completed: downloadInfo?.completed ?? false,
          progress: downloadInfo?.progress ?? 0,
          error: downloadInfo?.error,
          action: {
            text: "Download",
            callback: /* @__PURE__ */ __name(() => triggerDownload(model.url, model.directory, model.name), "callback")
          }
        };
      });
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$V, [
        _hoisted_2$H,
        _hoisted_3$k,
        createVNode(unref(script$L), {
          options: missingModels.value,
          optionLabel: "label",
          scrollHeight: "100%",
          class: normalizeClass("missing-models-list" + (props.maximized ? " maximized" : "")),
          pt: {
            list: { class: "border-none" }
          }
        }, {
          option: withCtx((slotProps) => [
            createBaseVNode("div", {
              class: "missing-model-item",
              style: normalizeStyle({ "--progress": `${slotProps.option.progress}%` })
            }, [
              createBaseVNode("div", _hoisted_4$d, [
                createBaseVNode("div", _hoisted_5$8, [
                  createBaseVNode("span", {
                    class: "model-type",
                    title: slotProps.option.hint
                  }, toDisplayString$1(slotProps.option.label), 9, _hoisted_6$7)
                ]),
                slotProps.option.error ? (openBlock(), createElementBlock("div", _hoisted_7$5, toDisplayString$1(slotProps.option.error), 1)) : createCommentVNode("", true)
              ]),
              createBaseVNode("div", _hoisted_8$4, [
                slotProps.option.action && !slotProps.option.downloading && !slotProps.option.completed && !slotProps.option.error ? (openBlock(), createBlock(unref(script$J), {
                  key: 0,
                  onClick: slotProps.option.action.callback,
                  label: slotProps.option.action.text,
                  class: "p-button-sm p-button-outlined model-action-button"
                }, null, 8, ["onClick", "label"])) : createCommentVNode("", true),
                slotProps.option.downloading ? (openBlock(), createElementBlock("div", _hoisted_9$3, [
                  createBaseVNode("span", _hoisted_10$3, toDisplayString$1(slotProps.option.progress.toFixed(2)) + "%", 1)
                ])) : createCommentVNode("", true),
                slotProps.option.completed ? (openBlock(), createElementBlock("div", _hoisted_11$3, _hoisted_13$1)) : createCommentVNode("", true),
                slotProps.option.error ? (openBlock(), createElementBlock("div", _hoisted_14$1, _hoisted_16$1)) : createCommentVNode("", true)
              ])
            ], 4)
          ]),
          _: 1
        }, 8, ["options", "class"])
      ]);
    };
  }
});
const MissingModelsWarning = /* @__PURE__ */ _export_sfc(_sfc_main$G, [["__scopeId", "data-v-a71fe7ef"]]);
var theme$o = /* @__PURE__ */ __name(function theme13(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-tabs {\n    display: flex;\n    flex-direction: column;\n}\n\n.p-tablist {\n    position: relative;\n}\n\n.p-tabs-scrollable > .p-tablist {\n    overflow: hidden;\n}\n\n.p-tablist-viewport {\n    overflow-x: auto;\n    overflow-y: hidden;\n    scroll-behavior: smooth;\n    scrollbar-width: none;\n    overscroll-behavior: contain auto;\n}\n\n.p-tablist-viewport::-webkit-scrollbar {\n    display: none;\n}\n\n.p-tablist-tab-list {\n    position: relative;\n    display: flex;\n    background: ".concat(dt3("tabs.tablist.background"), ";\n    border-style: solid;\n    border-color: ").concat(dt3("tabs.tablist.border.color"), ";\n    border-width: ").concat(dt3("tabs.tablist.border.width"), ";\n}\n\n.p-tablist-nav-button {\n    all: unset;\n    position: absolute;\n    top: 0;\n    z-index: 2;\n    height: 100%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    background: ").concat(dt3("tabs.nav.button.background"), ";\n    color: ").concat(dt3("tabs.nav.button.color"), ";\n    width: ").concat(dt3("tabs.nav.button.width"), ";\n    transition: color ").concat(dt3("tabs.transition.duration"), ", outline-color ").concat(dt3("tabs.transition.duration"), ", box-shadow ").concat(dt3("tabs.transition.duration"), ";\n    box-shadow: ").concat(dt3("tabs.nav.button.shadow"), ";\n    outline-color: transparent;\n    cursor: pointer;\n}\n\n.p-tablist-nav-button:focus-visible {\n    z-index: 1;\n    box-shadow: ").concat(dt3("tabs.nav.button.focus.ring.shadow"), ";\n    outline: ").concat(dt3("tabs.nav.button.focus.ring.width"), " ").concat(dt3("tabs.nav.button.focus.ring.style"), " ").concat(dt3("tabs.nav.button.focus.ring.color"), ";\n    outline-offset: ").concat(dt3("tabs.nav.button.focus.ring.offset"), ";\n}\n\n.p-tablist-nav-button:hover {\n    color: ").concat(dt3("tabs.nav.button.hover.color"), ";\n}\n\n.p-tablist-prev-button {\n    left: 0;\n}\n\n.p-tablist-next-button {\n    right: 0;\n}\n\n.p-tab {\n    cursor: pointer;\n    user-select: none;\n    position: relative;\n    border-style: solid;\n    white-space: nowrap;\n    background: ").concat(dt3("tabs.tab.background"), ";\n    border-width: ").concat(dt3("tabs.tab.border.width"), ";\n    border-color: ").concat(dt3("tabs.tab.border.color"), ";\n    color: ").concat(dt3("tabs.tab.color"), ";\n    padding: ").concat(dt3("tabs.tab.padding"), ";\n    font-weight: ").concat(dt3("tabs.tab.font.weight"), ";\n    transition: background ").concat(dt3("tabs.transition.duration"), ", border-color ").concat(dt3("tabs.transition.duration"), ", color ").concat(dt3("tabs.transition.duration"), ", outline-color ").concat(dt3("tabs.transition.duration"), ", box-shadow ").concat(dt3("tabs.transition.duration"), ";\n    margin: ").concat(dt3("tabs.tab.margin"), ";\n    outline-color: transparent;\n}\n\n.p-tab:not(.p-disabled):focus-visible {\n    z-index: 1;\n    box-shadow: ").concat(dt3("tabs.tab.focus.ring.shadow"), ";\n    outline: ").concat(dt3("tabs.tab.focus.ring.width"), " ").concat(dt3("tabs.tab.focus.ring.style"), " ").concat(dt3("tabs.tab.focus.ring.color"), ";\n    outline-offset: ").concat(dt3("tabs.tab.focus.ring.offset"), ";\n}\n\n.p-tab:not(.p-tab-active):not(.p-disabled):hover {\n    background: ").concat(dt3("tabs.tab.hover.background"), ";\n    border-color: ").concat(dt3("tabs.tab.hover.border.color"), ";\n    color: ").concat(dt3("tabs.tab.hover.color"), ";\n}\n\n.p-tab-active {\n    background: ").concat(dt3("tabs.tab.active.background"), ";\n    border-color: ").concat(dt3("tabs.tab.active.border.color"), ";\n    color: ").concat(dt3("tabs.tab.active.color"), ";\n}\n\n.p-tabpanels {\n    background: ").concat(dt3("tabs.tabpanel.background"), ";\n    color: ").concat(dt3("tabs.tabpanel.color"), ";\n    padding: ").concat(dt3("tabs.tabpanel.padding"), ";\n    outline: 0 none;\n}\n\n.p-tabpanel:focus-visible {\n    box-shadow: ").concat(dt3("tabs.tabpanel.focus.ring.shadow"), ";\n    outline: ").concat(dt3("tabs.tabpanel.focus.ring.width"), " ").concat(dt3("tabs.tabpanel.focus.ring.style"), " ").concat(dt3("tabs.tabpanel.focus.ring.color"), ";\n    outline-offset: ").concat(dt3("tabs.tabpanel.focus.ring.offset"), ";\n}\n\n.p-tablist-active-bar {\n    z-index: 1;\n    display: block;\n    position: absolute;\n    bottom: ").concat(dt3("tabs.active.bar.bottom"), ";\n    height: ").concat(dt3("tabs.active.bar.height"), ";\n    background: ").concat(dt3("tabs.active.bar.background"), ";\n    transition: 250ms cubic-bezier(0.35, 0, 0.25, 1);\n}\n");
}, "theme");
var classes$r = {
  root: /* @__PURE__ */ __name(function root5(_ref2) {
    var props = _ref2.props;
    return ["p-tabs p-component", {
      "p-tabs-scrollable": props.scrollable
    }];
  }, "root")
};
var TabsStyle = BaseStyle.extend({
  name: "tabs",
  theme: theme$o,
  classes: classes$r
});
var script$1$r = {
  name: "BaseTabs",
  "extends": script$X,
  props: {
    value: {
      type: String,
      "default": void 0
    },
    lazy: {
      type: Boolean,
      "default": false
    },
    scrollable: {
      type: Boolean,
      "default": false
    },
    showNavigators: {
      type: Boolean,
      "default": true
    },
    tabindex: {
      type: Number,
      "default": 0
    },
    selectOnFocus: {
      type: Boolean,
      "default": false
    }
  },
  style: TabsStyle,
  provide: /* @__PURE__ */ __name(function provide12() {
    return {
      $pcTabs: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$I = {
  name: "Tabs",
  "extends": script$1$r,
  inheritAttrs: false,
  emits: ["update:value"],
  data: /* @__PURE__ */ __name(function data4() {
    return {
      id: this.$attrs.id,
      d_value: this.value
    };
  }, "data"),
  watch: {
    "$attrs.id": /* @__PURE__ */ __name(function $attrsId2(newValue) {
      this.id = newValue || UniqueComponentId();
    }, "$attrsId"),
    value: /* @__PURE__ */ __name(function value(newValue) {
      this.d_value = newValue;
    }, "value")
  },
  mounted: /* @__PURE__ */ __name(function mounted5() {
    this.id = this.id || UniqueComponentId();
  }, "mounted"),
  methods: {
    updateValue: /* @__PURE__ */ __name(function updateValue(newValue) {
      if (this.d_value !== newValue) {
        this.d_value = newValue;
        this.$emit("update:value", newValue);
      }
    }, "updateValue"),
    isVertical: /* @__PURE__ */ __name(function isVertical2() {
      return this.orientation === "vertical";
    }, "isVertical")
  }
};
function render$H(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("root")
  }, _ctx.ptmi("root")), [renderSlot(_ctx.$slots, "default")], 16);
}
__name(render$H, "render$H");
script$I.render = render$H;
var classes$q = {
  root: "p-tabpanels"
};
var TabPanelsStyle = BaseStyle.extend({
  name: "tabpanels",
  classes: classes$q
});
var script$1$q = {
  name: "BaseTabPanels",
  "extends": script$X,
  props: {},
  style: TabPanelsStyle,
  provide: /* @__PURE__ */ __name(function provide13() {
    return {
      $pcTabPanels: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$H = {
  name: "TabPanels",
  "extends": script$1$q,
  inheritAttrs: false
};
function render$G(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("root"),
    role: "presentation"
  }, _ctx.ptmi("root")), [renderSlot(_ctx.$slots, "default")], 16);
}
__name(render$G, "render$G");
script$H.render = render$G;
var classes$p = {
  root: /* @__PURE__ */ __name(function root6(_ref) {
    var instance = _ref.instance;
    return ["p-tabpanel", {
      "p-tabpanel-active": instance.active
    }];
  }, "root")
};
var TabPanelStyle = BaseStyle.extend({
  name: "tabpanel",
  classes: classes$p
});
var script$1$p = {
  name: "BaseTabPanel",
  "extends": script$X,
  props: {
    // in Tabs
    value: {
      type: String,
      "default": void 0
    },
    as: {
      type: String,
      "default": "DIV"
    },
    asChild: {
      type: Boolean,
      "default": false
    },
    // in TabView
    header: null,
    headerStyle: null,
    headerClass: null,
    headerProps: null,
    headerActionProps: null,
    contentStyle: null,
    contentClass: null,
    contentProps: null,
    disabled: Boolean
  },
  style: TabPanelStyle,
  provide: /* @__PURE__ */ __name(function provide14() {
    return {
      $pcTabPanel: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$G = {
  name: "TabPanel",
  "extends": script$1$p,
  inheritAttrs: false,
  inject: ["$pcTabs"],
  computed: {
    active: /* @__PURE__ */ __name(function active() {
      var _this$$pcTabs;
      return equals((_this$$pcTabs = this.$pcTabs) === null || _this$$pcTabs === void 0 ? void 0 : _this$$pcTabs.d_value, this.value);
    }, "active"),
    id: /* @__PURE__ */ __name(function id() {
      var _this$$pcTabs2;
      return "".concat((_this$$pcTabs2 = this.$pcTabs) === null || _this$$pcTabs2 === void 0 ? void 0 : _this$$pcTabs2.id, "_tabpanel_").concat(this.value);
    }, "id"),
    ariaLabelledby: /* @__PURE__ */ __name(function ariaLabelledby() {
      var _this$$pcTabs3;
      return "".concat((_this$$pcTabs3 = this.$pcTabs) === null || _this$$pcTabs3 === void 0 ? void 0 : _this$$pcTabs3.id, "_tab_").concat(this.value);
    }, "ariaLabelledby"),
    attrs: /* @__PURE__ */ __name(function attrs2() {
      return mergeProps(this.a11yAttrs, this.ptmi("root", this.ptParams));
    }, "attrs"),
    a11yAttrs: /* @__PURE__ */ __name(function a11yAttrs2() {
      var _this$$pcTabs4;
      return {
        id: this.id,
        tabindex: (_this$$pcTabs4 = this.$pcTabs) === null || _this$$pcTabs4 === void 0 ? void 0 : _this$$pcTabs4.tabindex,
        role: "tabpanel",
        "aria-labelledby": this.ariaLabelledby,
        "data-pc-name": "tabpanel",
        "data-p-active": this.active
      };
    }, "a11yAttrs"),
    ptParams: /* @__PURE__ */ __name(function ptParams() {
      return {
        context: {
          active: this.active
        }
      };
    }, "ptParams")
  }
};
function render$F(_ctx, _cache, $props, $setup, $data, $options) {
  var _$options$$pcTabs, _$options$$pcTabs2;
  return !$options.$pcTabs ? renderSlot(_ctx.$slots, "default", {
    key: 0
  }) : (openBlock(), createElementBlock(Fragment, {
    key: 1
  }, [!_ctx.asChild ? (openBlock(), createElementBlock(Fragment, {
    key: 0
  }, [((_$options$$pcTabs = $options.$pcTabs) !== null && _$options$$pcTabs !== void 0 && _$options$$pcTabs.lazy ? $options.active : true) ? withDirectives((openBlock(), createBlock(resolveDynamicComponent(_ctx.as), mergeProps({
    key: 0,
    "class": _ctx.cx("root")
  }, $options.attrs), {
    "default": withCtx(function() {
      return [renderSlot(_ctx.$slots, "default")];
    }),
    _: 3
  }, 16, ["class"])), [[vShow, (_$options$$pcTabs2 = $options.$pcTabs) !== null && _$options$$pcTabs2 !== void 0 && _$options$$pcTabs2.lazy ? true : $options.active]]) : createCommentVNode("", true)], 64)) : renderSlot(_ctx.$slots, "default", {
    key: 1,
    "class": normalizeClass(_ctx.cx("root")),
    active: $options.active,
    a11yAttrs: $options.a11yAttrs
  })], 64));
}
__name(render$F, "render$F");
script$G.render = render$F;
var theme$n = /* @__PURE__ */ __name(function theme14(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-divider-horizontal {\n    display: flex;\n    width: 100%;\n    position: relative;\n    align-items: center;\n    margin: ".concat(dt3("divider.horizontal.margin"), ";\n    padding: ").concat(dt3("divider.horizontal.padding"), ';\n}\n\n.p-divider-horizontal:before {\n    position: absolute;\n    display: block;\n    top: 50%;\n    left: 0;\n    width: 100%;\n    content: "";\n    border-top: 1px solid ').concat(dt3("divider.border.color"), ";\n}\n\n.p-divider-horizontal .p-divider-content {\n    padding: ").concat(dt3("divider.horizontal.content.padding"), ";\n}\n\n.p-divider-vertical {\n    min-height: 100%;\n    margin: 0 1rem;\n    display: flex;\n    position: relative;\n    justify-content: center;\n    margin: ").concat(dt3("divider.vertical.margin"), ";\n    padding: ").concat(dt3("divider.vertical.padding"), ';\n}\n\n.p-divider-vertical:before {\n    position: absolute;\n    display: block;\n    top: 0;\n    left: 50%;\n    height: 100%;\n    content: "";\n    border-left: 1px solid ').concat(dt3("divider.border.color"), ";\n}\n\n.p-divider.p-divider-vertical .p-divider-content {\n    padding: ").concat(dt3("divider.vertical.content.padding"), ";\n}\n\n.p-divider-content {\n    z-index: 1;\n    background: ").concat(dt3("divider.content.background"), ";\n    color: ").concat(dt3("divider.content.color"), ";\n}\n\n.p-divider-solid.p-divider-horizontal:before {\n    border-top-style: solid;\n}\n\n.p-divider-solid.p-divider-vertical:before {\n    border-left-style: solid;\n}\n\n.p-divider-dashed.p-divider-horizontal:before {\n    border-top-style: dashed;\n}\n\n.p-divider-dashed.p-divider-vertical:before {\n    border-left-style: dashed;\n}\n\n.p-divider-dotted.p-divider-horizontal:before {\n    border-top-style: dotted;\n}\n\n.p-divider-dotted.p-divider-vertical:before {\n    border-left-style: dotted;\n}\n");
}, "theme");
var inlineStyles$6 = {
  root: /* @__PURE__ */ __name(function root7(_ref2) {
    var props = _ref2.props;
    return {
      justifyContent: props.layout === "horizontal" ? props.align === "center" || props.align === null ? "center" : props.align === "left" ? "flex-start" : props.align === "right" ? "flex-end" : null : null,
      alignItems: props.layout === "vertical" ? props.align === "center" || props.align === null ? "center" : props.align === "top" ? "flex-start" : props.align === "bottom" ? "flex-end" : null : null
    };
  }, "root")
};
var classes$o = {
  root: /* @__PURE__ */ __name(function root8(_ref3) {
    var props = _ref3.props;
    return ["p-divider p-component", "p-divider-" + props.layout, "p-divider-" + props.type, {
      "p-divider-left": props.layout === "horizontal" && (!props.align || props.align === "left")
    }, {
      "p-divider-center": props.layout === "horizontal" && props.align === "center"
    }, {
      "p-divider-right": props.layout === "horizontal" && props.align === "right"
    }, {
      "p-divider-top": props.layout === "vertical" && props.align === "top"
    }, {
      "p-divider-center": props.layout === "vertical" && (!props.align || props.align === "center")
    }, {
      "p-divider-bottom": props.layout === "vertical" && props.align === "bottom"
    }];
  }, "root"),
  content: "p-divider-content"
};
var DividerStyle = BaseStyle.extend({
  name: "divider",
  theme: theme$n,
  classes: classes$o,
  inlineStyles: inlineStyles$6
});
var script$1$o = {
  name: "BaseDivider",
  "extends": script$X,
  props: {
    align: {
      type: String,
      "default": null
    },
    layout: {
      type: String,
      "default": "horizontal"
    },
    type: {
      type: String,
      "default": "solid"
    }
  },
  style: DividerStyle,
  provide: /* @__PURE__ */ __name(function provide15() {
    return {
      $pcDivider: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$F = {
  name: "Divider",
  "extends": script$1$o,
  inheritAttrs: false
};
var _hoisted_1$U = ["aria-orientation"];
function render$E(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("root"),
    style: _ctx.sx("root"),
    role: "separator",
    "aria-orientation": _ctx.layout
  }, _ctx.ptmi("root")), [_ctx.$slots["default"] ? (openBlock(), createElementBlock("div", mergeProps({
    key: 0,
    "class": _ctx.cx("content")
  }, _ctx.ptm("content")), [renderSlot(_ctx.$slots, "default")], 16)) : createCommentVNode("", true)], 16, _hoisted_1$U);
}
__name(render$E, "render$E");
script$F.render = render$E;
var script$E = {
  name: "AngleDownIcon",
  "extends": script$U
};
var _hoisted_1$T = /* @__PURE__ */ createBaseVNode("path", {
  d: "M3.58659 4.5007C3.68513 4.50023 3.78277 4.51945 3.87379 4.55723C3.9648 4.59501 4.04735 4.65058 4.11659 4.7207L7.11659 7.7207L10.1166 4.7207C10.2619 4.65055 10.4259 4.62911 10.5843 4.65956C10.7427 4.69002 10.8871 4.77074 10.996 4.88976C11.1049 5.00877 11.1726 5.15973 11.1889 5.32022C11.2052 5.48072 11.1693 5.6422 11.0866 5.7807L7.58659 9.2807C7.44597 9.42115 7.25534 9.50004 7.05659 9.50004C6.85784 9.50004 6.66722 9.42115 6.52659 9.2807L3.02659 5.7807C2.88614 5.64007 2.80725 5.44945 2.80725 5.2507C2.80725 5.05195 2.88614 4.86132 3.02659 4.7207C3.09932 4.64685 3.18675 4.58911 3.28322 4.55121C3.37969 4.51331 3.48305 4.4961 3.58659 4.5007Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$G = [_hoisted_1$T];
function render$D(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$G, 16);
}
__name(render$D, "render$D");
script$E.render = render$D;
var script$D = {
  name: "AngleUpIcon",
  "extends": script$U
};
var _hoisted_1$S = /* @__PURE__ */ createBaseVNode("path", {
  d: "M10.4134 9.49931C10.3148 9.49977 10.2172 9.48055 10.1262 9.44278C10.0352 9.405 9.95263 9.34942 9.88338 9.27931L6.88338 6.27931L3.88338 9.27931C3.73811 9.34946 3.57409 9.3709 3.41567 9.34044C3.25724 9.30999 3.11286 9.22926 3.00395 9.11025C2.89504 8.99124 2.82741 8.84028 2.8111 8.67978C2.79478 8.51928 2.83065 8.35781 2.91338 8.21931L6.41338 4.71931C6.55401 4.57886 6.74463 4.49997 6.94338 4.49997C7.14213 4.49997 7.33276 4.57886 7.47338 4.71931L10.9734 8.21931C11.1138 8.35994 11.1927 8.55056 11.1927 8.74931C11.1927 8.94806 11.1138 9.13868 10.9734 9.27931C10.9007 9.35315 10.8132 9.41089 10.7168 9.44879C10.6203 9.48669 10.5169 9.5039 10.4134 9.49931Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$F = [_hoisted_1$S];
function render$C(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$F, 16);
}
__name(render$C, "render$C");
script$D.render = render$C;
var theme$m = /* @__PURE__ */ __name(function theme15(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-inputnumber {\n    display: inline-flex;\n    position: relative;\n}\n\n.p-inputnumber-button {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    flex: 0 0 auto;\n    cursor: pointer;\n    background: ".concat(dt3("inputnumber.button.background"), ";\n    color: ").concat(dt3("inputnumber.button.color"), ";\n    width: ").concat(dt3("inputnumber.button.width"), ";\n    transition: background ").concat(dt3("inputnumber.transition.duration"), ", color ").concat(dt3("inputnumber.transition.duration"), ", border-color ").concat(dt3("inputnumber.transition.duration"), ", outline-color ").concat(dt3("inputnumber.transition.duration"), ";\n}\n\n.p-inputnumber-button:hover {\n    background: ").concat(dt3("inputnumber.button.hover.background"), ";\n    color: ").concat(dt3("inputnumber.button.hover.color"), ";\n}\n\n.p-inputnumber-button:active {\n    background: ").concat(dt3("inputnumber.button.active.background"), ";\n    color: ").concat(dt3("inputnumber.button.active.color"), ";\n}\n\n.p-inputnumber-stacked .p-inputnumber-button {\n    position: relative;\n    border: 0 none;\n}\n\n.p-inputnumber-stacked .p-inputnumber-button-group {\n    display: flex;\n    flex-direction: column;\n    position: absolute;\n    top: 1px;\n    right: 1px;\n    height: calc(100% - 2px);\n}\n\n.p-inputnumber-stacked .p-inputnumber-increment-button {\n    padding: 0;\n    border-top-right-radius: calc(").concat(dt3("inputnumber.button.border.radius"), " - 1px);\n}\n\n.p-inputnumber-stacked .p-inputnumber-decrement-button {\n    padding: 0;\n    border-bottom-right-radius: calc(").concat(dt3("inputnumber.button.border.radius"), " - 1px);\n}\n\n.p-inputnumber-stacked .p-inputnumber-button {\n    flex: 1 1 auto;\n    border: 0 none;\n}\n\n.p-inputnumber-horizontal .p-inputnumber-button {\n    border: 1px solid ").concat(dt3("inputnumber.button.border.color"), ";\n}\n\n.p-inputnumber-horizontal .p-inputnumber-button:hover {\n    border-color: ").concat(dt3("inputnumber.button.hover.border.color"), ";\n}\n\n.p-inputnumber-horizontal .p-inputnumber-button:active {\n    border-color: ").concat(dt3("inputnumber.button.active.border.color"), ";\n}\n\n.p-inputnumber-horizontal .p-inputnumber-increment-button {\n    order: 3;\n    border-top-right-radius: ").concat(dt3("inputnumber.button.border.radius"), ";\n    border-bottom-right-radius: ").concat(dt3("inputnumber.button.border.radius"), ";\n    border-left: 0 none;\n}\n\n.p-inputnumber-horizontal .p-inputnumber-input {\n    order: 2;\n    border-radius: 0;\n}\n\n.p-inputnumber-horizontal .p-inputnumber-decrement-button {\n    order: 1;\n    border-top-left-radius: ").concat(dt3("inputnumber.button.border.radius"), ";\n    border-bottom-left-radius: ").concat(dt3("inputnumber.button.border.radius"), ";\n    border-right: 0 none;\n}\n\n.p-inputnumber-vertical {\n    flex-direction: column;\n}\n\n.p-inputnumber-vertical .p-inputnumber-button {\n    border: 1px solid ").concat(dt3("inputnumber.button.border.color"), ";\n    padding: ").concat(dt3("inputnumber.button.vertical.padding"), "; 0;\n}\n\n.p-inputnumber-vertical .p-inputnumber-button:hover {\n    border-color: ").concat(dt3("inputnumber.button.hover.border.color"), ";\n}\n\n.p-inputnumber-vertical .p-inputnumber-button:active {\n    border-color: ").concat(dt3("inputnumber.button.active.border.color"), ";\n}\n\n.p-inputnumber-vertical .p-inputnumber-increment-button {\n    order: 1;\n    border-top-left-radius: ").concat(dt3("inputnumber.button.border.radius"), ";\n    border-top-right-radius: ").concat(dt3("inputnumber.button.border.radius"), ";\n    width: 100%;\n    border-bottom: 0 none;\n}\n\n.p-inputnumber-vertical .p-inputnumber-input {\n    order: 2;\n    border-radius: 0;\n    text-align: center;\n}\n\n.p-inputnumber-vertical .p-inputnumber-decrement-button {\n    order: 3;\n    border-bottom-left-radius: ").concat(dt3("inputnumber.button.border.radius"), ";\n    border-bottom-right-radius: ").concat(dt3("inputnumber.button.border.radius"), ";\n    width: 100%;\n    border-top: 0 none;\n}\n\n.p-inputnumber-input {\n    flex: 1 1 auto;\n}\n\n.p-inputnumber-fluid {\n    width: 100%;\n}\n\n.p-inputnumber-fluid .p-inputnumber-input {\n    width: 1%;\n}\n\n.p-inputnumber-fluid.p-inputnumber-vertical .p-inputnumber-input {\n    width: 100%;\n}\n");
}, "theme");
var classes$n = {
  root: /* @__PURE__ */ __name(function root9(_ref2) {
    var instance = _ref2.instance, props = _ref2.props;
    return ["p-inputnumber p-component p-inputwrapper", {
      "p-inputwrapper-filled": instance.filled || props.allowEmpty === false,
      "p-inputwrapper-focus": instance.focused,
      "p-inputnumber-stacked": props.showButtons && props.buttonLayout === "stacked",
      "p-inputnumber-horizontal": props.showButtons && props.buttonLayout === "horizontal",
      "p-inputnumber-vertical": props.showButtons && props.buttonLayout === "vertical",
      "p-inputnumber-fluid": instance.fluid
    }];
  }, "root"),
  pcInput: "p-inputnumber-input",
  buttonGroup: "p-inputnumber-button-group",
  incrementButton: /* @__PURE__ */ __name(function incrementButton(_ref3) {
    var instance = _ref3.instance, props = _ref3.props;
    return ["p-inputnumber-button p-inputnumber-increment-button", {
      "p-disabled": props.showButtons && props.max !== null && instance.maxBoundry()
    }];
  }, "incrementButton"),
  decrementButton: /* @__PURE__ */ __name(function decrementButton(_ref4) {
    var instance = _ref4.instance, props = _ref4.props;
    return ["p-inputnumber-button p-inputnumber-decrement-button", {
      "p-disabled": props.showButtons && props.min !== null && instance.minBoundry()
    }];
  }, "decrementButton")
};
var InputNumberStyle = BaseStyle.extend({
  name: "inputnumber",
  theme: theme$m,
  classes: classes$n
});
var script$1$n = {
  name: "BaseInputNumber",
  "extends": script$X,
  props: {
    modelValue: {
      type: Number,
      "default": null
    },
    format: {
      type: Boolean,
      "default": true
    },
    showButtons: {
      type: Boolean,
      "default": false
    },
    buttonLayout: {
      type: String,
      "default": "stacked"
    },
    incrementButtonClass: {
      type: String,
      "default": null
    },
    decrementButtonClass: {
      type: String,
      "default": null
    },
    incrementButtonIcon: {
      type: String,
      "default": void 0
    },
    incrementIcon: {
      type: String,
      "default": void 0
    },
    decrementButtonIcon: {
      type: String,
      "default": void 0
    },
    decrementIcon: {
      type: String,
      "default": void 0
    },
    locale: {
      type: String,
      "default": void 0
    },
    localeMatcher: {
      type: String,
      "default": void 0
    },
    mode: {
      type: String,
      "default": "decimal"
    },
    prefix: {
      type: String,
      "default": null
    },
    suffix: {
      type: String,
      "default": null
    },
    currency: {
      type: String,
      "default": void 0
    },
    currencyDisplay: {
      type: String,
      "default": void 0
    },
    useGrouping: {
      type: Boolean,
      "default": true
    },
    minFractionDigits: {
      type: Number,
      "default": void 0
    },
    maxFractionDigits: {
      type: Number,
      "default": void 0
    },
    roundingMode: {
      type: String,
      "default": "halfExpand",
      validator: /* @__PURE__ */ __name(function validator2(value3) {
        return ["ceil", "floor", "expand", "trunc", "halfCeil", "halfFloor", "halfExpand", "halfTrunc", "halfEven"].includes(value3);
      }, "validator")
    },
    min: {
      type: Number,
      "default": null
    },
    max: {
      type: Number,
      "default": null
    },
    step: {
      type: Number,
      "default": 1
    },
    allowEmpty: {
      type: Boolean,
      "default": true
    },
    highlightOnFocus: {
      type: Boolean,
      "default": false
    },
    readonly: {
      type: Boolean,
      "default": false
    },
    variant: {
      type: String,
      "default": null
    },
    invalid: {
      type: Boolean,
      "default": false
    },
    disabled: {
      type: Boolean,
      "default": false
    },
    placeholder: {
      type: String,
      "default": null
    },
    fluid: {
      type: Boolean,
      "default": false
    },
    inputId: {
      type: String,
      "default": null
    },
    inputClass: {
      type: [String, Object],
      "default": null
    },
    inputStyle: {
      type: Object,
      "default": null
    },
    ariaLabelledby: {
      type: String,
      "default": null
    },
    ariaLabel: {
      type: String,
      "default": null
    }
  },
  style: InputNumberStyle,
  provide: /* @__PURE__ */ __name(function provide16() {
    return {
      $pcInputNumber: this,
      $parentInstance: this
    };
  }, "provide")
};
function _typeof$a(o) {
  "@babel/helpers - typeof";
  return _typeof$a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$a(o);
}
__name(_typeof$a, "_typeof$a");
function ownKeys$b(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
__name(ownKeys$b, "ownKeys$b");
function _objectSpread$b(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$b(Object(t), true).forEach(function(r2) {
      _defineProperty$a(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$b(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
__name(_objectSpread$b, "_objectSpread$b");
function _defineProperty$a(e, r, t) {
  return (r = _toPropertyKey$9(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty$a, "_defineProperty$a");
function _toPropertyKey$9(t) {
  var i2 = _toPrimitive$9(t, "string");
  return "symbol" == _typeof$a(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$9, "_toPropertyKey$9");
function _toPrimitive$9(t, r) {
  if ("object" != _typeof$a(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$a(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive$9, "_toPrimitive$9");
function _toConsumableArray$b(r) {
  return _arrayWithoutHoles$b(r) || _iterableToArray$b(r) || _unsupportedIterableToArray$d(r) || _nonIterableSpread$b();
}
__name(_toConsumableArray$b, "_toConsumableArray$b");
function _nonIterableSpread$b() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableSpread$b, "_nonIterableSpread$b");
function _unsupportedIterableToArray$d(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$d(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$d(r, a) : void 0;
  }
}
__name(_unsupportedIterableToArray$d, "_unsupportedIterableToArray$d");
function _iterableToArray$b(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
__name(_iterableToArray$b, "_iterableToArray$b");
function _arrayWithoutHoles$b(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$d(r);
}
__name(_arrayWithoutHoles$b, "_arrayWithoutHoles$b");
function _arrayLikeToArray$d(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
__name(_arrayLikeToArray$d, "_arrayLikeToArray$d");
var script$C = {
  name: "InputNumber",
  "extends": script$1$n,
  inheritAttrs: false,
  emits: ["update:modelValue", "input", "focus", "blur"],
  numberFormat: null,
  _numeral: null,
  _decimal: null,
  _group: null,
  _minusSign: null,
  _currency: null,
  _suffix: null,
  _prefix: null,
  _index: null,
  groupChar: "",
  isSpecialChar: null,
  prefixChar: null,
  suffixChar: null,
  timer: null,
  data: /* @__PURE__ */ __name(function data5() {
    return {
      d_modelValue: this.modelValue,
      focused: false
    };
  }, "data"),
  watch: {
    modelValue: /* @__PURE__ */ __name(function modelValue(newValue) {
      this.d_modelValue = newValue;
    }, "modelValue"),
    locale: /* @__PURE__ */ __name(function locale(newValue, oldValue) {
      this.updateConstructParser(newValue, oldValue);
    }, "locale"),
    localeMatcher: /* @__PURE__ */ __name(function localeMatcher(newValue, oldValue) {
      this.updateConstructParser(newValue, oldValue);
    }, "localeMatcher"),
    mode: /* @__PURE__ */ __name(function mode(newValue, oldValue) {
      this.updateConstructParser(newValue, oldValue);
    }, "mode"),
    currency: /* @__PURE__ */ __name(function currency(newValue, oldValue) {
      this.updateConstructParser(newValue, oldValue);
    }, "currency"),
    currencyDisplay: /* @__PURE__ */ __name(function currencyDisplay(newValue, oldValue) {
      this.updateConstructParser(newValue, oldValue);
    }, "currencyDisplay"),
    useGrouping: /* @__PURE__ */ __name(function useGrouping(newValue, oldValue) {
      this.updateConstructParser(newValue, oldValue);
    }, "useGrouping"),
    minFractionDigits: /* @__PURE__ */ __name(function minFractionDigits(newValue, oldValue) {
      this.updateConstructParser(newValue, oldValue);
    }, "minFractionDigits"),
    maxFractionDigits: /* @__PURE__ */ __name(function maxFractionDigits(newValue, oldValue) {
      this.updateConstructParser(newValue, oldValue);
    }, "maxFractionDigits"),
    suffix: /* @__PURE__ */ __name(function suffix(newValue, oldValue) {
      this.updateConstructParser(newValue, oldValue);
    }, "suffix"),
    prefix: /* @__PURE__ */ __name(function prefix(newValue, oldValue) {
      this.updateConstructParser(newValue, oldValue);
    }, "prefix")
  },
  created: /* @__PURE__ */ __name(function created2() {
    this.constructParser();
  }, "created"),
  methods: {
    getOptions: /* @__PURE__ */ __name(function getOptions3() {
      return {
        localeMatcher: this.localeMatcher,
        style: this.mode,
        currency: this.currency,
        currencyDisplay: this.currencyDisplay,
        useGrouping: this.useGrouping,
        minimumFractionDigits: this.minFractionDigits,
        maximumFractionDigits: this.maxFractionDigits,
        roundingMode: this.roundingMode
      };
    }, "getOptions"),
    constructParser: /* @__PURE__ */ __name(function constructParser() {
      this.numberFormat = new Intl.NumberFormat(this.locale, this.getOptions());
      var numerals = _toConsumableArray$b(new Intl.NumberFormat(this.locale, {
        useGrouping: false
      }).format(9876543210)).reverse();
      var index2 = new Map(numerals.map(function(d, i2) {
        return [d, i2];
      }));
      this._numeral = new RegExp("[".concat(numerals.join(""), "]"), "g");
      this._group = this.getGroupingExpression();
      this._minusSign = this.getMinusSignExpression();
      this._currency = this.getCurrencyExpression();
      this._decimal = this.getDecimalExpression();
      this._suffix = this.getSuffixExpression();
      this._prefix = this.getPrefixExpression();
      this._index = function(d) {
        return index2.get(d);
      };
    }, "constructParser"),
    updateConstructParser: /* @__PURE__ */ __name(function updateConstructParser(newValue, oldValue) {
      if (newValue !== oldValue) {
        this.constructParser();
      }
    }, "updateConstructParser"),
    escapeRegExp: /* @__PURE__ */ __name(function escapeRegExp(text) {
      return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }, "escapeRegExp"),
    getDecimalExpression: /* @__PURE__ */ __name(function getDecimalExpression() {
      var formatter = new Intl.NumberFormat(this.locale, _objectSpread$b(_objectSpread$b({}, this.getOptions()), {}, {
        useGrouping: false
      }));
      return new RegExp("[".concat(formatter.format(1.1).replace(this._currency, "").trim().replace(this._numeral, ""), "]"), "g");
    }, "getDecimalExpression"),
    getGroupingExpression: /* @__PURE__ */ __name(function getGroupingExpression() {
      var formatter = new Intl.NumberFormat(this.locale, {
        useGrouping: true
      });
      this.groupChar = formatter.format(1e6).trim().replace(this._numeral, "").charAt(0);
      return new RegExp("[".concat(this.groupChar, "]"), "g");
    }, "getGroupingExpression"),
    getMinusSignExpression: /* @__PURE__ */ __name(function getMinusSignExpression() {
      var formatter = new Intl.NumberFormat(this.locale, {
        useGrouping: false
      });
      return new RegExp("[".concat(formatter.format(-1).trim().replace(this._numeral, ""), "]"), "g");
    }, "getMinusSignExpression"),
    getCurrencyExpression: /* @__PURE__ */ __name(function getCurrencyExpression() {
      if (this.currency) {
        var formatter = new Intl.NumberFormat(this.locale, {
          style: "currency",
          currency: this.currency,
          currencyDisplay: this.currencyDisplay,
          minimumFractionDigits: 0,
          maximumFractionDigits: 0,
          roundingMode: this.roundingMode
        });
        return new RegExp("[".concat(formatter.format(1).replace(/\s/g, "").replace(this._numeral, "").replace(this._group, ""), "]"), "g");
      }
      return new RegExp("[]", "g");
    }, "getCurrencyExpression"),
    getPrefixExpression: /* @__PURE__ */ __name(function getPrefixExpression() {
      if (this.prefix) {
        this.prefixChar = this.prefix;
      } else {
        var formatter = new Intl.NumberFormat(this.locale, {
          style: this.mode,
          currency: this.currency,
          currencyDisplay: this.currencyDisplay
        });
        this.prefixChar = formatter.format(1).split("1")[0];
      }
      return new RegExp("".concat(this.escapeRegExp(this.prefixChar || "")), "g");
    }, "getPrefixExpression"),
    getSuffixExpression: /* @__PURE__ */ __name(function getSuffixExpression() {
      if (this.suffix) {
        this.suffixChar = this.suffix;
      } else {
        var formatter = new Intl.NumberFormat(this.locale, {
          style: this.mode,
          currency: this.currency,
          currencyDisplay: this.currencyDisplay,
          minimumFractionDigits: 0,
          maximumFractionDigits: 0,
          roundingMode: this.roundingMode
        });
        this.suffixChar = formatter.format(1).split("1")[1];
      }
      return new RegExp("".concat(this.escapeRegExp(this.suffixChar || "")), "g");
    }, "getSuffixExpression"),
    formatValue: /* @__PURE__ */ __name(function formatValue(value3) {
      if (value3 != null) {
        if (value3 === "-") {
          return value3;
        }
        if (this.format) {
          var formatter = new Intl.NumberFormat(this.locale, this.getOptions());
          var formattedValue2 = formatter.format(value3);
          if (this.prefix) {
            formattedValue2 = this.prefix + formattedValue2;
          }
          if (this.suffix) {
            formattedValue2 = formattedValue2 + this.suffix;
          }
          return formattedValue2;
        }
        return value3.toString();
      }
      return "";
    }, "formatValue"),
    parseValue: /* @__PURE__ */ __name(function parseValue2(text) {
      var filteredText = text.replace(this._suffix, "").replace(this._prefix, "").trim().replace(/\s/g, "").replace(this._currency, "").replace(this._group, "").replace(this._minusSign, "-").replace(this._decimal, ".").replace(this._numeral, this._index);
      if (filteredText) {
        if (filteredText === "-")
          return filteredText;
        var parsedValue = +filteredText;
        return isNaN(parsedValue) ? null : parsedValue;
      }
      return null;
    }, "parseValue"),
    repeat: /* @__PURE__ */ __name(function repeat(event2, interval, dir) {
      var _this = this;
      if (this.readonly) {
        return;
      }
      var i2 = interval || 500;
      this.clearTimer();
      this.timer = setTimeout(function() {
        _this.repeat(event2, 40, dir);
      }, i2);
      this.spin(event2, dir);
    }, "repeat"),
    spin: /* @__PURE__ */ __name(function spin(event2, dir) {
      if (this.$refs.input) {
        var step2 = this.step * dir;
        var currentValue = this.parseValue(this.$refs.input.$el.value) || 0;
        var newValue = this.validateValue(currentValue + step2);
        this.updateInput(newValue, null, "spin");
        this.updateModel(event2, newValue);
        this.handleOnInput(event2, currentValue, newValue);
      }
    }, "spin"),
    onUpButtonMouseDown: /* @__PURE__ */ __name(function onUpButtonMouseDown(event2) {
      if (!this.disabled) {
        this.$refs.input.$el.focus();
        this.repeat(event2, null, 1);
        event2.preventDefault();
      }
    }, "onUpButtonMouseDown"),
    onUpButtonMouseUp: /* @__PURE__ */ __name(function onUpButtonMouseUp() {
      if (!this.disabled) {
        this.clearTimer();
      }
    }, "onUpButtonMouseUp"),
    onUpButtonMouseLeave: /* @__PURE__ */ __name(function onUpButtonMouseLeave() {
      if (!this.disabled) {
        this.clearTimer();
      }
    }, "onUpButtonMouseLeave"),
    onUpButtonKeyUp: /* @__PURE__ */ __name(function onUpButtonKeyUp() {
      if (!this.disabled) {
        this.clearTimer();
      }
    }, "onUpButtonKeyUp"),
    onUpButtonKeyDown: /* @__PURE__ */ __name(function onUpButtonKeyDown(event2) {
      if (event2.code === "Space" || event2.code === "Enter" || event2.code === "NumpadEnter") {
        this.repeat(event2, null, 1);
      }
    }, "onUpButtonKeyDown"),
    onDownButtonMouseDown: /* @__PURE__ */ __name(function onDownButtonMouseDown(event2) {
      if (!this.disabled) {
        this.$refs.input.$el.focus();
        this.repeat(event2, null, -1);
        event2.preventDefault();
      }
    }, "onDownButtonMouseDown"),
    onDownButtonMouseUp: /* @__PURE__ */ __name(function onDownButtonMouseUp() {
      if (!this.disabled) {
        this.clearTimer();
      }
    }, "onDownButtonMouseUp"),
    onDownButtonMouseLeave: /* @__PURE__ */ __name(function onDownButtonMouseLeave() {
      if (!this.disabled) {
        this.clearTimer();
      }
    }, "onDownButtonMouseLeave"),
    onDownButtonKeyUp: /* @__PURE__ */ __name(function onDownButtonKeyUp() {
      if (!this.disabled) {
        this.clearTimer();
      }
    }, "onDownButtonKeyUp"),
    onDownButtonKeyDown: /* @__PURE__ */ __name(function onDownButtonKeyDown(event2) {
      if (event2.code === "Space" || event2.code === "Enter" || event2.code === "NumpadEnter") {
        this.repeat(event2, null, -1);
      }
    }, "onDownButtonKeyDown"),
    onUserInput: /* @__PURE__ */ __name(function onUserInput() {
      if (this.isSpecialChar) {
        this.$refs.input.$el.value = this.lastValue;
      }
      this.isSpecialChar = false;
    }, "onUserInput"),
    onInputKeyDown: /* @__PURE__ */ __name(function onInputKeyDown(event2) {
      if (this.readonly) {
        return;
      }
      if (event2.altKey || event2.ctrlKey || event2.metaKey) {
        this.isSpecialChar = true;
        this.lastValue = this.$refs.input.$el.value;
        return;
      }
      this.lastValue = event2.target.value;
      var selectionStart = event2.target.selectionStart;
      var selectionEnd = event2.target.selectionEnd;
      var inputValue2 = event2.target.value;
      var newValueStr = null;
      switch (event2.code) {
        case "ArrowUp":
          this.spin(event2, 1);
          event2.preventDefault();
          break;
        case "ArrowDown":
          this.spin(event2, -1);
          event2.preventDefault();
          break;
        case "ArrowLeft":
          if (!this.isNumeralChar(inputValue2.charAt(selectionStart - 1))) {
            event2.preventDefault();
          }
          break;
        case "ArrowRight":
          if (!this.isNumeralChar(inputValue2.charAt(selectionStart))) {
            event2.preventDefault();
          }
          break;
        case "Tab":
        case "Enter":
        case "NumpadEnter":
          newValueStr = this.validateValue(this.parseValue(inputValue2));
          this.$refs.input.$el.value = this.formatValue(newValueStr);
          this.$refs.input.$el.setAttribute("aria-valuenow", newValueStr);
          this.updateModel(event2, newValueStr);
          break;
        case "Backspace": {
          event2.preventDefault();
          if (selectionStart === selectionEnd) {
            var deleteChar = inputValue2.charAt(selectionStart - 1);
            var _this$getDecimalCharI = this.getDecimalCharIndexes(inputValue2), decimalCharIndex = _this$getDecimalCharI.decimalCharIndex, decimalCharIndexWithoutPrefix = _this$getDecimalCharI.decimalCharIndexWithoutPrefix;
            if (this.isNumeralChar(deleteChar)) {
              var decimalLength = this.getDecimalLength(inputValue2);
              if (this._group.test(deleteChar)) {
                this._group.lastIndex = 0;
                newValueStr = inputValue2.slice(0, selectionStart - 2) + inputValue2.slice(selectionStart - 1);
              } else if (this._decimal.test(deleteChar)) {
                this._decimal.lastIndex = 0;
                if (decimalLength) {
                  this.$refs.input.$el.setSelectionRange(selectionStart - 1, selectionStart - 1);
                } else {
                  newValueStr = inputValue2.slice(0, selectionStart - 1) + inputValue2.slice(selectionStart);
                }
              } else if (decimalCharIndex > 0 && selectionStart > decimalCharIndex) {
                var insertedText = this.isDecimalMode() && (this.minFractionDigits || 0) < decimalLength ? "" : "0";
                newValueStr = inputValue2.slice(0, selectionStart - 1) + insertedText + inputValue2.slice(selectionStart);
              } else if (decimalCharIndexWithoutPrefix === 1) {
                newValueStr = inputValue2.slice(0, selectionStart - 1) + "0" + inputValue2.slice(selectionStart);
                newValueStr = this.parseValue(newValueStr) > 0 ? newValueStr : "";
              } else {
                newValueStr = inputValue2.slice(0, selectionStart - 1) + inputValue2.slice(selectionStart);
              }
            }
            this.updateValue(event2, newValueStr, null, "delete-single");
          } else {
            newValueStr = this.deleteRange(inputValue2, selectionStart, selectionEnd);
            this.updateValue(event2, newValueStr, null, "delete-range");
          }
          break;
        }
        case "Delete":
          event2.preventDefault();
          if (selectionStart === selectionEnd) {
            var _deleteChar = inputValue2.charAt(selectionStart);
            var _this$getDecimalCharI2 = this.getDecimalCharIndexes(inputValue2), _decimalCharIndex = _this$getDecimalCharI2.decimalCharIndex, _decimalCharIndexWithoutPrefix = _this$getDecimalCharI2.decimalCharIndexWithoutPrefix;
            if (this.isNumeralChar(_deleteChar)) {
              var _decimalLength = this.getDecimalLength(inputValue2);
              if (this._group.test(_deleteChar)) {
                this._group.lastIndex = 0;
                newValueStr = inputValue2.slice(0, selectionStart) + inputValue2.slice(selectionStart + 2);
              } else if (this._decimal.test(_deleteChar)) {
                this._decimal.lastIndex = 0;
                if (_decimalLength) {
                  this.$refs.input.$el.setSelectionRange(selectionStart + 1, selectionStart + 1);
                } else {
                  newValueStr = inputValue2.slice(0, selectionStart) + inputValue2.slice(selectionStart + 1);
                }
              } else if (_decimalCharIndex > 0 && selectionStart > _decimalCharIndex) {
                var _insertedText = this.isDecimalMode() && (this.minFractionDigits || 0) < _decimalLength ? "" : "0";
                newValueStr = inputValue2.slice(0, selectionStart) + _insertedText + inputValue2.slice(selectionStart + 1);
              } else if (_decimalCharIndexWithoutPrefix === 1) {
                newValueStr = inputValue2.slice(0, selectionStart) + "0" + inputValue2.slice(selectionStart + 1);
                newValueStr = this.parseValue(newValueStr) > 0 ? newValueStr : "";
              } else {
                newValueStr = inputValue2.slice(0, selectionStart) + inputValue2.slice(selectionStart + 1);
              }
            }
            this.updateValue(event2, newValueStr, null, "delete-back-single");
          } else {
            newValueStr = this.deleteRange(inputValue2, selectionStart, selectionEnd);
            this.updateValue(event2, newValueStr, null, "delete-range");
          }
          break;
        case "Home":
          event2.preventDefault();
          if (isNotEmpty(this.min)) {
            this.updateModel(event2, this.min);
          }
          break;
        case "End":
          event2.preventDefault();
          if (isNotEmpty(this.max)) {
            this.updateModel(event2, this.max);
          }
          break;
      }
    }, "onInputKeyDown"),
    onInputKeyPress: /* @__PURE__ */ __name(function onInputKeyPress(event2) {
      if (this.readonly) {
        return;
      }
      var _char = event2.key;
      var isDecimalSign2 = this.isDecimalSign(_char);
      var isMinusSign2 = this.isMinusSign(_char);
      if (event2.code !== "Enter") {
        event2.preventDefault();
      }
      if (Number(_char) >= 0 && Number(_char) <= 9 || isMinusSign2 || isDecimalSign2) {
        this.insert(event2, _char, {
          isDecimalSign: isDecimalSign2,
          isMinusSign: isMinusSign2
        });
      }
    }, "onInputKeyPress"),
    onPaste: /* @__PURE__ */ __name(function onPaste(event2) {
      event2.preventDefault();
      var data24 = (event2.clipboardData || window["clipboardData"]).getData("Text");
      if (data24) {
        var filteredData = this.parseValue(data24);
        if (filteredData != null) {
          this.insert(event2, filteredData.toString());
        }
      }
    }, "onPaste"),
    allowMinusSign: /* @__PURE__ */ __name(function allowMinusSign() {
      return this.min === null || this.min < 0;
    }, "allowMinusSign"),
    isMinusSign: /* @__PURE__ */ __name(function isMinusSign(_char2) {
      if (this._minusSign.test(_char2) || _char2 === "-") {
        this._minusSign.lastIndex = 0;
        return true;
      }
      return false;
    }, "isMinusSign"),
    isDecimalSign: /* @__PURE__ */ __name(function isDecimalSign(_char3) {
      if (this._decimal.test(_char3)) {
        this._decimal.lastIndex = 0;
        return true;
      }
      return false;
    }, "isDecimalSign"),
    isDecimalMode: /* @__PURE__ */ __name(function isDecimalMode() {
      return this.mode === "decimal";
    }, "isDecimalMode"),
    getDecimalCharIndexes: /* @__PURE__ */ __name(function getDecimalCharIndexes(val) {
      var decimalCharIndex = val.search(this._decimal);
      this._decimal.lastIndex = 0;
      var filteredVal = val.replace(this._prefix, "").trim().replace(/\s/g, "").replace(this._currency, "");
      var decimalCharIndexWithoutPrefix = filteredVal.search(this._decimal);
      this._decimal.lastIndex = 0;
      return {
        decimalCharIndex,
        decimalCharIndexWithoutPrefix
      };
    }, "getDecimalCharIndexes"),
    getCharIndexes: /* @__PURE__ */ __name(function getCharIndexes(val) {
      var decimalCharIndex = val.search(this._decimal);
      this._decimal.lastIndex = 0;
      var minusCharIndex = val.search(this._minusSign);
      this._minusSign.lastIndex = 0;
      var suffixCharIndex = val.search(this._suffix);
      this._suffix.lastIndex = 0;
      var currencyCharIndex = val.search(this._currency);
      this._currency.lastIndex = 0;
      return {
        decimalCharIndex,
        minusCharIndex,
        suffixCharIndex,
        currencyCharIndex
      };
    }, "getCharIndexes"),
    insert: /* @__PURE__ */ __name(function insert(event2, text) {
      var sign = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
        isDecimalSign: false,
        isMinusSign: false
      };
      var minusCharIndexOnText = text.search(this._minusSign);
      this._minusSign.lastIndex = 0;
      if (!this.allowMinusSign() && minusCharIndexOnText !== -1) {
        return;
      }
      var selectionStart = this.$refs.input.$el.selectionStart;
      var selectionEnd = this.$refs.input.$el.selectionEnd;
      var inputValue2 = this.$refs.input.$el.value.trim();
      var _this$getCharIndexes = this.getCharIndexes(inputValue2), decimalCharIndex = _this$getCharIndexes.decimalCharIndex, minusCharIndex = _this$getCharIndexes.minusCharIndex, suffixCharIndex = _this$getCharIndexes.suffixCharIndex, currencyCharIndex = _this$getCharIndexes.currencyCharIndex;
      var newValueStr;
      if (sign.isMinusSign) {
        if (selectionStart === 0) {
          newValueStr = inputValue2;
          if (minusCharIndex === -1 || selectionEnd !== 0) {
            newValueStr = this.insertText(inputValue2, text, 0, selectionEnd);
          }
          this.updateValue(event2, newValueStr, text, "insert");
        }
      } else if (sign.isDecimalSign) {
        if (decimalCharIndex > 0 && selectionStart === decimalCharIndex) {
          this.updateValue(event2, inputValue2, text, "insert");
        } else if (decimalCharIndex > selectionStart && decimalCharIndex < selectionEnd) {
          newValueStr = this.insertText(inputValue2, text, selectionStart, selectionEnd);
          this.updateValue(event2, newValueStr, text, "insert");
        } else if (decimalCharIndex === -1 && this.maxFractionDigits) {
          newValueStr = this.insertText(inputValue2, text, selectionStart, selectionEnd);
          this.updateValue(event2, newValueStr, text, "insert");
        }
      } else {
        var maxFractionDigits2 = this.numberFormat.resolvedOptions().maximumFractionDigits;
        var operation = selectionStart !== selectionEnd ? "range-insert" : "insert";
        if (decimalCharIndex > 0 && selectionStart > decimalCharIndex) {
          if (selectionStart + text.length - (decimalCharIndex + 1) <= maxFractionDigits2) {
            var charIndex = currencyCharIndex >= selectionStart ? currencyCharIndex - 1 : suffixCharIndex >= selectionStart ? suffixCharIndex : inputValue2.length;
            newValueStr = inputValue2.slice(0, selectionStart) + text + inputValue2.slice(selectionStart + text.length, charIndex) + inputValue2.slice(charIndex);
            this.updateValue(event2, newValueStr, text, operation);
          }
        } else {
          newValueStr = this.insertText(inputValue2, text, selectionStart, selectionEnd);
          this.updateValue(event2, newValueStr, text, operation);
        }
      }
    }, "insert"),
    insertText: /* @__PURE__ */ __name(function insertText(value3, text, start2, end) {
      var textSplit = text === "." ? text : text.split(".");
      if (textSplit.length === 2) {
        var decimalCharIndex = value3.slice(start2, end).search(this._decimal);
        this._decimal.lastIndex = 0;
        return decimalCharIndex > 0 ? value3.slice(0, start2) + this.formatValue(text) + value3.slice(end) : this.formatValue(text) || value3;
      } else if (end - start2 === value3.length) {
        return this.formatValue(text);
      } else if (start2 === 0) {
        return text + value3.slice(end);
      } else if (end === value3.length) {
        return value3.slice(0, start2) + text;
      } else {
        return value3.slice(0, start2) + text + value3.slice(end);
      }
    }, "insertText"),
    deleteRange: /* @__PURE__ */ __name(function deleteRange(value3, start2, end) {
      var newValueStr;
      if (end - start2 === value3.length) newValueStr = "";
      else if (start2 === 0) newValueStr = value3.slice(end);
      else if (end === value3.length) newValueStr = value3.slice(0, start2);
      else newValueStr = value3.slice(0, start2) + value3.slice(end);
      return newValueStr;
    }, "deleteRange"),
    initCursor: /* @__PURE__ */ __name(function initCursor() {
      var selectionStart = this.$refs.input.$el.selectionStart;
      var inputValue2 = this.$refs.input.$el.value;
      var valueLength = inputValue2.length;
      var index2 = null;
      var prefixLength = (this.prefixChar || "").length;
      inputValue2 = inputValue2.replace(this._prefix, "");
      selectionStart = selectionStart - prefixLength;
      var _char4 = inputValue2.charAt(selectionStart);
      if (this.isNumeralChar(_char4)) {
        return selectionStart + prefixLength;
      }
      var i2 = selectionStart - 1;
      while (i2 >= 0) {
        _char4 = inputValue2.charAt(i2);
        if (this.isNumeralChar(_char4)) {
          index2 = i2 + prefixLength;
          break;
        } else {
          i2--;
        }
      }
      if (index2 !== null) {
        this.$refs.input.$el.setSelectionRange(index2 + 1, index2 + 1);
      } else {
        i2 = selectionStart;
        while (i2 < valueLength) {
          _char4 = inputValue2.charAt(i2);
          if (this.isNumeralChar(_char4)) {
            index2 = i2 + prefixLength;
            break;
          } else {
            i2++;
          }
        }
        if (index2 !== null) {
          this.$refs.input.$el.setSelectionRange(index2, index2);
        }
      }
      return index2 || 0;
    }, "initCursor"),
    onInputClick: /* @__PURE__ */ __name(function onInputClick() {
      var currentValue = this.$refs.input.$el.value;
      if (!this.readonly && currentValue !== getSelection()) {
        this.initCursor();
      }
    }, "onInputClick"),
    isNumeralChar: /* @__PURE__ */ __name(function isNumeralChar(_char5) {
      if (_char5.length === 1 && (this._numeral.test(_char5) || this._decimal.test(_char5) || this._group.test(_char5) || this._minusSign.test(_char5))) {
        this.resetRegex();
        return true;
      }
      return false;
    }, "isNumeralChar"),
    resetRegex: /* @__PURE__ */ __name(function resetRegex() {
      this._numeral.lastIndex = 0;
      this._decimal.lastIndex = 0;
      this._group.lastIndex = 0;
      this._minusSign.lastIndex = 0;
    }, "resetRegex"),
    updateValue: /* @__PURE__ */ __name(function updateValue2(event2, valueStr, insertedValueStr, operation) {
      var currentValue = this.$refs.input.$el.value;
      var newValue = null;
      if (valueStr != null) {
        newValue = this.parseValue(valueStr);
        newValue = !newValue && !this.allowEmpty ? 0 : newValue;
        this.updateInput(newValue, insertedValueStr, operation, valueStr);
        this.handleOnInput(event2, currentValue, newValue);
      }
    }, "updateValue"),
    handleOnInput: /* @__PURE__ */ __name(function handleOnInput(event2, currentValue, newValue) {
      if (this.isValueChanged(currentValue, newValue)) {
        this.$emit("input", {
          originalEvent: event2,
          value: newValue,
          formattedValue: currentValue
        });
      }
    }, "handleOnInput"),
    isValueChanged: /* @__PURE__ */ __name(function isValueChanged(currentValue, newValue) {
      if (newValue === null && currentValue !== null) {
        return true;
      }
      if (newValue != null) {
        var parsedCurrentValue = typeof currentValue === "string" ? this.parseValue(currentValue) : currentValue;
        return newValue !== parsedCurrentValue;
      }
      return false;
    }, "isValueChanged"),
    validateValue: /* @__PURE__ */ __name(function validateValue(value3) {
      if (value3 === "-" || value3 == null) {
        return null;
      }
      if (this.min != null && value3 < this.min) {
        return this.min;
      }
      if (this.max != null && value3 > this.max) {
        return this.max;
      }
      return value3;
    }, "validateValue"),
    updateInput: /* @__PURE__ */ __name(function updateInput(value3, insertedValueStr, operation, valueStr) {
      insertedValueStr = insertedValueStr || "";
      var inputValue2 = this.$refs.input.$el.value;
      var newValue = this.formatValue(value3);
      var currentLength = inputValue2.length;
      if (newValue !== valueStr) {
        newValue = this.concatValues(newValue, valueStr);
      }
      if (currentLength === 0) {
        this.$refs.input.$el.value = newValue;
        this.$refs.input.$el.setSelectionRange(0, 0);
        var index2 = this.initCursor();
        var selectionEnd = index2 + insertedValueStr.length;
        this.$refs.input.$el.setSelectionRange(selectionEnd, selectionEnd);
      } else {
        var selectionStart = this.$refs.input.$el.selectionStart;
        var _selectionEnd = this.$refs.input.$el.selectionEnd;
        this.$refs.input.$el.value = newValue;
        var newLength = newValue.length;
        if (operation === "range-insert") {
          var startValue = this.parseValue((inputValue2 || "").slice(0, selectionStart));
          var startValueStr = startValue !== null ? startValue.toString() : "";
          var startExpr = startValueStr.split("").join("(".concat(this.groupChar, ")?"));
          var sRegex = new RegExp(startExpr, "g");
          sRegex.test(newValue);
          var tExpr = insertedValueStr.split("").join("(".concat(this.groupChar, ")?"));
          var tRegex = new RegExp(tExpr, "g");
          tRegex.test(newValue.slice(sRegex.lastIndex));
          _selectionEnd = sRegex.lastIndex + tRegex.lastIndex;
          this.$refs.input.$el.setSelectionRange(_selectionEnd, _selectionEnd);
        } else if (newLength === currentLength) {
          if (operation === "insert" || operation === "delete-back-single") {
            this.$refs.input.$el.setSelectionRange(_selectionEnd + 1, _selectionEnd + 1);
          } else if (operation === "delete-single") {
            this.$refs.input.$el.setSelectionRange(_selectionEnd - 1, _selectionEnd - 1);
          } else if (operation === "delete-range" || operation === "spin") {
            this.$refs.input.$el.setSelectionRange(_selectionEnd, _selectionEnd);
          }
        } else if (operation === "delete-back-single") {
          var prevChar = inputValue2.charAt(_selectionEnd - 1);
          var nextChar = inputValue2.charAt(_selectionEnd);
          var diff = currentLength - newLength;
          var isGroupChar = this._group.test(nextChar);
          if (isGroupChar && diff === 1) {
            _selectionEnd += 1;
          } else if (!isGroupChar && this.isNumeralChar(prevChar)) {
            _selectionEnd += -1 * diff + 1;
          }
          this._group.lastIndex = 0;
          this.$refs.input.$el.setSelectionRange(_selectionEnd, _selectionEnd);
        } else if (inputValue2 === "-" && operation === "insert") {
          this.$refs.input.$el.setSelectionRange(0, 0);
          var _index = this.initCursor();
          var _selectionEnd2 = _index + insertedValueStr.length + 1;
          this.$refs.input.$el.setSelectionRange(_selectionEnd2, _selectionEnd2);
        } else {
          _selectionEnd = _selectionEnd + (newLength - currentLength);
          this.$refs.input.$el.setSelectionRange(_selectionEnd, _selectionEnd);
        }
      }
      this.$refs.input.$el.setAttribute("aria-valuenow", value3);
    }, "updateInput"),
    concatValues: /* @__PURE__ */ __name(function concatValues(val1, val2) {
      if (val1 && val2) {
        var decimalCharIndex = val2.search(this._decimal);
        this._decimal.lastIndex = 0;
        if (this.suffixChar) {
          return decimalCharIndex !== -1 ? val1.replace(this.suffixChar, "").split(this._decimal)[0] + val2.replace(this.suffixChar, "").slice(decimalCharIndex) + this.suffixChar : val1;
        } else {
          return decimalCharIndex !== -1 ? val1.split(this._decimal)[0] + val2.slice(decimalCharIndex) : val1;
        }
      }
      return val1;
    }, "concatValues"),
    getDecimalLength: /* @__PURE__ */ __name(function getDecimalLength(value3) {
      if (value3) {
        var valueSplit = value3.split(this._decimal);
        if (valueSplit.length === 2) {
          return valueSplit[1].replace(this._suffix, "").trim().replace(/\s/g, "").replace(this._currency, "").length;
        }
      }
      return 0;
    }, "getDecimalLength"),
    updateModel: /* @__PURE__ */ __name(function updateModel2(event2, value3) {
      this.d_modelValue = value3;
      this.$emit("update:modelValue", value3);
    }, "updateModel"),
    onInputFocus: /* @__PURE__ */ __name(function onInputFocus(event2) {
      this.focused = true;
      if (!this.disabled && !this.readonly && this.$refs.input.$el.value !== getSelection() && this.highlightOnFocus) {
        event2.target.select();
      }
      this.$emit("focus", event2);
    }, "onInputFocus"),
    onInputBlur: /* @__PURE__ */ __name(function onInputBlur(event2) {
      this.focused = false;
      var input = event2.target;
      var newValue = this.validateValue(this.parseValue(input.value));
      this.$emit("blur", {
        originalEvent: event2,
        value: input.value
      });
      input.value = this.formatValue(newValue);
      input.setAttribute("aria-valuenow", newValue);
      this.updateModel(event2, newValue);
      if (!this.disabled && !this.readonly && this.highlightOnFocus) {
        clearSelection();
      }
    }, "onInputBlur"),
    clearTimer: /* @__PURE__ */ __name(function clearTimer() {
      if (this.timer) {
        clearInterval(this.timer);
      }
    }, "clearTimer"),
    maxBoundry: /* @__PURE__ */ __name(function maxBoundry() {
      return this.d_modelValue >= this.max;
    }, "maxBoundry"),
    minBoundry: /* @__PURE__ */ __name(function minBoundry() {
      return this.d_modelValue <= this.min;
    }, "minBoundry")
  },
  computed: {
    filled: /* @__PURE__ */ __name(function filled2() {
      return this.modelValue != null && this.modelValue.toString().length > 0;
    }, "filled"),
    upButtonListeners: /* @__PURE__ */ __name(function upButtonListeners() {
      var _this2 = this;
      return {
        mousedown: /* @__PURE__ */ __name(function mousedown(event2) {
          return _this2.onUpButtonMouseDown(event2);
        }, "mousedown"),
        mouseup: /* @__PURE__ */ __name(function mouseup(event2) {
          return _this2.onUpButtonMouseUp(event2);
        }, "mouseup"),
        mouseleave: /* @__PURE__ */ __name(function mouseleave(event2) {
          return _this2.onUpButtonMouseLeave(event2);
        }, "mouseleave"),
        keydown: /* @__PURE__ */ __name(function keydown(event2) {
          return _this2.onUpButtonKeyDown(event2);
        }, "keydown"),
        keyup: /* @__PURE__ */ __name(function keyup(event2) {
          return _this2.onUpButtonKeyUp(event2);
        }, "keyup")
      };
    }, "upButtonListeners"),
    downButtonListeners: /* @__PURE__ */ __name(function downButtonListeners() {
      var _this3 = this;
      return {
        mousedown: /* @__PURE__ */ __name(function mousedown(event2) {
          return _this3.onDownButtonMouseDown(event2);
        }, "mousedown"),
        mouseup: /* @__PURE__ */ __name(function mouseup(event2) {
          return _this3.onDownButtonMouseUp(event2);
        }, "mouseup"),
        mouseleave: /* @__PURE__ */ __name(function mouseleave(event2) {
          return _this3.onDownButtonMouseLeave(event2);
        }, "mouseleave"),
        keydown: /* @__PURE__ */ __name(function keydown(event2) {
          return _this3.onDownButtonKeyDown(event2);
        }, "keydown"),
        keyup: /* @__PURE__ */ __name(function keyup(event2) {
          return _this3.onDownButtonKeyUp(event2);
        }, "keyup")
      };
    }, "downButtonListeners"),
    formattedValue: /* @__PURE__ */ __name(function formattedValue() {
      var val = !this.modelValue && !this.allowEmpty ? 0 : this.modelValue;
      return this.formatValue(val);
    }, "formattedValue"),
    getFormatter: /* @__PURE__ */ __name(function getFormatter() {
      return this.numberFormat;
    }, "getFormatter")
  },
  components: {
    InputText: script$O,
    AngleUpIcon: script$D,
    AngleDownIcon: script$E
  }
};
var _hoisted_1$R = ["disabled"];
var _hoisted_2$E = ["disabled"];
var _hoisted_3$j = ["disabled"];
var _hoisted_4$c = ["disabled"];
function render$B(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_InputText = resolveComponent("InputText");
  return openBlock(), createElementBlock("span", mergeProps({
    "class": _ctx.cx("root")
  }, _ctx.ptmi("root")), [createVNode(_component_InputText, {
    ref: "input",
    id: _ctx.inputId,
    role: "spinbutton",
    "class": normalizeClass([_ctx.cx("pcInput"), _ctx.inputClass]),
    style: normalizeStyle(_ctx.inputStyle),
    value: $options.formattedValue,
    "aria-valuemin": _ctx.min,
    "aria-valuemax": _ctx.max,
    "aria-valuenow": _ctx.modelValue,
    inputmode: _ctx.mode === "decimal" && !_ctx.minFractionDigits ? "numeric" : "decimal",
    disabled: _ctx.disabled,
    readonly: _ctx.readonly,
    placeholder: _ctx.placeholder,
    "aria-labelledby": _ctx.ariaLabelledby,
    "aria-label": _ctx.ariaLabel,
    invalid: _ctx.invalid,
    variant: _ctx.variant,
    onInput: $options.onUserInput,
    onKeydown: $options.onInputKeyDown,
    onKeypress: $options.onInputKeyPress,
    onPaste: $options.onPaste,
    onClick: $options.onInputClick,
    onFocus: $options.onInputFocus,
    onBlur: $options.onInputBlur,
    pt: _ctx.ptm("pcInput"),
    unstyled: _ctx.unstyled
  }, null, 8, ["id", "class", "style", "value", "aria-valuemin", "aria-valuemax", "aria-valuenow", "inputmode", "disabled", "readonly", "placeholder", "aria-labelledby", "aria-label", "invalid", "variant", "onInput", "onKeydown", "onKeypress", "onPaste", "onClick", "onFocus", "onBlur", "pt", "unstyled"]), _ctx.showButtons && _ctx.buttonLayout === "stacked" ? (openBlock(), createElementBlock("span", mergeProps({
    key: 0,
    "class": _ctx.cx("buttonGroup")
  }, _ctx.ptm("buttonGroup")), [renderSlot(_ctx.$slots, "incrementbutton", {
    listeners: $options.upButtonListeners
  }, function() {
    return [createBaseVNode("button", mergeProps({
      "class": [_ctx.cx("incrementButton"), _ctx.incrementButtonClass]
    }, toHandlers($options.upButtonListeners, true), {
      disabled: _ctx.disabled,
      tabindex: -1,
      "aria-hidden": "true",
      type: "button"
    }, _ctx.ptm("incrementButton")), [renderSlot(_ctx.$slots, _ctx.$slots.incrementicon ? "incrementicon" : "incrementbuttonicon", {}, function() {
      return [(openBlock(), createBlock(resolveDynamicComponent(_ctx.incrementIcon || _ctx.incrementButtonIcon ? "span" : "AngleUpIcon"), mergeProps({
        "class": [_ctx.incrementIcon, _ctx.incrementButtonIcon]
      }, _ctx.ptm("incrementIcon"), {
        "data-pc-section": "incrementicon"
      }), null, 16, ["class"]))];
    })], 16, _hoisted_1$R)];
  }), renderSlot(_ctx.$slots, "decrementbutton", {
    listeners: $options.downButtonListeners
  }, function() {
    return [createBaseVNode("button", mergeProps({
      "class": [_ctx.cx("decrementButton"), _ctx.decrementButtonClass]
    }, toHandlers($options.downButtonListeners, true), {
      disabled: _ctx.disabled,
      tabindex: -1,
      "aria-hidden": "true",
      type: "button"
    }, _ctx.ptm("decrementButton")), [renderSlot(_ctx.$slots, _ctx.$slots.decrementicon ? "decrementicon" : "decrementbuttonicon", {}, function() {
      return [(openBlock(), createBlock(resolveDynamicComponent(_ctx.decrementIcon || _ctx.decrementButtonIcon ? "span" : "AngleDownIcon"), mergeProps({
        "class": [_ctx.decrementIcon, _ctx.decrementButtonIcon]
      }, _ctx.ptm("decrementIcon"), {
        "data-pc-section": "decrementicon"
      }), null, 16, ["class"]))];
    })], 16, _hoisted_2$E)];
  })], 16)) : createCommentVNode("", true), renderSlot(_ctx.$slots, "incrementbutton", {
    listeners: $options.upButtonListeners
  }, function() {
    return [_ctx.showButtons && _ctx.buttonLayout !== "stacked" ? (openBlock(), createElementBlock("button", mergeProps({
      key: 0,
      "class": [_ctx.cx("incrementButton"), _ctx.incrementButtonClass]
    }, toHandlers($options.upButtonListeners, true), {
      disabled: _ctx.disabled,
      tabindex: -1,
      "aria-hidden": "true",
      type: "button"
    }, _ctx.ptm("incrementButton")), [renderSlot(_ctx.$slots, _ctx.$slots.incrementicon ? "incrementicon" : "incrementbuttonicon", {}, function() {
      return [(openBlock(), createBlock(resolveDynamicComponent(_ctx.incrementIcon || _ctx.incrementButtonIcon ? "span" : "AngleUpIcon"), mergeProps({
        "class": [_ctx.incrementIcon, _ctx.incrementButtonIcon]
      }, _ctx.ptm("incrementIcon"), {
        "data-pc-section": "incrementicon"
      }), null, 16, ["class"]))];
    })], 16, _hoisted_3$j)) : createCommentVNode("", true)];
  }), renderSlot(_ctx.$slots, "decrementbutton", {
    listeners: $options.downButtonListeners
  }, function() {
    return [_ctx.showButtons && _ctx.buttonLayout !== "stacked" ? (openBlock(), createElementBlock("button", mergeProps({
      key: 0,
      "class": [_ctx.cx("decrementButton"), _ctx.decrementButtonClass]
    }, toHandlers($options.downButtonListeners, true), {
      disabled: _ctx.disabled,
      tabindex: -1,
      "aria-hidden": "true",
      type: "button"
    }, _ctx.ptm("decrementButton")), [renderSlot(_ctx.$slots, _ctx.$slots.decrementicon ? "decrementicon" : "decrementbuttonicon", {}, function() {
      return [(openBlock(), createBlock(resolveDynamicComponent(_ctx.decrementIcon || _ctx.decrementButtonIcon ? "span" : "AngleDownIcon"), mergeProps({
        "class": [_ctx.decrementIcon, _ctx.decrementButtonIcon]
      }, _ctx.ptm("decrementIcon"), {
        "data-pc-section": "decrementicon"
      }), null, 16, ["class"]))];
    })], 16, _hoisted_4$c)) : createCommentVNode("", true)];
  })], 16);
}
__name(render$B, "render$B");
script$C.render = render$B;
var script$B = {
  name: "ChevronDownIcon",
  "extends": script$U
};
var _hoisted_1$Q = /* @__PURE__ */ createBaseVNode("path", {
  d: "M7.01744 10.398C6.91269 10.3985 6.8089 10.378 6.71215 10.3379C6.61541 10.2977 6.52766 10.2386 6.45405 10.1641L1.13907 4.84913C1.03306 4.69404 0.985221 4.5065 1.00399 4.31958C1.02276 4.13266 1.10693 3.95838 1.24166 3.82747C1.37639 3.69655 1.55301 3.61742 1.74039 3.60402C1.92777 3.59062 2.11386 3.64382 2.26584 3.75424L7.01744 8.47394L11.769 3.75424C11.9189 3.65709 12.097 3.61306 12.2748 3.62921C12.4527 3.64535 12.6199 3.72073 12.7498 3.84328C12.8797 3.96582 12.9647 4.12842 12.9912 4.30502C13.0177 4.48162 12.9841 4.662 12.8958 4.81724L7.58083 10.1322C7.50996 10.2125 7.42344 10.2775 7.32656 10.3232C7.22968 10.3689 7.12449 10.3944 7.01744 10.398Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$D = [_hoisted_1$Q];
function render$A(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$D, 16);
}
__name(render$A, "render$A");
script$B.render = render$A;
var script$A = {
  name: "TimesIcon",
  "extends": script$U
};
var _hoisted_1$P = /* @__PURE__ */ createBaseVNode("path", {
  d: "M8.01186 7.00933L12.27 2.75116C12.341 2.68501 12.398 2.60524 12.4375 2.51661C12.4769 2.42798 12.4982 2.3323 12.4999 2.23529C12.5016 2.13827 12.4838 2.0419 12.4474 1.95194C12.4111 1.86197 12.357 1.78024 12.2884 1.71163C12.2198 1.64302 12.138 1.58893 12.0481 1.55259C11.9581 1.51625 11.8617 1.4984 11.7647 1.50011C11.6677 1.50182 11.572 1.52306 11.4834 1.56255C11.3948 1.60204 11.315 1.65898 11.2488 1.72997L6.99067 5.98814L2.7325 1.72997C2.59553 1.60234 2.41437 1.53286 2.22718 1.53616C2.03999 1.53946 1.8614 1.61529 1.72901 1.74767C1.59663 1.88006 1.5208 2.05865 1.5175 2.24584C1.5142 2.43303 1.58368 2.61419 1.71131 2.75116L5.96948 7.00933L1.71131 11.2675C1.576 11.403 1.5 11.5866 1.5 11.7781C1.5 11.9696 1.576 12.1532 1.71131 12.2887C1.84679 12.424 2.03043 12.5 2.2219 12.5C2.41338 12.5 2.59702 12.424 2.7325 12.2887L6.99067 8.03052L11.2488 12.2887C11.3843 12.424 11.568 12.5 11.7594 12.5C11.9509 12.5 12.1346 12.424 12.27 12.2887C12.4053 12.1532 12.4813 11.9696 12.4813 11.7781C12.4813 11.5866 12.4053 11.403 12.27 11.2675L8.01186 7.00933Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$C = [_hoisted_1$P];
function render$z(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$C, 16);
}
__name(render$z, "render$z");
script$A.render = render$z;
var OverlayEventBus = EventBus();
var script$z = {
  name: "Portal",
  props: {
    appendTo: {
      type: [String, Object],
      "default": "body"
    },
    disabled: {
      type: Boolean,
      "default": false
    }
  },
  data: /* @__PURE__ */ __name(function data6() {
    return {
      mounted: false
    };
  }, "data"),
  mounted: /* @__PURE__ */ __name(function mounted6() {
    this.mounted = isClient$1();
  }, "mounted"),
  computed: {
    inline: /* @__PURE__ */ __name(function inline() {
      return this.disabled || this.appendTo === "self";
    }, "inline")
  }
};
function render$y(_ctx, _cache, $props, $setup, $data, $options) {
  return $options.inline ? renderSlot(_ctx.$slots, "default", {
    key: 0
  }) : $data.mounted ? (openBlock(), createBlock(Teleport, {
    key: 1,
    to: $props.appendTo
  }, [renderSlot(_ctx.$slots, "default")], 8, ["to"])) : createCommentVNode("", true);
}
__name(render$y, "render$y");
script$z.render = render$y;
var theme$l = /* @__PURE__ */ __name(function theme16(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-select {\n    display: inline-flex;\n    cursor: pointer;\n    position: relative;\n    user-select: none;\n    background: ".concat(dt3("select.background"), ";\n    border: 1px solid ").concat(dt3("select.border.color"), ";\n    transition: background ").concat(dt3("select.transition.duration"), ", color ").concat(dt3("select.transition.duration"), ", border-color ").concat(dt3("select.transition.duration"), ",\n        outline-color ").concat(dt3("select.transition.duration"), ", box-shadow ").concat(dt3("select.transition.duration"), ";\n    border-radius: ").concat(dt3("select.border.radius"), ";\n    outline-color: transparent;\n    box-shadow: ").concat(dt3("select.shadow"), ";\n}\n\n.p-select:not(.p-disabled):hover {\n    border-color: ").concat(dt3("select.hover.border.color"), ";\n}\n\n.p-select:not(.p-disabled).p-focus {\n    border-color: ").concat(dt3("select.focus.border.color"), ";\n    box-shadow: ").concat(dt3("select.focus.ring.shadow"), ";\n    outline: ").concat(dt3("select.focus.ring.width"), " ").concat(dt3("select.focus.ring.style"), " ").concat(dt3("select.focus.ring.color"), ";\n    outline-offset: ").concat(dt3("select.focus.ring.offset"), ";\n}\n\n.p-select.p-variant-filled {\n    background: ").concat(dt3("select.filled.background"), ";\n}\n\n.p-select.p-variant-filled.p-focus {\n    background: ").concat(dt3("select.filled.focus.background"), ";\n}\n\n.p-select.p-invalid {\n    border-color: ").concat(dt3("select.invalid.border.color"), ";\n}\n\n.p-select.p-disabled {\n    opacity: 1;\n    background: ").concat(dt3("select.disabled.background"), ";\n}\n\n.p-select-clear-icon {\n    position: absolute;\n    top: 50%;\n    margin-top: -0.5rem;\n    color: ").concat(dt3("select.clear.icon.color"), ";\n    right: ").concat(dt3("select.dropdown.width"), ";\n}\n\n.p-select-dropdown {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    flex-shrink: 0;\n    background: transparent;\n    color: ").concat(dt3("select.dropdown.color"), ";\n    width: ").concat(dt3("select.dropdown.width"), ";\n    border-top-right-radius: ").concat(dt3("select.border.radius"), ";\n    border-bottom-right-radius: ").concat(dt3("select.border.radius"), ";\n}\n\n.p-select-label {\n    display: block;\n    white-space: nowrap;\n    overflow: hidden;\n    flex: 1 1 auto;\n    width: 1%;\n    padding: ").concat(dt3("select.padding.y"), " ").concat(dt3("select.padding.x"), ";\n    text-overflow: ellipsis;\n    cursor: pointer;\n    color: ").concat(dt3("select.color"), ";\n    background: transparent;\n    border: 0 none;\n    outline: 0 none;\n}\n\n.p-select-label.p-placeholder {\n    color: ").concat(dt3("select.placeholder.color"), ";\n}\n\n.p-select:has(.p-select-clear-icon) .p-select-label {\n    padding-right: calc(1rem + ").concat(dt3("select.padding.x"), ");\n}\n\n.p-select.p-disabled .p-select-label {\n    color: ").concat(dt3("select.disabled.color"), ";\n}\n\n.p-select-label-empty {\n    overflow: hidden;\n    opacity: 0;\n}\n\ninput.p-select-label {\n    cursor: default;\n}\n\n.p-select .p-select-overlay {\n    min-width: 100%;\n}\n\n.p-select-overlay {\n    position: absolute;\n    top: 0;\n    left: 0;\n    background: ").concat(dt3("select.overlay.background"), ";\n    color: ").concat(dt3("select.overlay.color"), ";\n    border: 1px solid ").concat(dt3("select.overlay.border.color"), ";\n    border-radius: ").concat(dt3("select.overlay.border.radius"), ";\n    box-shadow: ").concat(dt3("select.overlay.shadow"), ";\n}\n\n.p-select-header {\n    padding: ").concat(dt3("select.list.header.padding"), ";\n}\n\n.p-select-filter {\n    width: 100%;\n}\n\n.p-select-list-container {\n    overflow: auto;\n}\n\n.p-select-option-group {\n    cursor: auto;\n    margin: 0;\n    padding: ").concat(dt3("select.option.group.padding"), ";\n    background: ").concat(dt3("select.option.group.background"), ";\n    color: ").concat(dt3("select.option.group.color"), ";\n    font-weight: ").concat(dt3("select.option.group.font.weight"), ";\n}\n\n.p-select-list {\n    margin: 0;\n    padding: 0;\n    list-style-type: none;\n    padding: ").concat(dt3("select.list.padding"), ";\n    gap: ").concat(dt3("select.list.gap"), ";\n    display: flex;\n    flex-direction: column;\n}\n\n.p-select-option {\n    cursor: pointer;\n    font-weight: normal;\n    white-space: nowrap;\n    position: relative;\n    overflow: hidden;\n    display: flex;\n    align-items: center;\n    padding: ").concat(dt3("select.option.padding"), ";\n    border: 0 none;\n    color: ").concat(dt3("select.option.color"), ";\n    background: transparent;\n    transition: background ").concat(dt3("select.transition.duration"), ", color ").concat(dt3("select.transition.duration"), ", border-color ").concat(dt3("select.transition.duration"), ",\n            box-shadow ").concat(dt3("select.transition.duration"), ", outline-color ").concat(dt3("select.transition.duration"), ";\n    border-radius: ").concat(dt3("select.option.border.radius"), ";\n}\n\n.p-select-option:not(.p-select-option-selected):not(.p-disabled).p-focus {\n    background: ").concat(dt3("select.option.focus.background"), ";\n    color: ").concat(dt3("select.option.focus.color"), ";\n}\n\n.p-select-option.p-select-option-selected {\n    background: ").concat(dt3("select.option.selected.background"), ";\n    color: ").concat(dt3("select.option.selected.color"), ";\n}\n\n.p-select-option.p-select-option-selected.p-focus {\n    background: ").concat(dt3("select.option.selected.focus.background"), ";\n    color: ").concat(dt3("select.option.selected.focus.color"), ";\n}\n\n.p-select-option-check-icon {\n    position: relative;\n    margin-inline-start: ").concat(dt3("select.checkmark.gutter.start"), ";\n    margin-inline-end: ").concat(dt3("select.checkmark.gutter.end"), ";\n    color: ").concat(dt3("select.checkmark.color"), ";\n}\n\n.p-select-empty-message {\n    padding: ").concat(dt3("select.empty.message.padding"), ";\n}\n\n.p-select-fluid {\n    display: flex;\n}\n");
}, "theme");
var classes$m = {
  root: /* @__PURE__ */ __name(function root10(_ref2) {
    var instance = _ref2.instance, props = _ref2.props, state = _ref2.state;
    return ["p-select p-component p-inputwrapper", {
      "p-disabled": props.disabled,
      "p-invalid": props.invalid,
      "p-variant-filled": props.variant ? props.variant === "filled" : instance.$primevue.config.inputStyle === "filled" || instance.$primevue.config.inputVariant === "filled",
      "p-focus": state.focused,
      "p-inputwrapper-filled": instance.hasSelectedOption,
      "p-inputwrapper-focus": state.focused || state.overlayVisible,
      "p-select-open": state.overlayVisible,
      "p-select-fluid": props.fluid
    }];
  }, "root"),
  label: /* @__PURE__ */ __name(function label(_ref3) {
    var instance = _ref3.instance, props = _ref3.props;
    return ["p-select-label", {
      "p-placeholder": !props.editable && instance.label === props.placeholder,
      "p-select-label-empty": !props.editable && !instance.$slots["value"] && (instance.label === "p-emptylabel" || instance.label.length === 0)
    }];
  }, "label"),
  clearIcon: "p-select-clear-icon",
  dropdown: "p-select-dropdown",
  loadingicon: "p-select-loading-icon",
  dropdownIcon: "p-select-dropdown-icon",
  overlay: "p-select-overlay p-component",
  header: "p-select-header",
  pcFilter: "p-select-filter",
  listContainer: "p-select-list-container",
  list: "p-select-list",
  optionGroup: "p-select-option-group",
  optionGroupLabel: "p-select-option-group-label",
  option: /* @__PURE__ */ __name(function option2(_ref4) {
    var instance = _ref4.instance, props = _ref4.props, state = _ref4.state, _option = _ref4.option, focusedOption = _ref4.focusedOption;
    return ["p-select-option", {
      "p-select-option-selected": instance.isSelected(_option) && props.highlightOnSelect,
      "p-focus": state.focusedOptionIndex === focusedOption,
      "p-disabled": instance.isOptionDisabled(_option)
    }];
  }, "option"),
  optionLabel: "p-select-option-label",
  optionCheckIcon: "p-select-option-check-icon",
  optionBlankIcon: "p-select-option-blank-icon",
  emptyMessage: "p-select-empty-message"
};
var SelectStyle = BaseStyle.extend({
  name: "select",
  theme: theme$l,
  classes: classes$m
});
var script$1$m = {
  name: "BaseSelect",
  "extends": script$X,
  props: {
    modelValue: null,
    options: Array,
    optionLabel: [String, Function],
    optionValue: [String, Function],
    optionDisabled: [String, Function],
    optionGroupLabel: [String, Function],
    optionGroupChildren: [String, Function],
    scrollHeight: {
      type: String,
      "default": "14rem"
    },
    filter: Boolean,
    filterPlaceholder: String,
    filterLocale: String,
    filterMatchMode: {
      type: String,
      "default": "contains"
    },
    filterFields: {
      type: Array,
      "default": null
    },
    editable: Boolean,
    placeholder: {
      type: String,
      "default": null
    },
    variant: {
      type: String,
      "default": null
    },
    invalid: {
      type: Boolean,
      "default": false
    },
    disabled: {
      type: Boolean,
      "default": false
    },
    dataKey: null,
    showClear: {
      type: Boolean,
      "default": false
    },
    fluid: {
      type: Boolean,
      "default": false
    },
    inputId: {
      type: String,
      "default": null
    },
    inputClass: {
      type: [String, Object],
      "default": null
    },
    inputStyle: {
      type: Object,
      "default": null
    },
    labelId: {
      type: String,
      "default": null
    },
    labelClass: {
      type: [String, Object],
      "default": null
    },
    labelStyle: {
      type: Object,
      "default": null
    },
    panelClass: {
      type: [String, Object],
      "default": null
    },
    overlayStyle: {
      type: Object,
      "default": null
    },
    overlayClass: {
      type: [String, Object],
      "default": null
    },
    panelStyle: {
      type: Object,
      "default": null
    },
    appendTo: {
      type: [String, Object],
      "default": "body"
    },
    loading: {
      type: Boolean,
      "default": false
    },
    clearIcon: {
      type: String,
      "default": void 0
    },
    dropdownIcon: {
      type: String,
      "default": void 0
    },
    filterIcon: {
      type: String,
      "default": void 0
    },
    loadingIcon: {
      type: String,
      "default": void 0
    },
    resetFilterOnHide: {
      type: Boolean,
      "default": false
    },
    resetFilterOnClear: {
      type: Boolean,
      "default": false
    },
    virtualScrollerOptions: {
      type: Object,
      "default": null
    },
    autoOptionFocus: {
      type: Boolean,
      "default": false
    },
    autoFilterFocus: {
      type: Boolean,
      "default": false
    },
    selectOnFocus: {
      type: Boolean,
      "default": false
    },
    focusOnHover: {
      type: Boolean,
      "default": true
    },
    highlightOnSelect: {
      type: Boolean,
      "default": true
    },
    checkmark: {
      type: Boolean,
      "default": false
    },
    filterMessage: {
      type: String,
      "default": null
    },
    selectionMessage: {
      type: String,
      "default": null
    },
    emptySelectionMessage: {
      type: String,
      "default": null
    },
    emptyFilterMessage: {
      type: String,
      "default": null
    },
    emptyMessage: {
      type: String,
      "default": null
    },
    tabindex: {
      type: Number,
      "default": 0
    },
    ariaLabel: {
      type: String,
      "default": null
    },
    ariaLabelledby: {
      type: String,
      "default": null
    }
  },
  style: SelectStyle,
  provide: /* @__PURE__ */ __name(function provide17() {
    return {
      $pcSelect: this,
      $parentInstance: this
    };
  }, "provide")
};
function _typeof$9(o) {
  "@babel/helpers - typeof";
  return _typeof$9 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$9(o);
}
__name(_typeof$9, "_typeof$9");
function _toConsumableArray$a(r) {
  return _arrayWithoutHoles$a(r) || _iterableToArray$a(r) || _unsupportedIterableToArray$c(r) || _nonIterableSpread$a();
}
__name(_toConsumableArray$a, "_toConsumableArray$a");
function _nonIterableSpread$a() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableSpread$a, "_nonIterableSpread$a");
function _unsupportedIterableToArray$c(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$c(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$c(r, a) : void 0;
  }
}
__name(_unsupportedIterableToArray$c, "_unsupportedIterableToArray$c");
function _iterableToArray$a(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
__name(_iterableToArray$a, "_iterableToArray$a");
function _arrayWithoutHoles$a(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$c(r);
}
__name(_arrayWithoutHoles$a, "_arrayWithoutHoles$a");
function _arrayLikeToArray$c(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
__name(_arrayLikeToArray$c, "_arrayLikeToArray$c");
function ownKeys$a(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
__name(ownKeys$a, "ownKeys$a");
function _objectSpread$a(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$a(Object(t), true).forEach(function(r2) {
      _defineProperty$9(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$a(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
__name(_objectSpread$a, "_objectSpread$a");
function _defineProperty$9(e, r, t) {
  return (r = _toPropertyKey$8(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty$9, "_defineProperty$9");
function _toPropertyKey$8(t) {
  var i2 = _toPrimitive$8(t, "string");
  return "symbol" == _typeof$9(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$8, "_toPropertyKey$8");
function _toPrimitive$8(t, r) {
  if ("object" != _typeof$9(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$9(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive$8, "_toPrimitive$8");
var script$y = {
  name: "Select",
  "extends": script$1$m,
  inheritAttrs: false,
  emits: ["update:modelValue", "change", "focus", "blur", "before-show", "before-hide", "show", "hide", "filter"],
  outsideClickListener: null,
  scrollHandler: null,
  resizeListener: null,
  labelClickListener: null,
  overlay: null,
  list: null,
  virtualScroller: null,
  searchTimeout: null,
  searchValue: null,
  isModelValueChanged: false,
  data: /* @__PURE__ */ __name(function data7() {
    return {
      id: this.$attrs.id,
      clicked: false,
      focused: false,
      focusedOptionIndex: -1,
      filterValue: null,
      overlayVisible: false
    };
  }, "data"),
  watch: {
    "$attrs.id": /* @__PURE__ */ __name(function $attrsId3(newValue) {
      this.id = newValue || UniqueComponentId();
    }, "$attrsId"),
    modelValue: /* @__PURE__ */ __name(function modelValue2() {
      this.isModelValueChanged = true;
    }, "modelValue"),
    options: /* @__PURE__ */ __name(function options2() {
      this.autoUpdateModel();
    }, "options")
  },
  mounted: /* @__PURE__ */ __name(function mounted7() {
    this.id = this.id || UniqueComponentId();
    this.autoUpdateModel();
    this.bindLabelClickListener();
  }, "mounted"),
  updated: /* @__PURE__ */ __name(function updated4() {
    if (this.overlayVisible && this.isModelValueChanged) {
      this.scrollInView(this.findSelectedOptionIndex());
    }
    this.isModelValueChanged = false;
  }, "updated"),
  beforeUnmount: /* @__PURE__ */ __name(function beforeUnmount2() {
    this.unbindOutsideClickListener();
    this.unbindResizeListener();
    this.unbindLabelClickListener();
    if (this.scrollHandler) {
      this.scrollHandler.destroy();
      this.scrollHandler = null;
    }
    if (this.overlay) {
      ZIndex.clear(this.overlay);
      this.overlay = null;
    }
  }, "beforeUnmount"),
  methods: {
    getOptionIndex: /* @__PURE__ */ __name(function getOptionIndex2(index2, fn) {
      return this.virtualScrollerDisabled ? index2 : fn && fn(index2)["index"];
    }, "getOptionIndex"),
    getOptionLabel: /* @__PURE__ */ __name(function getOptionLabel2(option4) {
      return this.optionLabel ? resolveFieldData(option4, this.optionLabel) : option4;
    }, "getOptionLabel"),
    getOptionValue: /* @__PURE__ */ __name(function getOptionValue3(option4) {
      return this.optionValue ? resolveFieldData(option4, this.optionValue) : option4;
    }, "getOptionValue"),
    getOptionRenderKey: /* @__PURE__ */ __name(function getOptionRenderKey2(option4, index2) {
      return (this.dataKey ? resolveFieldData(option4, this.dataKey) : this.getOptionLabel(option4)) + "_" + index2;
    }, "getOptionRenderKey"),
    getPTItemOptions: /* @__PURE__ */ __name(function getPTItemOptions(option4, itemOptions, index2, key) {
      return this.ptm(key, {
        context: {
          option: option4,
          index: index2,
          selected: this.isSelected(option4),
          focused: this.focusedOptionIndex === this.getOptionIndex(index2, itemOptions),
          disabled: this.isOptionDisabled(option4)
        }
      });
    }, "getPTItemOptions"),
    isOptionDisabled: /* @__PURE__ */ __name(function isOptionDisabled2(option4) {
      return this.optionDisabled ? resolveFieldData(option4, this.optionDisabled) : false;
    }, "isOptionDisabled"),
    isOptionGroup: /* @__PURE__ */ __name(function isOptionGroup2(option4) {
      return this.optionGroupLabel && option4.optionGroup && option4.group;
    }, "isOptionGroup"),
    getOptionGroupLabel: /* @__PURE__ */ __name(function getOptionGroupLabel2(optionGroup) {
      return resolveFieldData(optionGroup, this.optionGroupLabel);
    }, "getOptionGroupLabel"),
    getOptionGroupChildren: /* @__PURE__ */ __name(function getOptionGroupChildren2(optionGroup) {
      return resolveFieldData(optionGroup, this.optionGroupChildren);
    }, "getOptionGroupChildren"),
    getAriaPosInset: /* @__PURE__ */ __name(function getAriaPosInset2(index2) {
      var _this = this;
      return (this.optionGroupLabel ? index2 - this.visibleOptions.slice(0, index2).filter(function(option4) {
        return _this.isOptionGroup(option4);
      }).length : index2) + 1;
    }, "getAriaPosInset"),
    show: /* @__PURE__ */ __name(function show2(isFocus) {
      this.$emit("before-show");
      this.overlayVisible = true;
      this.focusedOptionIndex = this.focusedOptionIndex !== -1 ? this.focusedOptionIndex : this.autoOptionFocus ? this.findFirstFocusedOptionIndex() : this.editable ? -1 : this.findSelectedOptionIndex();
      isFocus && focus(this.$refs.focusInput);
    }, "show"),
    hide: /* @__PURE__ */ __name(function hide2(isFocus) {
      var _this2 = this;
      var _hide = /* @__PURE__ */ __name(function _hide2() {
        _this2.$emit("before-hide");
        _this2.overlayVisible = false;
        _this2.clicked = false;
        _this2.focusedOptionIndex = -1;
        _this2.searchValue = "";
        _this2.resetFilterOnHide && (_this2.filterValue = null);
        isFocus && focus(_this2.$refs.focusInput);
      }, "_hide");
      setTimeout(function() {
        _hide();
      }, 0);
    }, "hide"),
    onFocus: /* @__PURE__ */ __name(function onFocus2(event2) {
      if (this.disabled) {
        return;
      }
      this.focused = true;
      if (this.overlayVisible) {
        this.focusedOptionIndex = this.focusedOptionIndex !== -1 ? this.focusedOptionIndex : this.autoOptionFocus ? this.findFirstFocusedOptionIndex() : this.editable ? -1 : this.findSelectedOptionIndex();
        this.scrollInView(this.focusedOptionIndex);
      }
      this.$emit("focus", event2);
    }, "onFocus"),
    onBlur: /* @__PURE__ */ __name(function onBlur2(event2) {
      this.focused = false;
      this.focusedOptionIndex = -1;
      this.searchValue = "";
      this.$emit("blur", event2);
    }, "onBlur"),
    onKeyDown: /* @__PURE__ */ __name(function onKeyDown2(event2) {
      if (this.disabled || isAndroid$1()) {
        event2.preventDefault();
        return;
      }
      var metaKey = event2.metaKey || event2.ctrlKey;
      switch (event2.code) {
        case "ArrowDown":
          this.onArrowDownKey(event2);
          break;
        case "ArrowUp":
          this.onArrowUpKey(event2, this.editable);
          break;
        case "ArrowLeft":
        case "ArrowRight":
          this.onArrowLeftKey(event2, this.editable);
          break;
        case "Home":
          this.onHomeKey(event2, this.editable);
          break;
        case "End":
          this.onEndKey(event2, this.editable);
          break;
        case "PageDown":
          this.onPageDownKey(event2);
          break;
        case "PageUp":
          this.onPageUpKey(event2);
          break;
        case "Space":
          this.onSpaceKey(event2, this.editable);
          break;
        case "Enter":
        case "NumpadEnter":
          this.onEnterKey(event2);
          break;
        case "Escape":
          this.onEscapeKey(event2);
          break;
        case "Tab":
          this.onTabKey(event2);
          break;
        case "Backspace":
          this.onBackspaceKey(event2, this.editable);
          break;
        case "ShiftLeft":
        case "ShiftRight":
          break;
        default:
          if (!metaKey && isPrintableCharacter(event2.key)) {
            !this.overlayVisible && this.show();
            !this.editable && this.searchOptions(event2, event2.key);
          }
          break;
      }
      this.clicked = false;
    }, "onKeyDown"),
    onEditableInput: /* @__PURE__ */ __name(function onEditableInput(event2) {
      var value3 = event2.target.value;
      this.searchValue = "";
      var matched = this.searchOptions(event2, value3);
      !matched && (this.focusedOptionIndex = -1);
      this.updateModel(event2, value3);
      !this.overlayVisible && isNotEmpty(value3) && this.show();
    }, "onEditableInput"),
    onContainerClick: /* @__PURE__ */ __name(function onContainerClick(event2) {
      if (this.disabled || this.loading) {
        return;
      }
      if (event2.target.tagName === "INPUT" || event2.target.getAttribute("data-pc-section") === "clearicon" || event2.target.closest('[data-pc-section="clearicon"]')) {
        return;
      } else if (!this.overlay || !this.overlay.contains(event2.target)) {
        this.overlayVisible ? this.hide(true) : this.show(true);
      }
      this.clicked = true;
    }, "onContainerClick"),
    onClearClick: /* @__PURE__ */ __name(function onClearClick(event2) {
      this.updateModel(event2, null);
      this.resetFilterOnClear && (this.filterValue = null);
    }, "onClearClick"),
    onFirstHiddenFocus: /* @__PURE__ */ __name(function onFirstHiddenFocus2(event2) {
      var focusableEl = event2.relatedTarget === this.$refs.focusInput ? getFirstFocusableElement(this.overlay, ':not([data-p-hidden-focusable="true"])') : this.$refs.focusInput;
      focus(focusableEl);
    }, "onFirstHiddenFocus"),
    onLastHiddenFocus: /* @__PURE__ */ __name(function onLastHiddenFocus2(event2) {
      var focusableEl = event2.relatedTarget === this.$refs.focusInput ? getLastFocusableElement(this.overlay, ':not([data-p-hidden-focusable="true"])') : this.$refs.focusInput;
      focus(focusableEl);
    }, "onLastHiddenFocus"),
    onOptionSelect: /* @__PURE__ */ __name(function onOptionSelect2(event2, option4) {
      var isHide = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      var value3 = this.getOptionValue(option4);
      this.updateModel(event2, value3);
      isHide && this.hide(true);
    }, "onOptionSelect"),
    onOptionMouseMove: /* @__PURE__ */ __name(function onOptionMouseMove2(event2, index2) {
      if (this.focusOnHover) {
        this.changeFocusedOptionIndex(event2, index2);
      }
    }, "onOptionMouseMove"),
    onFilterChange: /* @__PURE__ */ __name(function onFilterChange2(event2) {
      var value3 = event2.target.value;
      this.filterValue = value3;
      this.focusedOptionIndex = -1;
      this.$emit("filter", {
        originalEvent: event2,
        value: value3
      });
      !this.virtualScrollerDisabled && this.virtualScroller.scrollToIndex(0);
    }, "onFilterChange"),
    onFilterKeyDown: /* @__PURE__ */ __name(function onFilterKeyDown2(event2) {
      switch (event2.code) {
        case "ArrowDown":
          this.onArrowDownKey(event2);
          break;
        case "ArrowUp":
          this.onArrowUpKey(event2, true);
          break;
        case "ArrowLeft":
        case "ArrowRight":
          this.onArrowLeftKey(event2, true);
          break;
        case "Home":
          this.onHomeKey(event2, true);
          break;
        case "End":
          this.onEndKey(event2, true);
          break;
        case "Enter":
        case "NumpadEnter":
          this.onEnterKey(event2);
          break;
        case "Escape":
          this.onEscapeKey(event2);
          break;
        case "Tab":
          this.onTabKey(event2, true);
          break;
      }
    }, "onFilterKeyDown"),
    onFilterBlur: /* @__PURE__ */ __name(function onFilterBlur2() {
      this.focusedOptionIndex = -1;
    }, "onFilterBlur"),
    onFilterUpdated: /* @__PURE__ */ __name(function onFilterUpdated() {
      if (this.overlayVisible) {
        this.alignOverlay();
      }
    }, "onFilterUpdated"),
    onOverlayClick: /* @__PURE__ */ __name(function onOverlayClick(event2) {
      OverlayEventBus.emit("overlay-click", {
        originalEvent: event2,
        target: this.$el
      });
    }, "onOverlayClick"),
    onOverlayKeyDown: /* @__PURE__ */ __name(function onOverlayKeyDown(event2) {
      switch (event2.code) {
        case "Escape":
          this.onEscapeKey(event2);
          break;
      }
    }, "onOverlayKeyDown"),
    onArrowDownKey: /* @__PURE__ */ __name(function onArrowDownKey2(event2) {
      if (!this.overlayVisible) {
        this.show();
        this.editable && this.changeFocusedOptionIndex(event2, this.findSelectedOptionIndex());
      } else {
        var optionIndex = this.focusedOptionIndex !== -1 ? this.findNextOptionIndex(this.focusedOptionIndex) : this.clicked ? this.findFirstOptionIndex() : this.findFirstFocusedOptionIndex();
        this.changeFocusedOptionIndex(event2, optionIndex);
      }
      event2.preventDefault();
    }, "onArrowDownKey"),
    onArrowUpKey: /* @__PURE__ */ __name(function onArrowUpKey2(event2) {
      var pressedInInputText = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (event2.altKey && !pressedInInputText) {
        if (this.focusedOptionIndex !== -1) {
          this.onOptionSelect(event2, this.visibleOptions[this.focusedOptionIndex]);
        }
        this.overlayVisible && this.hide();
        event2.preventDefault();
      } else {
        var optionIndex = this.focusedOptionIndex !== -1 ? this.findPrevOptionIndex(this.focusedOptionIndex) : this.clicked ? this.findLastOptionIndex() : this.findLastFocusedOptionIndex();
        this.changeFocusedOptionIndex(event2, optionIndex);
        !this.overlayVisible && this.show();
        event2.preventDefault();
      }
    }, "onArrowUpKey"),
    onArrowLeftKey: /* @__PURE__ */ __name(function onArrowLeftKey2(event2) {
      var pressedInInputText = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      pressedInInputText && (this.focusedOptionIndex = -1);
    }, "onArrowLeftKey"),
    onHomeKey: /* @__PURE__ */ __name(function onHomeKey2(event2) {
      var pressedInInputText = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (pressedInInputText) {
        var target = event2.currentTarget;
        if (event2.shiftKey) {
          target.setSelectionRange(0, event2.target.selectionStart);
        } else {
          target.setSelectionRange(0, 0);
          this.focusedOptionIndex = -1;
        }
      } else {
        this.changeFocusedOptionIndex(event2, this.findFirstOptionIndex());
        !this.overlayVisible && this.show();
      }
      event2.preventDefault();
    }, "onHomeKey"),
    onEndKey: /* @__PURE__ */ __name(function onEndKey2(event2) {
      var pressedInInputText = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (pressedInInputText) {
        var target = event2.currentTarget;
        if (event2.shiftKey) {
          target.setSelectionRange(event2.target.selectionStart, target.value.length);
        } else {
          var len = target.value.length;
          target.setSelectionRange(len, len);
          this.focusedOptionIndex = -1;
        }
      } else {
        this.changeFocusedOptionIndex(event2, this.findLastOptionIndex());
        !this.overlayVisible && this.show();
      }
      event2.preventDefault();
    }, "onEndKey"),
    onPageUpKey: /* @__PURE__ */ __name(function onPageUpKey2(event2) {
      this.scrollInView(0);
      event2.preventDefault();
    }, "onPageUpKey"),
    onPageDownKey: /* @__PURE__ */ __name(function onPageDownKey2(event2) {
      this.scrollInView(this.visibleOptions.length - 1);
      event2.preventDefault();
    }, "onPageDownKey"),
    onEnterKey: /* @__PURE__ */ __name(function onEnterKey2(event2) {
      if (!this.overlayVisible) {
        this.focusedOptionIndex = -1;
        this.onArrowDownKey(event2);
      } else {
        if (this.focusedOptionIndex !== -1) {
          this.onOptionSelect(event2, this.visibleOptions[this.focusedOptionIndex]);
        }
        this.hide();
      }
      event2.preventDefault();
    }, "onEnterKey"),
    onSpaceKey: /* @__PURE__ */ __name(function onSpaceKey2(event2) {
      var pressedInInputText = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      !pressedInInputText && this.onEnterKey(event2);
    }, "onSpaceKey"),
    onEscapeKey: /* @__PURE__ */ __name(function onEscapeKey(event2) {
      this.overlayVisible && this.hide(true);
      event2.preventDefault();
      event2.stopPropagation();
    }, "onEscapeKey"),
    onTabKey: /* @__PURE__ */ __name(function onTabKey(event2) {
      var pressedInInputText = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (!pressedInInputText) {
        if (this.overlayVisible && this.hasFocusableElements()) {
          focus(this.$refs.firstHiddenFocusableElementOnOverlay);
          event2.preventDefault();
        } else {
          if (this.focusedOptionIndex !== -1) {
            this.onOptionSelect(event2, this.visibleOptions[this.focusedOptionIndex]);
          }
          this.overlayVisible && this.hide(this.filter);
        }
      }
    }, "onTabKey"),
    onBackspaceKey: /* @__PURE__ */ __name(function onBackspaceKey(event2) {
      var pressedInInputText = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (pressedInInputText) {
        !this.overlayVisible && this.show();
      }
    }, "onBackspaceKey"),
    onOverlayEnter: /* @__PURE__ */ __name(function onOverlayEnter(el) {
      ZIndex.set("overlay", el, this.$primevue.config.zIndex.overlay);
      addStyle(el, {
        position: "absolute",
        top: "0",
        left: "0"
      });
      this.alignOverlay();
      this.scrollInView();
      this.autoFilterFocus && focus(this.$refs.filterInput.$el);
    }, "onOverlayEnter"),
    onOverlayAfterEnter: /* @__PURE__ */ __name(function onOverlayAfterEnter() {
      this.bindOutsideClickListener();
      this.bindScrollListener();
      this.bindResizeListener();
      this.$emit("show");
    }, "onOverlayAfterEnter"),
    onOverlayLeave: /* @__PURE__ */ __name(function onOverlayLeave() {
      this.unbindOutsideClickListener();
      this.unbindScrollListener();
      this.unbindResizeListener();
      this.$emit("hide");
      this.overlay = null;
    }, "onOverlayLeave"),
    onOverlayAfterLeave: /* @__PURE__ */ __name(function onOverlayAfterLeave(el) {
      ZIndex.clear(el);
    }, "onOverlayAfterLeave"),
    alignOverlay: /* @__PURE__ */ __name(function alignOverlay2() {
      if (this.appendTo === "self") {
        relativePosition(this.overlay, this.$el);
      } else {
        this.overlay.style.minWidth = getOuterWidth(this.$el) + "px";
        absolutePosition(this.overlay, this.$el);
      }
    }, "alignOverlay"),
    bindOutsideClickListener: /* @__PURE__ */ __name(function bindOutsideClickListener() {
      var _this3 = this;
      if (!this.outsideClickListener) {
        this.outsideClickListener = function(event2) {
          if (_this3.overlayVisible && _this3.overlay && !_this3.$el.contains(event2.target) && !_this3.overlay.contains(event2.target)) {
            _this3.hide();
          }
        };
        document.addEventListener("click", this.outsideClickListener);
      }
    }, "bindOutsideClickListener"),
    unbindOutsideClickListener: /* @__PURE__ */ __name(function unbindOutsideClickListener() {
      if (this.outsideClickListener) {
        document.removeEventListener("click", this.outsideClickListener);
        this.outsideClickListener = null;
      }
    }, "unbindOutsideClickListener"),
    bindScrollListener: /* @__PURE__ */ __name(function bindScrollListener2() {
      var _this4 = this;
      if (!this.scrollHandler) {
        this.scrollHandler = new ConnectedOverlayScrollHandler(this.$refs.container, function() {
          if (_this4.overlayVisible) {
            _this4.hide();
          }
        });
      }
      this.scrollHandler.bindScrollListener();
    }, "bindScrollListener"),
    unbindScrollListener: /* @__PURE__ */ __name(function unbindScrollListener2() {
      if (this.scrollHandler) {
        this.scrollHandler.unbindScrollListener();
      }
    }, "unbindScrollListener"),
    bindResizeListener: /* @__PURE__ */ __name(function bindResizeListener2() {
      var _this5 = this;
      if (!this.resizeListener) {
        this.resizeListener = function() {
          if (_this5.overlayVisible && !isTouchDevice()) {
            _this5.hide();
          }
        };
        window.addEventListener("resize", this.resizeListener);
      }
    }, "bindResizeListener"),
    unbindResizeListener: /* @__PURE__ */ __name(function unbindResizeListener2() {
      if (this.resizeListener) {
        window.removeEventListener("resize", this.resizeListener);
        this.resizeListener = null;
      }
    }, "unbindResizeListener"),
    bindLabelClickListener: /* @__PURE__ */ __name(function bindLabelClickListener() {
      var _this6 = this;
      if (!this.editable && !this.labelClickListener) {
        var label5 = document.querySelector('label[for="'.concat(this.inputId, '"]'));
        if (label5 && isVisible(label5)) {
          this.labelClickListener = function() {
            focus(_this6.$refs.focusInput);
          };
          label5.addEventListener("click", this.labelClickListener);
        }
      }
    }, "bindLabelClickListener"),
    unbindLabelClickListener: /* @__PURE__ */ __name(function unbindLabelClickListener() {
      if (this.labelClickListener) {
        var label5 = document.querySelector('label[for="'.concat(this.inputId, '"]'));
        if (label5 && isVisible(label5)) {
          label5.removeEventListener("click", this.labelClickListener);
        }
      }
    }, "unbindLabelClickListener"),
    hasFocusableElements: /* @__PURE__ */ __name(function hasFocusableElements() {
      return getFocusableElements(this.overlay, ':not([data-p-hidden-focusable="true"])').length > 0;
    }, "hasFocusableElements"),
    isOptionMatched: /* @__PURE__ */ __name(function isOptionMatched2(option4) {
      var _this$getOptionLabel;
      return this.isValidOption(option4) && typeof this.getOptionLabel(option4) === "string" && ((_this$getOptionLabel = this.getOptionLabel(option4)) === null || _this$getOptionLabel === void 0 ? void 0 : _this$getOptionLabel.toLocaleLowerCase(this.filterLocale).startsWith(this.searchValue.toLocaleLowerCase(this.filterLocale)));
    }, "isOptionMatched"),
    isValidOption: /* @__PURE__ */ __name(function isValidOption2(option4) {
      return isNotEmpty(option4) && !(this.isOptionDisabled(option4) || this.isOptionGroup(option4));
    }, "isValidOption"),
    isValidSelectedOption: /* @__PURE__ */ __name(function isValidSelectedOption2(option4) {
      return this.isValidOption(option4) && this.isSelected(option4);
    }, "isValidSelectedOption"),
    isSelected: /* @__PURE__ */ __name(function isSelected2(option4) {
      return this.isValidOption(option4) && equals(this.modelValue, this.getOptionValue(option4), this.equalityKey);
    }, "isSelected"),
    findFirstOptionIndex: /* @__PURE__ */ __name(function findFirstOptionIndex2() {
      var _this7 = this;
      return this.visibleOptions.findIndex(function(option4) {
        return _this7.isValidOption(option4);
      });
    }, "findFirstOptionIndex"),
    findLastOptionIndex: /* @__PURE__ */ __name(function findLastOptionIndex2() {
      var _this8 = this;
      return findLastIndex(this.visibleOptions, function(option4) {
        return _this8.isValidOption(option4);
      });
    }, "findLastOptionIndex"),
    findNextOptionIndex: /* @__PURE__ */ __name(function findNextOptionIndex2(index2) {
      var _this9 = this;
      var matchedOptionIndex = index2 < this.visibleOptions.length - 1 ? this.visibleOptions.slice(index2 + 1).findIndex(function(option4) {
        return _this9.isValidOption(option4);
      }) : -1;
      return matchedOptionIndex > -1 ? matchedOptionIndex + index2 + 1 : index2;
    }, "findNextOptionIndex"),
    findPrevOptionIndex: /* @__PURE__ */ __name(function findPrevOptionIndex2(index2) {
      var _this10 = this;
      var matchedOptionIndex = index2 > 0 ? findLastIndex(this.visibleOptions.slice(0, index2), function(option4) {
        return _this10.isValidOption(option4);
      }) : -1;
      return matchedOptionIndex > -1 ? matchedOptionIndex : index2;
    }, "findPrevOptionIndex"),
    findSelectedOptionIndex: /* @__PURE__ */ __name(function findSelectedOptionIndex2() {
      var _this11 = this;
      return this.hasSelectedOption ? this.visibleOptions.findIndex(function(option4) {
        return _this11.isValidSelectedOption(option4);
      }) : -1;
    }, "findSelectedOptionIndex"),
    findFirstFocusedOptionIndex: /* @__PURE__ */ __name(function findFirstFocusedOptionIndex2() {
      var selectedIndex = this.findSelectedOptionIndex();
      return selectedIndex < 0 ? this.findFirstOptionIndex() : selectedIndex;
    }, "findFirstFocusedOptionIndex"),
    findLastFocusedOptionIndex: /* @__PURE__ */ __name(function findLastFocusedOptionIndex2() {
      var selectedIndex = this.findSelectedOptionIndex();
      return selectedIndex < 0 ? this.findLastOptionIndex() : selectedIndex;
    }, "findLastFocusedOptionIndex"),
    searchOptions: /* @__PURE__ */ __name(function searchOptions2(event2, _char) {
      var _this12 = this;
      this.searchValue = (this.searchValue || "") + _char;
      var optionIndex = -1;
      var matched = false;
      if (isNotEmpty(this.searchValue)) {
        if (this.focusedOptionIndex !== -1) {
          optionIndex = this.visibleOptions.slice(this.focusedOptionIndex).findIndex(function(option4) {
            return _this12.isOptionMatched(option4);
          });
          optionIndex = optionIndex === -1 ? this.visibleOptions.slice(0, this.focusedOptionIndex).findIndex(function(option4) {
            return _this12.isOptionMatched(option4);
          }) : optionIndex + this.focusedOptionIndex;
        } else {
          optionIndex = this.visibleOptions.findIndex(function(option4) {
            return _this12.isOptionMatched(option4);
          });
        }
        if (optionIndex !== -1) {
          matched = true;
        }
        if (optionIndex === -1 && this.focusedOptionIndex === -1) {
          optionIndex = this.findFirstFocusedOptionIndex();
        }
        if (optionIndex !== -1) {
          this.changeFocusedOptionIndex(event2, optionIndex);
        }
      }
      if (this.searchTimeout) {
        clearTimeout(this.searchTimeout);
      }
      this.searchTimeout = setTimeout(function() {
        _this12.searchValue = "";
        _this12.searchTimeout = null;
      }, 500);
      return matched;
    }, "searchOptions"),
    changeFocusedOptionIndex: /* @__PURE__ */ __name(function changeFocusedOptionIndex2(event2, index2) {
      if (this.focusedOptionIndex !== index2) {
        this.focusedOptionIndex = index2;
        this.scrollInView();
        if (this.selectOnFocus) {
          this.onOptionSelect(event2, this.visibleOptions[index2], false);
        }
      }
    }, "changeFocusedOptionIndex"),
    scrollInView: /* @__PURE__ */ __name(function scrollInView4() {
      var _this13 = this;
      var index2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : -1;
      this.$nextTick(function() {
        var id2 = index2 !== -1 ? "".concat(_this13.id, "_").concat(index2) : _this13.focusedOptionId;
        var element = findSingle(_this13.list, 'li[id="'.concat(id2, '"]'));
        if (element) {
          element.scrollIntoView && element.scrollIntoView({
            block: "nearest",
            inline: "start"
          });
        } else if (!_this13.virtualScrollerDisabled) {
          _this13.virtualScroller && _this13.virtualScroller.scrollToIndex(index2 !== -1 ? index2 : _this13.focusedOptionIndex);
        }
      });
    }, "scrollInView"),
    autoUpdateModel: /* @__PURE__ */ __name(function autoUpdateModel2() {
      if (this.selectOnFocus && this.autoOptionFocus && !this.hasSelectedOption) {
        this.focusedOptionIndex = this.findFirstFocusedOptionIndex();
        this.onOptionSelect(null, this.visibleOptions[this.focusedOptionIndex], false);
      }
    }, "autoUpdateModel"),
    updateModel: /* @__PURE__ */ __name(function updateModel3(event2, value3) {
      this.$emit("update:modelValue", value3);
      this.$emit("change", {
        originalEvent: event2,
        value: value3
      });
    }, "updateModel"),
    flatOptions: /* @__PURE__ */ __name(function flatOptions2(options3) {
      var _this14 = this;
      return (options3 || []).reduce(function(result, option4, index2) {
        result.push({
          optionGroup: option4,
          group: true,
          index: index2
        });
        var optionGroupChildren = _this14.getOptionGroupChildren(option4);
        optionGroupChildren && optionGroupChildren.forEach(function(o) {
          return result.push(o);
        });
        return result;
      }, []);
    }, "flatOptions"),
    overlayRef: /* @__PURE__ */ __name(function overlayRef(el) {
      this.overlay = el;
    }, "overlayRef"),
    listRef: /* @__PURE__ */ __name(function listRef2(el, contentRef3) {
      this.list = el;
      contentRef3 && contentRef3(el);
    }, "listRef"),
    virtualScrollerRef: /* @__PURE__ */ __name(function virtualScrollerRef2(el) {
      this.virtualScroller = el;
    }, "virtualScrollerRef")
  },
  computed: {
    visibleOptions: /* @__PURE__ */ __name(function visibleOptions2() {
      var _this15 = this;
      var options3 = this.optionGroupLabel ? this.flatOptions(this.options) : this.options || [];
      if (this.filterValue) {
        var filteredOptions = FilterService.filter(options3, this.searchFields, this.filterValue, this.filterMatchMode, this.filterLocale);
        if (this.optionGroupLabel) {
          var optionGroups = this.options || [];
          var filtered = [];
          optionGroups.forEach(function(group) {
            var groupChildren = _this15.getOptionGroupChildren(group);
            var filteredItems = groupChildren.filter(function(item2) {
              return filteredOptions.includes(item2);
            });
            if (filteredItems.length > 0) filtered.push(_objectSpread$a(_objectSpread$a({}, group), {}, _defineProperty$9({}, typeof _this15.optionGroupChildren === "string" ? _this15.optionGroupChildren : "items", _toConsumableArray$a(filteredItems))));
          });
          return this.flatOptions(filtered);
        }
        return filteredOptions;
      }
      return options3;
    }, "visibleOptions"),
    hasSelectedOption: /* @__PURE__ */ __name(function hasSelectedOption2() {
      return isNotEmpty(this.modelValue);
    }, "hasSelectedOption"),
    label: /* @__PURE__ */ __name(function label2() {
      var selectedOptionIndex = this.findSelectedOptionIndex();
      return selectedOptionIndex !== -1 ? this.getOptionLabel(this.visibleOptions[selectedOptionIndex]) : this.placeholder || "p-emptylabel";
    }, "label"),
    editableInputValue: /* @__PURE__ */ __name(function editableInputValue() {
      var selectedOptionIndex = this.findSelectedOptionIndex();
      return selectedOptionIndex !== -1 ? this.getOptionLabel(this.visibleOptions[selectedOptionIndex]) : this.modelValue || "";
    }, "editableInputValue"),
    equalityKey: /* @__PURE__ */ __name(function equalityKey2() {
      return this.optionValue ? null : this.dataKey;
    }, "equalityKey"),
    searchFields: /* @__PURE__ */ __name(function searchFields2() {
      return this.filterFields || [this.optionLabel];
    }, "searchFields"),
    filterResultMessageText: /* @__PURE__ */ __name(function filterResultMessageText2() {
      return isNotEmpty(this.visibleOptions) ? this.filterMessageText.replaceAll("{0}", this.visibleOptions.length) : this.emptyFilterMessageText;
    }, "filterResultMessageText"),
    filterMessageText: /* @__PURE__ */ __name(function filterMessageText2() {
      return this.filterMessage || this.$primevue.config.locale.searchMessage || "";
    }, "filterMessageText"),
    emptyFilterMessageText: /* @__PURE__ */ __name(function emptyFilterMessageText2() {
      return this.emptyFilterMessage || this.$primevue.config.locale.emptySearchMessage || this.$primevue.config.locale.emptyFilterMessage || "";
    }, "emptyFilterMessageText"),
    emptyMessageText: /* @__PURE__ */ __name(function emptyMessageText2() {
      return this.emptyMessage || this.$primevue.config.locale.emptyMessage || "";
    }, "emptyMessageText"),
    selectionMessageText: /* @__PURE__ */ __name(function selectionMessageText2() {
      return this.selectionMessage || this.$primevue.config.locale.selectionMessage || "";
    }, "selectionMessageText"),
    emptySelectionMessageText: /* @__PURE__ */ __name(function emptySelectionMessageText2() {
      return this.emptySelectionMessage || this.$primevue.config.locale.emptySelectionMessage || "";
    }, "emptySelectionMessageText"),
    selectedMessageText: /* @__PURE__ */ __name(function selectedMessageText2() {
      return this.hasSelectedOption ? this.selectionMessageText.replaceAll("{0}", "1") : this.emptySelectionMessageText;
    }, "selectedMessageText"),
    focusedOptionId: /* @__PURE__ */ __name(function focusedOptionId2() {
      return this.focusedOptionIndex !== -1 ? "".concat(this.id, "_").concat(this.focusedOptionIndex) : null;
    }, "focusedOptionId"),
    ariaSetSize: /* @__PURE__ */ __name(function ariaSetSize2() {
      var _this16 = this;
      return this.visibleOptions.filter(function(option4) {
        return !_this16.isOptionGroup(option4);
      }).length;
    }, "ariaSetSize"),
    virtualScrollerDisabled: /* @__PURE__ */ __name(function virtualScrollerDisabled2() {
      return !this.virtualScrollerOptions;
    }, "virtualScrollerDisabled")
  },
  directives: {
    ripple: Ripple
  },
  components: {
    InputText: script$O,
    VirtualScroller: script$M,
    Portal: script$z,
    InputIcon: script$P,
    IconField: script$Q,
    TimesIcon: script$A,
    ChevronDownIcon: script$B,
    SpinnerIcon: script$N,
    SearchIcon: script$R,
    CheckIcon: script$S,
    BlankIcon: script$T
  }
};
var _hoisted_1$O = ["id"];
var _hoisted_2$B = ["id", "value", "placeholder", "tabindex", "disabled", "aria-label", "aria-labelledby", "aria-expanded", "aria-controls", "aria-activedescendant", "aria-invalid"];
var _hoisted_3$i = ["id", "tabindex", "aria-label", "aria-labelledby", "aria-expanded", "aria-controls", "aria-activedescendant", "aria-disabled"];
var _hoisted_4$b = ["id"];
var _hoisted_5$7 = ["id"];
var _hoisted_6$6 = ["id", "aria-label", "aria-selected", "aria-disabled", "aria-setsize", "aria-posinset", "onClick", "onMousemove", "data-p-selected", "data-p-focused", "data-p-disabled"];
function render$x(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_SpinnerIcon = resolveComponent("SpinnerIcon");
  var _component_InputText = resolveComponent("InputText");
  var _component_SearchIcon = resolveComponent("SearchIcon");
  var _component_InputIcon = resolveComponent("InputIcon");
  var _component_IconField = resolveComponent("IconField");
  var _component_CheckIcon = resolveComponent("CheckIcon");
  var _component_BlankIcon = resolveComponent("BlankIcon");
  var _component_VirtualScroller = resolveComponent("VirtualScroller");
  var _component_Portal = resolveComponent("Portal");
  var _directive_ripple = resolveDirective("ripple");
  return openBlock(), createElementBlock("div", mergeProps({
    ref: "container",
    id: $data.id,
    "class": _ctx.cx("root"),
    onClick: _cache[11] || (_cache[11] = function() {
      return $options.onContainerClick && $options.onContainerClick.apply($options, arguments);
    })
  }, _ctx.ptmi("root")), [_ctx.editable ? (openBlock(), createElementBlock("input", mergeProps({
    key: 0,
    ref: "focusInput",
    id: _ctx.labelId || _ctx.inputId,
    type: "text",
    "class": [_ctx.cx("label"), _ctx.inputClass, _ctx.labelClass],
    style: [_ctx.inputStyle, _ctx.labelStyle],
    value: $options.editableInputValue,
    placeholder: _ctx.placeholder,
    tabindex: !_ctx.disabled ? _ctx.tabindex : -1,
    disabled: _ctx.disabled,
    autocomplete: "off",
    role: "combobox",
    "aria-label": _ctx.ariaLabel,
    "aria-labelledby": _ctx.ariaLabelledby,
    "aria-haspopup": "listbox",
    "aria-expanded": $data.overlayVisible,
    "aria-controls": $data.id + "_list",
    "aria-activedescendant": $data.focused ? $options.focusedOptionId : void 0,
    "aria-invalid": _ctx.invalid || void 0,
    onFocus: _cache[0] || (_cache[0] = function() {
      return $options.onFocus && $options.onFocus.apply($options, arguments);
    }),
    onBlur: _cache[1] || (_cache[1] = function() {
      return $options.onBlur && $options.onBlur.apply($options, arguments);
    }),
    onKeydown: _cache[2] || (_cache[2] = function() {
      return $options.onKeyDown && $options.onKeyDown.apply($options, arguments);
    }),
    onInput: _cache[3] || (_cache[3] = function() {
      return $options.onEditableInput && $options.onEditableInput.apply($options, arguments);
    })
  }, _ctx.ptm("label")), null, 16, _hoisted_2$B)) : (openBlock(), createElementBlock("span", mergeProps({
    key: 1,
    ref: "focusInput",
    id: _ctx.labelId || _ctx.inputId,
    "class": [_ctx.cx("label"), _ctx.inputClass, _ctx.labelClass],
    style: [_ctx.inputStyle, _ctx.labelStyle],
    tabindex: !_ctx.disabled ? _ctx.tabindex : -1,
    role: "combobox",
    "aria-label": _ctx.ariaLabel || ($options.label === "p-emptylabel" ? void 0 : $options.label),
    "aria-labelledby": _ctx.ariaLabelledby,
    "aria-haspopup": "listbox",
    "aria-expanded": $data.overlayVisible,
    "aria-controls": $data.id + "_list",
    "aria-activedescendant": $data.focused ? $options.focusedOptionId : void 0,
    "aria-disabled": _ctx.disabled,
    onFocus: _cache[4] || (_cache[4] = function() {
      return $options.onFocus && $options.onFocus.apply($options, arguments);
    }),
    onBlur: _cache[5] || (_cache[5] = function() {
      return $options.onBlur && $options.onBlur.apply($options, arguments);
    }),
    onKeydown: _cache[6] || (_cache[6] = function() {
      return $options.onKeyDown && $options.onKeyDown.apply($options, arguments);
    })
  }, _ctx.ptm("label")), [renderSlot(_ctx.$slots, "value", {
    value: _ctx.modelValue,
    placeholder: _ctx.placeholder
  }, function() {
    return [createTextVNode(toDisplayString$1($options.label === "p-emptylabel" ? "" : $options.label || "empty"), 1)];
  })], 16, _hoisted_3$i)), _ctx.showClear && _ctx.modelValue != null ? renderSlot(_ctx.$slots, "clearicon", {
    key: 2,
    "class": normalizeClass(_ctx.cx("clearIcon")),
    clearCallback: $options.onClearClick
  }, function() {
    return [(openBlock(), createBlock(resolveDynamicComponent(_ctx.clearIcon ? "i" : "TimesIcon"), mergeProps({
      ref: "clearIcon",
      "class": [_ctx.cx("clearIcon"), _ctx.clearIcon],
      onClick: $options.onClearClick
    }, _ctx.ptm("clearIcon"), {
      "data-pc-section": "clearicon"
    }), null, 16, ["class", "onClick"]))];
  }) : createCommentVNode("", true), createBaseVNode("div", mergeProps({
    "class": _ctx.cx("dropdown")
  }, _ctx.ptm("dropdown")), [_ctx.loading ? renderSlot(_ctx.$slots, "loadingicon", {
    key: 0,
    "class": normalizeClass(_ctx.cx("loadingIcon"))
  }, function() {
    return [_ctx.loadingIcon ? (openBlock(), createElementBlock("span", mergeProps({
      key: 0,
      "class": [_ctx.cx("loadingIcon"), "pi-spin", _ctx.loadingIcon],
      "aria-hidden": "true"
    }, _ctx.ptm("loadingIcon")), null, 16)) : (openBlock(), createBlock(_component_SpinnerIcon, mergeProps({
      key: 1,
      "class": _ctx.cx("loadingIcon"),
      spin: "",
      "aria-hidden": "true"
    }, _ctx.ptm("loadingIcon")), null, 16, ["class"]))];
  }) : renderSlot(_ctx.$slots, "dropdownicon", {
    key: 1,
    "class": normalizeClass(_ctx.cx("dropdownIcon"))
  }, function() {
    return [(openBlock(), createBlock(resolveDynamicComponent(_ctx.dropdownIcon ? "span" : "ChevronDownIcon"), mergeProps({
      "class": [_ctx.cx("dropdownIcon"), _ctx.dropdownIcon],
      "aria-hidden": "true"
    }, _ctx.ptm("dropdownIcon")), null, 16, ["class"]))];
  })], 16), createVNode(_component_Portal, {
    appendTo: _ctx.appendTo
  }, {
    "default": withCtx(function() {
      return [createVNode(Transition, mergeProps({
        name: "p-connected-overlay",
        onEnter: $options.onOverlayEnter,
        onAfterEnter: $options.onOverlayAfterEnter,
        onLeave: $options.onOverlayLeave,
        onAfterLeave: $options.onOverlayAfterLeave
      }, _ctx.ptm("transition")), {
        "default": withCtx(function() {
          return [$data.overlayVisible ? (openBlock(), createElementBlock("div", mergeProps({
            key: 0,
            ref: $options.overlayRef,
            "class": [_ctx.cx("overlay"), _ctx.panelClass, _ctx.overlayClass],
            style: [_ctx.panelStyle, _ctx.overlayStyle],
            onClick: _cache[9] || (_cache[9] = function() {
              return $options.onOverlayClick && $options.onOverlayClick.apply($options, arguments);
            }),
            onKeydown: _cache[10] || (_cache[10] = function() {
              return $options.onOverlayKeyDown && $options.onOverlayKeyDown.apply($options, arguments);
            })
          }, _ctx.ptm("overlay")), [createBaseVNode("span", mergeProps({
            ref: "firstHiddenFocusableElementOnOverlay",
            role: "presentation",
            "aria-hidden": "true",
            "class": "p-hidden-accessible p-hidden-focusable",
            tabindex: 0,
            onFocus: _cache[7] || (_cache[7] = function() {
              return $options.onFirstHiddenFocus && $options.onFirstHiddenFocus.apply($options, arguments);
            })
          }, _ctx.ptm("hiddenFirstFocusableEl"), {
            "data-p-hidden-accessible": true,
            "data-p-hidden-focusable": true
          }), null, 16), renderSlot(_ctx.$slots, "header", {
            value: _ctx.modelValue,
            options: $options.visibleOptions
          }), _ctx.filter ? (openBlock(), createElementBlock("div", mergeProps({
            key: 0,
            "class": _ctx.cx("header")
          }, _ctx.ptm("header")), [createVNode(_component_IconField, mergeProps({
            unstyled: _ctx.unstyled
          }, _ctx.ptm("pcFilterContainer")), {
            "default": withCtx(function() {
              return [createVNode(_component_InputText, {
                ref: "filterInput",
                type: "text",
                value: $data.filterValue,
                onVnodeMounted: $options.onFilterUpdated,
                onVnodeUpdated: $options.onFilterUpdated,
                "class": normalizeClass(_ctx.cx("pcFilter")),
                placeholder: _ctx.filterPlaceholder,
                variant: _ctx.variant,
                unstyled: _ctx.unstyled,
                role: "searchbox",
                autocomplete: "off",
                "aria-owns": $data.id + "_list",
                "aria-activedescendant": $options.focusedOptionId,
                onKeydown: $options.onFilterKeyDown,
                onBlur: $options.onFilterBlur,
                onInput: $options.onFilterChange,
                pt: _ctx.ptm("pcFilter")
              }, null, 8, ["value", "onVnodeMounted", "onVnodeUpdated", "class", "placeholder", "variant", "unstyled", "aria-owns", "aria-activedescendant", "onKeydown", "onBlur", "onInput", "pt"]), createVNode(_component_InputIcon, mergeProps({
                unstyled: _ctx.unstyled
              }, _ctx.ptm("pcFilterIconContainer")), {
                "default": withCtx(function() {
                  return [renderSlot(_ctx.$slots, "filtericon", {}, function() {
                    return [_ctx.filterIcon ? (openBlock(), createElementBlock("span", mergeProps({
                      key: 0,
                      "class": _ctx.filterIcon
                    }, _ctx.ptm("filterIcon")), null, 16)) : (openBlock(), createBlock(_component_SearchIcon, normalizeProps(mergeProps({
                      key: 1
                    }, _ctx.ptm("filterIcon"))), null, 16))];
                  })];
                }),
                _: 3
              }, 16, ["unstyled"])];
            }),
            _: 3
          }, 16, ["unstyled"]), createBaseVNode("span", mergeProps({
            role: "status",
            "aria-live": "polite",
            "class": "p-hidden-accessible"
          }, _ctx.ptm("hiddenFilterResult"), {
            "data-p-hidden-accessible": true
          }), toDisplayString$1($options.filterResultMessageText), 17)], 16)) : createCommentVNode("", true), createBaseVNode("div", mergeProps({
            "class": _ctx.cx("listContainer"),
            style: {
              "max-height": $options.virtualScrollerDisabled ? _ctx.scrollHeight : ""
            }
          }, _ctx.ptm("listContainer")), [createVNode(_component_VirtualScroller, mergeProps({
            ref: $options.virtualScrollerRef
          }, _ctx.virtualScrollerOptions, {
            items: $options.visibleOptions,
            style: {
              height: _ctx.scrollHeight
            },
            tabindex: -1,
            disabled: $options.virtualScrollerDisabled,
            pt: _ctx.ptm("virtualScroller")
          }), createSlots({
            content: withCtx(function(_ref) {
              var styleClass = _ref.styleClass, contentRef3 = _ref.contentRef, items2 = _ref.items, getItemOptions = _ref.getItemOptions, contentStyle = _ref.contentStyle, itemSize2 = _ref.itemSize;
              return [createBaseVNode("ul", mergeProps({
                ref: /* @__PURE__ */ __name(function ref2(el) {
                  return $options.listRef(el, contentRef3);
                }, "ref"),
                id: $data.id + "_list",
                "class": [_ctx.cx("list"), styleClass],
                style: contentStyle,
                role: "listbox"
              }, _ctx.ptm("list")), [(openBlock(true), createElementBlock(Fragment, null, renderList(items2, function(option4, i2) {
                return openBlock(), createElementBlock(Fragment, {
                  key: $options.getOptionRenderKey(option4, $options.getOptionIndex(i2, getItemOptions))
                }, [$options.isOptionGroup(option4) ? (openBlock(), createElementBlock("li", mergeProps({
                  key: 0,
                  id: $data.id + "_" + $options.getOptionIndex(i2, getItemOptions),
                  style: {
                    height: itemSize2 ? itemSize2 + "px" : void 0
                  },
                  "class": _ctx.cx("optionGroup"),
                  role: "option",
                  ref_for: true
                }, _ctx.ptm("optionGroup")), [renderSlot(_ctx.$slots, "optiongroup", {
                  option: option4.optionGroup,
                  index: $options.getOptionIndex(i2, getItemOptions)
                }, function() {
                  return [createBaseVNode("span", mergeProps({
                    "class": _ctx.cx("optionGroupLabel"),
                    ref_for: true
                  }, _ctx.ptm("optionGroupLabel")), toDisplayString$1($options.getOptionGroupLabel(option4.optionGroup)), 17)];
                })], 16, _hoisted_5$7)) : withDirectives((openBlock(), createElementBlock("li", mergeProps({
                  key: 1,
                  id: $data.id + "_" + $options.getOptionIndex(i2, getItemOptions),
                  "class": _ctx.cx("option", {
                    option: option4,
                    focusedOption: $options.getOptionIndex(i2, getItemOptions)
                  }),
                  style: {
                    height: itemSize2 ? itemSize2 + "px" : void 0
                  },
                  role: "option",
                  "aria-label": $options.getOptionLabel(option4),
                  "aria-selected": $options.isSelected(option4),
                  "aria-disabled": $options.isOptionDisabled(option4),
                  "aria-setsize": $options.ariaSetSize,
                  "aria-posinset": $options.getAriaPosInset($options.getOptionIndex(i2, getItemOptions)),
                  onClick: /* @__PURE__ */ __name(function onClick3($event) {
                    return $options.onOptionSelect($event, option4);
                  }, "onClick"),
                  onMousemove: /* @__PURE__ */ __name(function onMousemove($event) {
                    return $options.onOptionMouseMove($event, $options.getOptionIndex(i2, getItemOptions));
                  }, "onMousemove"),
                  "data-p-selected": $options.isSelected(option4),
                  "data-p-focused": $data.focusedOptionIndex === $options.getOptionIndex(i2, getItemOptions),
                  "data-p-disabled": $options.isOptionDisabled(option4),
                  ref_for: true
                }, $options.getPTItemOptions(option4, getItemOptions, i2, "option")), [_ctx.checkmark ? (openBlock(), createElementBlock(Fragment, {
                  key: 0
                }, [$options.isSelected(option4) ? (openBlock(), createBlock(_component_CheckIcon, mergeProps({
                  key: 0,
                  "class": _ctx.cx("optionCheckIcon"),
                  ref_for: true
                }, _ctx.ptm("optionCheckIcon")), null, 16, ["class"])) : (openBlock(), createBlock(_component_BlankIcon, mergeProps({
                  key: 1,
                  "class": _ctx.cx("optionBlankIcon"),
                  ref_for: true
                }, _ctx.ptm("optionBlankIcon")), null, 16, ["class"]))], 64)) : createCommentVNode("", true), renderSlot(_ctx.$slots, "option", {
                  option: option4,
                  selected: $options.isSelected(option4),
                  index: $options.getOptionIndex(i2, getItemOptions)
                }, function() {
                  return [createBaseVNode("span", mergeProps({
                    "class": _ctx.cx("optionLabel"),
                    ref_for: true
                  }, _ctx.ptm("optionLabel")), toDisplayString$1($options.getOptionLabel(option4)), 17)];
                })], 16, _hoisted_6$6)), [[_directive_ripple]])], 64);
              }), 128)), $data.filterValue && (!items2 || items2 && items2.length === 0) ? (openBlock(), createElementBlock("li", mergeProps({
                key: 0,
                "class": _ctx.cx("emptyMessage"),
                role: "option"
              }, _ctx.ptm("emptyMessage"), {
                "data-p-hidden-accessible": true
              }), [renderSlot(_ctx.$slots, "emptyfilter", {}, function() {
                return [createTextVNode(toDisplayString$1($options.emptyFilterMessageText), 1)];
              })], 16)) : !_ctx.options || _ctx.options && _ctx.options.length === 0 ? (openBlock(), createElementBlock("li", mergeProps({
                key: 1,
                "class": _ctx.cx("emptyMessage"),
                role: "option"
              }, _ctx.ptm("emptyMessage"), {
                "data-p-hidden-accessible": true
              }), [renderSlot(_ctx.$slots, "empty", {}, function() {
                return [createTextVNode(toDisplayString$1($options.emptyMessageText), 1)];
              })], 16)) : createCommentVNode("", true)], 16, _hoisted_4$b)];
            }),
            _: 2
          }, [_ctx.$slots.loader ? {
            name: "loader",
            fn: withCtx(function(_ref2) {
              var options3 = _ref2.options;
              return [renderSlot(_ctx.$slots, "loader", {
                options: options3
              })];
            }),
            key: "0"
          } : void 0]), 1040, ["items", "style", "disabled", "pt"])], 16), renderSlot(_ctx.$slots, "footer", {
            value: _ctx.modelValue,
            options: $options.visibleOptions
          }), !_ctx.options || _ctx.options && _ctx.options.length === 0 ? (openBlock(), createElementBlock("span", mergeProps({
            key: 1,
            role: "status",
            "aria-live": "polite",
            "class": "p-hidden-accessible"
          }, _ctx.ptm("hiddenEmptyMessage"), {
            "data-p-hidden-accessible": true
          }), toDisplayString$1($options.emptyMessageText), 17)) : createCommentVNode("", true), createBaseVNode("span", mergeProps({
            role: "status",
            "aria-live": "polite",
            "class": "p-hidden-accessible"
          }, _ctx.ptm("hiddenSelectedMessage"), {
            "data-p-hidden-accessible": true
          }), toDisplayString$1($options.selectedMessageText), 17), createBaseVNode("span", mergeProps({
            ref: "lastHiddenFocusableElementOnOverlay",
            role: "presentation",
            "aria-hidden": "true",
            "class": "p-hidden-accessible p-hidden-focusable",
            tabindex: 0,
            onFocus: _cache[8] || (_cache[8] = function() {
              return $options.onLastHiddenFocus && $options.onLastHiddenFocus.apply($options, arguments);
            })
          }, _ctx.ptm("hiddenLastFocusableEl"), {
            "data-p-hidden-accessible": true,
            "data-p-hidden-focusable": true
          }), null, 16)], 16)) : createCommentVNode("", true)];
        }),
        _: 3
      }, 16, ["onEnter", "onAfterEnter", "onLeave", "onAfterLeave"])];
    }),
    _: 3
  }, 8, ["appendTo"])], 16, _hoisted_1$O);
}
__name(render$x, "render$x");
script$y.render = render$x;
var theme$k = /* @__PURE__ */ __name(function theme17(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-toggleswitch {\n    display: inline-block;\n    width: ".concat(dt3("toggleswitch.width"), ";\n    height: ").concat(dt3("toggleswitch.height"), ";\n}\n\n.p-toggleswitch-input {\n    cursor: pointer;\n    appearance: none;\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    padding: 0;\n    margin: 0;\n    opacity: 0;\n    z-index: 1;\n    outline: 0 none;\n    border-radius: ").concat(dt3("toggleswitch.border.radius"), ";\n}\n\n.p-toggleswitch-slider {\n    display: inline-block;\n    cursor: pointer;\n    width: 100%;\n    height: 100%;\n    border-width: ").concat(dt3("toggleswitch.border.width"), ";\n    border-style: solid;\n    border-color: ").concat(dt3("toggleswitch.border.color"), ";\n    background: ").concat(dt3("toggleswitch.background"), ";\n    transition: background ").concat(dt3("toggleswitch.transition.duration"), ", color ").concat(dt3("toggleswitch.transition.duration"), ", border-color ").concat(dt3("toggleswitch.transition.duration"), ", outline-color ").concat(dt3("toggleswitch.transition.duration"), ", box-shadow ").concat(dt3("toggleswitch.transition.duration"), ";\n    border-radius: ").concat(dt3("toggleswitch.border.radius"), ";\n    outline-color: transparent;\n    box-shadow: ").concat(dt3("toggleswitch.shadow"), ';\n}\n\n.p-toggleswitch-slider:before {\n    position: absolute;\n    content: "";\n    top: 50%;\n    background: ').concat(dt3("toggleswitch.handle.background"), ";\n    width: ").concat(dt3("toggleswitch.handle.size"), ";\n    height: ").concat(dt3("toggleswitch.handle.size"), ";\n    left: ").concat(dt3("toggleswitch.gap"), ";\n    margin-top: calc(-1 * calc(").concat(dt3("toggleswitch.handle.size"), " / 2));\n    border-radius: ").concat(dt3("toggleswitch.handle.border.radius"), ";\n    transition: background ").concat(dt3("toggleswitch.transition.duration"), ", left ").concat(dt3("toggleswitch.slide.duration"), ";\n}\n\n.p-toggleswitch.p-toggleswitch-checked .p-toggleswitch-slider {\n    background: ").concat(dt3("toggleswitch.checked.background"), ";\n    border-color: ").concat(dt3("toggleswitch.checked.border.color"), ";\n}\n\n.p-toggleswitch.p-toggleswitch-checked .p-toggleswitch-slider:before {\n    background: ").concat(dt3("toggleswitch.handle.checked.background"), ";\n    left: calc(").concat(dt3("toggleswitch.width"), " - calc(").concat(dt3("toggleswitch.handle.size"), " + ").concat(dt3("toggleswitch.gap"), "));\n}\n\n.p-toggleswitch:not(.p-disabled):has(.p-toggleswitch-input:hover) .p-toggleswitch-slider {\n    background: ").concat(dt3("toggleswitch.hover.background"), ";\n    border-color: ").concat(dt3("toggleswitch.hover.border.color"), ";\n}\n\n.p-toggleswitch:not(.p-disabled):has(.p-toggleswitch-input:hover) .p-toggleswitch-slider:before {\n    background: ").concat(dt3("toggleswitch.handle.hover.background"), ";\n}\n\n.p-toggleswitch:not(.p-disabled):has(.p-toggleswitch-input:hover).p-toggleswitch-checked .p-toggleswitch-slider {\n    background: ").concat(dt3("toggleswitch.checked.hover.background"), ";\n    border-color: ").concat(dt3("toggleswitch.checked.hover.border.color"), ";\n}\n\n.p-toggleswitch:not(.p-disabled):has(.p-toggleswitch-input:hover).p-toggleswitch-checked .p-toggleswitch-slider:before {\n    background: ").concat(dt3("toggleswitch.handle.checked.hover.background"), ";\n}\n\n.p-toggleswitch:not(.p-disabled):has(.p-toggleswitch-input:focus-visible) .p-toggleswitch-slider {\n    box-shadow: ").concat(dt3("toggleswitch.focus.ring.shadow"), ";\n    outline: ").concat(dt3("toggleswitch.focus.ring.width"), " ").concat(dt3("toggleswitch.focus.ring.style"), " ").concat(dt3("toggleswitch.focus.ring.color"), ";\n    outline-offset: ").concat(dt3("toggleswitch.focus.ring.offset"), ";\n}\n\n.p-toggleswitch.p-invalid > .p-toggleswitch-slider {\n    border-color: ").concat(dt3("toggleswitch.invalid.border.color"), ";\n}\n\n.p-toggleswitch.p-disabled {\n    opacity: 1;\n}\n\n.p-toggleswitch.p-disabled .p-toggleswitch-slider {\n    background: ").concat(dt3("toggleswitch.disabled.background"), ";\n}\n\n.p-toggleswitch.p-disabled .p-toggleswitch-slider:before {\n    background: ").concat(dt3("toggleswitch.handle.disabled.background"), ";\n}\n");
}, "theme");
var inlineStyles$5 = {
  root: {
    position: "relative"
  }
};
var classes$l = {
  root: /* @__PURE__ */ __name(function root11(_ref2) {
    var instance = _ref2.instance, props = _ref2.props;
    return ["p-toggleswitch p-component", {
      "p-toggleswitch-checked": instance.checked,
      "p-disabled": props.disabled,
      "p-invalid": props.invalid
    }];
  }, "root"),
  input: "p-toggleswitch-input",
  slider: "p-toggleswitch-slider"
};
var ToggleSwitchStyle = BaseStyle.extend({
  name: "toggleswitch",
  theme: theme$k,
  classes: classes$l,
  inlineStyles: inlineStyles$5
});
var script$1$l = {
  name: "BaseToggleSwitch",
  "extends": script$X,
  props: {
    modelValue: {
      type: null,
      "default": false
    },
    trueValue: {
      type: null,
      "default": true
    },
    falseValue: {
      type: null,
      "default": false
    },
    invalid: {
      type: Boolean,
      "default": false
    },
    disabled: {
      type: Boolean,
      "default": false
    },
    readonly: {
      type: Boolean,
      "default": false
    },
    tabindex: {
      type: Number,
      "default": null
    },
    inputId: {
      type: String,
      "default": null
    },
    inputClass: {
      type: [String, Object],
      "default": null
    },
    inputStyle: {
      type: Object,
      "default": null
    },
    ariaLabelledby: {
      type: String,
      "default": null
    },
    ariaLabel: {
      type: String,
      "default": null
    }
  },
  style: ToggleSwitchStyle,
  provide: /* @__PURE__ */ __name(function provide18() {
    return {
      $pcToggleSwitch: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$x = {
  name: "ToggleSwitch",
  "extends": script$1$l,
  inheritAttrs: false,
  emits: ["update:modelValue", "change", "focus", "blur"],
  methods: {
    getPTOptions: /* @__PURE__ */ __name(function getPTOptions4(key) {
      var _ptm = key === "root" ? this.ptmi : this.ptm;
      return _ptm(key, {
        context: {
          checked: this.checked,
          disabled: this.disabled
        }
      });
    }, "getPTOptions"),
    onChange: /* @__PURE__ */ __name(function onChange(event2) {
      if (!this.disabled && !this.readonly) {
        var newValue = this.checked ? this.falseValue : this.trueValue;
        this.$emit("update:modelValue", newValue);
        this.$emit("change", event2);
      }
    }, "onChange"),
    onFocus: /* @__PURE__ */ __name(function onFocus3(event2) {
      this.$emit("focus", event2);
    }, "onFocus"),
    onBlur: /* @__PURE__ */ __name(function onBlur3(event2) {
      this.$emit("blur", event2);
    }, "onBlur")
  },
  computed: {
    checked: /* @__PURE__ */ __name(function checked() {
      return this.modelValue === this.trueValue;
    }, "checked")
  }
};
var _hoisted_1$N = ["data-p-checked", "data-p-disabled"];
var _hoisted_2$A = ["id", "checked", "tabindex", "disabled", "readonly", "aria-checked", "aria-labelledby", "aria-label", "aria-invalid"];
function render$w(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("root"),
    style: _ctx.sx("root")
  }, $options.getPTOptions("root"), {
    "data-p-checked": $options.checked,
    "data-p-disabled": _ctx.disabled
  }), [createBaseVNode("input", mergeProps({
    id: _ctx.inputId,
    type: "checkbox",
    role: "switch",
    "class": [_ctx.cx("input"), _ctx.inputClass],
    style: _ctx.inputStyle,
    checked: $options.checked,
    tabindex: _ctx.tabindex,
    disabled: _ctx.disabled,
    readonly: _ctx.readonly,
    "aria-checked": $options.checked,
    "aria-labelledby": _ctx.ariaLabelledby,
    "aria-label": _ctx.ariaLabel,
    "aria-invalid": _ctx.invalid || void 0,
    onFocus: _cache[0] || (_cache[0] = function() {
      return $options.onFocus && $options.onFocus.apply($options, arguments);
    }),
    onBlur: _cache[1] || (_cache[1] = function() {
      return $options.onBlur && $options.onBlur.apply($options, arguments);
    }),
    onChange: _cache[2] || (_cache[2] = function() {
      return $options.onChange && $options.onChange.apply($options, arguments);
    })
  }, $options.getPTOptions("input")), null, 16, _hoisted_2$A), createBaseVNode("span", mergeProps({
    "class": _ctx.cx("slider")
  }, $options.getPTOptions("slider")), null, 16)], 16, _hoisted_1$N);
}
__name(render$w, "render$w");
script$x.render = render$w;
var theme$j = /* @__PURE__ */ __name(function theme18(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-tag {\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    background: ".concat(dt3("tag.primary.background"), ";\n    color: ").concat(dt3("tag.primary.color"), ";\n    font-size: ").concat(dt3("tag.font.size"), ";\n    font-weight: ").concat(dt3("tag.font.weight"), ";\n    padding: ").concat(dt3("tag.padding"), ";\n    border-radius: ").concat(dt3("tag.border.radius"), ";\n    gap: ").concat(dt3("tag.gap"), ";\n}\n\n.p-tag-icon {\n    font-size: ").concat(dt3("tag.icon.size"), ";\n    width: ").concat(dt3("tag.icon.size"), ";\n    height:").concat(dt3("tag.icon.size"), ";\n}\n\n.p-tag-rounded {\n    border-radius: ").concat(dt3("tag.rounded.border.radius"), ";\n}\n\n.p-tag-success {\n    background: ").concat(dt3("tag.success.background"), ";\n    color: ").concat(dt3("tag.success.color"), ";\n}\n\n.p-tag-info {\n    background: ").concat(dt3("tag.info.background"), ";\n    color: ").concat(dt3("tag.info.color"), ";\n}\n\n.p-tag-warn {\n    background: ").concat(dt3("tag.warn.background"), ";\n    color: ").concat(dt3("tag.warn.color"), ";\n}\n\n.p-tag-danger {\n    background: ").concat(dt3("tag.danger.background"), ";\n    color: ").concat(dt3("tag.danger.color"), ";\n}\n\n.p-tag-secondary {\n    background: ").concat(dt3("tag.secondary.background"), ";\n    color: ").concat(dt3("tag.secondary.color"), ";\n}\n\n.p-tag-contrast {\n    background: ").concat(dt3("tag.contrast.background"), ";\n    color: ").concat(dt3("tag.contrast.color"), ";\n}\n");
}, "theme");
var classes$k = {
  root: /* @__PURE__ */ __name(function root12(_ref2) {
    var props = _ref2.props;
    return ["p-tag p-component", {
      "p-tag-info": props.severity === "info",
      "p-tag-success": props.severity === "success",
      "p-tag-warn": props.severity === "warn",
      "p-tag-danger": props.severity === "danger",
      "p-tag-secondary": props.severity === "secondary",
      "p-tag-contrast": props.severity === "contrast",
      "p-tag-rounded": props.rounded
    }];
  }, "root"),
  icon: "p-tag-icon",
  label: "p-tag-label"
};
var TagStyle = BaseStyle.extend({
  name: "tag",
  theme: theme$j,
  classes: classes$k
});
var script$1$k = {
  name: "BaseTag",
  "extends": script$X,
  props: {
    value: null,
    severity: null,
    rounded: Boolean,
    icon: String
  },
  style: TagStyle,
  provide: /* @__PURE__ */ __name(function provide19() {
    return {
      $pcTag: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$w = {
  name: "Tag",
  "extends": script$1$k,
  inheritAttrs: false
};
function render$v(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps({
    "class": _ctx.cx("root")
  }, _ctx.ptmi("root")), [_ctx.$slots.icon ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.$slots.icon), mergeProps({
    key: 0,
    "class": _ctx.cx("icon")
  }, _ctx.ptm("icon")), null, 16, ["class"])) : _ctx.icon ? (openBlock(), createElementBlock("span", mergeProps({
    key: 1,
    "class": [_ctx.cx("icon"), _ctx.icon]
  }, _ctx.ptm("icon")), null, 16)) : createCommentVNode("", true), _ctx.value != null || _ctx.$slots["default"] ? renderSlot(_ctx.$slots, "default", {
    key: 2
  }, function() {
    return [createBaseVNode("span", mergeProps({
      "class": _ctx.cx("label")
    }, _ctx.ptm("label")), toDisplayString$1(_ctx.value), 17)];
  }) : createCommentVNode("", true)], 16);
}
__name(render$v, "render$v");
script$w.render = render$v;
const _sfc_main$F = /* @__PURE__ */ defineComponent({
  __name: "CustomSettingValue",
  props: {
    renderFunction: { type: Function }
  },
  setup(__props) {
    const props = __props;
    const container = ref(null);
    function renderContent() {
      if (container.value) {
        container.value.innerHTML = "";
        const element = props.renderFunction();
        container.value.appendChild(element);
      }
    }
    __name(renderContent, "renderContent");
    onMounted(renderContent);
    watch(() => props.renderFunction, renderContent);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "container",
        ref: container
      }, null, 512);
    };
  }
});
var theme$i = /* @__PURE__ */ __name(function theme19(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-slider {\n    position: relative;\n    background: ".concat(dt3("slider.track.background"), ";\n    border-radius: ").concat(dt3("slider.border.radius"), ";\n}\n\n.p-slider-handle {\n    cursor: grab;\n    touch-action: none;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    height: ").concat(dt3("slider.handle.height"), ";\n    width: ").concat(dt3("slider.handle.width"), ";\n    background: ").concat(dt3("slider.handle.background"), ";\n    border-radius: ").concat(dt3("slider.handle.border.radius"), ";\n    transition: background ").concat(dt3("slider.transition.duration"), ", color ").concat(dt3("slider.transition.duration"), ", border-color ").concat(dt3("slider.transition.duration"), ", box-shadow ").concat(dt3("slider.transition.duration"), ", outline-color ").concat(dt3("slider.transition.duration"), ';\n    outline-color: transparent;\n}\n\n.p-slider-handle::before {\n    content: "";\n    width: ').concat(dt3("slider.handle.content.width"), ";\n    height: ").concat(dt3("slider.handle.content.height"), ";\n    display: block;\n    background: ").concat(dt3("slider.handle.content.background"), ";\n    border-radius: ").concat(dt3("slider.handle.content.border.radius"), ";\n    box-shadow: ").concat(dt3("slider.handle.content.shadow"), ";\n    transition: background ").concat(dt3("slider.transition.duration"), ";\n}\n\n.p-slider:not(.p-disabled) .p-slider-handle:hover {\n    background: ").concat(dt3("slider.handle.hover.background"), ";\n}\n\n.p-slider:not(.p-disabled) .p-slider-handle:hover::before {\n    background: ").concat(dt3("slider.handle.content.hover.background"), ";\n}\n\n.p-slider-handle:focus-visible {\n    border-color: ").concat(dt3("slider.handle.focus.border.color"), ";\n    box-shadow: ").concat(dt3("slider.handle.focus.ring.shadow"), ";\n    outline: ").concat(dt3("slider.handle.focus.ring.width"), " ").concat(dt3("slider.handle.focus.ring.style"), " ").concat(dt3("slider.handle.focus.ring.color"), ";\n    outline-offset: ").concat(dt3("slider.handle.focus.ring.offset"), ";\n}\n\n.p-slider-range {\n    display: block;\n    background: ").concat(dt3("slider.range.background"), ";\n    border-radius: ").concat(dt3("slider.border.radius"), ";\n}\n\n.p-slider.p-slider-horizontal {\n    height: ").concat(dt3("slider.track.size"), ";\n}\n\n.p-slider-horizontal .p-slider-range {\n    top: 0;\n    left: 0;\n    height: 100%;\n}\n\n.p-slider-horizontal .p-slider-handle {\n    top: 50%;\n    margin-top: calc(-1 * calc(").concat(dt3("slider.handle.height"), " / 2));\n    margin-left: calc(-1 * calc(").concat(dt3("slider.handle.width"), " / 2));\n}\n\n.p-slider-vertical {\n    min-height: 100px;\n    width: ").concat(dt3("slider.track.size"), ";\n}\n\n.p-slider-vertical .p-slider-handle {\n    left: 50%;\n    margin-left: calc(-1 * calc(").concat(dt3("slider.handle.width"), " / 2));\n    margin-bottom: calc(-1 * calc(").concat(dt3("slider.handle.height"), " / 2));\n}\n\n.p-slider-vertical .p-slider-range {\n    bottom: 0;\n    left: 0;\n    width: 100%;\n}\n");
}, "theme");
var inlineStyles$4 = {
  handle: {
    position: "absolute"
  },
  range: {
    position: "absolute"
  }
};
var classes$j = {
  root: /* @__PURE__ */ __name(function root13(_ref2) {
    var props = _ref2.props;
    return ["p-slider p-component", {
      "p-disabled": props.disabled,
      "p-slider-horizontal": props.orientation === "horizontal",
      "p-slider-vertical": props.orientation === "vertical"
    }];
  }, "root"),
  range: "p-slider-range",
  handle: "p-slider-handle"
};
var SliderStyle = BaseStyle.extend({
  name: "slider",
  theme: theme$i,
  classes: classes$j,
  inlineStyles: inlineStyles$4
});
var script$1$j = {
  name: "BaseSlider",
  "extends": script$X,
  props: {
    modelValue: [Number, Array],
    min: {
      type: Number,
      "default": 0
    },
    max: {
      type: Number,
      "default": 100
    },
    orientation: {
      type: String,
      "default": "horizontal"
    },
    step: {
      type: Number,
      "default": null
    },
    range: {
      type: Boolean,
      "default": false
    },
    disabled: {
      type: Boolean,
      "default": false
    },
    tabindex: {
      type: Number,
      "default": 0
    },
    ariaLabelledby: {
      type: String,
      "default": null
    },
    ariaLabel: {
      type: String,
      "default": null
    }
  },
  style: SliderStyle,
  provide: /* @__PURE__ */ __name(function provide20() {
    return {
      $pcSlider: this,
      $parentInstance: this
    };
  }, "provide")
};
function _toConsumableArray$9(r) {
  return _arrayWithoutHoles$9(r) || _iterableToArray$9(r) || _unsupportedIterableToArray$b(r) || _nonIterableSpread$9();
}
__name(_toConsumableArray$9, "_toConsumableArray$9");
function _nonIterableSpread$9() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableSpread$9, "_nonIterableSpread$9");
function _unsupportedIterableToArray$b(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$b(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$b(r, a) : void 0;
  }
}
__name(_unsupportedIterableToArray$b, "_unsupportedIterableToArray$b");
function _iterableToArray$9(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
__name(_iterableToArray$9, "_iterableToArray$9");
function _arrayWithoutHoles$9(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$b(r);
}
__name(_arrayWithoutHoles$9, "_arrayWithoutHoles$9");
function _arrayLikeToArray$b(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
__name(_arrayLikeToArray$b, "_arrayLikeToArray$b");
var script$v = {
  name: "Slider",
  "extends": script$1$j,
  inheritAttrs: false,
  emits: ["update:modelValue", "change", "slideend"],
  dragging: false,
  handleIndex: null,
  initX: null,
  initY: null,
  barWidth: null,
  barHeight: null,
  dragListener: null,
  dragEndListener: null,
  beforeUnmount: /* @__PURE__ */ __name(function beforeUnmount3() {
    this.unbindDragListeners();
  }, "beforeUnmount"),
  methods: {
    updateDomData: /* @__PURE__ */ __name(function updateDomData() {
      var rect = this.$el.getBoundingClientRect();
      this.initX = rect.left + getWindowScrollLeft();
      this.initY = rect.top + getWindowScrollTop();
      this.barWidth = this.$el.offsetWidth;
      this.barHeight = this.$el.offsetHeight;
    }, "updateDomData"),
    setValue: /* @__PURE__ */ __name(function setValue(event2) {
      var handleValue;
      var pageX = event2.touches ? event2.touches[0].pageX : event2.pageX;
      var pageY = event2.touches ? event2.touches[0].pageY : event2.pageY;
      if (this.orientation === "horizontal") handleValue = (pageX - this.initX) * 100 / this.barWidth;
      else handleValue = (this.initY + this.barHeight - pageY) * 100 / this.barHeight;
      var newValue = (this.max - this.min) * (handleValue / 100) + this.min;
      if (this.step) {
        var oldValue = this.range ? this.value[this.handleIndex] : this.value;
        var diff = newValue - oldValue;
        if (diff < 0) newValue = oldValue + Math.ceil(newValue / this.step - oldValue / this.step) * this.step;
        else if (diff > 0) newValue = oldValue + Math.floor(newValue / this.step - oldValue / this.step) * this.step;
      } else {
        newValue = Math.floor(newValue);
      }
      this.updateModel(event2, newValue);
    }, "setValue"),
    updateModel: /* @__PURE__ */ __name(function updateModel4(event2, value3) {
      var newValue = parseFloat(value3.toFixed(10));
      var modelValue3;
      if (this.range) {
        modelValue3 = this.value ? _toConsumableArray$9(this.value) : [];
        if (this.handleIndex == 0) {
          if (newValue < this.min) newValue = this.min;
          else if (newValue >= this.max) newValue = this.max;
          modelValue3[0] = newValue;
        } else {
          if (newValue > this.max) newValue = this.max;
          else if (newValue <= this.min) newValue = this.min;
          modelValue3[1] = newValue;
        }
      } else {
        if (newValue < this.min) newValue = this.min;
        else if (newValue > this.max) newValue = this.max;
        modelValue3 = newValue;
      }
      this.$emit("update:modelValue", modelValue3);
      this.$emit("change", modelValue3);
    }, "updateModel"),
    onDragStart: /* @__PURE__ */ __name(function onDragStart(event2, index2) {
      if (this.disabled) {
        return;
      }
      this.$el.setAttribute("data-p-sliding", true);
      this.dragging = true;
      this.updateDomData();
      if (this.range && this.value[0] === this.max) {
        this.handleIndex = 0;
      } else {
        this.handleIndex = index2;
      }
      event2.currentTarget.focus();
      event2.preventDefault();
    }, "onDragStart"),
    onDrag: /* @__PURE__ */ __name(function onDrag(event2) {
      if (this.dragging) {
        this.setValue(event2);
        event2.preventDefault();
      }
    }, "onDrag"),
    onDragEnd: /* @__PURE__ */ __name(function onDragEnd(event2) {
      if (this.dragging) {
        this.dragging = false;
        this.$el.setAttribute("data-p-sliding", false);
        this.$emit("slideend", {
          originalEvent: event2,
          value: this.value
        });
      }
    }, "onDragEnd"),
    onBarClick: /* @__PURE__ */ __name(function onBarClick(event2) {
      if (this.disabled) {
        return;
      }
      if (getAttribute(event2.target, "data-pc-section") !== "handle") {
        this.updateDomData();
        this.setValue(event2);
      }
    }, "onBarClick"),
    onMouseDown: /* @__PURE__ */ __name(function onMouseDown2(event2, index2) {
      this.bindDragListeners();
      this.onDragStart(event2, index2);
    }, "onMouseDown"),
    onKeyDown: /* @__PURE__ */ __name(function onKeyDown3(event2, index2) {
      this.handleIndex = index2;
      switch (event2.code) {
        case "ArrowDown":
        case "ArrowLeft":
          this.decrementValue(event2, index2);
          event2.preventDefault();
          break;
        case "ArrowUp":
        case "ArrowRight":
          this.incrementValue(event2, index2);
          event2.preventDefault();
          break;
        case "PageDown":
          this.decrementValue(event2, index2, true);
          event2.preventDefault();
          break;
        case "PageUp":
          this.incrementValue(event2, index2, true);
          event2.preventDefault();
          break;
        case "Home":
          this.updateModel(event2, this.min);
          event2.preventDefault();
          break;
        case "End":
          this.updateModel(event2, this.max);
          event2.preventDefault();
          break;
      }
    }, "onKeyDown"),
    decrementValue: /* @__PURE__ */ __name(function decrementValue(event2, index2) {
      var pageKey = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var newValue;
      if (this.range) {
        if (this.step) newValue = this.value[index2] - this.step;
        else newValue = this.value[index2] - 1;
      } else {
        if (this.step) newValue = this.value - this.step;
        else if (!this.step && pageKey) newValue = this.value - 10;
        else newValue = this.value - 1;
      }
      this.updateModel(event2, newValue);
      event2.preventDefault();
    }, "decrementValue"),
    incrementValue: /* @__PURE__ */ __name(function incrementValue(event2, index2) {
      var pageKey = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var newValue;
      if (this.range) {
        if (this.step) newValue = this.value[index2] + this.step;
        else newValue = this.value[index2] + 1;
      } else {
        if (this.step) newValue = this.value + this.step;
        else if (!this.step && pageKey) newValue = this.value + 10;
        else newValue = this.value + 1;
      }
      this.updateModel(event2, newValue);
      event2.preventDefault();
    }, "incrementValue"),
    bindDragListeners: /* @__PURE__ */ __name(function bindDragListeners() {
      if (!this.dragListener) {
        this.dragListener = this.onDrag.bind(this);
        document.addEventListener("mousemove", this.dragListener);
      }
      if (!this.dragEndListener) {
        this.dragEndListener = this.onDragEnd.bind(this);
        document.addEventListener("mouseup", this.dragEndListener);
      }
    }, "bindDragListeners"),
    unbindDragListeners: /* @__PURE__ */ __name(function unbindDragListeners() {
      if (this.dragListener) {
        document.removeEventListener("mousemove", this.dragListener);
        this.dragListener = null;
      }
      if (this.dragEndListener) {
        document.removeEventListener("mouseup", this.dragEndListener);
        this.dragEndListener = null;
      }
    }, "unbindDragListeners")
  },
  computed: {
    value: /* @__PURE__ */ __name(function value2() {
      var _this$modelValue3;
      if (this.range) {
        var _this$modelValue$, _this$modelValue, _this$modelValue$2, _this$modelValue2;
        return [(_this$modelValue$ = (_this$modelValue = this.modelValue) === null || _this$modelValue === void 0 ? void 0 : _this$modelValue[0]) !== null && _this$modelValue$ !== void 0 ? _this$modelValue$ : this.min, (_this$modelValue$2 = (_this$modelValue2 = this.modelValue) === null || _this$modelValue2 === void 0 ? void 0 : _this$modelValue2[1]) !== null && _this$modelValue$2 !== void 0 ? _this$modelValue$2 : this.max];
      }
      return (_this$modelValue3 = this.modelValue) !== null && _this$modelValue3 !== void 0 ? _this$modelValue3 : this.min;
    }, "value"),
    horizontal: /* @__PURE__ */ __name(function horizontal() {
      return this.orientation === "horizontal";
    }, "horizontal"),
    vertical: /* @__PURE__ */ __name(function vertical() {
      return this.orientation === "vertical";
    }, "vertical"),
    rangeStyle: /* @__PURE__ */ __name(function rangeStyle() {
      if (this.range) {
        var rangeSliderWidth = this.rangeEndPosition > this.rangeStartPosition ? this.rangeEndPosition - this.rangeStartPosition : this.rangeStartPosition - this.rangeEndPosition;
        var rangeSliderPosition = this.rangeEndPosition > this.rangeStartPosition ? this.rangeStartPosition : this.rangeEndPosition;
        if (this.horizontal) return {
          left: rangeSliderPosition + "%",
          width: rangeSliderWidth + "%"
        };
        else return {
          bottom: rangeSliderPosition + "%",
          height: rangeSliderWidth + "%"
        };
      } else {
        if (this.horizontal) return {
          width: this.handlePosition + "%"
        };
        else return {
          height: this.handlePosition + "%"
        };
      }
    }, "rangeStyle"),
    handleStyle: /* @__PURE__ */ __name(function handleStyle() {
      if (this.horizontal) return {
        left: this.handlePosition + "%"
      };
      else return {
        bottom: this.handlePosition + "%"
      };
    }, "handleStyle"),
    handlePosition: /* @__PURE__ */ __name(function handlePosition() {
      if (this.value < this.min) return 0;
      else if (this.value > this.max) return 100;
      else return (this.value - this.min) * 100 / (this.max - this.min);
    }, "handlePosition"),
    rangeStartPosition: /* @__PURE__ */ __name(function rangeStartPosition() {
      if (this.value && this.value[0]) return (this.value[0] < this.min ? 0 : this.value[0] - this.min) * 100 / (this.max - this.min);
      else return 0;
    }, "rangeStartPosition"),
    rangeEndPosition: /* @__PURE__ */ __name(function rangeEndPosition() {
      if (this.value && this.value.length === 2) return (this.value[1] > this.max ? 100 : this.value[1] - this.min) * 100 / (this.max - this.min);
      else return 100;
    }, "rangeEndPosition"),
    rangeStartHandleStyle: /* @__PURE__ */ __name(function rangeStartHandleStyle() {
      if (this.horizontal) return {
        left: this.rangeStartPosition + "%"
      };
      else return {
        bottom: this.rangeStartPosition + "%"
      };
    }, "rangeStartHandleStyle"),
    rangeEndHandleStyle: /* @__PURE__ */ __name(function rangeEndHandleStyle() {
      if (this.horizontal) return {
        left: this.rangeEndPosition + "%"
      };
      else return {
        bottom: this.rangeEndPosition + "%"
      };
    }, "rangeEndHandleStyle")
  }
};
var _hoisted_1$M = ["tabindex", "aria-valuemin", "aria-valuenow", "aria-valuemax", "aria-labelledby", "aria-label", "aria-orientation"];
var _hoisted_2$z = ["tabindex", "aria-valuemin", "aria-valuenow", "aria-valuemax", "aria-labelledby", "aria-label", "aria-orientation"];
var _hoisted_3$h = ["tabindex", "aria-valuemin", "aria-valuenow", "aria-valuemax", "aria-labelledby", "aria-label", "aria-orientation"];
function render$u(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("root"),
    onClick: _cache[15] || (_cache[15] = function() {
      return $options.onBarClick && $options.onBarClick.apply($options, arguments);
    })
  }, _ctx.ptmi("root"), {
    "data-p-sliding": false
  }), [createBaseVNode("span", mergeProps({
    "class": _ctx.cx("range"),
    style: [_ctx.sx("range"), $options.rangeStyle]
  }, _ctx.ptm("range")), null, 16), !_ctx.range ? (openBlock(), createElementBlock("span", mergeProps({
    key: 0,
    "class": _ctx.cx("handle"),
    style: [_ctx.sx("handle"), $options.handleStyle],
    onTouchstartPassive: _cache[0] || (_cache[0] = function($event) {
      return $options.onDragStart($event);
    }),
    onTouchmovePassive: _cache[1] || (_cache[1] = function($event) {
      return $options.onDrag($event);
    }),
    onTouchend: _cache[2] || (_cache[2] = function($event) {
      return $options.onDragEnd($event);
    }),
    onMousedown: _cache[3] || (_cache[3] = function($event) {
      return $options.onMouseDown($event);
    }),
    onKeydown: _cache[4] || (_cache[4] = function($event) {
      return $options.onKeyDown($event);
    }),
    tabindex: _ctx.tabindex,
    role: "slider",
    "aria-valuemin": _ctx.min,
    "aria-valuenow": _ctx.modelValue,
    "aria-valuemax": _ctx.max,
    "aria-labelledby": _ctx.ariaLabelledby,
    "aria-label": _ctx.ariaLabel,
    "aria-orientation": _ctx.orientation
  }, _ctx.ptm("handle")), null, 16, _hoisted_1$M)) : createCommentVNode("", true), _ctx.range ? (openBlock(), createElementBlock("span", mergeProps({
    key: 1,
    "class": _ctx.cx("handle"),
    style: [_ctx.sx("handle"), $options.rangeStartHandleStyle],
    onTouchstartPassive: _cache[5] || (_cache[5] = function($event) {
      return $options.onDragStart($event, 0);
    }),
    onTouchmovePassive: _cache[6] || (_cache[6] = function($event) {
      return $options.onDrag($event);
    }),
    onTouchend: _cache[7] || (_cache[7] = function($event) {
      return $options.onDragEnd($event);
    }),
    onMousedown: _cache[8] || (_cache[8] = function($event) {
      return $options.onMouseDown($event, 0);
    }),
    onKeydown: _cache[9] || (_cache[9] = function($event) {
      return $options.onKeyDown($event, 0);
    }),
    tabindex: _ctx.tabindex,
    role: "slider",
    "aria-valuemin": _ctx.min,
    "aria-valuenow": _ctx.modelValue ? _ctx.modelValue[0] : null,
    "aria-valuemax": _ctx.max,
    "aria-labelledby": _ctx.ariaLabelledby,
    "aria-label": _ctx.ariaLabel,
    "aria-orientation": _ctx.orientation
  }, _ctx.ptm("startHandler")), null, 16, _hoisted_2$z)) : createCommentVNode("", true), _ctx.range ? (openBlock(), createElementBlock("span", mergeProps({
    key: 2,
    "class": _ctx.cx("handle"),
    style: [_ctx.sx("handle"), $options.rangeEndHandleStyle],
    onTouchstartPassive: _cache[10] || (_cache[10] = function($event) {
      return $options.onDragStart($event, 1);
    }),
    onTouchmovePassive: _cache[11] || (_cache[11] = function($event) {
      return $options.onDrag($event);
    }),
    onTouchend: _cache[12] || (_cache[12] = function($event) {
      return $options.onDragEnd($event);
    }),
    onMousedown: _cache[13] || (_cache[13] = function($event) {
      return $options.onMouseDown($event, 1);
    }),
    onKeydown: _cache[14] || (_cache[14] = function($event) {
      return $options.onKeyDown($event, 1);
    }),
    tabindex: _ctx.tabindex,
    role: "slider",
    "aria-valuemin": _ctx.min,
    "aria-valuenow": _ctx.modelValue ? _ctx.modelValue[1] : null,
    "aria-valuemax": _ctx.max,
    "aria-labelledby": _ctx.ariaLabelledby,
    "aria-label": _ctx.ariaLabel,
    "aria-orientation": _ctx.orientation
  }, _ctx.ptm("endHandler")), null, 16, _hoisted_3$h)) : createCommentVNode("", true)], 16);
}
__name(render$u, "render$u");
script$v.render = render$u;
const _withScopeId$k = /* @__PURE__ */ __name((n) => (pushScopeId("data-v-0937e20d"), n = n(), popScopeId(), n), "_withScopeId$k");
const _hoisted_1$L = { class: "input-slider" };
const _sfc_main$E = /* @__PURE__ */ defineComponent({
  __name: "InputSlider",
  props: {
    modelValue: {},
    inputClass: {},
    sliderClass: {},
    min: {},
    max: {},
    step: {}
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const localValue = ref(props.modelValue);
    watch(
      () => props.modelValue,
      (newValue) => {
        localValue.value = newValue;
      }
    );
    const updateValue3 = /* @__PURE__ */ __name((newValue) => {
      if (newValue === null) {
        newValue = Number(props.min) || 0;
      }
      const min = Number(props.min) || Number.NEGATIVE_INFINITY;
      const max = Number(props.max) || Number.POSITIVE_INFINITY;
      const step2 = Number(props.step) || 1;
      newValue = Math.max(min, Math.min(max, newValue));
      newValue = Math.round(newValue / step2) * step2;
      localValue.value = newValue;
      emit2("update:modelValue", newValue);
    }, "updateValue");
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$L, [
        createVNode(unref(script$v), {
          modelValue: _ctx.modelValue,
          "onUpdate:modelValue": updateValue3,
          class: normalizeClass(["slider-part", _ctx.sliderClass]),
          min: _ctx.min,
          max: _ctx.max,
          step: _ctx.step
        }, null, 8, ["modelValue", "class", "min", "max", "step"]),
        createVNode(unref(script$C), {
          modelValue: _ctx.modelValue,
          "onUpdate:modelValue": updateValue3,
          class: normalizeClass(["input-part", _ctx.inputClass]),
          min: _ctx.min,
          max: _ctx.max,
          step: _ctx.step
        }, null, 8, ["modelValue", "class", "min", "max", "step"])
      ]);
    };
  }
});
const InputSlider = /* @__PURE__ */ _export_sfc(_sfc_main$E, [["__scopeId", "data-v-0937e20d"]]);
function formatCamelCase(str) {
  const isCamelCase = /^([A-Z][a-z]*)+$/.test(str);
  if (!isCamelCase) {
    return str;
  }
  const words = str.split(/(?=[A-Z][a-z])|\d+/);
  const processedWords = words.map((word) => {
    if (word.length > 1 && word === word.toUpperCase()) {
      return word;
    }
    return word.charAt(0).toUpperCase() + word.slice(1);
  });
  return processedWords.join(" ");
}
__name(formatCamelCase, "formatCamelCase");
const _withScopeId$j = /* @__PURE__ */ __name((n) => (pushScopeId("data-v-ffbfdf57"), n = n(), popScopeId(), n), "_withScopeId$j");
const _hoisted_1$K = { class: "setting-group" };
const _hoisted_2$y = { class: "setting-label" };
const _hoisted_3$g = {
  key: 2,
  class: "pi pi-info-circle info-chip"
};
const _hoisted_4$a = { class: "setting-input" };
const _sfc_main$D = /* @__PURE__ */ defineComponent({
  __name: "SettingGroup",
  props: {
    group: {},
    divider: { type: Boolean }
  },
  setup(__props) {
    const settingStore = useSettingStore();
    function getSettingAttrs(setting) {
      const attrs3 = { ...setting.attrs || {} };
      const settingType = setting.type;
      if (typeof settingType === "function") {
        attrs3["renderFunction"] = () => settingType(
          setting.name,
          (v2) => updateSetting(setting, v2),
          settingStore.get(setting.id),
          setting.attrs
        );
      }
      switch (setting.type) {
        case "combo":
          attrs3["options"] = typeof setting.options === "function" ? setting.options(settingStore.get(setting.id)) : setting.options;
          if (typeof setting.options[0] !== "string") {
            attrs3["optionLabel"] = "text";
            attrs3["optionValue"] = "value";
          }
          break;
      }
      return attrs3;
    }
    __name(getSettingAttrs, "getSettingAttrs");
    const updateSetting = /* @__PURE__ */ __name((setting, value3) => {
      if (setting.onChange) setting.onChange(value3, settingStore.get(setting.id));
      settingStore.set(setting.id, value3);
    }, "updateSetting");
    function getSettingComponent(setting) {
      if (typeof setting.type === "function") {
        return _sfc_main$F;
      }
      switch (setting.type) {
        case "boolean":
          return script$x;
        case "number":
          return script$C;
        case "slider":
          return InputSlider;
        case "combo":
          return script$y;
        default:
          return script$O;
      }
    }
    __name(getSettingComponent, "getSettingComponent");
    return (_ctx, _cache) => {
      const _directive_tooltip = resolveDirective("tooltip");
      return openBlock(), createElementBlock("div", _hoisted_1$K, [
        _ctx.divider ? (openBlock(), createBlock(unref(script$F), { key: 0 })) : createCommentVNode("", true),
        createBaseVNode("h3", null, toDisplayString$1(unref(formatCamelCase)(_ctx.group.label)), 1),
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.group.settings, (setting) => {
          return openBlock(), createElementBlock("div", {
            key: setting.id,
            class: "setting-item"
          }, [
            createBaseVNode("div", _hoisted_2$y, [
              createBaseVNode("span", null, [
                setting.experimental ? (openBlock(), createBlock(unref(script$w), {
                  key: 0,
                  value: _ctx.$t("experimental")
                }, null, 8, ["value"])) : createCommentVNode("", true),
                setting.deprecated ? (openBlock(), createBlock(unref(script$w), {
                  key: 1,
                  value: _ctx.$t("deprecated"),
                  severity: "danger"
                }, null, 8, ["value"])) : createCommentVNode("", true),
                createTextVNode(" " + toDisplayString$1(setting.name) + " ", 1),
                setting.tooltip ? withDirectives((openBlock(), createElementBlock("i", _hoisted_3$g, null, 512)), [
                  [_directive_tooltip, setting.tooltip]
                ]) : createCommentVNode("", true)
              ])
            ]),
            createBaseVNode("div", _hoisted_4$a, [
              (openBlock(), createBlock(resolveDynamicComponent(markRaw(getSettingComponent(setting))), mergeProps({
                id: setting.id,
                modelValue: unref(settingStore).get(setting.id),
                "onUpdate:modelValue": /* @__PURE__ */ __name(($event) => updateSetting(setting, $event), "onUpdate:modelValue"),
                ref_for: true
              }, getSettingAttrs(setting)), null, 16, ["id", "modelValue", "onUpdate:modelValue"]))
            ])
          ]);
        }), 128))
      ]);
    };
  }
});
const SettingGroup = /* @__PURE__ */ _export_sfc(_sfc_main$D, [["__scopeId", "data-v-ffbfdf57"]]);
var lodash$1 = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
var lodash = lodash$1.exports;
(function(module, exports) {
  ;
  (function() {
    var undefined$1;
    var VERSION2 = "4.17.21";
    var LARGE_ARRAY_SIZE = 200;
    var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_MEMOIZE_SIZE = 500;
    var PLACEHOLDER = "__lodash_placeholder__";
    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
    var INFINITY2 = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
    var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    var wrapFlags = [
      ["ary", WRAP_ARY_FLAG],
      ["bind", WRAP_BIND_FLAG],
      ["bindKey", WRAP_BIND_KEY_FLAG],
      ["curry", WRAP_CURRY_FLAG],
      ["curryRight", WRAP_CURRY_RIGHT_FLAG],
      ["flip", WRAP_FLIP_FLAG],
      ["partial", WRAP_PARTIAL_FLAG],
      ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
      ["rearg", WRAP_REARG_FLAG]
    ];
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
    var reTrimStart = /^\s+/;
    var reWhitespace = /\s/;
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
    var reEscapeChar = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "[']", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var contextProps = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ];
    var templateCounter = -1;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var deburredLetters = {
      // Latin-1 Supplement block.
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "C",
      "": "c",
      "": "D",
      "": "d",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "N",
      "": "n",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "Y",
      "": "y",
      "": "y",
      "": "Ae",
      "": "ae",
      "": "Th",
      "": "th",
      "": "ss",
      // Latin Extended-A block.
      "": "A",
      "": "A",
      "": "A",
      "": "a",
      "": "a",
      "": "a",
      "": "C",
      "": "C",
      "": "C",
      "": "C",
      "": "c",
      "": "c",
      "": "c",
      "": "c",
      "": "D",
      "": "D",
      "": "d",
      "": "d",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "G",
      "": "G",
      "": "G",
      "": "G",
      "": "g",
      "": "g",
      "": "g",
      "": "g",
      "": "H",
      "": "H",
      "": "h",
      "": "h",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "J",
      "": "j",
      "": "K",
      "": "k",
      "": "k",
      "": "L",
      "": "L",
      "": "L",
      "": "L",
      "": "L",
      "": "l",
      "": "l",
      "": "l",
      "": "l",
      "": "l",
      "": "N",
      "": "N",
      "": "N",
      "": "N",
      "": "n",
      "": "n",
      "": "n",
      "": "n",
      "": "O",
      "": "O",
      "": "O",
      "": "o",
      "": "o",
      "": "o",
      "": "R",
      "": "R",
      "": "R",
      "": "r",
      "": "r",
      "": "r",
      "": "S",
      "": "S",
      "": "S",
      "": "S",
      "": "s",
      "": "s",
      "": "s",
      "": "s",
      "": "T",
      "": "T",
      "": "T",
      "": "t",
      "": "t",
      "": "t",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "W",
      "": "w",
      "": "Y",
      "": "y",
      "": "Y",
      "": "Z",
      "": "Z",
      "": "Z",
      "": "z",
      "": "z",
      "": "z",
      "": "IJ",
      "": "ij",
      "": "Oe",
      "": "oe",
      "": "'n",
      "": "s"
    };
    var htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var htmlUnescapes = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    };
    var stringEscapes = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    var freeParseFloat = parseFloat, freeParseInt = parseInt;
    var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root26 = freeGlobal || freeSelf || Function("return this")();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply2(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    __name(apply2, "apply");
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        var value3 = array[index2];
        setter(accumulator, value3, iteratee(value3), array);
      }
      return accumulator;
    }
    __name(arrayAggregator, "arrayAggregator");
    function arrayEach(array, iteratee) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (iteratee(array[index2], index2, array) === false) {
          break;
        }
      }
      return array;
    }
    __name(arrayEach, "arrayEach");
    function arrayEachRight(array, iteratee) {
      var length = array == null ? 0 : array.length;
      while (length--) {
        if (iteratee(array[length], length, array) === false) {
          break;
        }
      }
      return array;
    }
    __name(arrayEachRight, "arrayEachRight");
    function arrayEvery(array, predicate) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (!predicate(array[index2], index2, array)) {
          return false;
        }
      }
      return true;
    }
    __name(arrayEvery, "arrayEvery");
    function arrayFilter(array, predicate) {
      var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index2 < length) {
        var value3 = array[index2];
        if (predicate(value3, index2, array)) {
          result[resIndex++] = value3;
        }
      }
      return result;
    }
    __name(arrayFilter, "arrayFilter");
    function arrayIncludes(array, value3) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value3, 0) > -1;
    }
    __name(arrayIncludes, "arrayIncludes");
    function arrayIncludesWith(array, value3, comparator2) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (comparator2(value3, array[index2])) {
          return true;
        }
      }
      return false;
    }
    __name(arrayIncludesWith, "arrayIncludesWith");
    function arrayMap(array, iteratee) {
      var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index2 < length) {
        result[index2] = iteratee(array[index2], index2, array);
      }
      return result;
    }
    __name(arrayMap, "arrayMap");
    function arrayPush(array, values2) {
      var index2 = -1, length = values2.length, offset = array.length;
      while (++index2 < length) {
        array[offset + index2] = values2[index2];
      }
      return array;
    }
    __name(arrayPush, "arrayPush");
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index2 = -1, length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[++index2];
      }
      while (++index2 < length) {
        accumulator = iteratee(accumulator, array[index2], index2, array);
      }
      return accumulator;
    }
    __name(arrayReduce, "arrayReduce");
    function arrayReduceRight(array, iteratee, accumulator, initAccum) {
      var length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
      }
      return accumulator;
    }
    __name(arrayReduceRight, "arrayReduceRight");
    function arraySome(array, predicate) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (predicate(array[index2], index2, array)) {
          return true;
        }
      }
      return false;
    }
    __name(arraySome, "arraySome");
    var asciiSize = baseProperty("length");
    function asciiToArray(string) {
      return string.split("");
    }
    __name(asciiToArray, "asciiToArray");
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    __name(asciiWords, "asciiWords");
    function baseFindKey(collection, predicate, eachFunc) {
      var result;
      eachFunc(collection, function(value3, key, collection2) {
        if (predicate(value3, key, collection2)) {
          result = key;
          return false;
        }
      });
      return result;
    }
    __name(baseFindKey, "baseFindKey");
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index2-- : ++index2 < length) {
        if (predicate(array[index2], index2, array)) {
          return index2;
        }
      }
      return -1;
    }
    __name(baseFindIndex, "baseFindIndex");
    function baseIndexOf(array, value3, fromIndex) {
      return value3 === value3 ? strictIndexOf(array, value3, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    __name(baseIndexOf, "baseIndexOf");
    function baseIndexOfWith(array, value3, fromIndex, comparator2) {
      var index2 = fromIndex - 1, length = array.length;
      while (++index2 < length) {
        if (comparator2(array[index2], value3)) {
          return index2;
        }
      }
      return -1;
    }
    __name(baseIndexOfWith, "baseIndexOfWith");
    function baseIsNaN(value3) {
      return value3 !== value3;
    }
    __name(baseIsNaN, "baseIsNaN");
    function baseMean(array, iteratee) {
      var length = array == null ? 0 : array.length;
      return length ? baseSum(array, iteratee) / length : NAN;
    }
    __name(baseMean, "baseMean");
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined$1 : object[key];
      };
    }
    __name(baseProperty, "baseProperty");
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? undefined$1 : object[key];
      };
    }
    __name(basePropertyOf, "basePropertyOf");
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value3, index2, collection2) {
        accumulator = initAccum ? (initAccum = false, value3) : iteratee(accumulator, value3, index2, collection2);
      });
      return accumulator;
    }
    __name(baseReduce, "baseReduce");
    function baseSortBy(array, comparer) {
      var length = array.length;
      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }
    __name(baseSortBy, "baseSortBy");
    function baseSum(array, iteratee) {
      var result, index2 = -1, length = array.length;
      while (++index2 < length) {
        var current = iteratee(array[index2]);
        if (current !== undefined$1) {
          result = result === undefined$1 ? current : result + current;
        }
      }
      return result;
    }
    __name(baseSum, "baseSum");
    function baseTimes(n, iteratee) {
      var index2 = -1, result = Array(n);
      while (++index2 < n) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    __name(baseTimes, "baseTimes");
    function baseToPairs(object, props) {
      return arrayMap(props, function(key) {
        return [key, object[key]];
      });
    }
    __name(baseToPairs, "baseToPairs");
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
    }
    __name(baseTrim, "baseTrim");
    function baseUnary(func) {
      return function(value3) {
        return func(value3);
      };
    }
    __name(baseUnary, "baseUnary");
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    __name(baseValues, "baseValues");
    function cacheHas(cache2, key) {
      return cache2.has(key);
    }
    __name(cacheHas, "cacheHas");
    function charsStartIndex(strSymbols, chrSymbols) {
      var index2 = -1, length = strSymbols.length;
      while (++index2 < length && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
      }
      return index2;
    }
    __name(charsStartIndex, "charsStartIndex");
    function charsEndIndex(strSymbols, chrSymbols) {
      var index2 = strSymbols.length;
      while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
      }
      return index2;
    }
    __name(charsEndIndex, "charsEndIndex");
    function countHolders(array, placeholder) {
      var length = array.length, result = 0;
      while (length--) {
        if (array[length] === placeholder) {
          ++result;
        }
      }
      return result;
    }
    __name(countHolders, "countHolders");
    var deburrLetter = basePropertyOf(deburredLetters);
    var escapeHtmlChar = basePropertyOf(htmlEscapes);
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    __name(escapeStringChar, "escapeStringChar");
    function getValue2(object, key) {
      return object == null ? undefined$1 : object[key];
    }
    __name(getValue2, "getValue");
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    __name(hasUnicode, "hasUnicode");
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    __name(hasUnicodeWord, "hasUnicodeWord");
    function iteratorToArray(iterator) {
      var data24, result = [];
      while (!(data24 = iterator.next()).done) {
        result.push(data24.value);
      }
      return result;
    }
    __name(iteratorToArray, "iteratorToArray");
    function mapToArray(map2) {
      var index2 = -1, result = Array(map2.size);
      map2.forEach(function(value3, key) {
        result[++index2] = [key, value3];
      });
      return result;
    }
    __name(mapToArray, "mapToArray");
    function overArg(func, transform2) {
      return function(arg) {
        return func(transform2(arg));
      };
    }
    __name(overArg, "overArg");
    function replaceHolders(array, placeholder) {
      var index2 = -1, length = array.length, resIndex = 0, result = [];
      while (++index2 < length) {
        var value3 = array[index2];
        if (value3 === placeholder || value3 === PLACEHOLDER) {
          array[index2] = PLACEHOLDER;
          result[resIndex++] = index2;
        }
      }
      return result;
    }
    __name(replaceHolders, "replaceHolders");
    function setToArray(set2) {
      var index2 = -1, result = Array(set2.size);
      set2.forEach(function(value3) {
        result[++index2] = value3;
      });
      return result;
    }
    __name(setToArray, "setToArray");
    function setToPairs(set2) {
      var index2 = -1, result = Array(set2.size);
      set2.forEach(function(value3) {
        result[++index2] = [value3, value3];
      });
      return result;
    }
    __name(setToPairs, "setToPairs");
    function strictIndexOf(array, value3, fromIndex) {
      var index2 = fromIndex - 1, length = array.length;
      while (++index2 < length) {
        if (array[index2] === value3) {
          return index2;
        }
      }
      return -1;
    }
    __name(strictIndexOf, "strictIndexOf");
    function strictLastIndexOf(array, value3, fromIndex) {
      var index2 = fromIndex + 1;
      while (index2--) {
        if (array[index2] === value3) {
          return index2;
        }
      }
      return index2;
    }
    __name(strictLastIndexOf, "strictLastIndexOf");
    function stringSize(string) {
      return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
    }
    __name(stringSize, "stringSize");
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    __name(stringToArray, "stringToArray");
    function trimmedEndIndex(string) {
      var index2 = string.length;
      while (index2-- && reWhitespace.test(string.charAt(index2))) {
      }
      return index2;
    }
    __name(trimmedEndIndex, "trimmedEndIndex");
    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    function unicodeSize(string) {
      var result = reUnicode.lastIndex = 0;
      while (reUnicode.test(string)) {
        ++result;
      }
      return result;
    }
    __name(unicodeSize, "unicodeSize");
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    __name(unicodeToArray, "unicodeToArray");
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    __name(unicodeWords, "unicodeWords");
    var runInContext = /* @__PURE__ */ __name(function runInContext2(context) {
      context = context == null ? root26 : _2.defaults(root26.Object(), context, _2.pick(root26, contextProps));
      var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
      var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
      var coreJsData = context["__core-js_shared__"];
      var funcToString = funcProto.toString;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      var idCounter = 0;
      var maskSrcKey = function() {
        var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid2 ? "Symbol(src)_1." + uid2 : "";
      }();
      var nativeObjectToString = objectProto.toString;
      var objectCtorString = funcToString.call(Object2);
      var oldDash = root26._;
      var reIsNative = RegExp2(
        "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      var Buffer2 = moduleExports ? context.Buffer : undefined$1, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined$1, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined$1, symIterator = Symbol2 ? Symbol2.iterator : undefined$1, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined$1;
      var defineProperty = function() {
        try {
          var func = getNative(Object2, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e) {
        }
      }();
      var ctxClearTimeout = context.clearTimeout !== root26.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root26.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root26.setTimeout && context.setTimeout;
      var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined$1, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
      var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
      var metaMap = WeakMap2 && new WeakMap2();
      var realNames = {};
      var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
      var symbolProto = Symbol2 ? Symbol2.prototype : undefined$1, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1, symbolToString = symbolProto ? symbolProto.toString : undefined$1;
      function lodash2(value3) {
        if (isObjectLike2(value3) && !isArray3(value3) && !(value3 instanceof LazyWrapper)) {
          if (value3 instanceof LodashWrapper) {
            return value3;
          }
          if (hasOwnProperty2.call(value3, "__wrapped__")) {
            return wrapperClone(value3);
          }
        }
        return new LodashWrapper(value3);
      }
      __name(lodash2, "lodash");
      var baseCreate = /* @__PURE__ */ function() {
        function object() {
        }
        __name(object, "object");
        return function(proto) {
          if (!isObject3(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object.prototype = proto;
          var result2 = new object();
          object.prototype = undefined$1;
          return result2;
        };
      }();
      function baseLodash() {
      }
      __name(baseLodash, "baseLodash");
      function LodashWrapper(value3, chainAll) {
        this.__wrapped__ = value3;
        this.__actions__ = [];
        this.__chain__ = !!chainAll;
        this.__index__ = 0;
        this.__values__ = undefined$1;
      }
      __name(LodashWrapper, "LodashWrapper");
      lodash2.templateSettings = {
        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        "escape": reEscape,
        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        "evaluate": reEvaluate,
        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        "interpolate": reInterpolate,
        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */
        "variable": "",
        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */
        "imports": {
          /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */
          "_": lodash2
        }
      };
      lodash2.prototype = baseLodash.prototype;
      lodash2.prototype.constructor = lodash2;
      LodashWrapper.prototype = baseCreate(baseLodash.prototype);
      LodashWrapper.prototype.constructor = LodashWrapper;
      function LazyWrapper(value3) {
        this.__wrapped__ = value3;
        this.__actions__ = [];
        this.__dir__ = 1;
        this.__filtered__ = false;
        this.__iteratees__ = [];
        this.__takeCount__ = MAX_ARRAY_LENGTH;
        this.__views__ = [];
      }
      __name(LazyWrapper, "LazyWrapper");
      function lazyClone() {
        var result2 = new LazyWrapper(this.__wrapped__);
        result2.__actions__ = copyArray(this.__actions__);
        result2.__dir__ = this.__dir__;
        result2.__filtered__ = this.__filtered__;
        result2.__iteratees__ = copyArray(this.__iteratees__);
        result2.__takeCount__ = this.__takeCount__;
        result2.__views__ = copyArray(this.__views__);
        return result2;
      }
      __name(lazyClone, "lazyClone");
      function lazyReverse() {
        if (this.__filtered__) {
          var result2 = new LazyWrapper(this);
          result2.__dir__ = -1;
          result2.__filtered__ = true;
        } else {
          result2 = this.clone();
          result2.__dir__ *= -1;
        }
        return result2;
      }
      __name(lazyReverse, "lazyReverse");
      function lazyValue() {
        var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray3(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start2 = view.start, end = view.end, length = end - start2, index2 = isRight ? end : start2 - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
        if (!isArr || !isRight && arrLength == length && takeCount == length) {
          return baseWrapperValue(array, this.__actions__);
        }
        var result2 = [];
        outer:
          while (length-- && resIndex < takeCount) {
            index2 += dir;
            var iterIndex = -1, value3 = array[index2];
            while (++iterIndex < iterLength) {
              var data24 = iteratees[iterIndex], iteratee2 = data24.iteratee, type = data24.type, computed2 = iteratee2(value3);
              if (type == LAZY_MAP_FLAG) {
                value3 = computed2;
              } else if (!computed2) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result2[resIndex++] = value3;
          }
        return result2;
      }
      __name(lazyValue, "lazyValue");
      LazyWrapper.prototype = baseCreate(baseLodash.prototype);
      LazyWrapper.prototype.constructor = LazyWrapper;
      function Hash(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      __name(Hash, "Hash");
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      __name(hashClear, "hashClear");
      function hashDelete(key) {
        var result2 = this.has(key) && delete this.__data__[key];
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      __name(hashDelete, "hashDelete");
      function hashGet(key) {
        var data24 = this.__data__;
        if (nativeCreate) {
          var result2 = data24[key];
          return result2 === HASH_UNDEFINED ? undefined$1 : result2;
        }
        return hasOwnProperty2.call(data24, key) ? data24[key] : undefined$1;
      }
      __name(hashGet, "hashGet");
      function hashHas(key) {
        var data24 = this.__data__;
        return nativeCreate ? data24[key] !== undefined$1 : hasOwnProperty2.call(data24, key);
      }
      __name(hashHas, "hashHas");
      function hashSet(key, value3) {
        var data24 = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data24[key] = nativeCreate && value3 === undefined$1 ? HASH_UNDEFINED : value3;
        return this;
      }
      __name(hashSet, "hashSet");
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function ListCache(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      __name(ListCache, "ListCache");
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      __name(listCacheClear, "listCacheClear");
      function listCacheDelete(key) {
        var data24 = this.__data__, index2 = assocIndexOf(data24, key);
        if (index2 < 0) {
          return false;
        }
        var lastIndex = data24.length - 1;
        if (index2 == lastIndex) {
          data24.pop();
        } else {
          splice.call(data24, index2, 1);
        }
        --this.size;
        return true;
      }
      __name(listCacheDelete, "listCacheDelete");
      function listCacheGet(key) {
        var data24 = this.__data__, index2 = assocIndexOf(data24, key);
        return index2 < 0 ? undefined$1 : data24[index2][1];
      }
      __name(listCacheGet, "listCacheGet");
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      __name(listCacheHas, "listCacheHas");
      function listCacheSet(key, value3) {
        var data24 = this.__data__, index2 = assocIndexOf(data24, key);
        if (index2 < 0) {
          ++this.size;
          data24.push([key, value3]);
        } else {
          data24[index2][1] = value3;
        }
        return this;
      }
      __name(listCacheSet, "listCacheSet");
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      __name(MapCache, "MapCache");
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map2 || ListCache)(),
          "string": new Hash()
        };
      }
      __name(mapCacheClear, "mapCacheClear");
      function mapCacheDelete(key) {
        var result2 = getMapData(this, key)["delete"](key);
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      __name(mapCacheDelete, "mapCacheDelete");
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      __name(mapCacheGet, "mapCacheGet");
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      __name(mapCacheHas, "mapCacheHas");
      function mapCacheSet(key, value3) {
        var data24 = getMapData(this, key), size3 = data24.size;
        data24.set(key, value3);
        this.size += data24.size == size3 ? 0 : 1;
        return this;
      }
      __name(mapCacheSet, "mapCacheSet");
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function SetCache(values3) {
        var index2 = -1, length = values3 == null ? 0 : values3.length;
        this.__data__ = new MapCache();
        while (++index2 < length) {
          this.add(values3[index2]);
        }
      }
      __name(SetCache, "SetCache");
      function setCacheAdd(value3) {
        this.__data__.set(value3, HASH_UNDEFINED);
        return this;
      }
      __name(setCacheAdd, "setCacheAdd");
      function setCacheHas(value3) {
        return this.__data__.has(value3);
      }
      __name(setCacheHas, "setCacheHas");
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function Stack(entries) {
        var data24 = this.__data__ = new ListCache(entries);
        this.size = data24.size;
      }
      __name(Stack, "Stack");
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      __name(stackClear, "stackClear");
      function stackDelete(key) {
        var data24 = this.__data__, result2 = data24["delete"](key);
        this.size = data24.size;
        return result2;
      }
      __name(stackDelete, "stackDelete");
      function stackGet(key) {
        return this.__data__.get(key);
      }
      __name(stackGet, "stackGet");
      function stackHas(key) {
        return this.__data__.has(key);
      }
      __name(stackHas, "stackHas");
      function stackSet(key, value3) {
        var data24 = this.__data__;
        if (data24 instanceof ListCache) {
          var pairs = data24.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value3]);
            this.size = ++data24.size;
            return this;
          }
          data24 = this.__data__ = new MapCache(pairs);
        }
        data24.set(key, value3);
        this.size = data24.size;
        return this;
      }
      __name(stackSet, "stackSet");
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function arrayLikeKeys(value3, inherited) {
        var isArr = isArray3(value3), isArg = !isArr && isArguments(value3), isBuff = !isArr && !isArg && isBuffer2(value3), isType = !isArr && !isArg && !isBuff && isTypedArray2(value3), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value3.length, String2) : [], length = result2.length;
        for (var key in value3) {
          if ((inherited || hasOwnProperty2.call(value3, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
          isIndex(key, length)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      __name(arrayLikeKeys, "arrayLikeKeys");
      function arraySample(array) {
        var length = array.length;
        return length ? array[baseRandom(0, length - 1)] : undefined$1;
      }
      __name(arraySample, "arraySample");
      function arraySampleSize(array, n) {
        return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
      }
      __name(arraySampleSize, "arraySampleSize");
      function arrayShuffle(array) {
        return shuffleSelf(copyArray(array));
      }
      __name(arrayShuffle, "arrayShuffle");
      function assignMergeValue(object, key, value3) {
        if (value3 !== undefined$1 && !eq(object[key], value3) || value3 === undefined$1 && !(key in object)) {
          baseAssignValue(object, key, value3);
        }
      }
      __name(assignMergeValue, "assignMergeValue");
      function assignValue(object, key, value3) {
        var objValue = object[key];
        if (!(hasOwnProperty2.call(object, key) && eq(objValue, value3)) || value3 === undefined$1 && !(key in object)) {
          baseAssignValue(object, key, value3);
        }
      }
      __name(assignValue, "assignValue");
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      __name(assocIndexOf, "assocIndexOf");
      function baseAggregator(collection, setter, iteratee2, accumulator) {
        baseEach(collection, function(value3, key, collection2) {
          setter(accumulator, value3, iteratee2(value3), collection2);
        });
        return accumulator;
      }
      __name(baseAggregator, "baseAggregator");
      function baseAssign(object, source) {
        return object && copyObject(source, keys2(source), object);
      }
      __name(baseAssign, "baseAssign");
      function baseAssignIn(object, source) {
        return object && copyObject(source, keysIn(source), object);
      }
      __name(baseAssignIn, "baseAssignIn");
      function baseAssignValue(object, key, value3) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object, key, {
            "configurable": true,
            "enumerable": true,
            "value": value3,
            "writable": true
          });
        } else {
          object[key] = value3;
        }
      }
      __name(baseAssignValue, "baseAssignValue");
      function baseAt(object, paths) {
        var index2 = -1, length = paths.length, result2 = Array2(length), skip = object == null;
        while (++index2 < length) {
          result2[index2] = skip ? undefined$1 : get2(object, paths[index2]);
        }
        return result2;
      }
      __name(baseAt, "baseAt");
      function baseClamp(number2, lower, upper) {
        if (number2 === number2) {
          if (upper !== undefined$1) {
            number2 = number2 <= upper ? number2 : upper;
          }
          if (lower !== undefined$1) {
            number2 = number2 >= lower ? number2 : lower;
          }
        }
        return number2;
      }
      __name(baseClamp, "baseClamp");
      function baseClone(value3, bitmask, customizer, key, object, stack2) {
        var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer) {
          result2 = object ? customizer(value3, key, object, stack2) : customizer(value3);
        }
        if (result2 !== undefined$1) {
          return result2;
        }
        if (!isObject3(value3)) {
          return value3;
        }
        var isArr = isArray3(value3);
        if (isArr) {
          result2 = initCloneArray(value3);
          if (!isDeep) {
            return copyArray(value3, result2);
          }
        } else {
          var tag = getTag2(value3), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer2(value3)) {
            return cloneBuffer(value3, isDeep);
          }
          if (tag == objectTag || tag == argsTag || isFunc && !object) {
            result2 = isFlat || isFunc ? {} : initCloneObject(value3);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value3, baseAssignIn(result2, value3)) : copySymbols(value3, baseAssign(result2, value3));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object ? value3 : {};
            }
            result2 = initCloneByTag(value3, tag, isDeep);
          }
        }
        stack2 || (stack2 = new Stack());
        var stacked = stack2.get(value3);
        if (stacked) {
          return stacked;
        }
        stack2.set(value3, result2);
        if (isSet2(value3)) {
          value3.forEach(function(subValue) {
            result2.add(baseClone(subValue, bitmask, customizer, subValue, value3, stack2));
          });
        } else if (isMap2(value3)) {
          value3.forEach(function(subValue, key2) {
            result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value3, stack2));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys2;
        var props = isArr ? undefined$1 : keysFunc(value3);
        arrayEach(props || value3, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value3[key2];
          }
          assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value3, stack2));
        });
        return result2;
      }
      __name(baseClone, "baseClone");
      function baseConforms(source) {
        var props = keys2(source);
        return function(object) {
          return baseConformsTo(object, source, props);
        };
      }
      __name(baseConforms, "baseConforms");
      function baseConformsTo(object, source, props) {
        var length = props.length;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (length--) {
          var key = props[length], predicate = source[key], value3 = object[key];
          if (value3 === undefined$1 && !(key in object) || !predicate(value3)) {
            return false;
          }
        }
        return true;
      }
      __name(baseConformsTo, "baseConformsTo");
      function baseDelay(func, wait, args) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return setTimeout2(function() {
          func.apply(undefined$1, args);
        }, wait);
      }
      __name(baseDelay, "baseDelay");
      function baseDifference(array, values3, iteratee2, comparator2) {
        var index2 = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values3.length;
        if (!length) {
          return result2;
        }
        if (iteratee2) {
          values3 = arrayMap(values3, baseUnary(iteratee2));
        }
        if (comparator2) {
          includes2 = arrayIncludesWith;
          isCommon = false;
        } else if (values3.length >= LARGE_ARRAY_SIZE) {
          includes2 = cacheHas;
          isCommon = false;
          values3 = new SetCache(values3);
        }
        outer:
          while (++index2 < length) {
            var value3 = array[index2], computed2 = iteratee2 == null ? value3 : iteratee2(value3);
            value3 = comparator2 || value3 !== 0 ? value3 : 0;
            if (isCommon && computed2 === computed2) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values3[valuesIndex] === computed2) {
                  continue outer;
                }
              }
              result2.push(value3);
            } else if (!includes2(values3, computed2, comparator2)) {
              result2.push(value3);
            }
          }
        return result2;
      }
      __name(baseDifference, "baseDifference");
      var baseEach = createBaseEach(baseForOwn);
      var baseEachRight = createBaseEach(baseForOwnRight, true);
      function baseEvery(collection, predicate) {
        var result2 = true;
        baseEach(collection, function(value3, index2, collection2) {
          result2 = !!predicate(value3, index2, collection2);
          return result2;
        });
        return result2;
      }
      __name(baseEvery, "baseEvery");
      function baseExtremum(array, iteratee2, comparator2) {
        var index2 = -1, length = array.length;
        while (++index2 < length) {
          var value3 = array[index2], current = iteratee2(value3);
          if (current != null && (computed2 === undefined$1 ? current === current && !isSymbol2(current) : comparator2(current, computed2))) {
            var computed2 = current, result2 = value3;
          }
        }
        return result2;
      }
      __name(baseExtremum, "baseExtremum");
      function baseFill(array, value3, start2, end) {
        var length = array.length;
        start2 = toInteger(start2);
        if (start2 < 0) {
          start2 = -start2 > length ? 0 : length + start2;
        }
        end = end === undefined$1 || end > length ? length : toInteger(end);
        if (end < 0) {
          end += length;
        }
        end = start2 > end ? 0 : toLength(end);
        while (start2 < end) {
          array[start2++] = value3;
        }
        return array;
      }
      __name(baseFill, "baseFill");
      function baseFilter(collection, predicate) {
        var result2 = [];
        baseEach(collection, function(value3, index2, collection2) {
          if (predicate(value3, index2, collection2)) {
            result2.push(value3);
          }
        });
        return result2;
      }
      __name(baseFilter, "baseFilter");
      function baseFlatten(array, depth, predicate, isStrict, result2) {
        var index2 = -1, length = array.length;
        predicate || (predicate = isFlattenable);
        result2 || (result2 = []);
        while (++index2 < length) {
          var value3 = array[index2];
          if (depth > 0 && predicate(value3)) {
            if (depth > 1) {
              baseFlatten(value3, depth - 1, predicate, isStrict, result2);
            } else {
              arrayPush(result2, value3);
            }
          } else if (!isStrict) {
            result2[result2.length] = value3;
          }
        }
        return result2;
      }
      __name(baseFlatten, "baseFlatten");
      var baseFor = createBaseFor();
      var baseForRight = createBaseFor(true);
      function baseForOwn(object, iteratee2) {
        return object && baseFor(object, iteratee2, keys2);
      }
      __name(baseForOwn, "baseForOwn");
      function baseForOwnRight(object, iteratee2) {
        return object && baseForRight(object, iteratee2, keys2);
      }
      __name(baseForOwnRight, "baseForOwnRight");
      function baseFunctions(object, props) {
        return arrayFilter(props, function(key) {
          return isFunction3(object[key]);
        });
      }
      __name(baseFunctions, "baseFunctions");
      function baseGet(object, path) {
        path = castPath(path, object);
        var index2 = 0, length = path.length;
        while (object != null && index2 < length) {
          object = object[toKey(path[index2++])];
        }
        return index2 && index2 == length ? object : undefined$1;
      }
      __name(baseGet, "baseGet");
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result2 = keysFunc(object);
        return isArray3(object) ? result2 : arrayPush(result2, symbolsFunc(object));
      }
      __name(baseGetAllKeys, "baseGetAllKeys");
      function baseGetTag(value3) {
        if (value3 == null) {
          return value3 === undefined$1 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object2(value3) ? getRawTag(value3) : objectToString2(value3);
      }
      __name(baseGetTag, "baseGetTag");
      function baseGt(value3, other) {
        return value3 > other;
      }
      __name(baseGt, "baseGt");
      function baseHas(object, key) {
        return object != null && hasOwnProperty2.call(object, key);
      }
      __name(baseHas, "baseHas");
      function baseHasIn(object, key) {
        return object != null && key in Object2(object);
      }
      __name(baseHasIn, "baseHasIn");
      function baseInRange(number2, start2, end) {
        return number2 >= nativeMin(start2, end) && number2 < nativeMax(start2, end);
      }
      __name(baseInRange, "baseInRange");
      function baseIntersection(arrays, iteratee2, comparator2) {
        var includes2 = comparator2 ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
        while (othIndex--) {
          var array = arrays[othIndex];
          if (othIndex && iteratee2) {
            array = arrayMap(array, baseUnary(iteratee2));
          }
          maxLength = nativeMin(array.length, maxLength);
          caches[othIndex] = !comparator2 && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined$1;
        }
        array = arrays[0];
        var index2 = -1, seen2 = caches[0];
        outer:
          while (++index2 < length && result2.length < maxLength) {
            var value3 = array[index2], computed2 = iteratee2 ? iteratee2(value3) : value3;
            value3 = comparator2 || value3 !== 0 ? value3 : 0;
            if (!(seen2 ? cacheHas(seen2, computed2) : includes2(result2, computed2, comparator2))) {
              othIndex = othLength;
              while (--othIndex) {
                var cache2 = caches[othIndex];
                if (!(cache2 ? cacheHas(cache2, computed2) : includes2(arrays[othIndex], computed2, comparator2))) {
                  continue outer;
                }
              }
              if (seen2) {
                seen2.push(computed2);
              }
              result2.push(value3);
            }
          }
        return result2;
      }
      __name(baseIntersection, "baseIntersection");
      function baseInverter(object, setter, iteratee2, accumulator) {
        baseForOwn(object, function(value3, key, object2) {
          setter(accumulator, iteratee2(value3), key, object2);
        });
        return accumulator;
      }
      __name(baseInverter, "baseInverter");
      function baseInvoke(object, path, args) {
        path = castPath(path, object);
        object = parent(object, path);
        var func = object == null ? object : object[toKey(last(path))];
        return func == null ? undefined$1 : apply2(func, object, args);
      }
      __name(baseInvoke, "baseInvoke");
      function baseIsArguments(value3) {
        return isObjectLike2(value3) && baseGetTag(value3) == argsTag;
      }
      __name(baseIsArguments, "baseIsArguments");
      function baseIsArrayBuffer(value3) {
        return isObjectLike2(value3) && baseGetTag(value3) == arrayBufferTag;
      }
      __name(baseIsArrayBuffer, "baseIsArrayBuffer");
      function baseIsDate(value3) {
        return isObjectLike2(value3) && baseGetTag(value3) == dateTag;
      }
      __name(baseIsDate, "baseIsDate");
      function baseIsEqual(value3, other, bitmask, customizer, stack2) {
        if (value3 === other) {
          return true;
        }
        if (value3 == null || other == null || !isObjectLike2(value3) && !isObjectLike2(other)) {
          return value3 !== value3 && other !== other;
        }
        return baseIsEqualDeep(value3, other, bitmask, customizer, baseIsEqual, stack2);
      }
      __name(baseIsEqual, "baseIsEqual");
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack2) {
        var objIsArr = isArray3(object), othIsArr = isArray3(other), objTag = objIsArr ? arrayTag : getTag2(object), othTag = othIsArr ? arrayTag : getTag2(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer2(object)) {
          if (!isBuffer2(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack2 || (stack2 = new Stack());
          return objIsArr || isTypedArray2(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack2) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack2);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack2 || (stack2 = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack2 || (stack2 = new Stack());
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack2);
      }
      __name(baseIsEqualDeep, "baseIsEqualDeep");
      function baseIsMap(value3) {
        return isObjectLike2(value3) && getTag2(value3) == mapTag;
      }
      __name(baseIsMap, "baseIsMap");
      function baseIsMatch(object, source, matchData, customizer) {
        var index2 = matchData.length, length = index2, noCustomizer = !customizer;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (index2--) {
          var data24 = matchData[index2];
          if (noCustomizer && data24[2] ? data24[1] !== object[data24[0]] : !(data24[0] in object)) {
            return false;
          }
        }
        while (++index2 < length) {
          data24 = matchData[index2];
          var key = data24[0], objValue = object[key], srcValue = data24[1];
          if (noCustomizer && data24[2]) {
            if (objValue === undefined$1 && !(key in object)) {
              return false;
            }
          } else {
            var stack2 = new Stack();
            if (customizer) {
              var result2 = customizer(objValue, srcValue, key, object, source, stack2);
            }
            if (!(result2 === undefined$1 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack2) : result2)) {
              return false;
            }
          }
        }
        return true;
      }
      __name(baseIsMatch, "baseIsMatch");
      function baseIsNative(value3) {
        if (!isObject3(value3) || isMasked(value3)) {
          return false;
        }
        var pattern = isFunction3(value3) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value3));
      }
      __name(baseIsNative, "baseIsNative");
      function baseIsRegExp(value3) {
        return isObjectLike2(value3) && baseGetTag(value3) == regexpTag;
      }
      __name(baseIsRegExp, "baseIsRegExp");
      function baseIsSet(value3) {
        return isObjectLike2(value3) && getTag2(value3) == setTag;
      }
      __name(baseIsSet, "baseIsSet");
      function baseIsTypedArray(value3) {
        return isObjectLike2(value3) && isLength(value3.length) && !!typedArrayTags[baseGetTag(value3)];
      }
      __name(baseIsTypedArray, "baseIsTypedArray");
      function baseIteratee(value3) {
        if (typeof value3 == "function") {
          return value3;
        }
        if (value3 == null) {
          return identity2;
        }
        if (typeof value3 == "object") {
          return isArray3(value3) ? baseMatchesProperty(value3[0], value3[1]) : baseMatches(value3);
        }
        return property(value3);
      }
      __name(baseIteratee, "baseIteratee");
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result2 = [];
        for (var key in Object2(object)) {
          if (hasOwnProperty2.call(object, key) && key != "constructor") {
            result2.push(key);
          }
        }
        return result2;
      }
      __name(baseKeys, "baseKeys");
      function baseKeysIn(object) {
        if (!isObject3(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype(object), result2 = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      __name(baseKeysIn, "baseKeysIn");
      function baseLt(value3, other) {
        return value3 < other;
      }
      __name(baseLt, "baseLt");
      function baseMap(collection, iteratee2) {
        var index2 = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value3, key, collection2) {
          result2[++index2] = iteratee2(value3, key, collection2);
        });
        return result2;
      }
      __name(baseMap, "baseMap");
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }
      __name(baseMatches, "baseMatches");
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object) {
          var objValue = get2(object, path);
          return objValue === undefined$1 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      __name(baseMatchesProperty, "baseMatchesProperty");
      function baseMerge(object, source, srcIndex, customizer, stack2) {
        if (object === source) {
          return;
        }
        baseFor(source, function(srcValue, key) {
          stack2 || (stack2 = new Stack());
          if (isObject3(srcValue)) {
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack2);
          } else {
            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack2) : undefined$1;
            if (newValue === undefined$1) {
              newValue = srcValue;
            }
            assignMergeValue(object, key, newValue);
          }
        }, keysIn);
      }
      __name(baseMerge, "baseMerge");
      function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack2) {
        var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack2.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack2) : undefined$1;
        var isCommon = newValue === undefined$1;
        if (isCommon) {
          var isArr = isArray3(srcValue), isBuff = !isArr && isBuffer2(srcValue), isTyped = !isArr && !isBuff && isTypedArray2(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray3(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject3(objValue) || isFunction3(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack2.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack2);
          stack2["delete"](srcValue);
        }
        assignMergeValue(object, key, newValue);
      }
      __name(baseMergeDeep, "baseMergeDeep");
      function baseNth(array, n) {
        var length = array.length;
        if (!length) {
          return;
        }
        n += n < 0 ? length : 0;
        return isIndex(n, length) ? array[n] : undefined$1;
      }
      __name(baseNth, "baseNth");
      function baseOrderBy(collection, iteratees, orders) {
        if (iteratees.length) {
          iteratees = arrayMap(iteratees, function(iteratee2) {
            if (isArray3(iteratee2)) {
              return function(value3) {
                return baseGet(value3, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
              };
            }
            return iteratee2;
          });
        } else {
          iteratees = [identity2];
        }
        var index2 = -1;
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        var result2 = baseMap(collection, function(value3, key, collection2) {
          var criteria = arrayMap(iteratees, function(iteratee2) {
            return iteratee2(value3);
          });
          return { "criteria": criteria, "index": ++index2, "value": value3 };
        });
        return baseSortBy(result2, function(object, other) {
          return compareMultiple(object, other, orders);
        });
      }
      __name(baseOrderBy, "baseOrderBy");
      function basePick(object, paths) {
        return basePickBy(object, paths, function(value3, path) {
          return hasIn(object, path);
        });
      }
      __name(basePick, "basePick");
      function basePickBy(object, paths, predicate) {
        var index2 = -1, length = paths.length, result2 = {};
        while (++index2 < length) {
          var path = paths[index2], value3 = baseGet(object, path);
          if (predicate(value3, path)) {
            baseSet(result2, castPath(path, object), value3);
          }
        }
        return result2;
      }
      __name(basePickBy, "basePickBy");
      function basePropertyDeep(path) {
        return function(object) {
          return baseGet(object, path);
        };
      }
      __name(basePropertyDeep, "basePropertyDeep");
      function basePullAll(array, values3, iteratee2, comparator2) {
        var indexOf2 = comparator2 ? baseIndexOfWith : baseIndexOf, index2 = -1, length = values3.length, seen2 = array;
        if (array === values3) {
          values3 = copyArray(values3);
        }
        if (iteratee2) {
          seen2 = arrayMap(array, baseUnary(iteratee2));
        }
        while (++index2 < length) {
          var fromIndex = 0, value3 = values3[index2], computed2 = iteratee2 ? iteratee2(value3) : value3;
          while ((fromIndex = indexOf2(seen2, computed2, fromIndex, comparator2)) > -1) {
            if (seen2 !== array) {
              splice.call(seen2, fromIndex, 1);
            }
            splice.call(array, fromIndex, 1);
          }
        }
        return array;
      }
      __name(basePullAll, "basePullAll");
      function basePullAt(array, indexes) {
        var length = array ? indexes.length : 0, lastIndex = length - 1;
        while (length--) {
          var index2 = indexes[length];
          if (length == lastIndex || index2 !== previous) {
            var previous = index2;
            if (isIndex(index2)) {
              splice.call(array, index2, 1);
            } else {
              baseUnset(array, index2);
            }
          }
        }
        return array;
      }
      __name(basePullAt, "basePullAt");
      function baseRandom(lower, upper) {
        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
      }
      __name(baseRandom, "baseRandom");
      function baseRange(start2, end, step2, fromRight) {
        var index2 = -1, length = nativeMax(nativeCeil((end - start2) / (step2 || 1)), 0), result2 = Array2(length);
        while (length--) {
          result2[fromRight ? length : ++index2] = start2;
          start2 += step2;
        }
        return result2;
      }
      __name(baseRange, "baseRange");
      function baseRepeat(string, n) {
        var result2 = "";
        if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
          return result2;
        }
        do {
          if (n % 2) {
            result2 += string;
          }
          n = nativeFloor(n / 2);
          if (n) {
            string += string;
          }
        } while (n);
        return result2;
      }
      __name(baseRepeat, "baseRepeat");
      function baseRest(func, start2) {
        return setToString(overRest(func, start2, identity2), func + "");
      }
      __name(baseRest, "baseRest");
      function baseSample(collection) {
        return arraySample(values2(collection));
      }
      __name(baseSample, "baseSample");
      function baseSampleSize(collection, n) {
        var array = values2(collection);
        return shuffleSelf(array, baseClamp(n, 0, array.length));
      }
      __name(baseSampleSize, "baseSampleSize");
      function baseSet(object, path, value3, customizer) {
        if (!isObject3(object)) {
          return object;
        }
        path = castPath(path, object);
        var index2 = -1, length = path.length, lastIndex = length - 1, nested = object;
        while (nested != null && ++index2 < length) {
          var key = toKey(path[index2]), newValue = value3;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object;
          }
          if (index2 != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
            if (newValue === undefined$1) {
              newValue = isObject3(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object;
      }
      __name(baseSet, "baseSet");
      var baseSetData = !metaMap ? identity2 : function(func, data24) {
        metaMap.set(func, data24);
        return func;
      };
      var baseSetToString = !defineProperty ? identity2 : function(func, string) {
        return defineProperty(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant(string),
          "writable": true
        });
      };
      function baseShuffle(collection) {
        return shuffleSelf(values2(collection));
      }
      __name(baseShuffle, "baseShuffle");
      function baseSlice(array, start2, end) {
        var index2 = -1, length = array.length;
        if (start2 < 0) {
          start2 = -start2 > length ? 0 : length + start2;
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start2 > end ? 0 : end - start2 >>> 0;
        start2 >>>= 0;
        var result2 = Array2(length);
        while (++index2 < length) {
          result2[index2] = array[index2 + start2];
        }
        return result2;
      }
      __name(baseSlice, "baseSlice");
      function baseSome(collection, predicate) {
        var result2;
        baseEach(collection, function(value3, index2, collection2) {
          result2 = predicate(value3, index2, collection2);
          return !result2;
        });
        return !!result2;
      }
      __name(baseSome, "baseSome");
      function baseSortedIndex(array, value3, retHighest) {
        var low = 0, high = array == null ? low : array.length;
        if (typeof value3 == "number" && value3 === value3 && high <= HALF_MAX_ARRAY_LENGTH) {
          while (low < high) {
            var mid = low + high >>> 1, computed2 = array[mid];
            if (computed2 !== null && !isSymbol2(computed2) && (retHighest ? computed2 <= value3 : computed2 < value3)) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return high;
        }
        return baseSortedIndexBy(array, value3, identity2, retHighest);
      }
      __name(baseSortedIndex, "baseSortedIndex");
      function baseSortedIndexBy(array, value3, iteratee2, retHighest) {
        var low = 0, high = array == null ? 0 : array.length;
        if (high === 0) {
          return 0;
        }
        value3 = iteratee2(value3);
        var valIsNaN = value3 !== value3, valIsNull = value3 === null, valIsSymbol = isSymbol2(value3), valIsUndefined = value3 === undefined$1;
        while (low < high) {
          var mid = nativeFloor((low + high) / 2), computed2 = iteratee2(array[mid]), othIsDefined = computed2 !== undefined$1, othIsNull = computed2 === null, othIsReflexive = computed2 === computed2, othIsSymbol = isSymbol2(computed2);
          if (valIsNaN) {
            var setLow = retHighest || othIsReflexive;
          } else if (valIsUndefined) {
            setLow = othIsReflexive && (retHighest || othIsDefined);
          } else if (valIsNull) {
            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
          } else if (valIsSymbol) {
            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
          } else if (othIsNull || othIsSymbol) {
            setLow = false;
          } else {
            setLow = retHighest ? computed2 <= value3 : computed2 < value3;
          }
          if (setLow) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return nativeMin(high, MAX_ARRAY_INDEX);
      }
      __name(baseSortedIndexBy, "baseSortedIndexBy");
      function baseSortedUniq(array, iteratee2) {
        var index2 = -1, length = array.length, resIndex = 0, result2 = [];
        while (++index2 < length) {
          var value3 = array[index2], computed2 = iteratee2 ? iteratee2(value3) : value3;
          if (!index2 || !eq(computed2, seen2)) {
            var seen2 = computed2;
            result2[resIndex++] = value3 === 0 ? 0 : value3;
          }
        }
        return result2;
      }
      __name(baseSortedUniq, "baseSortedUniq");
      function baseToNumber(value3) {
        if (typeof value3 == "number") {
          return value3;
        }
        if (isSymbol2(value3)) {
          return NAN;
        }
        return +value3;
      }
      __name(baseToNumber, "baseToNumber");
      function baseToString2(value3) {
        if (typeof value3 == "string") {
          return value3;
        }
        if (isArray3(value3)) {
          return arrayMap(value3, baseToString2) + "";
        }
        if (isSymbol2(value3)) {
          return symbolToString ? symbolToString.call(value3) : "";
        }
        var result2 = value3 + "";
        return result2 == "0" && 1 / value3 == -INFINITY2 ? "-0" : result2;
      }
      __name(baseToString2, "baseToString");
      function baseUniq(array, iteratee2, comparator2) {
        var index2 = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen2 = result2;
        if (comparator2) {
          isCommon = false;
          includes2 = arrayIncludesWith;
        } else if (length >= LARGE_ARRAY_SIZE) {
          var set3 = iteratee2 ? null : createSet(array);
          if (set3) {
            return setToArray(set3);
          }
          isCommon = false;
          includes2 = cacheHas;
          seen2 = new SetCache();
        } else {
          seen2 = iteratee2 ? [] : result2;
        }
        outer:
          while (++index2 < length) {
            var value3 = array[index2], computed2 = iteratee2 ? iteratee2(value3) : value3;
            value3 = comparator2 || value3 !== 0 ? value3 : 0;
            if (isCommon && computed2 === computed2) {
              var seenIndex = seen2.length;
              while (seenIndex--) {
                if (seen2[seenIndex] === computed2) {
                  continue outer;
                }
              }
              if (iteratee2) {
                seen2.push(computed2);
              }
              result2.push(value3);
            } else if (!includes2(seen2, computed2, comparator2)) {
              if (seen2 !== result2) {
                seen2.push(computed2);
              }
              result2.push(value3);
            }
          }
        return result2;
      }
      __name(baseUniq, "baseUniq");
      function baseUnset(object, path) {
        path = castPath(path, object);
        object = parent(object, path);
        return object == null || delete object[toKey(last(path))];
      }
      __name(baseUnset, "baseUnset");
      function baseUpdate(object, path, updater, customizer) {
        return baseSet(object, path, updater(baseGet(object, path)), customizer);
      }
      __name(baseUpdate, "baseUpdate");
      function baseWhile(array, predicate, isDrop, fromRight) {
        var length = array.length, index2 = fromRight ? length : -1;
        while ((fromRight ? index2-- : ++index2 < length) && predicate(array[index2], index2, array)) {
        }
        return isDrop ? baseSlice(array, fromRight ? 0 : index2, fromRight ? index2 + 1 : length) : baseSlice(array, fromRight ? index2 + 1 : 0, fromRight ? length : index2);
      }
      __name(baseWhile, "baseWhile");
      function baseWrapperValue(value3, actions) {
        var result2 = value3;
        if (result2 instanceof LazyWrapper) {
          result2 = result2.value();
        }
        return arrayReduce(actions, function(result3, action) {
          return action.func.apply(action.thisArg, arrayPush([result3], action.args));
        }, result2);
      }
      __name(baseWrapperValue, "baseWrapperValue");
      function baseXor(arrays, iteratee2, comparator2) {
        var length = arrays.length;
        if (length < 2) {
          return length ? baseUniq(arrays[0]) : [];
        }
        var index2 = -1, result2 = Array2(length);
        while (++index2 < length) {
          var array = arrays[index2], othIndex = -1;
          while (++othIndex < length) {
            if (othIndex != index2) {
              result2[index2] = baseDifference(result2[index2] || array, arrays[othIndex], iteratee2, comparator2);
            }
          }
        }
        return baseUniq(baseFlatten(result2, 1), iteratee2, comparator2);
      }
      __name(baseXor, "baseXor");
      function baseZipObject(props, values3, assignFunc) {
        var index2 = -1, length = props.length, valsLength = values3.length, result2 = {};
        while (++index2 < length) {
          var value3 = index2 < valsLength ? values3[index2] : undefined$1;
          assignFunc(result2, props[index2], value3);
        }
        return result2;
      }
      __name(baseZipObject, "baseZipObject");
      function castArrayLikeObject(value3) {
        return isArrayLikeObject(value3) ? value3 : [];
      }
      __name(castArrayLikeObject, "castArrayLikeObject");
      function castFunction(value3) {
        return typeof value3 == "function" ? value3 : identity2;
      }
      __name(castFunction, "castFunction");
      function castPath(value3, object) {
        if (isArray3(value3)) {
          return value3;
        }
        return isKey(value3, object) ? [value3] : stringToPath(toString3(value3));
      }
      __name(castPath, "castPath");
      var castRest = baseRest;
      function castSlice(array, start2, end) {
        var length = array.length;
        end = end === undefined$1 ? length : end;
        return !start2 && end >= length ? array : baseSlice(array, start2, end);
      }
      __name(castSlice, "castSlice");
      var clearTimeout2 = ctxClearTimeout || function(id2) {
        return root26.clearTimeout(id2);
      };
      function cloneBuffer(buffer2, isDeep) {
        if (isDeep) {
          return buffer2.slice();
        }
        var length = buffer2.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer2.constructor(length);
        buffer2.copy(result2);
        return result2;
      }
      __name(cloneBuffer, "cloneBuffer");
      function cloneArrayBuffer(arrayBuffer) {
        var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
        return result2;
      }
      __name(cloneArrayBuffer, "cloneArrayBuffer");
      function cloneDataView(dataView, isDeep) {
        var buffer2 = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer2, dataView.byteOffset, dataView.byteLength);
      }
      __name(cloneDataView, "cloneDataView");
      function cloneRegExp(regexp) {
        var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result2.lastIndex = regexp.lastIndex;
        return result2;
      }
      __name(cloneRegExp, "cloneRegExp");
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
      }
      __name(cloneSymbol, "cloneSymbol");
      function cloneTypedArray(typedArray, isDeep) {
        var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
      }
      __name(cloneTypedArray, "cloneTypedArray");
      function compareAscending(value3, other) {
        if (value3 !== other) {
          var valIsDefined = value3 !== undefined$1, valIsNull = value3 === null, valIsReflexive = value3 === value3, valIsSymbol = isSymbol2(value3);
          var othIsDefined = other !== undefined$1, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol2(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value3 > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value3 < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      __name(compareAscending, "compareAscending");
      function compareMultiple(object, other, orders) {
        var index2 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
        while (++index2 < length) {
          var result2 = compareAscending(objCriteria[index2], othCriteria[index2]);
          if (result2) {
            if (index2 >= ordersLength) {
              return result2;
            }
            var order = orders[index2];
            return result2 * (order == "desc" ? -1 : 1);
          }
        }
        return object.index - other.index;
      }
      __name(compareMultiple, "compareMultiple");
      function composeArgs(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
        while (++leftIndex < leftLength) {
          result2[leftIndex] = partials[leftIndex];
        }
        while (++argsIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[holders[argsIndex]] = args[argsIndex];
          }
        }
        while (rangeLength--) {
          result2[leftIndex++] = args[argsIndex++];
        }
        return result2;
      }
      __name(composeArgs, "composeArgs");
      function composeArgsRight(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
        while (++argsIndex < rangeLength) {
          result2[argsIndex] = args[argsIndex];
        }
        var offset = argsIndex;
        while (++rightIndex < rightLength) {
          result2[offset + rightIndex] = partials[rightIndex];
        }
        while (++holdersIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[offset + holders[holdersIndex]] = args[argsIndex++];
          }
        }
        return result2;
      }
      __name(composeArgsRight, "composeArgsRight");
      function copyArray(source, array) {
        var index2 = -1, length = source.length;
        array || (array = Array2(length));
        while (++index2 < length) {
          array[index2] = source[index2];
        }
        return array;
      }
      __name(copyArray, "copyArray");
      function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index2 = -1, length = props.length;
        while (++index2 < length) {
          var key = props[index2];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined$1;
          if (newValue === undefined$1) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object, key, newValue);
          } else {
            assignValue(object, key, newValue);
          }
        }
        return object;
      }
      __name(copyObject, "copyObject");
      function copySymbols(source, object) {
        return copyObject(source, getSymbols(source), object);
      }
      __name(copySymbols, "copySymbols");
      function copySymbolsIn(source, object) {
        return copyObject(source, getSymbolsIn(source), object);
      }
      __name(copySymbolsIn, "copySymbolsIn");
      function createAggregator(setter, initializer) {
        return function(collection, iteratee2) {
          var func = isArray3(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
        };
      }
      __name(createAggregator, "createAggregator");
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined$1, guard = length > 2 ? sources[2] : undefined$1;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined$1;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined$1 : customizer;
            length = 1;
          }
          object = Object2(object);
          while (++index2 < length) {
            var source = sources[index2];
            if (source) {
              assigner(object, source, index2, customizer);
            }
          }
          return object;
        });
      }
      __name(createAssigner, "createAssigner");
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee2) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee2);
          }
          var length = collection.length, index2 = fromRight ? length : -1, iterable = Object2(collection);
          while (fromRight ? index2-- : ++index2 < length) {
            if (iteratee2(iterable[index2], index2, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      __name(createBaseEach, "createBaseEach");
      function createBaseFor(fromRight) {
        return function(object, iteratee2, keysFunc) {
          var index2 = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index2];
            if (iteratee2(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      __name(createBaseFor, "createBaseFor");
      function createBind(func, bitmask, thisArg) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var fn = this && this !== root26 && this instanceof wrapper ? Ctor : func;
          return fn.apply(isBind ? thisArg : this, arguments);
        }
        __name(wrapper, "wrapper");
        return wrapper;
      }
      __name(createBind, "createBind");
      function createCaseFirst(methodName) {
        return function(string) {
          string = toString3(string);
          var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined$1;
          var chr = strSymbols ? strSymbols[0] : string.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      __name(createCaseFirst, "createCaseFirst");
      function createCompounder(callback) {
        return function(string) {
          return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
        };
      }
      __name(createCompounder, "createCompounder");
      function createCtor(Ctor) {
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return new Ctor();
            case 1:
              return new Ctor(args[0]);
            case 2:
              return new Ctor(args[0], args[1]);
            case 3:
              return new Ctor(args[0], args[1], args[2]);
            case 4:
              return new Ctor(args[0], args[1], args[2], args[3]);
            case 5:
              return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            case 6:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
            case 7:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          }
          var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
          return isObject3(result2) ? result2 : thisBinding;
        };
      }
      __name(createCtor, "createCtor");
      function createCurry(func, bitmask, arity) {
        var Ctor = createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index2 = length, placeholder = getHolder(wrapper);
          while (index2--) {
            args[index2] = arguments[index2];
          }
          var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
          length -= holders.length;
          if (length < arity) {
            return createRecurry(
              func,
              bitmask,
              createHybrid,
              wrapper.placeholder,
              undefined$1,
              args,
              holders,
              undefined$1,
              undefined$1,
              arity - length
            );
          }
          var fn = this && this !== root26 && this instanceof wrapper ? Ctor : func;
          return apply2(fn, this, args);
        }
        __name(wrapper, "wrapper");
        return wrapper;
      }
      __name(createCurry, "createCurry");
      function createFind(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object2(collection);
          if (!isArrayLike(collection)) {
            var iteratee2 = getIteratee(predicate, 3);
            collection = keys2(collection);
            predicate = /* @__PURE__ */ __name(function(key) {
              return iteratee2(iterable[key], key, iterable);
            }, "predicate");
          }
          var index2 = findIndexFunc(collection, predicate, fromIndex);
          return index2 > -1 ? iterable[iteratee2 ? collection[index2] : index2] : undefined$1;
        };
      }
      __name(createFind, "createFind");
      function createFlow(fromRight) {
        return flatRest(function(funcs) {
          var length = funcs.length, index2 = length, prereq = LodashWrapper.prototype.thru;
          if (fromRight) {
            funcs.reverse();
          }
          while (index2--) {
            var func = funcs[index2];
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (prereq && !wrapper && getFuncName(func) == "wrapper") {
              var wrapper = new LodashWrapper([], true);
            }
          }
          index2 = wrapper ? index2 : length;
          while (++index2 < length) {
            func = funcs[index2];
            var funcName = getFuncName(func), data24 = funcName == "wrapper" ? getData(func) : undefined$1;
            if (data24 && isLaziable(data24[0]) && data24[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data24[4].length && data24[9] == 1) {
              wrapper = wrapper[getFuncName(data24[0])].apply(wrapper, data24[3]);
            } else {
              wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
            }
          }
          return function() {
            var args = arguments, value3 = args[0];
            if (wrapper && args.length == 1 && isArray3(value3)) {
              return wrapper.plant(value3).value();
            }
            var index3 = 0, result2 = length ? funcs[index3].apply(this, args) : value3;
            while (++index3 < length) {
              result2 = funcs[index3].call(this, result2);
            }
            return result2;
          };
        });
      }
      __name(createFlow, "createFlow");
      function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
        var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$1 : createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index2 = length;
          while (index2--) {
            args[index2] = arguments[index2];
          }
          if (isCurried) {
            var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
          }
          if (partials) {
            args = composeArgs(args, partials, holders, isCurried);
          }
          if (partialsRight) {
            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
          }
          length -= holdersCount;
          if (isCurried && length < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(
              func,
              bitmask,
              createHybrid,
              wrapper.placeholder,
              thisArg,
              args,
              newHolders,
              argPos,
              ary2,
              arity - length
            );
          }
          var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
          length = args.length;
          if (argPos) {
            args = reorder(args, argPos);
          } else if (isFlip && length > 1) {
            args.reverse();
          }
          if (isAry && ary2 < length) {
            args.length = ary2;
          }
          if (this && this !== root26 && this instanceof wrapper) {
            fn = Ctor || createCtor(fn);
          }
          return fn.apply(thisBinding, args);
        }
        __name(wrapper, "wrapper");
        return wrapper;
      }
      __name(createHybrid, "createHybrid");
      function createInverter(setter, toIteratee) {
        return function(object, iteratee2) {
          return baseInverter(object, setter, toIteratee(iteratee2), {});
        };
      }
      __name(createInverter, "createInverter");
      function createMathOperation(operator, defaultValue) {
        return function(value3, other) {
          var result2;
          if (value3 === undefined$1 && other === undefined$1) {
            return defaultValue;
          }
          if (value3 !== undefined$1) {
            result2 = value3;
          }
          if (other !== undefined$1) {
            if (result2 === undefined$1) {
              return other;
            }
            if (typeof value3 == "string" || typeof other == "string") {
              value3 = baseToString2(value3);
              other = baseToString2(other);
            } else {
              value3 = baseToNumber(value3);
              other = baseToNumber(other);
            }
            result2 = operator(value3, other);
          }
          return result2;
        };
      }
      __name(createMathOperation, "createMathOperation");
      function createOver(arrayFunc) {
        return flatRest(function(iteratees) {
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          return baseRest(function(args) {
            var thisArg = this;
            return arrayFunc(iteratees, function(iteratee2) {
              return apply2(iteratee2, thisArg, args);
            });
          });
        });
      }
      __name(createOver, "createOver");
      function createPadding(length, chars) {
        chars = chars === undefined$1 ? " " : baseToString2(chars);
        var charsLength = chars.length;
        if (charsLength < 2) {
          return charsLength ? baseRepeat(chars, length) : chars;
        }
        var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
        return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
      }
      __name(createPadding, "createPadding");
      function createPartial(func, bitmask, thisArg, partials) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root26 && this instanceof wrapper ? Ctor : func;
          while (++leftIndex < leftLength) {
            args[leftIndex] = partials[leftIndex];
          }
          while (argsLength--) {
            args[leftIndex++] = arguments[++argsIndex];
          }
          return apply2(fn, isBind ? thisArg : this, args);
        }
        __name(wrapper, "wrapper");
        return wrapper;
      }
      __name(createPartial, "createPartial");
      function createRange(fromRight) {
        return function(start2, end, step2) {
          if (step2 && typeof step2 != "number" && isIterateeCall(start2, end, step2)) {
            end = step2 = undefined$1;
          }
          start2 = toFinite(start2);
          if (end === undefined$1) {
            end = start2;
            start2 = 0;
          } else {
            end = toFinite(end);
          }
          step2 = step2 === undefined$1 ? start2 < end ? 1 : -1 : toFinite(step2);
          return baseRange(start2, end, step2, fromRight);
        };
      }
      __name(createRange, "createRange");
      function createRelationalOperation(operator) {
        return function(value3, other) {
          if (!(typeof value3 == "string" && typeof other == "string")) {
            value3 = toNumber2(value3);
            other = toNumber2(other);
          }
          return operator(value3, other);
        };
      }
      __name(createRelationalOperation, "createRelationalOperation");
      function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
        var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$1, newHoldersRight = isCurry ? undefined$1 : holders, newPartials = isCurry ? partials : undefined$1, newPartialsRight = isCurry ? undefined$1 : partials;
        bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
        bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
        if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
          bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
        }
        var newData = [
          func,
          bitmask,
          thisArg,
          newPartials,
          newHolders,
          newPartialsRight,
          newHoldersRight,
          argPos,
          ary2,
          arity
        ];
        var result2 = wrapFunc.apply(undefined$1, newData);
        if (isLaziable(func)) {
          setData(result2, newData);
        }
        result2.placeholder = placeholder;
        return setWrapToString(result2, func, bitmask);
      }
      __name(createRecurry, "createRecurry");
      function createRound(methodName) {
        var func = Math2[methodName];
        return function(number2, precision) {
          number2 = toNumber2(number2);
          precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
          if (precision && nativeIsFinite(number2)) {
            var pair = (toString3(number2) + "e").split("e"), value3 = func(pair[0] + "e" + (+pair[1] + precision));
            pair = (toString3(value3) + "e").split("e");
            return +(pair[0] + "e" + (+pair[1] - precision));
          }
          return func(number2);
        };
      }
      __name(createRound, "createRound");
      var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY2) ? noop2 : function(values3) {
        return new Set2(values3);
      };
      function createToPairs(keysFunc) {
        return function(object) {
          var tag = getTag2(object);
          if (tag == mapTag) {
            return mapToArray(object);
          }
          if (tag == setTag) {
            return setToPairs(object);
          }
          return baseToPairs(object, keysFunc(object));
        };
      }
      __name(createToPairs, "createToPairs");
      function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
        if (!isBindKey && typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var length = partials ? partials.length : 0;
        if (!length) {
          bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
          partials = holders = undefined$1;
        }
        ary2 = ary2 === undefined$1 ? ary2 : nativeMax(toInteger(ary2), 0);
        arity = arity === undefined$1 ? arity : toInteger(arity);
        length -= holders ? holders.length : 0;
        if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials, holdersRight = holders;
          partials = holders = undefined$1;
        }
        var data24 = isBindKey ? undefined$1 : getData(func);
        var newData = [
          func,
          bitmask,
          thisArg,
          partials,
          holders,
          partialsRight,
          holdersRight,
          argPos,
          ary2,
          arity
        ];
        if (data24) {
          mergeData(newData, data24);
        }
        func = newData[0];
        bitmask = newData[1];
        thisArg = newData[2];
        partials = newData[3];
        holders = newData[4];
        arity = newData[9] = newData[9] === undefined$1 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
        if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
          bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
        }
        if (!bitmask || bitmask == WRAP_BIND_FLAG) {
          var result2 = createBind(func, bitmask, thisArg);
        } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
          result2 = createCurry(func, bitmask, arity);
        } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
          result2 = createPartial(func, bitmask, thisArg, partials);
        } else {
          result2 = createHybrid.apply(undefined$1, newData);
        }
        var setter = data24 ? baseSetData : setData;
        return setWrapToString(setter(result2, newData), func, bitmask);
      }
      __name(createWrap, "createWrap");
      function customDefaultsAssignIn(objValue, srcValue, key, object) {
        if (objValue === undefined$1 || eq(objValue, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
          return srcValue;
        }
        return objValue;
      }
      __name(customDefaultsAssignIn, "customDefaultsAssignIn");
      function customDefaultsMerge(objValue, srcValue, key, object, source, stack2) {
        if (isObject3(objValue) && isObject3(srcValue)) {
          stack2.set(srcValue, objValue);
          baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack2);
          stack2["delete"](srcValue);
        }
        return objValue;
      }
      __name(customDefaultsMerge, "customDefaultsMerge");
      function customOmitClone(value3) {
        return isPlainObject2(value3) ? undefined$1 : value3;
      }
      __name(customOmitClone, "customOmitClone");
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack2) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack2.get(array);
        var othStacked = stack2.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array;
        }
        var index2 = -1, result2 = true, seen2 = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined$1;
        stack2.set(array, other);
        stack2.set(other, array);
        while (++index2 < arrLength) {
          var arrValue = array[index2], othValue = other[index2];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack2) : customizer(arrValue, othValue, index2, array, other, stack2);
          }
          if (compared !== undefined$1) {
            if (compared) {
              continue;
            }
            result2 = false;
            break;
          }
          if (seen2) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen2, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
                return seen2.push(othIndex);
              }
            })) {
              result2 = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
            result2 = false;
            break;
          }
        }
        stack2["delete"](array);
        stack2["delete"](other);
        return result2;
      }
      __name(equalArrays, "equalArrays");
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack2) {
        switch (tag) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack2.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack2.set(object, other);
            var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack2);
            stack2["delete"](object);
            return result2;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      __name(equalByTag, "equalByTag");
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack2) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index2 = objLength;
        while (index2--) {
          var key = objProps[index2];
          if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack2.get(object);
        var othStacked = stack2.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result2 = true;
        stack2.set(object, other);
        stack2.set(other, object);
        var skipCtor = isPartial;
        while (++index2 < objLength) {
          key = objProps[index2];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack2) : customizer(objValue, othValue, key, object, other, stack2);
          }
          if (!(compared === undefined$1 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
            result2 = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result2 && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result2 = false;
          }
        }
        stack2["delete"](object);
        stack2["delete"](other);
        return result2;
      }
      __name(equalObjects, "equalObjects");
      function flatRest(func) {
        return setToString(overRest(func, undefined$1, flatten), func + "");
      }
      __name(flatRest, "flatRest");
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys2, getSymbols);
      }
      __name(getAllKeys, "getAllKeys");
      function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn, getSymbolsIn);
      }
      __name(getAllKeysIn, "getAllKeysIn");
      var getData = !metaMap ? noop2 : function(func) {
        return metaMap.get(func);
      };
      function getFuncName(func) {
        var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty2.call(realNames, result2) ? array.length : 0;
        while (length--) {
          var data24 = array[length], otherFunc = data24.func;
          if (otherFunc == null || otherFunc == func) {
            return data24.name;
          }
        }
        return result2;
      }
      __name(getFuncName, "getFuncName");
      function getHolder(func) {
        var object = hasOwnProperty2.call(lodash2, "placeholder") ? lodash2 : func;
        return object.placeholder;
      }
      __name(getHolder, "getHolder");
      function getIteratee() {
        var result2 = lodash2.iteratee || iteratee;
        result2 = result2 === iteratee ? baseIteratee : result2;
        return arguments.length ? result2(arguments[0], arguments[1]) : result2;
      }
      __name(getIteratee, "getIteratee");
      function getMapData(map3, key) {
        var data24 = map3.__data__;
        return isKeyable(key) ? data24[typeof key == "string" ? "string" : "hash"] : data24.map;
      }
      __name(getMapData, "getMapData");
      function getMatchData(object) {
        var result2 = keys2(object), length = result2.length;
        while (length--) {
          var key = result2[length], value3 = object[key];
          result2[length] = [key, value3, isStrictComparable(value3)];
        }
        return result2;
      }
      __name(getMatchData, "getMatchData");
      function getNative(object, key) {
        var value3 = getValue2(object, key);
        return baseIsNative(value3) ? value3 : undefined$1;
      }
      __name(getNative, "getNative");
      function getRawTag(value3) {
        var isOwn = hasOwnProperty2.call(value3, symToStringTag), tag = value3[symToStringTag];
        try {
          value3[symToStringTag] = undefined$1;
          var unmasked = true;
        } catch (e) {
        }
        var result2 = nativeObjectToString.call(value3);
        if (unmasked) {
          if (isOwn) {
            value3[symToStringTag] = tag;
          } else {
            delete value3[symToStringTag];
          }
        }
        return result2;
      }
      __name(getRawTag, "getRawTag");
      var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
        if (object == null) {
          return [];
        }
        object = Object2(object);
        return arrayFilter(nativeGetSymbols(object), function(symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      };
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
        var result2 = [];
        while (object) {
          arrayPush(result2, getSymbols(object));
          object = getPrototype(object);
        }
        return result2;
      };
      var getTag2 = baseGetTag;
      if (DataView2 && getTag2(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag2(new Map2()) != mapTag || Promise2 && getTag2(Promise2.resolve()) != promiseTag || Set2 && getTag2(new Set2()) != setTag || WeakMap2 && getTag2(new WeakMap2()) != weakMapTag) {
        getTag2 = /* @__PURE__ */ __name(function(value3) {
          var result2 = baseGetTag(value3), Ctor = result2 == objectTag ? value3.constructor : undefined$1, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result2;
        }, "getTag");
      }
      function getView(start2, end, transforms) {
        var index2 = -1, length = transforms.length;
        while (++index2 < length) {
          var data24 = transforms[index2], size3 = data24.size;
          switch (data24.type) {
            case "drop":
              start2 += size3;
              break;
            case "dropRight":
              end -= size3;
              break;
            case "take":
              end = nativeMin(end, start2 + size3);
              break;
            case "takeRight":
              start2 = nativeMax(start2, end - size3);
              break;
          }
        }
        return { "start": start2, "end": end };
      }
      __name(getView, "getView");
      function getWrapDetails(source) {
        var match = source.match(reWrapDetails);
        return match ? match[1].split(reSplitDetails) : [];
      }
      __name(getWrapDetails, "getWrapDetails");
      function hasPath(object, path, hasFunc) {
        path = castPath(path, object);
        var index2 = -1, length = path.length, result2 = false;
        while (++index2 < length) {
          var key = toKey(path[index2]);
          if (!(result2 = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result2 || ++index2 != length) {
          return result2;
        }
        length = object == null ? 0 : object.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray3(object) || isArguments(object));
      }
      __name(hasPath, "hasPath");
      function initCloneArray(array) {
        var length = array.length, result2 = new array.constructor(length);
        if (length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
          result2.index = array.index;
          result2.input = array.input;
        }
        return result2;
      }
      __name(initCloneArray, "initCloneArray");
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
      }
      __name(initCloneObject, "initCloneObject");
      function initCloneByTag(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object);
          case boolTag:
          case dateTag:
            return new Ctor(+object);
          case dataViewTag:
            return cloneDataView(object, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object, isDeep);
          case mapTag:
            return new Ctor();
          case numberTag:
          case stringTag:
            return new Ctor(object);
          case regexpTag:
            return cloneRegExp(object);
          case setTag:
            return new Ctor();
          case symbolTag:
            return cloneSymbol(object);
        }
      }
      __name(initCloneByTag, "initCloneByTag");
      function insertWrapDetails(source, details) {
        var length = details.length;
        if (!length) {
          return source;
        }
        var lastIndex = length - 1;
        details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
        details = details.join(length > 2 ? ", " : " ");
        return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
      }
      __name(insertWrapDetails, "insertWrapDetails");
      function isFlattenable(value3) {
        return isArray3(value3) || isArguments(value3) || !!(spreadableSymbol && value3 && value3[spreadableSymbol]);
      }
      __name(isFlattenable, "isFlattenable");
      function isIndex(value3, length) {
        var type = typeof value3;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint.test(value3)) && (value3 > -1 && value3 % 1 == 0 && value3 < length);
      }
      __name(isIndex, "isIndex");
      function isIterateeCall(value3, index2, object) {
        if (!isObject3(object)) {
          return false;
        }
        var type = typeof index2;
        if (type == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
          return eq(object[index2], value3);
        }
        return false;
      }
      __name(isIterateeCall, "isIterateeCall");
      function isKey(value3, object) {
        if (isArray3(value3)) {
          return false;
        }
        var type = typeof value3;
        if (type == "number" || type == "symbol" || type == "boolean" || value3 == null || isSymbol2(value3)) {
          return true;
        }
        return reIsPlainProp.test(value3) || !reIsDeepProp.test(value3) || object != null && value3 in Object2(object);
      }
      __name(isKey, "isKey");
      function isKeyable(value3) {
        var type = typeof value3;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value3 !== "__proto__" : value3 === null;
      }
      __name(isKeyable, "isKeyable");
      function isLaziable(func) {
        var funcName = getFuncName(func), other = lodash2[funcName];
        if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
          return false;
        }
        if (func === other) {
          return true;
        }
        var data24 = getData(other);
        return !!data24 && func === data24[0];
      }
      __name(isLaziable, "isLaziable");
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      __name(isMasked, "isMasked");
      var isMaskable = coreJsData ? isFunction3 : stubFalse;
      function isPrototype(value3) {
        var Ctor = value3 && value3.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value3 === proto;
      }
      __name(isPrototype, "isPrototype");
      function isStrictComparable(value3) {
        return value3 === value3 && !isObject3(value3);
      }
      __name(isStrictComparable, "isStrictComparable");
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== undefined$1 || key in Object2(object));
        };
      }
      __name(matchesStrictComparable, "matchesStrictComparable");
      function memoizeCapped(func) {
        var result2 = memoize(func, function(key) {
          if (cache2.size === MAX_MEMOIZE_SIZE) {
            cache2.clear();
          }
          return key;
        });
        var cache2 = result2.cache;
        return result2;
      }
      __name(memoizeCapped, "memoizeCapped");
      function mergeData(data24, source) {
        var bitmask = data24[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
        var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data24[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
        if (!(isCommon || isCombo)) {
          return data24;
        }
        if (srcBitmask & WRAP_BIND_FLAG) {
          data24[2] = source[2];
          newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
        }
        var value3 = source[3];
        if (value3) {
          var partials = data24[3];
          data24[3] = partials ? composeArgs(partials, value3, source[4]) : value3;
          data24[4] = partials ? replaceHolders(data24[3], PLACEHOLDER) : source[4];
        }
        value3 = source[5];
        if (value3) {
          partials = data24[5];
          data24[5] = partials ? composeArgsRight(partials, value3, source[6]) : value3;
          data24[6] = partials ? replaceHolders(data24[5], PLACEHOLDER) : source[6];
        }
        value3 = source[7];
        if (value3) {
          data24[7] = value3;
        }
        if (srcBitmask & WRAP_ARY_FLAG) {
          data24[8] = data24[8] == null ? source[8] : nativeMin(data24[8], source[8]);
        }
        if (data24[9] == null) {
          data24[9] = source[9];
        }
        data24[0] = source[0];
        data24[1] = newBitmask;
        return data24;
      }
      __name(mergeData, "mergeData");
      function nativeKeysIn(object) {
        var result2 = [];
        if (object != null) {
          for (var key in Object2(object)) {
            result2.push(key);
          }
        }
        return result2;
      }
      __name(nativeKeysIn, "nativeKeysIn");
      function objectToString2(value3) {
        return nativeObjectToString.call(value3);
      }
      __name(objectToString2, "objectToString");
      function overRest(func, start2, transform3) {
        start2 = nativeMax(start2 === undefined$1 ? func.length - 1 : start2, 0);
        return function() {
          var args = arguments, index2 = -1, length = nativeMax(args.length - start2, 0), array = Array2(length);
          while (++index2 < length) {
            array[index2] = args[start2 + index2];
          }
          index2 = -1;
          var otherArgs = Array2(start2 + 1);
          while (++index2 < start2) {
            otherArgs[index2] = args[index2];
          }
          otherArgs[start2] = transform3(array);
          return apply2(func, this, otherArgs);
        };
      }
      __name(overRest, "overRest");
      function parent(object, path) {
        return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
      }
      __name(parent, "parent");
      function reorder(array, indexes) {
        var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
        while (length--) {
          var index2 = indexes[length];
          array[length] = isIndex(index2, arrLength) ? oldArray[index2] : undefined$1;
        }
        return array;
      }
      __name(reorder, "reorder");
      function safeGet(object, key) {
        if (key === "constructor" && typeof object[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object[key];
      }
      __name(safeGet, "safeGet");
      var setData = shortOut(baseSetData);
      var setTimeout2 = ctxSetTimeout || function(func, wait) {
        return root26.setTimeout(func, wait);
      };
      var setToString = shortOut(baseSetToString);
      function setWrapToString(wrapper, reference, bitmask) {
        var source = reference + "";
        return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
      }
      __name(setWrapToString, "setWrapToString");
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(undefined$1, arguments);
        };
      }
      __name(shortOut, "shortOut");
      function shuffleSelf(array, size3) {
        var index2 = -1, length = array.length, lastIndex = length - 1;
        size3 = size3 === undefined$1 ? length : size3;
        while (++index2 < size3) {
          var rand2 = baseRandom(index2, lastIndex), value3 = array[rand2];
          array[rand2] = array[index2];
          array[index2] = value3;
        }
        array.length = size3;
        return array;
      }
      __name(shuffleSelf, "shuffleSelf");
      var stringToPath = memoizeCapped(function(string) {
        var result2 = [];
        if (string.charCodeAt(0) === 46) {
          result2.push("");
        }
        string.replace(rePropName, function(match, number2, quote, subString) {
          result2.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match);
        });
        return result2;
      });
      function toKey(value3) {
        if (typeof value3 == "string" || isSymbol2(value3)) {
          return value3;
        }
        var result2 = value3 + "";
        return result2 == "0" && 1 / value3 == -INFINITY2 ? "-0" : result2;
      }
      __name(toKey, "toKey");
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      __name(toSource, "toSource");
      function updateWrapDetails(details, bitmask) {
        arrayEach(wrapFlags, function(pair) {
          var value3 = "_." + pair[0];
          if (bitmask & pair[1] && !arrayIncludes(details, value3)) {
            details.push(value3);
          }
        });
        return details.sort();
      }
      __name(updateWrapDetails, "updateWrapDetails");
      function wrapperClone(wrapper) {
        if (wrapper instanceof LazyWrapper) {
          return wrapper.clone();
        }
        var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
        result2.__actions__ = copyArray(wrapper.__actions__);
        result2.__index__ = wrapper.__index__;
        result2.__values__ = wrapper.__values__;
        return result2;
      }
      __name(wrapperClone, "wrapperClone");
      function chunk(array, size3, guard) {
        if (guard ? isIterateeCall(array, size3, guard) : size3 === undefined$1) {
          size3 = 1;
        } else {
          size3 = nativeMax(toInteger(size3), 0);
        }
        var length = array == null ? 0 : array.length;
        if (!length || size3 < 1) {
          return [];
        }
        var index2 = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size3));
        while (index2 < length) {
          result2[resIndex++] = baseSlice(array, index2, index2 += size3);
        }
        return result2;
      }
      __name(chunk, "chunk");
      function compact(array) {
        var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
        while (++index2 < length) {
          var value3 = array[index2];
          if (value3) {
            result2[resIndex++] = value3;
          }
        }
        return result2;
      }
      __name(compact, "compact");
      function concat() {
        var length = arguments.length;
        if (!length) {
          return [];
        }
        var args = Array2(length - 1), array = arguments[0], index2 = length;
        while (index2--) {
          args[index2 - 1] = arguments[index2];
        }
        return arrayPush(isArray3(array) ? copyArray(array) : [array], baseFlatten(args, 1));
      }
      __name(concat, "concat");
      var difference = baseRest(function(array, values3) {
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values3, 1, isArrayLikeObject, true)) : [];
      });
      var differenceBy = baseRest(function(array, values3) {
        var iteratee2 = last(values3);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values3, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
      });
      var differenceWith = baseRest(function(array, values3) {
        var comparator2 = last(values3);
        if (isArrayLikeObject(comparator2)) {
          comparator2 = undefined$1;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values3, 1, isArrayLikeObject, true), undefined$1, comparator2) : [];
      });
      function drop(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined$1 ? 1 : toInteger(n);
        return baseSlice(array, n < 0 ? 0 : n, length);
      }
      __name(drop, "drop");
      function dropRight(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined$1 ? 1 : toInteger(n);
        n = length - n;
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }
      __name(dropRight, "dropRight");
      function dropRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
      }
      __name(dropRightWhile, "dropRightWhile");
      function dropWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
      }
      __name(dropWhile, "dropWhile");
      function fill(array, value3, start2, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (start2 && typeof start2 != "number" && isIterateeCall(array, value3, start2)) {
          start2 = 0;
          end = length;
        }
        return baseFill(array, value3, start2, end);
      }
      __name(fill, "fill");
      function findIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index2 < 0) {
          index2 = nativeMax(length + index2, 0);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index2);
      }
      __name(findIndex, "findIndex");
      function findLastIndex2(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index2 = length - 1;
        if (fromIndex !== undefined$1) {
          index2 = toInteger(fromIndex);
          index2 = fromIndex < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index2, true);
      }
      __name(findLastIndex2, "findLastIndex");
      function flatten(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, 1) : [];
      }
      __name(flatten, "flatten");
      function flattenDeep(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, INFINITY2) : [];
      }
      __name(flattenDeep, "flattenDeep");
      function flattenDepth(array, depth) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        depth = depth === undefined$1 ? 1 : toInteger(depth);
        return baseFlatten(array, depth);
      }
      __name(flattenDepth, "flattenDepth");
      function fromPairs(pairs) {
        var index2 = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
        while (++index2 < length) {
          var pair = pairs[index2];
          result2[pair[0]] = pair[1];
        }
        return result2;
      }
      __name(fromPairs, "fromPairs");
      function head(array) {
        return array && array.length ? array[0] : undefined$1;
      }
      __name(head, "head");
      function indexOf(array, value3, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index2 < 0) {
          index2 = nativeMax(length + index2, 0);
        }
        return baseIndexOf(array, value3, index2);
      }
      __name(indexOf, "indexOf");
      function initial(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 0, -1) : [];
      }
      __name(initial, "initial");
      var intersection = baseRest(function(arrays) {
        var mapped = arrayMap(arrays, castArrayLikeObject);
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
      });
      var intersectionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        if (iteratee2 === last(mapped)) {
          iteratee2 = undefined$1;
        } else {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
      });
      var intersectionWith = baseRest(function(arrays) {
        var comparator2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        comparator2 = typeof comparator2 == "function" ? comparator2 : undefined$1;
        if (comparator2) {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$1, comparator2) : [];
      });
      function join2(array, separator) {
        return array == null ? "" : nativeJoin.call(array, separator);
      }
      __name(join2, "join");
      function last(array) {
        var length = array == null ? 0 : array.length;
        return length ? array[length - 1] : undefined$1;
      }
      __name(last, "last");
      function lastIndexOf(array, value3, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index2 = length;
        if (fromIndex !== undefined$1) {
          index2 = toInteger(fromIndex);
          index2 = index2 < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
        }
        return value3 === value3 ? strictLastIndexOf(array, value3, index2) : baseFindIndex(array, baseIsNaN, index2, true);
      }
      __name(lastIndexOf, "lastIndexOf");
      function nth(array, n) {
        return array && array.length ? baseNth(array, toInteger(n)) : undefined$1;
      }
      __name(nth, "nth");
      var pull = baseRest(pullAll);
      function pullAll(array, values3) {
        return array && array.length && values3 && values3.length ? basePullAll(array, values3) : array;
      }
      __name(pullAll, "pullAll");
      function pullAllBy(array, values3, iteratee2) {
        return array && array.length && values3 && values3.length ? basePullAll(array, values3, getIteratee(iteratee2, 2)) : array;
      }
      __name(pullAllBy, "pullAllBy");
      function pullAllWith(array, values3, comparator2) {
        return array && array.length && values3 && values3.length ? basePullAll(array, values3, undefined$1, comparator2) : array;
      }
      __name(pullAllWith, "pullAllWith");
      var pullAt = flatRest(function(array, indexes) {
        var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
        basePullAt(array, arrayMap(indexes, function(index2) {
          return isIndex(index2, length) ? +index2 : index2;
        }).sort(compareAscending));
        return result2;
      });
      function remove5(array, predicate) {
        var result2 = [];
        if (!(array && array.length)) {
          return result2;
        }
        var index2 = -1, indexes = [], length = array.length;
        predicate = getIteratee(predicate, 3);
        while (++index2 < length) {
          var value3 = array[index2];
          if (predicate(value3, index2, array)) {
            result2.push(value3);
            indexes.push(index2);
          }
        }
        basePullAt(array, indexes);
        return result2;
      }
      __name(remove5, "remove");
      function reverse(array) {
        return array == null ? array : nativeReverse.call(array);
      }
      __name(reverse, "reverse");
      function slice(array, start2, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (end && typeof end != "number" && isIterateeCall(array, start2, end)) {
          start2 = 0;
          end = length;
        } else {
          start2 = start2 == null ? 0 : toInteger(start2);
          end = end === undefined$1 ? length : toInteger(end);
        }
        return baseSlice(array, start2, end);
      }
      __name(slice, "slice");
      function sortedIndex(array, value3) {
        return baseSortedIndex(array, value3);
      }
      __name(sortedIndex, "sortedIndex");
      function sortedIndexBy(array, value3, iteratee2) {
        return baseSortedIndexBy(array, value3, getIteratee(iteratee2, 2));
      }
      __name(sortedIndexBy, "sortedIndexBy");
      function sortedIndexOf(array, value3) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index2 = baseSortedIndex(array, value3);
          if (index2 < length && eq(array[index2], value3)) {
            return index2;
          }
        }
        return -1;
      }
      __name(sortedIndexOf, "sortedIndexOf");
      function sortedLastIndex(array, value3) {
        return baseSortedIndex(array, value3, true);
      }
      __name(sortedLastIndex, "sortedLastIndex");
      function sortedLastIndexBy(array, value3, iteratee2) {
        return baseSortedIndexBy(array, value3, getIteratee(iteratee2, 2), true);
      }
      __name(sortedLastIndexBy, "sortedLastIndexBy");
      function sortedLastIndexOf(array, value3) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index2 = baseSortedIndex(array, value3, true) - 1;
          if (eq(array[index2], value3)) {
            return index2;
          }
        }
        return -1;
      }
      __name(sortedLastIndexOf, "sortedLastIndexOf");
      function sortedUniq(array) {
        return array && array.length ? baseSortedUniq(array) : [];
      }
      __name(sortedUniq, "sortedUniq");
      function sortedUniqBy(array, iteratee2) {
        return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      __name(sortedUniqBy, "sortedUniqBy");
      function tail(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 1, length) : [];
      }
      __name(tail, "tail");
      function take(array, n, guard) {
        if (!(array && array.length)) {
          return [];
        }
        n = guard || n === undefined$1 ? 1 : toInteger(n);
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }
      __name(take, "take");
      function takeRight(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined$1 ? 1 : toInteger(n);
        n = length - n;
        return baseSlice(array, n < 0 ? 0 : n, length);
      }
      __name(takeRight, "takeRight");
      function takeRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
      }
      __name(takeRightWhile, "takeRightWhile");
      function takeWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
      }
      __name(takeWhile, "takeWhile");
      var union = baseRest(function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
      });
      var unionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
      });
      var unionWith = baseRest(function(arrays) {
        var comparator2 = last(arrays);
        comparator2 = typeof comparator2 == "function" ? comparator2 : undefined$1;
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator2);
      });
      function uniq2(array) {
        return array && array.length ? baseUniq(array) : [];
      }
      __name(uniq2, "uniq");
      function uniqBy(array, iteratee2) {
        return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      __name(uniqBy, "uniqBy");
      function uniqWith(array, comparator2) {
        comparator2 = typeof comparator2 == "function" ? comparator2 : undefined$1;
        return array && array.length ? baseUniq(array, undefined$1, comparator2) : [];
      }
      __name(uniqWith, "uniqWith");
      function unzip(array) {
        if (!(array && array.length)) {
          return [];
        }
        var length = 0;
        array = arrayFilter(array, function(group) {
          if (isArrayLikeObject(group)) {
            length = nativeMax(group.length, length);
            return true;
          }
        });
        return baseTimes(length, function(index2) {
          return arrayMap(array, baseProperty(index2));
        });
      }
      __name(unzip, "unzip");
      function unzipWith(array, iteratee2) {
        if (!(array && array.length)) {
          return [];
        }
        var result2 = unzip(array);
        if (iteratee2 == null) {
          return result2;
        }
        return arrayMap(result2, function(group) {
          return apply2(iteratee2, undefined$1, group);
        });
      }
      __name(unzipWith, "unzipWith");
      var without = baseRest(function(array, values3) {
        return isArrayLikeObject(array) ? baseDifference(array, values3) : [];
      });
      var xor = baseRest(function(arrays) {
        return baseXor(arrayFilter(arrays, isArrayLikeObject));
      });
      var xorBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
      });
      var xorWith = baseRest(function(arrays) {
        var comparator2 = last(arrays);
        comparator2 = typeof comparator2 == "function" ? comparator2 : undefined$1;
        return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator2);
      });
      var zip = baseRest(unzip);
      function zipObject(props, values3) {
        return baseZipObject(props || [], values3 || [], assignValue);
      }
      __name(zipObject, "zipObject");
      function zipObjectDeep(props, values3) {
        return baseZipObject(props || [], values3 || [], baseSet);
      }
      __name(zipObjectDeep, "zipObjectDeep");
      var zipWith = baseRest(function(arrays) {
        var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined$1;
        iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$1;
        return unzipWith(arrays, iteratee2);
      });
      function chain(value3) {
        var result2 = lodash2(value3);
        result2.__chain__ = true;
        return result2;
      }
      __name(chain, "chain");
      function tap(value3, interceptor) {
        interceptor(value3);
        return value3;
      }
      __name(tap, "tap");
      function thru(value3, interceptor) {
        return interceptor(value3);
      }
      __name(thru, "thru");
      var wrapperAt = flatRest(function(paths) {
        var length = paths.length, start2 = length ? paths[0] : 0, value3 = this.__wrapped__, interceptor = /* @__PURE__ */ __name(function(object) {
          return baseAt(object, paths);
        }, "interceptor");
        if (length > 1 || this.__actions__.length || !(value3 instanceof LazyWrapper) || !isIndex(start2)) {
          return this.thru(interceptor);
        }
        value3 = value3.slice(start2, +start2 + (length ? 1 : 0));
        value3.__actions__.push({
          "func": thru,
          "args": [interceptor],
          "thisArg": undefined$1
        });
        return new LodashWrapper(value3, this.__chain__).thru(function(array) {
          if (length && !array.length) {
            array.push(undefined$1);
          }
          return array;
        });
      });
      function wrapperChain() {
        return chain(this);
      }
      __name(wrapperChain, "wrapperChain");
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }
      __name(wrapperCommit, "wrapperCommit");
      function wrapperNext() {
        if (this.__values__ === undefined$1) {
          this.__values__ = toArray2(this.value());
        }
        var done = this.__index__ >= this.__values__.length, value3 = done ? undefined$1 : this.__values__[this.__index__++];
        return { "done": done, "value": value3 };
      }
      __name(wrapperNext, "wrapperNext");
      function wrapperToIterator() {
        return this;
      }
      __name(wrapperToIterator, "wrapperToIterator");
      function wrapperPlant(value3) {
        var result2, parent2 = this;
        while (parent2 instanceof baseLodash) {
          var clone3 = wrapperClone(parent2);
          clone3.__index__ = 0;
          clone3.__values__ = undefined$1;
          if (result2) {
            previous.__wrapped__ = clone3;
          } else {
            result2 = clone3;
          }
          var previous = clone3;
          parent2 = parent2.__wrapped__;
        }
        previous.__wrapped__ = value3;
        return result2;
      }
      __name(wrapperPlant, "wrapperPlant");
      function wrapperReverse() {
        var value3 = this.__wrapped__;
        if (value3 instanceof LazyWrapper) {
          var wrapped = value3;
          if (this.__actions__.length) {
            wrapped = new LazyWrapper(this);
          }
          wrapped = wrapped.reverse();
          wrapped.__actions__.push({
            "func": thru,
            "args": [reverse],
            "thisArg": undefined$1
          });
          return new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse);
      }
      __name(wrapperReverse, "wrapperReverse");
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }
      __name(wrapperValue, "wrapperValue");
      var countBy = createAggregator(function(result2, value3, key) {
        if (hasOwnProperty2.call(result2, key)) {
          ++result2[key];
        } else {
          baseAssignValue(result2, key, 1);
        }
      });
      function every(collection, predicate, guard) {
        var func = isArray3(collection) ? arrayEvery : baseEvery;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$1;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      __name(every, "every");
      function filter4(collection, predicate) {
        var func = isArray3(collection) ? arrayFilter : baseFilter;
        return func(collection, getIteratee(predicate, 3));
      }
      __name(filter4, "filter");
      var find2 = createFind(findIndex);
      var findLast2 = createFind(findLastIndex2);
      function flatMap(collection, iteratee2) {
        return baseFlatten(map2(collection, iteratee2), 1);
      }
      __name(flatMap, "flatMap");
      function flatMapDeep(collection, iteratee2) {
        return baseFlatten(map2(collection, iteratee2), INFINITY2);
      }
      __name(flatMapDeep, "flatMapDeep");
      function flatMapDepth(collection, iteratee2, depth) {
        depth = depth === undefined$1 ? 1 : toInteger(depth);
        return baseFlatten(map2(collection, iteratee2), depth);
      }
      __name(flatMapDepth, "flatMapDepth");
      function forEach2(collection, iteratee2) {
        var func = isArray3(collection) ? arrayEach : baseEach;
        return func(collection, getIteratee(iteratee2, 3));
      }
      __name(forEach2, "forEach");
      function forEachRight(collection, iteratee2) {
        var func = isArray3(collection) ? arrayEachRight : baseEachRight;
        return func(collection, getIteratee(iteratee2, 3));
      }
      __name(forEachRight, "forEachRight");
      var groupBy = createAggregator(function(result2, value3, key) {
        if (hasOwnProperty2.call(result2, key)) {
          result2[key].push(value3);
        } else {
          baseAssignValue(result2, key, [value3]);
        }
      });
      function includes(collection, value3, fromIndex, guard) {
        collection = isArrayLike(collection) ? collection : values2(collection);
        fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
        var length = collection.length;
        if (fromIndex < 0) {
          fromIndex = nativeMax(length + fromIndex, 0);
        }
        return isString3(collection) ? fromIndex <= length && collection.indexOf(value3, fromIndex) > -1 : !!length && baseIndexOf(collection, value3, fromIndex) > -1;
      }
      __name(includes, "includes");
      var invokeMap = baseRest(function(collection, path, args) {
        var index2 = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value3) {
          result2[++index2] = isFunc ? apply2(path, value3, args) : baseInvoke(value3, path, args);
        });
        return result2;
      });
      var keyBy = createAggregator(function(result2, value3, key) {
        baseAssignValue(result2, key, value3);
      });
      function map2(collection, iteratee2) {
        var func = isArray3(collection) ? arrayMap : baseMap;
        return func(collection, getIteratee(iteratee2, 3));
      }
      __name(map2, "map");
      function orderBy(collection, iteratees, orders, guard) {
        if (collection == null) {
          return [];
        }
        if (!isArray3(iteratees)) {
          iteratees = iteratees == null ? [] : [iteratees];
        }
        orders = guard ? undefined$1 : orders;
        if (!isArray3(orders)) {
          orders = orders == null ? [] : [orders];
        }
        return baseOrderBy(collection, iteratees, orders);
      }
      __name(orderBy, "orderBy");
      var partition = createAggregator(function(result2, value3, key) {
        result2[key ? 0 : 1].push(value3);
      }, function() {
        return [[], []];
      });
      function reduce(collection, iteratee2, accumulator) {
        var func = isArray3(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
      }
      __name(reduce, "reduce");
      function reduceRight(collection, iteratee2, accumulator) {
        var func = isArray3(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
      }
      __name(reduceRight, "reduceRight");
      function reject2(collection, predicate) {
        var func = isArray3(collection) ? arrayFilter : baseFilter;
        return func(collection, negate(getIteratee(predicate, 3)));
      }
      __name(reject2, "reject");
      function sample(collection) {
        var func = isArray3(collection) ? arraySample : baseSample;
        return func(collection);
      }
      __name(sample, "sample");
      function sampleSize(collection, n, guard) {
        if (guard ? isIterateeCall(collection, n, guard) : n === undefined$1) {
          n = 1;
        } else {
          n = toInteger(n);
        }
        var func = isArray3(collection) ? arraySampleSize : baseSampleSize;
        return func(collection, n);
      }
      __name(sampleSize, "sampleSize");
      function shuffle(collection) {
        var func = isArray3(collection) ? arrayShuffle : baseShuffle;
        return func(collection);
      }
      __name(shuffle, "shuffle");
      function size2(collection) {
        if (collection == null) {
          return 0;
        }
        if (isArrayLike(collection)) {
          return isString3(collection) ? stringSize(collection) : collection.length;
        }
        var tag = getTag2(collection);
        if (tag == mapTag || tag == setTag) {
          return collection.size;
        }
        return baseKeys(collection).length;
      }
      __name(size2, "size");
      function some(collection, predicate, guard) {
        var func = isArray3(collection) ? arraySome : baseSome;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$1;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      __name(some, "some");
      var sortBy = baseRest(function(collection, iteratees) {
        if (collection == null) {
          return [];
        }
        var length = iteratees.length;
        if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }
        return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
      });
      var now2 = ctxNow || function() {
        return root26.Date.now();
      };
      function after(n, func) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n = toInteger(n);
        return function() {
          if (--n < 1) {
            return func.apply(this, arguments);
          }
        };
      }
      __name(after, "after");
      function ary(func, n, guard) {
        n = guard ? undefined$1 : n;
        n = func && n == null ? func.length : n;
        return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n);
      }
      __name(ary, "ary");
      function before(n, func) {
        var result2;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n = toInteger(n);
        return function() {
          if (--n > 0) {
            result2 = func.apply(this, arguments);
          }
          if (n <= 1) {
            func = undefined$1;
          }
          return result2;
        };
      }
      __name(before, "before");
      var bind3 = baseRest(function(func, thisArg, partials) {
        var bitmask = WRAP_BIND_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind3));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(func, bitmask, thisArg, partials, holders);
      });
      var bindKey = baseRest(function(object, key, partials) {
        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(key, bitmask, object, partials, holders);
      });
      function curry(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        result2.placeholder = curry.placeholder;
        return result2;
      }
      __name(curry, "curry");
      function curryRight(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        result2.placeholder = curryRight.placeholder;
        return result2;
      }
      __name(curryRight, "curryRight");
      function debounce(func, wait, options3) {
        var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        wait = toNumber2(wait) || 0;
        if (isObject3(options3)) {
          leading = !!options3.leading;
          maxing = "maxWait" in options3;
          maxWait = maxing ? nativeMax(toNumber2(options3.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options3 ? !!options3.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = undefined$1;
          lastInvokeTime = time;
          result2 = func.apply(thisArg, args);
          return result2;
        }
        __name(invokeFunc, "invokeFunc");
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout2(timerExpired, wait);
          return leading ? invokeFunc(time) : result2;
        }
        __name(leadingEdge, "leadingEdge");
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        __name(remainingWait, "remainingWait");
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === undefined$1 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        __name(shouldInvoke, "shouldInvoke");
        function timerExpired() {
          var time = now2();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout2(timerExpired, remainingWait(time));
        }
        __name(timerExpired, "timerExpired");
        function trailingEdge(time) {
          timerId = undefined$1;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = undefined$1;
          return result2;
        }
        __name(trailingEdge, "trailingEdge");
        function cancel() {
          if (timerId !== undefined$1) {
            clearTimeout2(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined$1;
        }
        __name(cancel, "cancel");
        function flush() {
          return timerId === undefined$1 ? result2 : trailingEdge(now2());
        }
        __name(flush, "flush");
        function debounced() {
          var time = now2(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === undefined$1) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout2(timerId);
              timerId = setTimeout2(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined$1) {
            timerId = setTimeout2(timerExpired, wait);
          }
          return result2;
        }
        __name(debounced, "debounced");
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      __name(debounce, "debounce");
      var defer = baseRest(function(func, args) {
        return baseDelay(func, 1, args);
      });
      var delay = baseRest(function(func, wait, args) {
        return baseDelay(func, toNumber2(wait) || 0, args);
      });
      function flip(func) {
        return createWrap(func, WRAP_FLIP_FLAG);
      }
      __name(flip, "flip");
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var memoized = /* @__PURE__ */ __name(function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
          if (cache2.has(key)) {
            return cache2.get(key);
          }
          var result2 = func.apply(this, args);
          memoized.cache = cache2.set(key, result2) || cache2;
          return result2;
        }, "memoized");
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      __name(memoize, "memoize");
      memoize.Cache = MapCache;
      function negate(predicate) {
        if (typeof predicate != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args[0]);
            case 2:
              return !predicate.call(this, args[0], args[1]);
            case 3:
              return !predicate.call(this, args[0], args[1], args[2]);
          }
          return !predicate.apply(this, args);
        };
      }
      __name(negate, "negate");
      function once2(func) {
        return before(2, func);
      }
      __name(once2, "once");
      var overArgs = castRest(function(func, transforms) {
        transforms = transforms.length == 1 && isArray3(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
        var funcsLength = transforms.length;
        return baseRest(function(args) {
          var index2 = -1, length = nativeMin(args.length, funcsLength);
          while (++index2 < length) {
            args[index2] = transforms[index2].call(this, args[index2]);
          }
          return apply2(func, this, args);
        });
      });
      var partial = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partial));
        return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
      });
      var partialRight = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
      });
      var rearg = flatRest(function(func, indexes) {
        return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
      });
      function rest(func, start2) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start2 = start2 === undefined$1 ? start2 : toInteger(start2);
        return baseRest(func, start2);
      }
      __name(rest, "rest");
      function spread2(func, start2) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start2 = start2 == null ? 0 : nativeMax(toInteger(start2), 0);
        return baseRest(function(args) {
          var array = args[start2], otherArgs = castSlice(args, 0, start2);
          if (array) {
            arrayPush(otherArgs, array);
          }
          return apply2(func, this, otherArgs);
        });
      }
      __name(spread2, "spread");
      function throttle2(func, wait, options3) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        if (isObject3(options3)) {
          leading = "leading" in options3 ? !!options3.leading : leading;
          trailing = "trailing" in options3 ? !!options3.trailing : trailing;
        }
        return debounce(func, wait, {
          "leading": leading,
          "maxWait": wait,
          "trailing": trailing
        });
      }
      __name(throttle2, "throttle");
      function unary(func) {
        return ary(func, 1);
      }
      __name(unary, "unary");
      function wrap(value3, wrapper) {
        return partial(castFunction(wrapper), value3);
      }
      __name(wrap, "wrap");
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value3 = arguments[0];
        return isArray3(value3) ? value3 : [value3];
      }
      __name(castArray, "castArray");
      function clone2(value3) {
        return baseClone(value3, CLONE_SYMBOLS_FLAG);
      }
      __name(clone2, "clone");
      function cloneWith(value3, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseClone(value3, CLONE_SYMBOLS_FLAG, customizer);
      }
      __name(cloneWith, "cloneWith");
      function cloneDeep(value3) {
        return baseClone(value3, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      __name(cloneDeep, "cloneDeep");
      function cloneDeepWith(value3, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseClone(value3, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
      }
      __name(cloneDeepWith, "cloneDeepWith");
      function conformsTo(object, source) {
        return source == null || baseConformsTo(object, source, keys2(source));
      }
      __name(conformsTo, "conformsTo");
      function eq(value3, other) {
        return value3 === other || value3 !== value3 && other !== other;
      }
      __name(eq, "eq");
      var gt2 = createRelationalOperation(baseGt);
      var gte2 = createRelationalOperation(function(value3, other) {
        return value3 >= other;
      });
      var isArguments = baseIsArguments(/* @__PURE__ */ function() {
        return arguments;
      }()) ? baseIsArguments : function(value3) {
        return isObjectLike2(value3) && hasOwnProperty2.call(value3, "callee") && !propertyIsEnumerable.call(value3, "callee");
      };
      var isArray3 = Array2.isArray;
      var isArrayBuffer2 = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
      function isArrayLike(value3) {
        return value3 != null && isLength(value3.length) && !isFunction3(value3);
      }
      __name(isArrayLike, "isArrayLike");
      function isArrayLikeObject(value3) {
        return isObjectLike2(value3) && isArrayLike(value3);
      }
      __name(isArrayLikeObject, "isArrayLikeObject");
      function isBoolean2(value3) {
        return value3 === true || value3 === false || isObjectLike2(value3) && baseGetTag(value3) == boolTag;
      }
      __name(isBoolean2, "isBoolean");
      var isBuffer2 = nativeIsBuffer || stubFalse;
      var isDate2 = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
      function isElement2(value3) {
        return isObjectLike2(value3) && value3.nodeType === 1 && !isPlainObject2(value3);
      }
      __name(isElement2, "isElement");
      function isEmpty3(value3) {
        if (value3 == null) {
          return true;
        }
        if (isArrayLike(value3) && (isArray3(value3) || typeof value3 == "string" || typeof value3.splice == "function" || isBuffer2(value3) || isTypedArray2(value3) || isArguments(value3))) {
          return !value3.length;
        }
        var tag = getTag2(value3);
        if (tag == mapTag || tag == setTag) {
          return !value3.size;
        }
        if (isPrototype(value3)) {
          return !baseKeys(value3).length;
        }
        for (var key in value3) {
          if (hasOwnProperty2.call(value3, key)) {
            return false;
          }
        }
        return true;
      }
      __name(isEmpty3, "isEmpty");
      function isEqual(value3, other) {
        return baseIsEqual(value3, other);
      }
      __name(isEqual, "isEqual");
      function isEqualWith(value3, other, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        var result2 = customizer ? customizer(value3, other) : undefined$1;
        return result2 === undefined$1 ? baseIsEqual(value3, other, undefined$1, customizer) : !!result2;
      }
      __name(isEqualWith, "isEqualWith");
      function isError(value3) {
        if (!isObjectLike2(value3)) {
          return false;
        }
        var tag = baseGetTag(value3);
        return tag == errorTag || tag == domExcTag || typeof value3.message == "string" && typeof value3.name == "string" && !isPlainObject2(value3);
      }
      __name(isError, "isError");
      function isFinite2(value3) {
        return typeof value3 == "number" && nativeIsFinite(value3);
      }
      __name(isFinite2, "isFinite");
      function isFunction3(value3) {
        if (!isObject3(value3)) {
          return false;
        }
        var tag = baseGetTag(value3);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      __name(isFunction3, "isFunction");
      function isInteger(value3) {
        return typeof value3 == "number" && value3 == toInteger(value3);
      }
      __name(isInteger, "isInteger");
      function isLength(value3) {
        return typeof value3 == "number" && value3 > -1 && value3 % 1 == 0 && value3 <= MAX_SAFE_INTEGER;
      }
      __name(isLength, "isLength");
      function isObject3(value3) {
        var type = typeof value3;
        return value3 != null && (type == "object" || type == "function");
      }
      __name(isObject3, "isObject");
      function isObjectLike2(value3) {
        return value3 != null && typeof value3 == "object";
      }
      __name(isObjectLike2, "isObjectLike");
      var isMap2 = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      function isMatch(object, source) {
        return object === source || baseIsMatch(object, source, getMatchData(source));
      }
      __name(isMatch, "isMatch");
      function isMatchWith(object, source, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseIsMatch(object, source, getMatchData(source), customizer);
      }
      __name(isMatchWith, "isMatchWith");
      function isNaN2(value3) {
        return isNumber3(value3) && value3 != +value3;
      }
      __name(isNaN2, "isNaN");
      function isNative(value3) {
        if (isMaskable(value3)) {
          throw new Error2(CORE_ERROR_TEXT);
        }
        return baseIsNative(value3);
      }
      __name(isNative, "isNative");
      function isNull(value3) {
        return value3 === null;
      }
      __name(isNull, "isNull");
      function isNil(value3) {
        return value3 == null;
      }
      __name(isNil, "isNil");
      function isNumber3(value3) {
        return typeof value3 == "number" || isObjectLike2(value3) && baseGetTag(value3) == numberTag;
      }
      __name(isNumber3, "isNumber");
      function isPlainObject2(value3) {
        if (!isObjectLike2(value3) || baseGetTag(value3) != objectTag) {
          return false;
        }
        var proto = getPrototype(value3);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      __name(isPlainObject2, "isPlainObject");
      var isRegExp2 = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
      function isSafeInteger(value3) {
        return isInteger(value3) && value3 >= -MAX_SAFE_INTEGER && value3 <= MAX_SAFE_INTEGER;
      }
      __name(isSafeInteger, "isSafeInteger");
      var isSet2 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      function isString3(value3) {
        return typeof value3 == "string" || !isArray3(value3) && isObjectLike2(value3) && baseGetTag(value3) == stringTag;
      }
      __name(isString3, "isString");
      function isSymbol2(value3) {
        return typeof value3 == "symbol" || isObjectLike2(value3) && baseGetTag(value3) == symbolTag;
      }
      __name(isSymbol2, "isSymbol");
      var isTypedArray2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function isUndefined2(value3) {
        return value3 === undefined$1;
      }
      __name(isUndefined2, "isUndefined");
      function isWeakMap(value3) {
        return isObjectLike2(value3) && getTag2(value3) == weakMapTag;
      }
      __name(isWeakMap, "isWeakMap");
      function isWeakSet(value3) {
        return isObjectLike2(value3) && baseGetTag(value3) == weakSetTag;
      }
      __name(isWeakSet, "isWeakSet");
      var lt2 = createRelationalOperation(baseLt);
      var lte2 = createRelationalOperation(function(value3, other) {
        return value3 <= other;
      });
      function toArray2(value3) {
        if (!value3) {
          return [];
        }
        if (isArrayLike(value3)) {
          return isString3(value3) ? stringToArray(value3) : copyArray(value3);
        }
        if (symIterator && value3[symIterator]) {
          return iteratorToArray(value3[symIterator]());
        }
        var tag = getTag2(value3), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values2;
        return func(value3);
      }
      __name(toArray2, "toArray");
      function toFinite(value3) {
        if (!value3) {
          return value3 === 0 ? value3 : 0;
        }
        value3 = toNumber2(value3);
        if (value3 === INFINITY2 || value3 === -INFINITY2) {
          var sign = value3 < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value3 === value3 ? value3 : 0;
      }
      __name(toFinite, "toFinite");
      function toInteger(value3) {
        var result2 = toFinite(value3), remainder = result2 % 1;
        return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
      }
      __name(toInteger, "toInteger");
      function toLength(value3) {
        return value3 ? baseClamp(toInteger(value3), 0, MAX_ARRAY_LENGTH) : 0;
      }
      __name(toLength, "toLength");
      function toNumber2(value3) {
        if (typeof value3 == "number") {
          return value3;
        }
        if (isSymbol2(value3)) {
          return NAN;
        }
        if (isObject3(value3)) {
          var other = typeof value3.valueOf == "function" ? value3.valueOf() : value3;
          value3 = isObject3(other) ? other + "" : other;
        }
        if (typeof value3 != "string") {
          return value3 === 0 ? value3 : +value3;
        }
        value3 = baseTrim(value3);
        var isBinary = reIsBinary.test(value3);
        return isBinary || reIsOctal.test(value3) ? freeParseInt(value3.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value3) ? NAN : +value3;
      }
      __name(toNumber2, "toNumber");
      function toPlainObject(value3) {
        return copyObject(value3, keysIn(value3));
      }
      __name(toPlainObject, "toPlainObject");
      function toSafeInteger(value3) {
        return value3 ? baseClamp(toInteger(value3), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value3 === 0 ? value3 : 0;
      }
      __name(toSafeInteger, "toSafeInteger");
      function toString3(value3) {
        return value3 == null ? "" : baseToString2(value3);
      }
      __name(toString3, "toString");
      var assign2 = createAssigner(function(object, source) {
        if (isPrototype(source) || isArrayLike(source)) {
          copyObject(source, keys2(source), object);
          return;
        }
        for (var key in source) {
          if (hasOwnProperty2.call(source, key)) {
            assignValue(object, key, source[key]);
          }
        }
      });
      var assignIn = createAssigner(function(object, source) {
        copyObject(source, keysIn(source), object);
      });
      var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keysIn(source), object, customizer);
      });
      var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keys2(source), object, customizer);
      });
      var at = flatRest(baseAt);
      function create2(prototype2, properties) {
        var result2 = baseCreate(prototype2);
        return properties == null ? result2 : baseAssign(result2, properties);
      }
      __name(create2, "create");
      var defaults2 = baseRest(function(object, sources) {
        object = Object2(object);
        var index2 = -1;
        var length = sources.length;
        var guard = length > 2 ? sources[2] : undefined$1;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          length = 1;
        }
        while (++index2 < length) {
          var source = sources[index2];
          var props = keysIn(source);
          var propsIndex = -1;
          var propsLength = props.length;
          while (++propsIndex < propsLength) {
            var key = props[propsIndex];
            var value3 = object[key];
            if (value3 === undefined$1 || eq(value3, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
              object[key] = source[key];
            }
          }
        }
        return object;
      });
      var defaultsDeep = baseRest(function(args) {
        args.push(undefined$1, customDefaultsMerge);
        return apply2(mergeWith, undefined$1, args);
      });
      function findKey2(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
      }
      __name(findKey2, "findKey");
      function findLastKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
      }
      __name(findLastKey, "findLastKey");
      function forIn(object, iteratee2) {
        return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
      }
      __name(forIn, "forIn");
      function forInRight(object, iteratee2) {
        return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
      }
      __name(forInRight, "forInRight");
      function forOwn(object, iteratee2) {
        return object && baseForOwn(object, getIteratee(iteratee2, 3));
      }
      __name(forOwn, "forOwn");
      function forOwnRight(object, iteratee2) {
        return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
      }
      __name(forOwnRight, "forOwnRight");
      function functions(object) {
        return object == null ? [] : baseFunctions(object, keys2(object));
      }
      __name(functions, "functions");
      function functionsIn(object) {
        return object == null ? [] : baseFunctions(object, keysIn(object));
      }
      __name(functionsIn, "functionsIn");
      function get2(object, path, defaultValue) {
        var result2 = object == null ? undefined$1 : baseGet(object, path);
        return result2 === undefined$1 ? defaultValue : result2;
      }
      __name(get2, "get");
      function has2(object, path) {
        return object != null && hasPath(object, path, baseHas);
      }
      __name(has2, "has");
      function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn);
      }
      __name(hasIn, "hasIn");
      var invert = createInverter(function(result2, value3, key) {
        if (value3 != null && typeof value3.toString != "function") {
          value3 = nativeObjectToString.call(value3);
        }
        result2[value3] = key;
      }, constant(identity2));
      var invertBy = createInverter(function(result2, value3, key) {
        if (value3 != null && typeof value3.toString != "function") {
          value3 = nativeObjectToString.call(value3);
        }
        if (hasOwnProperty2.call(result2, value3)) {
          result2[value3].push(key);
        } else {
          result2[value3] = [key];
        }
      }, getIteratee);
      var invoke2 = baseRest(baseInvoke);
      function keys2(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      __name(keys2, "keys");
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }
      __name(keysIn, "keysIn");
      function mapKeys(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value3, key, object2) {
          baseAssignValue(result2, iteratee2(value3, key, object2), value3);
        });
        return result2;
      }
      __name(mapKeys, "mapKeys");
      function mapValues(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value3, key, object2) {
          baseAssignValue(result2, key, iteratee2(value3, key, object2));
        });
        return result2;
      }
      __name(mapValues, "mapValues");
      var merge3 = createAssigner(function(object, source, srcIndex) {
        baseMerge(object, source, srcIndex);
      });
      var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
        baseMerge(object, source, srcIndex, customizer);
      });
      var omit = flatRest(function(object, paths) {
        var result2 = {};
        if (object == null) {
          return result2;
        }
        var isDeep = false;
        paths = arrayMap(paths, function(path) {
          path = castPath(path, object);
          isDeep || (isDeep = path.length > 1);
          return path;
        });
        copyObject(object, getAllKeysIn(object), result2);
        if (isDeep) {
          result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
        }
        var length = paths.length;
        while (length--) {
          baseUnset(result2, paths[length]);
        }
        return result2;
      });
      function omitBy(object, predicate) {
        return pickBy(object, negate(getIteratee(predicate)));
      }
      __name(omitBy, "omitBy");
      var pick = flatRest(function(object, paths) {
        return object == null ? {} : basePick(object, paths);
      });
      function pickBy(object, predicate) {
        if (object == null) {
          return {};
        }
        var props = arrayMap(getAllKeysIn(object), function(prop2) {
          return [prop2];
        });
        predicate = getIteratee(predicate);
        return basePickBy(object, props, function(value3, path) {
          return predicate(value3, path[0]);
        });
      }
      __name(pickBy, "pickBy");
      function result(object, path, defaultValue) {
        path = castPath(path, object);
        var index2 = -1, length = path.length;
        if (!length) {
          length = 1;
          object = undefined$1;
        }
        while (++index2 < length) {
          var value3 = object == null ? undefined$1 : object[toKey(path[index2])];
          if (value3 === undefined$1) {
            index2 = length;
            value3 = defaultValue;
          }
          object = isFunction3(value3) ? value3.call(object) : value3;
        }
        return object;
      }
      __name(result, "result");
      function set2(object, path, value3) {
        return object == null ? object : baseSet(object, path, value3);
      }
      __name(set2, "set");
      function setWith(object, path, value3, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return object == null ? object : baseSet(object, path, value3, customizer);
      }
      __name(setWith, "setWith");
      var toPairs = createToPairs(keys2);
      var toPairsIn = createToPairs(keysIn);
      function transform2(object, iteratee2, accumulator) {
        var isArr = isArray3(object), isArrLike = isArr || isBuffer2(object) || isTypedArray2(object);
        iteratee2 = getIteratee(iteratee2, 4);
        if (accumulator == null) {
          var Ctor = object && object.constructor;
          if (isArrLike) {
            accumulator = isArr ? new Ctor() : [];
          } else if (isObject3(object)) {
            accumulator = isFunction3(Ctor) ? baseCreate(getPrototype(object)) : {};
          } else {
            accumulator = {};
          }
        }
        (isArrLike ? arrayEach : baseForOwn)(object, function(value3, index2, object2) {
          return iteratee2(accumulator, value3, index2, object2);
        });
        return accumulator;
      }
      __name(transform2, "transform");
      function unset(object, path) {
        return object == null ? true : baseUnset(object, path);
      }
      __name(unset, "unset");
      function update2(object, path, updater) {
        return object == null ? object : baseUpdate(object, path, castFunction(updater));
      }
      __name(update2, "update");
      function updateWith(object, path, updater, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
      }
      __name(updateWith, "updateWith");
      function values2(object) {
        return object == null ? [] : baseValues(object, keys2(object));
      }
      __name(values2, "values");
      function valuesIn(object) {
        return object == null ? [] : baseValues(object, keysIn(object));
      }
      __name(valuesIn, "valuesIn");
      function clamp2(number2, lower, upper) {
        if (upper === undefined$1) {
          upper = lower;
          lower = undefined$1;
        }
        if (upper !== undefined$1) {
          upper = toNumber2(upper);
          upper = upper === upper ? upper : 0;
        }
        if (lower !== undefined$1) {
          lower = toNumber2(lower);
          lower = lower === lower ? lower : 0;
        }
        return baseClamp(toNumber2(number2), lower, upper);
      }
      __name(clamp2, "clamp");
      function inRange(number2, start2, end) {
        start2 = toFinite(start2);
        if (end === undefined$1) {
          end = start2;
          start2 = 0;
        } else {
          end = toFinite(end);
        }
        number2 = toNumber2(number2);
        return baseInRange(number2, start2, end);
      }
      __name(inRange, "inRange");
      function random(lower, upper, floating) {
        if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
          upper = floating = undefined$1;
        }
        if (floating === undefined$1) {
          if (typeof upper == "boolean") {
            floating = upper;
            upper = undefined$1;
          } else if (typeof lower == "boolean") {
            floating = lower;
            lower = undefined$1;
          }
        }
        if (lower === undefined$1 && upper === undefined$1) {
          lower = 0;
          upper = 1;
        } else {
          lower = toFinite(lower);
          if (upper === undefined$1) {
            upper = lower;
            lower = 0;
          } else {
            upper = toFinite(upper);
          }
        }
        if (lower > upper) {
          var temp = lower;
          lower = upper;
          upper = temp;
        }
        if (floating || lower % 1 || upper % 1) {
          var rand2 = nativeRandom();
          return nativeMin(lower + rand2 * (upper - lower + freeParseFloat("1e-" + ((rand2 + "").length - 1))), upper);
        }
        return baseRandom(lower, upper);
      }
      __name(random, "random");
      var camelCase = createCompounder(function(result2, word, index2) {
        word = word.toLowerCase();
        return result2 + (index2 ? capitalize2(word) : word);
      });
      function capitalize2(string) {
        return upperFirst(toString3(string).toLowerCase());
      }
      __name(capitalize2, "capitalize");
      function deburr(string) {
        string = toString3(string);
        return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      __name(deburr, "deburr");
      function endsWith3(string, target, position2) {
        string = toString3(string);
        target = baseToString2(target);
        var length = string.length;
        position2 = position2 === undefined$1 ? length : baseClamp(toInteger(position2), 0, length);
        var end = position2;
        position2 -= target.length;
        return position2 >= 0 && string.slice(position2, end) == target;
      }
      __name(endsWith3, "endsWith");
      function escape2(string) {
        string = toString3(string);
        return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
      }
      __name(escape2, "escape");
      function escapeRegExp2(string) {
        string = toString3(string);
        return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
      }
      __name(escapeRegExp2, "escapeRegExp");
      var kebabCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? "-" : "") + word.toLowerCase();
      });
      var lowerCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + word.toLowerCase();
      });
      var lowerFirst = createCaseFirst("toLowerCase");
      function pad(string, length, chars) {
        string = toString3(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        if (!length || strLength >= length) {
          return string;
        }
        var mid = (length - strLength) / 2;
        return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
      }
      __name(pad, "pad");
      function padEnd(string, length, chars) {
        string = toString3(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
      }
      __name(padEnd, "padEnd");
      function padStart(string, length, chars) {
        string = toString3(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
      }
      __name(padStart, "padStart");
      function parseInt2(string, radix, guard) {
        if (guard || radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        return nativeParseInt(toString3(string).replace(reTrimStart, ""), radix || 0);
      }
      __name(parseInt2, "parseInt");
      function repeat4(string, n, guard) {
        if (guard ? isIterateeCall(string, n, guard) : n === undefined$1) {
          n = 1;
        } else {
          n = toInteger(n);
        }
        return baseRepeat(toString3(string), n);
      }
      __name(repeat4, "repeat");
      function replace() {
        var args = arguments, string = toString3(args[0]);
        return args.length < 3 ? string : string.replace(args[1], args[2]);
      }
      __name(replace, "replace");
      var snakeCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? "_" : "") + word.toLowerCase();
      });
      function split(string, separator, limit) {
        if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
          separator = limit = undefined$1;
        }
        limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
        if (!limit) {
          return [];
        }
        string = toString3(string);
        if (string && (typeof separator == "string" || separator != null && !isRegExp2(separator))) {
          separator = baseToString2(separator);
          if (!separator && hasUnicode(string)) {
            return castSlice(stringToArray(string), 0, limit);
          }
        }
        return string.split(separator, limit);
      }
      __name(split, "split");
      var startCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + upperFirst(word);
      });
      function startsWith2(string, target, position2) {
        string = toString3(string);
        position2 = position2 == null ? 0 : baseClamp(toInteger(position2), 0, string.length);
        target = baseToString2(target);
        return string.slice(position2, position2 + target.length) == target;
      }
      __name(startsWith2, "startsWith");
      function template(string, options3, guard) {
        var settings = lodash2.templateSettings;
        if (guard && isIterateeCall(string, options3, guard)) {
          options3 = undefined$1;
        }
        string = toString3(string);
        options3 = assignInWith({}, options3, settings, customDefaultsAssignIn);
        var imports = assignInWith({}, options3.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys2(imports), importsValues = baseValues(imports, importsKeys);
        var isEscaping, isEvaluating, index2 = 0, interpolate = options3.interpolate || reNoMatch, source = "__p += '";
        var reDelimiters = RegExp2(
          (options3.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options3.evaluate || reNoMatch).source + "|$",
          "g"
        );
        var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options3, "sourceURL") ? (options3.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
        string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
          interpolateValue || (interpolateValue = esTemplateValue);
          source += string.slice(index2, offset).replace(reUnescapedString, escapeStringChar);
          if (escapeValue) {
            isEscaping = true;
            source += "' +\n__e(" + escapeValue + ") +\n'";
          }
          if (evaluateValue) {
            isEvaluating = true;
            source += "';\n" + evaluateValue + ";\n__p += '";
          }
          if (interpolateValue) {
            source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
          }
          index2 = offset + match.length;
          return match;
        });
        source += "';\n";
        var variable = hasOwnProperty2.call(options3, "variable") && options3.variable;
        if (!variable) {
          source = "with (obj) {\n" + source + "\n}\n";
        } else if (reForbiddenIdentifierChars.test(variable)) {
          throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
        }
        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
        source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
        var result2 = attempt(function() {
          return Function2(importsKeys, sourceURL + "return " + source).apply(undefined$1, importsValues);
        });
        result2.source = source;
        if (isError(result2)) {
          throw result2;
        }
        return result2;
      }
      __name(template, "template");
      function toLower(value3) {
        return toString3(value3).toLowerCase();
      }
      __name(toLower, "toLower");
      function toUpper(value3) {
        return toString3(value3).toUpperCase();
      }
      __name(toUpper, "toUpper");
      function trim2(string, chars, guard) {
        string = toString3(string);
        if (string && (guard || chars === undefined$1)) {
          return baseTrim(string);
        }
        if (!string || !(chars = baseToString2(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start2 = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start2, end).join("");
      }
      __name(trim2, "trim");
      function trimEnd(string, chars, guard) {
        string = toString3(string);
        if (string && (guard || chars === undefined$1)) {
          return string.slice(0, trimmedEndIndex(string) + 1);
        }
        if (!string || !(chars = baseToString2(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
        return castSlice(strSymbols, 0, end).join("");
      }
      __name(trimEnd, "trimEnd");
      function trimStart(string, chars, guard) {
        string = toString3(string);
        if (string && (guard || chars === undefined$1)) {
          return string.replace(reTrimStart, "");
        }
        if (!string || !(chars = baseToString2(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), start2 = charsStartIndex(strSymbols, stringToArray(chars));
        return castSlice(strSymbols, start2).join("");
      }
      __name(trimStart, "trimStart");
      function truncate(string, options3) {
        var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
        if (isObject3(options3)) {
          var separator = "separator" in options3 ? options3.separator : separator;
          length = "length" in options3 ? toInteger(options3.length) : length;
          omission = "omission" in options3 ? baseToString2(options3.omission) : omission;
        }
        string = toString3(string);
        var strLength = string.length;
        if (hasUnicode(string)) {
          var strSymbols = stringToArray(string);
          strLength = strSymbols.length;
        }
        if (length >= strLength) {
          return string;
        }
        var end = length - stringSize(omission);
        if (end < 1) {
          return omission;
        }
        var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
        if (separator === undefined$1) {
          return result2 + omission;
        }
        if (strSymbols) {
          end += result2.length - end;
        }
        if (isRegExp2(separator)) {
          if (string.slice(end).search(separator)) {
            var match, substring = result2;
            if (!separator.global) {
              separator = RegExp2(separator.source, toString3(reFlags.exec(separator)) + "g");
            }
            separator.lastIndex = 0;
            while (match = separator.exec(substring)) {
              var newEnd = match.index;
            }
            result2 = result2.slice(0, newEnd === undefined$1 ? end : newEnd);
          }
        } else if (string.indexOf(baseToString2(separator), end) != end) {
          var index2 = result2.lastIndexOf(separator);
          if (index2 > -1) {
            result2 = result2.slice(0, index2);
          }
        }
        return result2 + omission;
      }
      __name(truncate, "truncate");
      function unescape2(string) {
        string = toString3(string);
        return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
      }
      __name(unescape2, "unescape");
      var upperCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + word.toUpperCase();
      });
      var upperFirst = createCaseFirst("toUpperCase");
      function words(string, pattern, guard) {
        string = toString3(string);
        pattern = guard ? undefined$1 : pattern;
        if (pattern === undefined$1) {
          return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
        }
        return string.match(pattern) || [];
      }
      __name(words, "words");
      var attempt = baseRest(function(func, args) {
        try {
          return apply2(func, undefined$1, args);
        } catch (e) {
          return isError(e) ? e : new Error2(e);
        }
      });
      var bindAll2 = flatRest(function(object, methodNames) {
        arrayEach(methodNames, function(key) {
          key = toKey(key);
          baseAssignValue(object, key, bind3(object[key], object));
        });
        return object;
      });
      function cond(pairs) {
        var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
        pairs = !length ? [] : arrayMap(pairs, function(pair) {
          if (typeof pair[1] != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return [toIteratee(pair[0]), pair[1]];
        });
        return baseRest(function(args) {
          var index2 = -1;
          while (++index2 < length) {
            var pair = pairs[index2];
            if (apply2(pair[0], this, args)) {
              return apply2(pair[1], this, args);
            }
          }
        });
      }
      __name(cond, "cond");
      function conforms(source) {
        return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
      }
      __name(conforms, "conforms");
      function constant(value3) {
        return function() {
          return value3;
        };
      }
      __name(constant, "constant");
      function defaultTo(value3, defaultValue) {
        return value3 == null || value3 !== value3 ? defaultValue : value3;
      }
      __name(defaultTo, "defaultTo");
      var flow = createFlow();
      var flowRight = createFlow(true);
      function identity2(value3) {
        return value3;
      }
      __name(identity2, "identity");
      function iteratee(func) {
        return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
      }
      __name(iteratee, "iteratee");
      function matches2(source) {
        return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
      }
      __name(matches2, "matches");
      function matchesProperty(path, srcValue) {
        return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
      }
      __name(matchesProperty, "matchesProperty");
      var method = baseRest(function(path, args) {
        return function(object) {
          return baseInvoke(object, path, args);
        };
      });
      var methodOf = baseRest(function(object, args) {
        return function(path) {
          return baseInvoke(object, path, args);
        };
      });
      function mixin(object, source, options3) {
        var props = keys2(source), methodNames = baseFunctions(source, props);
        if (options3 == null && !(isObject3(source) && (methodNames.length || !props.length))) {
          options3 = source;
          source = object;
          object = this;
          methodNames = baseFunctions(source, keys2(source));
        }
        var chain2 = !(isObject3(options3) && "chain" in options3) || !!options3.chain, isFunc = isFunction3(object);
        arrayEach(methodNames, function(methodName) {
          var func = source[methodName];
          object[methodName] = func;
          if (isFunc) {
            object.prototype[methodName] = function() {
              var chainAll = this.__chain__;
              if (chain2 || chainAll) {
                var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                actions.push({ "func": func, "args": arguments, "thisArg": object });
                result2.__chain__ = chainAll;
                return result2;
              }
              return func.apply(object, arrayPush([this.value()], arguments));
            };
          }
        });
        return object;
      }
      __name(mixin, "mixin");
      function noConflict() {
        if (root26._ === this) {
          root26._ = oldDash;
        }
        return this;
      }
      __name(noConflict, "noConflict");
      function noop2() {
      }
      __name(noop2, "noop");
      function nthArg(n) {
        n = toInteger(n);
        return baseRest(function(args) {
          return baseNth(args, n);
        });
      }
      __name(nthArg, "nthArg");
      var over = createOver(arrayMap);
      var overEvery = createOver(arrayEvery);
      var overSome = createOver(arraySome);
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      __name(property, "property");
      function propertyOf(object) {
        return function(path) {
          return object == null ? undefined$1 : baseGet(object, path);
        };
      }
      __name(propertyOf, "propertyOf");
      var range2 = createRange();
      var rangeRight = createRange(true);
      function stubArray() {
        return [];
      }
      __name(stubArray, "stubArray");
      function stubFalse() {
        return false;
      }
      __name(stubFalse, "stubFalse");
      function stubObject() {
        return {};
      }
      __name(stubObject, "stubObject");
      function stubString() {
        return "";
      }
      __name(stubString, "stubString");
      function stubTrue() {
        return true;
      }
      __name(stubTrue, "stubTrue");
      function times(n, iteratee2) {
        n = toInteger(n);
        if (n < 1 || n > MAX_SAFE_INTEGER) {
          return [];
        }
        var index2 = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
        iteratee2 = getIteratee(iteratee2);
        n -= MAX_ARRAY_LENGTH;
        var result2 = baseTimes(length, iteratee2);
        while (++index2 < n) {
          iteratee2(index2);
        }
        return result2;
      }
      __name(times, "times");
      function toPath(value3) {
        if (isArray3(value3)) {
          return arrayMap(value3, toKey);
        }
        return isSymbol2(value3) ? [value3] : copyArray(stringToPath(toString3(value3)));
      }
      __name(toPath, "toPath");
      function uniqueId(prefix2) {
        var id2 = ++idCounter;
        return toString3(prefix2) + id2;
      }
      __name(uniqueId, "uniqueId");
      var add3 = createMathOperation(function(augend, addend) {
        return augend + addend;
      }, 0);
      var ceil = createRound("ceil");
      var divide = createMathOperation(function(dividend, divisor) {
        return dividend / divisor;
      }, 1);
      var floor = createRound("floor");
      function max(array) {
        return array && array.length ? baseExtremum(array, identity2, baseGt) : undefined$1;
      }
      __name(max, "max");
      function maxBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined$1;
      }
      __name(maxBy, "maxBy");
      function mean(array) {
        return baseMean(array, identity2);
      }
      __name(mean, "mean");
      function meanBy(array, iteratee2) {
        return baseMean(array, getIteratee(iteratee2, 2));
      }
      __name(meanBy, "meanBy");
      function min(array) {
        return array && array.length ? baseExtremum(array, identity2, baseLt) : undefined$1;
      }
      __name(min, "min");
      function minBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined$1;
      }
      __name(minBy, "minBy");
      var multiply = createMathOperation(function(multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1);
      var round = createRound("round");
      var subtract = createMathOperation(function(minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);
      function sum(array) {
        return array && array.length ? baseSum(array, identity2) : 0;
      }
      __name(sum, "sum");
      function sumBy(array, iteratee2) {
        return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
      }
      __name(sumBy, "sumBy");
      lodash2.after = after;
      lodash2.ary = ary;
      lodash2.assign = assign2;
      lodash2.assignIn = assignIn;
      lodash2.assignInWith = assignInWith;
      lodash2.assignWith = assignWith;
      lodash2.at = at;
      lodash2.before = before;
      lodash2.bind = bind3;
      lodash2.bindAll = bindAll2;
      lodash2.bindKey = bindKey;
      lodash2.castArray = castArray;
      lodash2.chain = chain;
      lodash2.chunk = chunk;
      lodash2.compact = compact;
      lodash2.concat = concat;
      lodash2.cond = cond;
      lodash2.conforms = conforms;
      lodash2.constant = constant;
      lodash2.countBy = countBy;
      lodash2.create = create2;
      lodash2.curry = curry;
      lodash2.curryRight = curryRight;
      lodash2.debounce = debounce;
      lodash2.defaults = defaults2;
      lodash2.defaultsDeep = defaultsDeep;
      lodash2.defer = defer;
      lodash2.delay = delay;
      lodash2.difference = difference;
      lodash2.differenceBy = differenceBy;
      lodash2.differenceWith = differenceWith;
      lodash2.drop = drop;
      lodash2.dropRight = dropRight;
      lodash2.dropRightWhile = dropRightWhile;
      lodash2.dropWhile = dropWhile;
      lodash2.fill = fill;
      lodash2.filter = filter4;
      lodash2.flatMap = flatMap;
      lodash2.flatMapDeep = flatMapDeep;
      lodash2.flatMapDepth = flatMapDepth;
      lodash2.flatten = flatten;
      lodash2.flattenDeep = flattenDeep;
      lodash2.flattenDepth = flattenDepth;
      lodash2.flip = flip;
      lodash2.flow = flow;
      lodash2.flowRight = flowRight;
      lodash2.fromPairs = fromPairs;
      lodash2.functions = functions;
      lodash2.functionsIn = functionsIn;
      lodash2.groupBy = groupBy;
      lodash2.initial = initial;
      lodash2.intersection = intersection;
      lodash2.intersectionBy = intersectionBy;
      lodash2.intersectionWith = intersectionWith;
      lodash2.invert = invert;
      lodash2.invertBy = invertBy;
      lodash2.invokeMap = invokeMap;
      lodash2.iteratee = iteratee;
      lodash2.keyBy = keyBy;
      lodash2.keys = keys2;
      lodash2.keysIn = keysIn;
      lodash2.map = map2;
      lodash2.mapKeys = mapKeys;
      lodash2.mapValues = mapValues;
      lodash2.matches = matches2;
      lodash2.matchesProperty = matchesProperty;
      lodash2.memoize = memoize;
      lodash2.merge = merge3;
      lodash2.mergeWith = mergeWith;
      lodash2.method = method;
      lodash2.methodOf = methodOf;
      lodash2.mixin = mixin;
      lodash2.negate = negate;
      lodash2.nthArg = nthArg;
      lodash2.omit = omit;
      lodash2.omitBy = omitBy;
      lodash2.once = once2;
      lodash2.orderBy = orderBy;
      lodash2.over = over;
      lodash2.overArgs = overArgs;
      lodash2.overEvery = overEvery;
      lodash2.overSome = overSome;
      lodash2.partial = partial;
      lodash2.partialRight = partialRight;
      lodash2.partition = partition;
      lodash2.pick = pick;
      lodash2.pickBy = pickBy;
      lodash2.property = property;
      lodash2.propertyOf = propertyOf;
      lodash2.pull = pull;
      lodash2.pullAll = pullAll;
      lodash2.pullAllBy = pullAllBy;
      lodash2.pullAllWith = pullAllWith;
      lodash2.pullAt = pullAt;
      lodash2.range = range2;
      lodash2.rangeRight = rangeRight;
      lodash2.rearg = rearg;
      lodash2.reject = reject2;
      lodash2.remove = remove5;
      lodash2.rest = rest;
      lodash2.reverse = reverse;
      lodash2.sampleSize = sampleSize;
      lodash2.set = set2;
      lodash2.setWith = setWith;
      lodash2.shuffle = shuffle;
      lodash2.slice = slice;
      lodash2.sortBy = sortBy;
      lodash2.sortedUniq = sortedUniq;
      lodash2.sortedUniqBy = sortedUniqBy;
      lodash2.split = split;
      lodash2.spread = spread2;
      lodash2.tail = tail;
      lodash2.take = take;
      lodash2.takeRight = takeRight;
      lodash2.takeRightWhile = takeRightWhile;
      lodash2.takeWhile = takeWhile;
      lodash2.tap = tap;
      lodash2.throttle = throttle2;
      lodash2.thru = thru;
      lodash2.toArray = toArray2;
      lodash2.toPairs = toPairs;
      lodash2.toPairsIn = toPairsIn;
      lodash2.toPath = toPath;
      lodash2.toPlainObject = toPlainObject;
      lodash2.transform = transform2;
      lodash2.unary = unary;
      lodash2.union = union;
      lodash2.unionBy = unionBy;
      lodash2.unionWith = unionWith;
      lodash2.uniq = uniq2;
      lodash2.uniqBy = uniqBy;
      lodash2.uniqWith = uniqWith;
      lodash2.unset = unset;
      lodash2.unzip = unzip;
      lodash2.unzipWith = unzipWith;
      lodash2.update = update2;
      lodash2.updateWith = updateWith;
      lodash2.values = values2;
      lodash2.valuesIn = valuesIn;
      lodash2.without = without;
      lodash2.words = words;
      lodash2.wrap = wrap;
      lodash2.xor = xor;
      lodash2.xorBy = xorBy;
      lodash2.xorWith = xorWith;
      lodash2.zip = zip;
      lodash2.zipObject = zipObject;
      lodash2.zipObjectDeep = zipObjectDeep;
      lodash2.zipWith = zipWith;
      lodash2.entries = toPairs;
      lodash2.entriesIn = toPairsIn;
      lodash2.extend = assignIn;
      lodash2.extendWith = assignInWith;
      mixin(lodash2, lodash2);
      lodash2.add = add3;
      lodash2.attempt = attempt;
      lodash2.camelCase = camelCase;
      lodash2.capitalize = capitalize2;
      lodash2.ceil = ceil;
      lodash2.clamp = clamp2;
      lodash2.clone = clone2;
      lodash2.cloneDeep = cloneDeep;
      lodash2.cloneDeepWith = cloneDeepWith;
      lodash2.cloneWith = cloneWith;
      lodash2.conformsTo = conformsTo;
      lodash2.deburr = deburr;
      lodash2.defaultTo = defaultTo;
      lodash2.divide = divide;
      lodash2.endsWith = endsWith3;
      lodash2.eq = eq;
      lodash2.escape = escape2;
      lodash2.escapeRegExp = escapeRegExp2;
      lodash2.every = every;
      lodash2.find = find2;
      lodash2.findIndex = findIndex;
      lodash2.findKey = findKey2;
      lodash2.findLast = findLast2;
      lodash2.findLastIndex = findLastIndex2;
      lodash2.findLastKey = findLastKey;
      lodash2.floor = floor;
      lodash2.forEach = forEach2;
      lodash2.forEachRight = forEachRight;
      lodash2.forIn = forIn;
      lodash2.forInRight = forInRight;
      lodash2.forOwn = forOwn;
      lodash2.forOwnRight = forOwnRight;
      lodash2.get = get2;
      lodash2.gt = gt2;
      lodash2.gte = gte2;
      lodash2.has = has2;
      lodash2.hasIn = hasIn;
      lodash2.head = head;
      lodash2.identity = identity2;
      lodash2.includes = includes;
      lodash2.indexOf = indexOf;
      lodash2.inRange = inRange;
      lodash2.invoke = invoke2;
      lodash2.isArguments = isArguments;
      lodash2.isArray = isArray3;
      lodash2.isArrayBuffer = isArrayBuffer2;
      lodash2.isArrayLike = isArrayLike;
      lodash2.isArrayLikeObject = isArrayLikeObject;
      lodash2.isBoolean = isBoolean2;
      lodash2.isBuffer = isBuffer2;
      lodash2.isDate = isDate2;
      lodash2.isElement = isElement2;
      lodash2.isEmpty = isEmpty3;
      lodash2.isEqual = isEqual;
      lodash2.isEqualWith = isEqualWith;
      lodash2.isError = isError;
      lodash2.isFinite = isFinite2;
      lodash2.isFunction = isFunction3;
      lodash2.isInteger = isInteger;
      lodash2.isLength = isLength;
      lodash2.isMap = isMap2;
      lodash2.isMatch = isMatch;
      lodash2.isMatchWith = isMatchWith;
      lodash2.isNaN = isNaN2;
      lodash2.isNative = isNative;
      lodash2.isNil = isNil;
      lodash2.isNull = isNull;
      lodash2.isNumber = isNumber3;
      lodash2.isObject = isObject3;
      lodash2.isObjectLike = isObjectLike2;
      lodash2.isPlainObject = isPlainObject2;
      lodash2.isRegExp = isRegExp2;
      lodash2.isSafeInteger = isSafeInteger;
      lodash2.isSet = isSet2;
      lodash2.isString = isString3;
      lodash2.isSymbol = isSymbol2;
      lodash2.isTypedArray = isTypedArray2;
      lodash2.isUndefined = isUndefined2;
      lodash2.isWeakMap = isWeakMap;
      lodash2.isWeakSet = isWeakSet;
      lodash2.join = join2;
      lodash2.kebabCase = kebabCase;
      lodash2.last = last;
      lodash2.lastIndexOf = lastIndexOf;
      lodash2.lowerCase = lowerCase;
      lodash2.lowerFirst = lowerFirst;
      lodash2.lt = lt2;
      lodash2.lte = lte2;
      lodash2.max = max;
      lodash2.maxBy = maxBy;
      lodash2.mean = mean;
      lodash2.meanBy = meanBy;
      lodash2.min = min;
      lodash2.minBy = minBy;
      lodash2.stubArray = stubArray;
      lodash2.stubFalse = stubFalse;
      lodash2.stubObject = stubObject;
      lodash2.stubString = stubString;
      lodash2.stubTrue = stubTrue;
      lodash2.multiply = multiply;
      lodash2.nth = nth;
      lodash2.noConflict = noConflict;
      lodash2.noop = noop2;
      lodash2.now = now2;
      lodash2.pad = pad;
      lodash2.padEnd = padEnd;
      lodash2.padStart = padStart;
      lodash2.parseInt = parseInt2;
      lodash2.random = random;
      lodash2.reduce = reduce;
      lodash2.reduceRight = reduceRight;
      lodash2.repeat = repeat4;
      lodash2.replace = replace;
      lodash2.result = result;
      lodash2.round = round;
      lodash2.runInContext = runInContext2;
      lodash2.sample = sample;
      lodash2.size = size2;
      lodash2.snakeCase = snakeCase;
      lodash2.some = some;
      lodash2.sortedIndex = sortedIndex;
      lodash2.sortedIndexBy = sortedIndexBy;
      lodash2.sortedIndexOf = sortedIndexOf;
      lodash2.sortedLastIndex = sortedLastIndex;
      lodash2.sortedLastIndexBy = sortedLastIndexBy;
      lodash2.sortedLastIndexOf = sortedLastIndexOf;
      lodash2.startCase = startCase;
      lodash2.startsWith = startsWith2;
      lodash2.subtract = subtract;
      lodash2.sum = sum;
      lodash2.sumBy = sumBy;
      lodash2.template = template;
      lodash2.times = times;
      lodash2.toFinite = toFinite;
      lodash2.toInteger = toInteger;
      lodash2.toLength = toLength;
      lodash2.toLower = toLower;
      lodash2.toNumber = toNumber2;
      lodash2.toSafeInteger = toSafeInteger;
      lodash2.toString = toString3;
      lodash2.toUpper = toUpper;
      lodash2.trim = trim2;
      lodash2.trimEnd = trimEnd;
      lodash2.trimStart = trimStart;
      lodash2.truncate = truncate;
      lodash2.unescape = unescape2;
      lodash2.uniqueId = uniqueId;
      lodash2.upperCase = upperCase;
      lodash2.upperFirst = upperFirst;
      lodash2.each = forEach2;
      lodash2.eachRight = forEachRight;
      lodash2.first = head;
      mixin(lodash2, function() {
        var source = {};
        baseForOwn(lodash2, function(func, methodName) {
          if (!hasOwnProperty2.call(lodash2.prototype, methodName)) {
            source[methodName] = func;
          }
        });
        return source;
      }(), { "chain": false });
      lodash2.VERSION = VERSION2;
      arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
        lodash2[methodName].placeholder = lodash2;
      });
      arrayEach(["drop", "take"], function(methodName, index2) {
        LazyWrapper.prototype[methodName] = function(n) {
          n = n === undefined$1 ? 1 : nativeMax(toInteger(n), 0);
          var result2 = this.__filtered__ && !index2 ? new LazyWrapper(this) : this.clone();
          if (result2.__filtered__) {
            result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
          } else {
            result2.__views__.push({
              "size": nativeMin(n, MAX_ARRAY_LENGTH),
              "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
            });
          }
          return result2;
        };
        LazyWrapper.prototype[methodName + "Right"] = function(n) {
          return this.reverse()[methodName](n).reverse();
        };
      });
      arrayEach(["filter", "map", "takeWhile"], function(methodName, index2) {
        var type = index2 + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
        LazyWrapper.prototype[methodName] = function(iteratee2) {
          var result2 = this.clone();
          result2.__iteratees__.push({
            "iteratee": getIteratee(iteratee2, 3),
            "type": type
          });
          result2.__filtered__ = result2.__filtered__ || isFilter;
          return result2;
        };
      });
      arrayEach(["head", "last"], function(methodName, index2) {
        var takeName = "take" + (index2 ? "Right" : "");
        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      });
      arrayEach(["initial", "tail"], function(methodName, index2) {
        var dropName = "drop" + (index2 ? "" : "Right");
        LazyWrapper.prototype[methodName] = function() {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      });
      LazyWrapper.prototype.compact = function() {
        return this.filter(identity2);
      };
      LazyWrapper.prototype.find = function(predicate) {
        return this.filter(predicate).head();
      };
      LazyWrapper.prototype.findLast = function(predicate) {
        return this.reverse().find(predicate);
      };
      LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
        if (typeof path == "function") {
          return new LazyWrapper(this);
        }
        return this.map(function(value3) {
          return baseInvoke(value3, path, args);
        });
      });
      LazyWrapper.prototype.reject = function(predicate) {
        return this.filter(negate(getIteratee(predicate)));
      };
      LazyWrapper.prototype.slice = function(start2, end) {
        start2 = toInteger(start2);
        var result2 = this;
        if (result2.__filtered__ && (start2 > 0 || end < 0)) {
          return new LazyWrapper(result2);
        }
        if (start2 < 0) {
          result2 = result2.takeRight(-start2);
        } else if (start2) {
          result2 = result2.drop(start2);
        }
        if (end !== undefined$1) {
          end = toInteger(end);
          result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start2);
        }
        return result2;
      };
      LazyWrapper.prototype.takeRightWhile = function(predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      };
      LazyWrapper.prototype.toArray = function() {
        return this.take(MAX_ARRAY_LENGTH);
      };
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
        if (!lodashFunc) {
          return;
        }
        lodash2.prototype[methodName] = function() {
          var value3 = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value3 instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray3(value3);
          var interceptor = /* @__PURE__ */ __name(function(value4) {
            var result3 = lodashFunc.apply(lodash2, arrayPush([value4], args));
            return isTaker && chainAll ? result3[0] : result3;
          }, "interceptor");
          if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
            isLazy = useLazy = false;
          }
          var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
          if (!retUnwrapped && useLazy) {
            value3 = onlyLazy ? value3 : new LazyWrapper(this);
            var result2 = func.apply(value3, args);
            result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined$1 });
            return new LodashWrapper(result2, chainAll);
          }
          if (isUnwrapped && onlyLazy) {
            return func.apply(this, args);
          }
          result2 = this.thru(interceptor);
          return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
        };
      });
      arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
        var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
        lodash2.prototype[methodName] = function() {
          var args = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value3 = this.value();
            return func.apply(isArray3(value3) ? value3 : [], args);
          }
          return this[chainName](function(value4) {
            return func.apply(isArray3(value4) ? value4 : [], args);
          });
        };
      });
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var lodashFunc = lodash2[methodName];
        if (lodashFunc) {
          var key = lodashFunc.name + "";
          if (!hasOwnProperty2.call(realNames, key)) {
            realNames[key] = [];
          }
          realNames[key].push({ "name": methodName, "func": lodashFunc });
        }
      });
      realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
        "name": "wrapper",
        "func": undefined$1
      }];
      LazyWrapper.prototype.clone = lazyClone;
      LazyWrapper.prototype.reverse = lazyReverse;
      LazyWrapper.prototype.value = lazyValue;
      lodash2.prototype.at = wrapperAt;
      lodash2.prototype.chain = wrapperChain;
      lodash2.prototype.commit = wrapperCommit;
      lodash2.prototype.next = wrapperNext;
      lodash2.prototype.plant = wrapperPlant;
      lodash2.prototype.reverse = wrapperReverse;
      lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue;
      lodash2.prototype.first = lodash2.prototype.head;
      if (symIterator) {
        lodash2.prototype[symIterator] = wrapperToIterator;
      }
      return lodash2;
    }, "runInContext");
    var _2 = runInContext();
    if (typeof undefined$1 == "function" && typeof undefined$1.amd == "object" && undefined$1.amd) {
      root26._ = _2;
      undefined$1(function() {
        return _2;
      });
    } else if (freeModule) {
      (freeModule.exports = _2)._ = _2;
      freeExports._ = _2;
    } else {
      root26._ = _2;
    }
  }).call(commonjsGlobal);
})(lodash$1, lodash$1.exports);
var lodashExports = lodash$1.exports;
const _ = /* @__PURE__ */ getDefaultExportFromCjs(lodashExports);
var script$u = {
  name: "TimesCircleIcon",
  "extends": script$U
};
var _hoisted_1$J = /* @__PURE__ */ createBaseVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M7 14C5.61553 14 4.26215 13.5895 3.11101 12.8203C1.95987 12.0511 1.06266 10.9579 0.532846 9.67879C0.00303296 8.3997 -0.13559 6.99224 0.134506 5.63437C0.404603 4.2765 1.07129 3.02922 2.05026 2.05026C3.02922 1.07129 4.2765 0.404603 5.63437 0.134506C6.99224 -0.13559 8.3997 0.00303296 9.67879 0.532846C10.9579 1.06266 12.0511 1.95987 12.8203 3.11101C13.5895 4.26215 14 5.61553 14 7C14 8.85652 13.2625 10.637 11.9497 11.9497C10.637 13.2625 8.85652 14 7 14ZM7 1.16667C5.84628 1.16667 4.71846 1.50879 3.75918 2.14976C2.79989 2.79074 2.05222 3.70178 1.61071 4.76768C1.16919 5.83358 1.05367 7.00647 1.27876 8.13803C1.50384 9.26958 2.05941 10.309 2.87521 11.1248C3.69102 11.9406 4.73042 12.4962 5.86198 12.7212C6.99353 12.9463 8.16642 12.8308 9.23232 12.3893C10.2982 11.9478 11.2093 11.2001 11.8502 10.2408C12.4912 9.28154 12.8333 8.15373 12.8333 7C12.8333 5.45291 12.2188 3.96918 11.1248 2.87521C10.0308 1.78125 8.5471 1.16667 7 1.16667ZM4.66662 9.91668C4.58998 9.91704 4.51404 9.90209 4.44325 9.87271C4.37246 9.84333 4.30826 9.8001 4.2544 9.74557C4.14516 9.6362 4.0838 9.48793 4.0838 9.33335C4.0838 9.17876 4.14516 9.0305 4.2544 8.92113L6.17553 7L4.25443 5.07891C4.15139 4.96832 4.09529 4.82207 4.09796 4.67094C4.10063 4.51982 4.16185 4.37563 4.26872 4.26876C4.3756 4.16188 4.51979 4.10066 4.67091 4.09799C4.82204 4.09532 4.96829 4.15142 5.07887 4.25446L6.99997 6.17556L8.92106 4.25446C9.03164 4.15142 9.1779 4.09532 9.32903 4.09799C9.48015 4.10066 9.62434 4.16188 9.73121 4.26876C9.83809 4.37563 9.89931 4.51982 9.90198 4.67094C9.90464 4.82207 9.84855 4.96832 9.74551 5.07891L7.82441 7L9.74554 8.92113C9.85478 9.0305 9.91614 9.17876 9.91614 9.33335C9.91614 9.48793 9.85478 9.6362 9.74554 9.74557C9.69168 9.8001 9.62748 9.84333 9.55669 9.87271C9.4859 9.90209 9.40996 9.91704 9.33332 9.91668C9.25668 9.91704 9.18073 9.90209 9.10995 9.87271C9.03916 9.84333 8.97495 9.8001 8.9211 9.74557L6.99997 7.82444L5.07884 9.74557C5.02499 9.8001 4.96078 9.84333 4.88999 9.87271C4.81921 9.90209 4.74326 9.91704 4.66662 9.91668Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$x = [_hoisted_1$J];
function render$t(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$x, 16);
}
__name(render$t, "render$t");
script$u.render = render$t;
var theme$h = /* @__PURE__ */ __name(function theme20(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-chip {\n    display: inline-flex;\n    align-items: center;\n    background: ".concat(dt3("chip.background"), ";\n    color: ").concat(dt3("chip.color"), ";\n    border-radius: ").concat(dt3("chip.border.radius"), ";\n    padding: ").concat(dt3("chip.padding.y"), " ").concat(dt3("chip.padding.x"), ";\n    gap: ").concat(dt3("chip.gap"), ";\n}\n\n.p-chip-icon {\n    color: ").concat(dt3("chip.icon.color"), ";\n    font-size: ").concat(dt3("chip.icon.font.size"), ";\n    width: ").concat(dt3("chip.icon.size"), ";\n    height: ").concat(dt3("chip.icon.size"), ";\n}\n\n.p-chip-image {\n    border-radius: 50%;\n    width: ").concat(dt3("chip.image.width"), ";\n    height: ").concat(dt3("chip.image.height"), ";\n    margin-left: calc(-1 * ").concat(dt3("chip.padding.y"), ");\n}\n\n.p-chip:has(.p-chip-remove-icon) {\n    padding-right: ").concat(dt3("chip.padding.y"), ";\n}\n\n.p-chip:has(.p-chip-image) {\n    padding-top: calc(").concat(dt3("chip.padding.y"), " / 2);\n    padding-bottom: calc(").concat(dt3("chip.padding.y"), " / 2);\n}\n\n.p-chip-remove-icon {\n    cursor: pointer;\n    font-size: ").concat(dt3("chip.remove.icon.size"), ";\n    width: ").concat(dt3("chip.remove.icon.size"), ";\n    height: ").concat(dt3("chip.remove.icon.size"), ";\n    color: ").concat(dt3("chip.remove.icon.color"), ";\n    border-radius: 50%;\n    transition: outline-color ").concat(dt3("chip.transition.duration"), ", box-shadow ").concat(dt3("chip.transition.duration"), ";\n    outline-color: transparent;\n}\n\n.p-chip-remove-icon:focus-visible {\n    box-shadow: ").concat(dt3("chip.remove.icon.focus.ring.shadow"), ";\n    outline: ").concat(dt3("chip.remove.icon.focus.ring.width"), " ").concat(dt3("chip.remove.icon.focus.ring.style"), " ").concat(dt3("chip.remove.icon.focus.ring.color"), ";\n    outline-offset: ").concat(dt3("chip.remove.icon.focus.ring.offset"), ";\n}\n");
}, "theme");
var classes$i = {
  root: "p-chip p-component",
  image: "p-chip-image",
  icon: "p-chip-icon",
  label: "p-chip-label",
  removeIcon: "p-chip-remove-icon"
};
var ChipStyle = BaseStyle.extend({
  name: "chip",
  theme: theme$h,
  classes: classes$i
});
var script$1$i = {
  name: "BaseChip",
  "extends": script$X,
  props: {
    label: {
      type: String,
      "default": null
    },
    icon: {
      type: String,
      "default": null
    },
    image: {
      type: String,
      "default": null
    },
    removable: {
      type: Boolean,
      "default": false
    },
    removeIcon: {
      type: String,
      "default": void 0
    }
  },
  style: ChipStyle,
  provide: /* @__PURE__ */ __name(function provide21() {
    return {
      $pcChip: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$t = {
  name: "Chip",
  "extends": script$1$i,
  inheritAttrs: false,
  emits: ["remove"],
  data: /* @__PURE__ */ __name(function data8() {
    return {
      visible: true
    };
  }, "data"),
  methods: {
    onKeydown: /* @__PURE__ */ __name(function onKeydown2(event2) {
      if (event2.key === "Enter" || event2.key === "Backspace") {
        this.close(event2);
      }
    }, "onKeydown"),
    close: /* @__PURE__ */ __name(function close(event2) {
      this.visible = false;
      this.$emit("remove", event2);
    }, "close")
  },
  components: {
    TimesCircleIcon: script$u
  }
};
var _hoisted_1$I = ["aria-label"];
var _hoisted_2$w = ["src"];
function render$s(_ctx, _cache, $props, $setup, $data, $options) {
  return $data.visible ? (openBlock(), createElementBlock("div", mergeProps({
    key: 0,
    "class": _ctx.cx("root"),
    "aria-label": _ctx.label
  }, _ctx.ptmi("root")), [renderSlot(_ctx.$slots, "default", {}, function() {
    return [_ctx.image ? (openBlock(), createElementBlock("img", mergeProps({
      key: 0,
      src: _ctx.image
    }, _ctx.ptm("image"), {
      "class": _ctx.cx("image")
    }), null, 16, _hoisted_2$w)) : _ctx.$slots.icon ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.$slots.icon), mergeProps({
      key: 1,
      "class": _ctx.cx("icon")
    }, _ctx.ptm("icon")), null, 16, ["class"])) : _ctx.icon ? (openBlock(), createElementBlock("span", mergeProps({
      key: 2,
      "class": [_ctx.cx("icon"), _ctx.icon]
    }, _ctx.ptm("icon")), null, 16)) : createCommentVNode("", true), _ctx.label ? (openBlock(), createElementBlock("div", mergeProps({
      key: 3,
      "class": _ctx.cx("label")
    }, _ctx.ptm("label")), toDisplayString$1(_ctx.label), 17)) : createCommentVNode("", true)];
  }), _ctx.removable ? renderSlot(_ctx.$slots, "removeicon", {
    key: 0,
    removeCallback: $options.close,
    keydownCallback: $options.onKeydown
  }, function() {
    return [(openBlock(), createBlock(resolveDynamicComponent(_ctx.removeIcon ? "span" : "TimesCircleIcon"), mergeProps({
      tabindex: "0",
      "class": [_ctx.cx("removeIcon"), _ctx.removeIcon],
      onClick: $options.close,
      onKeydown: $options.onKeydown
    }, _ctx.ptm("removeIcon")), null, 16, ["class", "onClick", "onKeydown"]))];
  }) : createCommentVNode("", true)], 16, _hoisted_1$I)) : createCommentVNode("", true);
}
__name(render$s, "render$s");
script$t.render = render$s;
const _sfc_main$C = /* @__PURE__ */ defineComponent({
  __name: "SearchFilterChip",
  props: {
    text: {},
    badge: {},
    badgeClass: {}
  },
  emits: ["remove"],
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(script$t), {
        removable: "",
        onRemove: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("remove", $event))
      }, {
        default: withCtx(() => [
          createVNode(unref(script$K), {
            size: "small",
            class: normalizeClass(_ctx.badgeClass)
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString$1(_ctx.badge), 1)
            ]),
            _: 1
          }, 8, ["class"]),
          createTextVNode(" " + toDisplayString$1(_ctx.text), 1)
        ]),
        _: 1
      });
    };
  }
});
const SearchFilterChip = /* @__PURE__ */ _export_sfc(_sfc_main$C, [["__scopeId", "data-v-a4c03005"]]);
const _withScopeId$i = /* @__PURE__ */ __name((n) => (pushScopeId("data-v-73e04275"), n = n(), popScopeId(), n), "_withScopeId$i");
const _hoisted_1$H = {
  key: 0,
  class: "search-filters"
};
const _sfc_main$B = /* @__PURE__ */ defineComponent({
  __name: "SearchBox",
  props: {
    class: {},
    modelValue: {},
    placeholder: { default: "Search..." },
    icon: { default: "pi pi-search" },
    debounceTime: { default: 300 },
    filterIcon: {},
    filters: {}
  },
  emits: [
    "update:modelValue",
    "search",
    "showFilter",
    "removeFilter"
  ],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const { filters } = toRefs$1(props);
    const emit2 = __emit;
    const emitSearch = lodashExports.debounce((value3) => {
      emit2("search", value3, props.filters);
    }, props.debounceTime);
    const handleInput = /* @__PURE__ */ __name((event2) => {
      const target = event2.target;
      emit2("update:modelValue", target.value);
      emitSearch(target.value);
    }, "handleInput");
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(props.class)
      }, [
        createVNode(unref(script$Q), null, {
          default: withCtx(() => [
            createVNode(unref(script$P), {
              class: normalizeClass(props.icon)
            }, null, 8, ["class"]),
            createVNode(unref(script$O), {
              class: normalizeClass(["search-box-input", { ["with-filter"]: props.filterIcon }]),
              onInput: handleInput,
              modelValue: props.modelValue,
              placeholder: props.placeholder
            }, null, 8, ["class", "modelValue", "placeholder"]),
            props.filterIcon ? (openBlock(), createBlock(unref(script$J), {
              key: 0,
              class: "p-inputicon",
              icon: props.filterIcon,
              text: "",
              severity: "contrast",
              onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("showFilter", $event))
            }, null, 8, ["icon"])) : createCommentVNode("", true)
          ]),
          _: 1
        }),
        unref(filters) ? (openBlock(), createElementBlock("div", _hoisted_1$H, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(filters), (filter4) => {
            return openBlock(), createBlock(SearchFilterChip, {
              key: filter4.id,
              text: filter4.text,
              badge: filter4.badge,
              "badge-class": filter4.badgeClass,
              onRemove: /* @__PURE__ */ __name(($event) => _ctx.$emit("removeFilter", filter4), "onRemove")
            }, null, 8, ["text", "badge", "badge-class", "onRemove"]);
          }), 128))
        ])) : createCommentVNode("", true)
      ], 2);
    };
  }
});
const SearchBox = /* @__PURE__ */ _export_sfc(_sfc_main$B, [["__scopeId", "data-v-73e04275"]]);
var theme$g = /* @__PURE__ */ __name(function theme21(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-card {\n    background: ".concat(dt3("card.background"), ";\n    color: ").concat(dt3("card.color"), ";\n    box-shadow: ").concat(dt3("card.shadow"), ";\n    border-radius: ").concat(dt3("card.border.radius"), ";\n    display: flex;\n    flex-direction: column;\n}\n\n.p-card-caption {\n    display: flex;\n    flex-direction: column;\n    gap: ").concat(dt3("card.caption.gap"), ";\n}\n\n.p-card-body {\n    padding: ").concat(dt3("card.body.padding"), ";\n    display: flex;\n    flex-direction: column;\n    gap: ").concat(dt3("card.body.gap"), ";\n}\n\n.p-card-title {\n    font-size: ").concat(dt3("card.title.font.size"), ";\n    font-weight: ").concat(dt3("card.title.font.weight"), ";\n}\n\n.p-card-subtitle {\n    color: ").concat(dt3("card.subtitle.color"), ";\n}\n");
}, "theme");
var classes$h = {
  root: "p-card p-component",
  header: "p-card-header",
  body: "p-card-body",
  caption: "p-card-caption",
  title: "p-card-title",
  subtitle: "p-card-subtitle",
  content: "p-card-content",
  footer: "p-card-footer"
};
var CardStyle = BaseStyle.extend({
  name: "card",
  theme: theme$g,
  classes: classes$h
});
var script$1$h = {
  name: "BaseCard",
  "extends": script$X,
  style: CardStyle,
  provide: /* @__PURE__ */ __name(function provide22() {
    return {
      $pcCard: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$s = {
  name: "Card",
  "extends": script$1$h,
  inheritAttrs: false
};
function render$r(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("root")
  }, _ctx.ptmi("root")), [_ctx.$slots.header ? (openBlock(), createElementBlock("div", mergeProps({
    key: 0,
    "class": _ctx.cx("header")
  }, _ctx.ptm("header")), [renderSlot(_ctx.$slots, "header")], 16)) : createCommentVNode("", true), createBaseVNode("div", mergeProps({
    "class": _ctx.cx("body")
  }, _ctx.ptm("body")), [_ctx.$slots.title || _ctx.$slots.subtitle ? (openBlock(), createElementBlock("div", mergeProps({
    key: 0,
    "class": _ctx.cx("caption")
  }, _ctx.ptm("caption")), [_ctx.$slots.title ? (openBlock(), createElementBlock("div", mergeProps({
    key: 0,
    "class": _ctx.cx("title")
  }, _ctx.ptm("title")), [renderSlot(_ctx.$slots, "title")], 16)) : createCommentVNode("", true), _ctx.$slots.subtitle ? (openBlock(), createElementBlock("div", mergeProps({
    key: 1,
    "class": _ctx.cx("subtitle")
  }, _ctx.ptm("subtitle")), [renderSlot(_ctx.$slots, "subtitle")], 16)) : createCommentVNode("", true)], 16)) : createCommentVNode("", true), createBaseVNode("div", mergeProps({
    "class": _ctx.cx("content")
  }, _ctx.ptm("content")), [renderSlot(_ctx.$slots, "content")], 16), _ctx.$slots.footer ? (openBlock(), createElementBlock("div", mergeProps({
    key: 1,
    "class": _ctx.cx("footer")
  }, _ctx.ptm("footer")), [renderSlot(_ctx.$slots, "footer")], 16)) : createCommentVNode("", true)], 16)], 16);
}
__name(render$r, "render$r");
script$s.render = render$r;
const _withScopeId$h = /* @__PURE__ */ __name((n) => (pushScopeId("data-v-b87655d7"), n = n(), popScopeId(), n), "_withScopeId$h");
const _hoisted_1$G = { class: "no-results-placeholder" };
const _hoisted_2$v = { class: "flex flex-column align-items-center" };
const _sfc_main$A = /* @__PURE__ */ defineComponent({
  __name: "NoResultsPlaceholder",
  props: {
    icon: {},
    title: {},
    message: {},
    buttonLabel: {}
  },
  emits: ["action"],
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$G, [
        createVNode(unref(script$s), null, {
          content: withCtx(() => [
            createBaseVNode("div", _hoisted_2$v, [
              createBaseVNode("i", {
                class: normalizeClass(_ctx.icon),
                style: { "font-size": "3rem", "margin-bottom": "1rem" }
              }, null, 2),
              createBaseVNode("h3", null, toDisplayString$1(_ctx.title), 1),
              createBaseVNode("p", null, toDisplayString$1(_ctx.message), 1),
              _ctx.buttonLabel ? (openBlock(), createBlock(unref(script$J), {
                key: 0,
                label: _ctx.buttonLabel,
                onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("action")),
                class: "p-button-text"
              }, null, 8, ["label"])) : createCommentVNode("", true)
            ])
          ]),
          _: 1
        })
      ]);
    };
  }
});
const NoResultsPlaceholder = /* @__PURE__ */ _export_sfc(_sfc_main$A, [["__scopeId", "data-v-b87655d7"]]);
const _withScopeId$g = /* @__PURE__ */ __name((n) => (pushScopeId("data-v-593b49af"), n = n(), popScopeId(), n), "_withScopeId$g");
const _hoisted_1$F = { class: "settings-container" };
const _hoisted_2$u = { class: "settings-sidebar" };
const _hoisted_3$f = { class: "settings-content" };
const _hoisted_4$9 = { key: 0 };
const _sfc_main$z = /* @__PURE__ */ defineComponent({
  __name: "SettingDialogContent",
  setup(__props) {
    const settingStore = useSettingStore();
    const settingRoot = computed(() => settingStore.settingTree);
    const categories = computed(
      () => settingRoot.value.children || []
    );
    const activeCategory = ref(null);
    const searchResults = ref([]);
    watch(activeCategory, (newCategory, oldCategory) => {
      if (newCategory === null) {
        activeCategory.value = oldCategory;
      }
    });
    onMounted(() => {
      activeCategory.value = categories.value[0];
    });
    const sortedGroups = /* @__PURE__ */ __name((category) => {
      return [...category.children || []].sort(
        (a, b) => a.label.localeCompare(b.label)
      );
    }, "sortedGroups");
    const searchQuery = ref("");
    const searchInProgress = ref(false);
    watch(searchQuery, () => searchInProgress.value = true);
    const handleSearch = /* @__PURE__ */ __name((query) => {
      if (!query) {
        searchResults.value = [];
        return;
      }
      const allSettings = flattenTree(settingRoot.value);
      const filteredSettings = allSettings.filter(
        (setting) => setting.id.toLowerCase().includes(query.toLowerCase()) || setting.name.toLowerCase().includes(query.toLowerCase())
      );
      const groupedSettings = {};
      filteredSettings.forEach((setting) => {
        const groupLabel = setting.id.split(".")[1];
        if (!groupedSettings[groupLabel]) {
          groupedSettings[groupLabel] = [];
        }
        groupedSettings[groupLabel].push(setting);
      });
      searchResults.value = Object.entries(groupedSettings).map(
        ([label5, settings]) => ({
          label: label5,
          settings
        })
      );
      searchInProgress.value = false;
    }, "handleSearch");
    const inSearch = computed(
      () => searchQuery.value.length > 0 && !searchInProgress.value
    );
    const tabValue = computed(
      () => inSearch.value ? "Search Results" : activeCategory.value?.label
    );
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$F, [
        createBaseVNode("div", _hoisted_2$u, [
          createVNode(SearchBox, {
            class: "settings-search-box",
            modelValue: searchQuery.value,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => searchQuery.value = $event),
            onSearch: handleSearch,
            placeholder: _ctx.$t("searchSettings") + "..."
          }, null, 8, ["modelValue", "placeholder"]),
          createVNode(unref(script$L), {
            modelValue: activeCategory.value,
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => activeCategory.value = $event),
            options: categories.value,
            optionLabel: "label",
            scrollHeight: "100%",
            disabled: inSearch.value,
            pt: { root: { class: "border-none" } }
          }, null, 8, ["modelValue", "options", "disabled"])
        ]),
        createVNode(unref(script$F), { layout: "vertical" }),
        createBaseVNode("div", _hoisted_3$f, [
          createVNode(unref(script$I), { value: tabValue.value }, {
            default: withCtx(() => [
              createVNode(unref(script$H), { class: "settings-tab-panels" }, {
                default: withCtx(() => [
                  createVNode(unref(script$G), {
                    key: "search-results",
                    value: "Search Results"
                  }, {
                    default: withCtx(() => [
                      searchResults.value.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_4$9, [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(searchResults.value, (group, i2) => {
                          return openBlock(), createBlock(SettingGroup, {
                            key: group.label,
                            divider: i2 !== 0,
                            group
                          }, null, 8, ["divider", "group"]);
                        }), 128))
                      ])) : (openBlock(), createBlock(NoResultsPlaceholder, {
                        key: 1,
                        icon: "pi pi-search",
                        title: _ctx.$t("noResultsFound"),
                        message: _ctx.$t("searchFailedMessage")
                      }, null, 8, ["title", "message"]))
                    ]),
                    _: 1
                  }),
                  (openBlock(true), createElementBlock(Fragment, null, renderList(categories.value, (category) => {
                    return openBlock(), createBlock(unref(script$G), {
                      key: category.key,
                      value: category.label
                    }, {
                      default: withCtx(() => [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(sortedGroups(category), (group, i2) => {
                          return openBlock(), createBlock(SettingGroup, {
                            key: group.label,
                            divider: i2 !== 0,
                            group: {
                              label: group.label,
                              settings: unref(flattenTree)(group)
                            }
                          }, null, 8, ["divider", "group"]);
                        }), 128))
                      ]),
                      _: 2
                    }, 1032, ["value"]);
                  }), 128))
                ]),
                _: 1
              })
            ]),
            _: 1
          }, 8, ["value"])
        ])
      ]);
    };
  }
});
const SettingDialogContent = /* @__PURE__ */ _export_sfc(_sfc_main$z, [["__scopeId", "data-v-593b49af"]]);
const _withScopeId$f = /* @__PURE__ */ __name((n) => (pushScopeId("data-v-494412ee"), n = n(), popScopeId(), n), "_withScopeId$f");
const _hoisted_1$E = /* @__PURE__ */ _withScopeId$f(() => /* @__PURE__ */ createBaseVNode("i", { class: "pi pi-cog" }, null, -1));
const _sfc_main$y = /* @__PURE__ */ defineComponent({
  __name: "SettingDialogHeader",
  setup(__props) {
    const frontendVersion = "v" + window["__COMFYUI_FRONTEND_VERSION__"];
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createBaseVNode("h2", null, [
          _hoisted_1$E,
          createBaseVNode("span", null, toDisplayString$1(_ctx.$t("settings")), 1),
          createVNode(unref(script$w), {
            value: frontendVersion,
            severity: "secondary",
            class: "version-tag"
          })
        ])
      ]);
    };
  }
});
const SettingDialogHeader = /* @__PURE__ */ _export_sfc(_sfc_main$y, [["__scopeId", "data-v-494412ee"]]);
var isVue2$1 = false;
var isVue3$1 = true;
var Vue2$1 = void 0;
function install$1() {
}
__name(install$1, "install$1");
function set$2(target, key, val) {
  if (Array.isArray(target)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val;
  }
  target[key] = val;
  return val;
}
__name(set$2, "set$2");
function del$1(target, key) {
  if (Array.isArray(target)) {
    target.splice(key, 1);
    return;
  }
  delete target[key];
}
__name(del$1, "del$1");
function computedEager(fn, options3) {
  var _a;
  const result = shallowRef();
  watchEffect(() => {
    result.value = fn();
  }, {
    ...options3,
    flush: (_a = options3 == null ? void 0 : options3.flush) != null ? _a : "sync"
  });
  return readonly(result);
}
__name(computedEager, "computedEager");
function computedWithControl(source, fn) {
  let v2 = void 0;
  let track2;
  let trigger2;
  const dirty = ref(true);
  const update2 = /* @__PURE__ */ __name(() => {
    dirty.value = true;
    trigger2();
  }, "update");
  watch(source, update2, { flush: "sync" });
  const get2 = typeof fn === "function" ? fn : fn.get;
  const set2 = typeof fn === "function" ? void 0 : fn.set;
  const result = customRef((_track, _trigger) => {
    track2 = _track;
    trigger2 = _trigger;
    return {
      get() {
        if (dirty.value) {
          v2 = get2(v2);
          dirty.value = false;
        }
        track2();
        return v2;
      },
      set(v22) {
        set2 == null ? void 0 : set2(v22);
      }
    };
  });
  if (Object.isExtensible(result))
    result.trigger = update2;
  return result;
}
__name(computedWithControl, "computedWithControl");
function tryOnScopeDispose(fn) {
  if (getCurrentScope()) {
    onScopeDispose(fn);
    return true;
  }
  return false;
}
__name(tryOnScopeDispose, "tryOnScopeDispose");
function createEventHook() {
  const fns = /* @__PURE__ */ new Set();
  const off = /* @__PURE__ */ __name((fn) => {
    fns.delete(fn);
  }, "off");
  const on = /* @__PURE__ */ __name((fn) => {
    fns.add(fn);
    const offFn = /* @__PURE__ */ __name(() => off(fn), "offFn");
    tryOnScopeDispose(offFn);
    return {
      off: offFn
    };
  }, "on");
  const trigger2 = /* @__PURE__ */ __name((...args) => {
    return Promise.all(Array.from(fns).map((fn) => fn(...args)));
  }, "trigger");
  return {
    on,
    off,
    trigger: trigger2
  };
}
__name(createEventHook, "createEventHook");
function createGlobalState(stateFactory) {
  let initialized = false;
  let state;
  const scope = effectScope(true);
  return (...args) => {
    if (!initialized) {
      state = scope.run(() => stateFactory(...args));
      initialized = true;
    }
    return state;
  };
}
__name(createGlobalState, "createGlobalState");
const localProvidedStateMap = /* @__PURE__ */ new WeakMap();
const provideLocal = /* @__PURE__ */ __name((key, value3) => {
  var _a;
  const instance = (_a = getCurrentInstance()) == null ? void 0 : _a.proxy;
  if (instance == null)
    throw new Error("provideLocal must be called in setup");
  if (!localProvidedStateMap.has(instance))
    localProvidedStateMap.set(instance, /* @__PURE__ */ Object.create(null));
  const localProvidedState = localProvidedStateMap.get(instance);
  localProvidedState[key] = value3;
  provide(key, value3);
}, "provideLocal");
const injectLocal = /* @__PURE__ */ __name((...args) => {
  var _a;
  const key = args[0];
  const instance = (_a = getCurrentInstance()) == null ? void 0 : _a.proxy;
  if (instance == null)
    throw new Error("injectLocal must be called in setup");
  if (localProvidedStateMap.has(instance) && key in localProvidedStateMap.get(instance))
    return localProvidedStateMap.get(instance)[key];
  return inject(...args);
}, "injectLocal");
function createInjectionState(composable, options3) {
  const key = (options3 == null ? void 0 : options3.injectionKey) || Symbol(composable.name || "InjectionState");
  const defaultValue = options3 == null ? void 0 : options3.defaultValue;
  const useProvidingState = /* @__PURE__ */ __name((...args) => {
    const state = composable(...args);
    provideLocal(key, state);
    return state;
  }, "useProvidingState");
  const useInjectedState = /* @__PURE__ */ __name(() => injectLocal(key, defaultValue), "useInjectedState");
  return [useProvidingState, useInjectedState];
}
__name(createInjectionState, "createInjectionState");
function createSharedComposable(composable) {
  let subscribers = 0;
  let state;
  let scope;
  const dispose = /* @__PURE__ */ __name(() => {
    subscribers -= 1;
    if (scope && subscribers <= 0) {
      scope.stop();
      state = void 0;
      scope = void 0;
    }
  }, "dispose");
  return (...args) => {
    subscribers += 1;
    if (!state) {
      scope = effectScope(true);
      state = scope.run(() => composable(...args));
    }
    tryOnScopeDispose(dispose);
    return state;
  };
}
__name(createSharedComposable, "createSharedComposable");
function extendRef(ref2, extend4, { enumerable = false, unwrap = true } = {}) {
  if (!isVue3$1 && !version.startsWith("2.7.")) {
    if (false)
      throw new Error("[VueUse] extendRef only works in Vue 2.7 or above.");
    return;
  }
  for (const [key, value3] of Object.entries(extend4)) {
    if (key === "value")
      continue;
    if (isRef(value3) && unwrap) {
      Object.defineProperty(ref2, key, {
        get() {
          return value3.value;
        },
        set(v2) {
          value3.value = v2;
        },
        enumerable
      });
    } else {
      Object.defineProperty(ref2, key, { value: value3, enumerable });
    }
  }
  return ref2;
}
__name(extendRef, "extendRef");
function get$1(obj, key) {
  if (key == null)
    return unref(obj);
  return unref(obj)[key];
}
__name(get$1, "get$1");
function isDefined$1(v2) {
  return unref(v2) != null;
}
__name(isDefined$1, "isDefined$1");
function makeDestructurable(obj, arr) {
  if (typeof Symbol !== "undefined") {
    const clone2 = { ...obj };
    Object.defineProperty(clone2, Symbol.iterator, {
      enumerable: false,
      value() {
        let index2 = 0;
        return {
          next: /* @__PURE__ */ __name(() => ({
            value: arr[index2++],
            done: index2 > arr.length
          }), "next")
        };
      }
    });
    return clone2;
  } else {
    return Object.assign([...arr], obj);
  }
}
__name(makeDestructurable, "makeDestructurable");
function toValue(r) {
  return typeof r === "function" ? r() : unref(r);
}
__name(toValue, "toValue");
const resolveUnref = toValue;
function reactify(fn, options3) {
  const unrefFn = (options3 == null ? void 0 : options3.computedGetter) === false ? unref : toValue;
  return function(...args) {
    return computed(() => fn.apply(this, args.map((i2) => unrefFn(i2))));
  };
}
__name(reactify, "reactify");
function reactifyObject(obj, optionsOrKeys = {}) {
  let keys2 = [];
  let options3;
  if (Array.isArray(optionsOrKeys)) {
    keys2 = optionsOrKeys;
  } else {
    options3 = optionsOrKeys;
    const { includeOwnProperties = true } = optionsOrKeys;
    keys2.push(...Object.keys(obj));
    if (includeOwnProperties)
      keys2.push(...Object.getOwnPropertyNames(obj));
  }
  return Object.fromEntries(
    keys2.map((key) => {
      const value3 = obj[key];
      return [
        key,
        typeof value3 === "function" ? reactify(value3.bind(obj), options3) : value3
      ];
    })
  );
}
__name(reactifyObject, "reactifyObject");
function toReactive(objectRef) {
  if (!isRef(objectRef))
    return reactive(objectRef);
  const proxy = new Proxy({}, {
    get(_2, p2, receiver) {
      return unref(Reflect.get(objectRef.value, p2, receiver));
    },
    set(_2, p2, value3) {
      if (isRef(objectRef.value[p2]) && !isRef(value3))
        objectRef.value[p2].value = value3;
      else
        objectRef.value[p2] = value3;
      return true;
    },
    deleteProperty(_2, p2) {
      return Reflect.deleteProperty(objectRef.value, p2);
    },
    has(_2, p2) {
      return Reflect.has(objectRef.value, p2);
    },
    ownKeys() {
      return Object.keys(objectRef.value);
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: true,
        configurable: true
      };
    }
  });
  return reactive(proxy);
}
__name(toReactive, "toReactive");
function reactiveComputed(fn) {
  return toReactive(computed(fn));
}
__name(reactiveComputed, "reactiveComputed");
function reactiveOmit(obj, ...keys2) {
  const flatKeys = keys2.flat();
  const predicate = flatKeys[0];
  return reactiveComputed(() => typeof predicate === "function" ? Object.fromEntries(Object.entries(toRefs$1(obj)).filter(([k, v2]) => !predicate(toValue(v2), k))) : Object.fromEntries(Object.entries(toRefs$1(obj)).filter((e) => !flatKeys.includes(e[0]))));
}
__name(reactiveOmit, "reactiveOmit");
const isClient = typeof window !== "undefined" && typeof document !== "undefined";
const isWorker = typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope;
const isDef = /* @__PURE__ */ __name((val) => typeof val !== "undefined", "isDef");
const notNullish = /* @__PURE__ */ __name((val) => val != null, "notNullish");
const assert = /* @__PURE__ */ __name((condition, ...infos) => {
  if (!condition)
    console.warn(...infos);
}, "assert");
const toString$1 = Object.prototype.toString;
const isObject$3 = /* @__PURE__ */ __name((val) => toString$1.call(val) === "[object Object]", "isObject$3");
const now = /* @__PURE__ */ __name(() => Date.now(), "now");
const timestamp = /* @__PURE__ */ __name(() => +Date.now(), "timestamp");
const clamp = /* @__PURE__ */ __name((n, min, max) => Math.min(max, Math.max(min, n)), "clamp");
const noop = /* @__PURE__ */ __name(() => {
}, "noop");
const rand = /* @__PURE__ */ __name((min, max) => {
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor(Math.random() * (max - min + 1)) + min;
}, "rand");
const hasOwn$2 = /* @__PURE__ */ __name((val, key) => Object.prototype.hasOwnProperty.call(val, key), "hasOwn$2");
const isIOS = /* @__PURE__ */ getIsIOS();
function getIsIOS() {
  var _a, _b;
  return isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((_b = window == null ? void 0 : window.navigator) == null ? void 0 : _b.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
}
__name(getIsIOS, "getIsIOS");
function createFilterWrapper(filter4, fn) {
  function wrapper(...args) {
    return new Promise((resolve8, reject2) => {
      Promise.resolve(filter4(() => fn.apply(this, args), { fn, thisArg: this, args })).then(resolve8).catch(reject2);
    });
  }
  __name(wrapper, "wrapper");
  return wrapper;
}
__name(createFilterWrapper, "createFilterWrapper");
const bypassFilter = /* @__PURE__ */ __name((invoke2) => {
  return invoke2();
}, "bypassFilter");
function debounceFilter(ms, options3 = {}) {
  let timer;
  let maxTimer;
  let lastRejector = noop;
  const _clearTimeout = /* @__PURE__ */ __name((timer2) => {
    clearTimeout(timer2);
    lastRejector();
    lastRejector = noop;
  }, "_clearTimeout");
  const filter4 = /* @__PURE__ */ __name((invoke2) => {
    const duration = toValue(ms);
    const maxDuration = toValue(options3.maxWait);
    if (timer)
      _clearTimeout(timer);
    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
      if (maxTimer) {
        _clearTimeout(maxTimer);
        maxTimer = null;
      }
      return Promise.resolve(invoke2());
    }
    return new Promise((resolve8, reject2) => {
      lastRejector = options3.rejectOnCancel ? reject2 : resolve8;
      if (maxDuration && !maxTimer) {
        maxTimer = setTimeout(() => {
          if (timer)
            _clearTimeout(timer);
          maxTimer = null;
          resolve8(invoke2());
        }, maxDuration);
      }
      timer = setTimeout(() => {
        if (maxTimer)
          _clearTimeout(maxTimer);
        maxTimer = null;
        resolve8(invoke2());
      }, duration);
    });
  }, "filter");
  return filter4;
}
__name(debounceFilter, "debounceFilter");
function throttleFilter(...args) {
  let lastExec = 0;
  let timer;
  let isLeading = true;
  let lastRejector = noop;
  let lastValue;
  let ms;
  let trailing;
  let leading;
  let rejectOnCancel;
  if (!isRef(args[0]) && typeof args[0] === "object")
    ({ delay: ms, trailing = true, leading = true, rejectOnCancel = false } = args[0]);
  else
    [ms, trailing = true, leading = true, rejectOnCancel = false] = args;
  const clear3 = /* @__PURE__ */ __name(() => {
    if (timer) {
      clearTimeout(timer);
      timer = void 0;
      lastRejector();
      lastRejector = noop;
    }
  }, "clear");
  const filter4 = /* @__PURE__ */ __name((_invoke) => {
    const duration = toValue(ms);
    const elapsed = Date.now() - lastExec;
    const invoke2 = /* @__PURE__ */ __name(() => {
      return lastValue = _invoke();
    }, "invoke2");
    clear3();
    if (duration <= 0) {
      lastExec = Date.now();
      return invoke2();
    }
    if (elapsed > duration && (leading || !isLeading)) {
      lastExec = Date.now();
      invoke2();
    } else if (trailing) {
      lastValue = new Promise((resolve8, reject2) => {
        lastRejector = rejectOnCancel ? reject2 : resolve8;
        timer = setTimeout(() => {
          lastExec = Date.now();
          isLeading = true;
          resolve8(invoke2());
          clear3();
        }, Math.max(0, duration - elapsed));
      });
    }
    if (!leading && !timer)
      timer = setTimeout(() => isLeading = true, duration);
    isLeading = false;
    return lastValue;
  }, "filter");
  return filter4;
}
__name(throttleFilter, "throttleFilter");
function pausableFilter(extendFilter = bypassFilter) {
  const isActive = ref(true);
  function pause() {
    isActive.value = false;
  }
  __name(pause, "pause");
  function resume() {
    isActive.value = true;
  }
  __name(resume, "resume");
  const eventFilter = /* @__PURE__ */ __name((...args) => {
    if (isActive.value)
      extendFilter(...args);
  }, "eventFilter");
  return { isActive: readonly(isActive), pause, resume, eventFilter };
}
__name(pausableFilter, "pausableFilter");
const directiveHooks = {
  mounted: isVue3$1 ? "mounted" : "inserted",
  updated: isVue3$1 ? "updated" : "componentUpdated",
  unmounted: isVue3$1 ? "unmounted" : "unbind"
};
function cacheStringFunction(fn) {
  const cache2 = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache2[str];
    return hit || (cache2[str] = fn(str));
  };
}
__name(cacheStringFunction, "cacheStringFunction");
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_2, c) => c ? c.toUpperCase() : "");
});
function promiseTimeout(ms, throwOnTimeout = false, reason = "Timeout") {
  return new Promise((resolve8, reject2) => {
    if (throwOnTimeout)
      setTimeout(() => reject2(reason), ms);
    else
      setTimeout(resolve8, ms);
  });
}
__name(promiseTimeout, "promiseTimeout");
function identity(arg) {
  return arg;
}
__name(identity, "identity");
function createSingletonPromise(fn) {
  let _promise;
  function wrapper() {
    if (!_promise)
      _promise = fn();
    return _promise;
  }
  __name(wrapper, "wrapper");
  wrapper.reset = async () => {
    const _prev = _promise;
    _promise = void 0;
    if (_prev)
      await _prev;
  };
  return wrapper;
}
__name(createSingletonPromise, "createSingletonPromise");
function invoke(fn) {
  return fn();
}
__name(invoke, "invoke");
function containsProp(obj, ...props) {
  return props.some((k) => k in obj);
}
__name(containsProp, "containsProp");
function increaseWithUnit(target, delta2) {
  var _a;
  if (typeof target === "number")
    return target + delta2;
  const value3 = ((_a = target.match(/^-?\d+\.?\d*/)) == null ? void 0 : _a[0]) || "";
  const unit = target.slice(value3.length);
  const result = Number.parseFloat(value3) + delta2;
  if (Number.isNaN(result))
    return target;
  return result + unit;
}
__name(increaseWithUnit, "increaseWithUnit");
function objectPick(obj, keys2, omitUndefined = false) {
  return keys2.reduce((n, k) => {
    if (k in obj) {
      if (!omitUndefined || obj[k] !== void 0)
        n[k] = obj[k];
    }
    return n;
  }, {});
}
__name(objectPick, "objectPick");
function objectOmit(obj, keys2, omitUndefined = false) {
  return Object.fromEntries(Object.entries(obj).filter(([key, value3]) => {
    return (!omitUndefined || value3 !== void 0) && !keys2.includes(key);
  }));
}
__name(objectOmit, "objectOmit");
function objectEntries(obj) {
  return Object.entries(obj);
}
__name(objectEntries, "objectEntries");
function getLifeCycleTarget(target) {
  return target || getCurrentInstance();
}
__name(getLifeCycleTarget, "getLifeCycleTarget");
function toRef(...args) {
  if (args.length !== 1)
    return toRef$1(...args);
  const r = args[0];
  return typeof r === "function" ? readonly(customRef(() => ({ get: r, set: noop }))) : ref(r);
}
__name(toRef, "toRef");
const resolveRef = toRef;
function reactivePick(obj, ...keys2) {
  const flatKeys = keys2.flat();
  const predicate = flatKeys[0];
  return reactiveComputed(() => typeof predicate === "function" ? Object.fromEntries(Object.entries(toRefs$1(obj)).filter(([k, v2]) => predicate(toValue(v2), k))) : Object.fromEntries(flatKeys.map((k) => [k, toRef(obj, k)])));
}
__name(reactivePick, "reactivePick");
function refAutoReset(defaultValue, afterMs = 1e4) {
  return customRef((track2, trigger2) => {
    let value3 = toValue(defaultValue);
    let timer;
    const resetAfter = /* @__PURE__ */ __name(() => setTimeout(() => {
      value3 = toValue(defaultValue);
      trigger2();
    }, toValue(afterMs)), "resetAfter");
    tryOnScopeDispose(() => {
      clearTimeout(timer);
    });
    return {
      get() {
        track2();
        return value3;
      },
      set(newValue) {
        value3 = newValue;
        trigger2();
        clearTimeout(timer);
        timer = resetAfter();
      }
    };
  });
}
__name(refAutoReset, "refAutoReset");
function useDebounceFn(fn, ms = 200, options3 = {}) {
  return createFilterWrapper(
    debounceFilter(ms, options3),
    fn
  );
}
__name(useDebounceFn, "useDebounceFn");
function refDebounced(value3, ms = 200, options3 = {}) {
  const debounced = ref(value3.value);
  const updater = useDebounceFn(() => {
    debounced.value = value3.value;
  }, ms, options3);
  watch(value3, () => updater());
  return debounced;
}
__name(refDebounced, "refDebounced");
function refDefault(source, defaultValue) {
  return computed({
    get() {
      var _a;
      return (_a = source.value) != null ? _a : defaultValue;
    },
    set(value3) {
      source.value = value3;
    }
  });
}
__name(refDefault, "refDefault");
function useThrottleFn(fn, ms = 200, trailing = false, leading = true, rejectOnCancel = false) {
  return createFilterWrapper(
    throttleFilter(ms, trailing, leading, rejectOnCancel),
    fn
  );
}
__name(useThrottleFn, "useThrottleFn");
function refThrottled(value3, delay = 200, trailing = true, leading = true) {
  if (delay <= 0)
    return value3;
  const throttled = ref(value3.value);
  const updater = useThrottleFn(() => {
    throttled.value = value3.value;
  }, delay, trailing, leading);
  watch(value3, () => updater());
  return throttled;
}
__name(refThrottled, "refThrottled");
function refWithControl(initial, options3 = {}) {
  let source = initial;
  let track2;
  let trigger2;
  const ref2 = customRef((_track, _trigger) => {
    track2 = _track;
    trigger2 = _trigger;
    return {
      get() {
        return get2();
      },
      set(v2) {
        set2(v2);
      }
    };
  });
  function get2(tracking = true) {
    if (tracking)
      track2();
    return source;
  }
  __name(get2, "get2");
  function set2(value3, triggering = true) {
    var _a, _b;
    if (value3 === source)
      return;
    const old = source;
    if (((_a = options3.onBeforeChange) == null ? void 0 : _a.call(options3, value3, old)) === false)
      return;
    source = value3;
    (_b = options3.onChanged) == null ? void 0 : _b.call(options3, value3, old);
    if (triggering)
      trigger2();
  }
  __name(set2, "set2");
  const untrackedGet = /* @__PURE__ */ __name(() => get2(false), "untrackedGet");
  const silentSet = /* @__PURE__ */ __name((v2) => set2(v2, false), "silentSet");
  const peek = /* @__PURE__ */ __name(() => get2(false), "peek");
  const lay = /* @__PURE__ */ __name((v2) => set2(v2, false), "lay");
  return extendRef(
    ref2,
    {
      get: get2,
      set: set2,
      untrackedGet,
      silentSet,
      peek,
      lay
    },
    { enumerable: true }
  );
}
__name(refWithControl, "refWithControl");
const controlledRef = refWithControl;
function set$1(...args) {
  if (args.length === 2) {
    const [ref2, value3] = args;
    ref2.value = value3;
  }
  if (args.length === 3) {
    if (isVue2$1) {
      set$2(...args);
    } else {
      const [target, key, value3] = args;
      target[key] = value3;
    }
  }
}
__name(set$1, "set$1");
function watchWithFilter(source, cb, options3 = {}) {
  const {
    eventFilter = bypassFilter,
    ...watchOptions
  } = options3;
  return watch(
    source,
    createFilterWrapper(
      eventFilter,
      cb
    ),
    watchOptions
  );
}
__name(watchWithFilter, "watchWithFilter");
function watchPausable(source, cb, options3 = {}) {
  const {
    eventFilter: filter4,
    ...watchOptions
  } = options3;
  const { eventFilter, pause, resume, isActive } = pausableFilter(filter4);
  const stop2 = watchWithFilter(
    source,
    cb,
    {
      ...watchOptions,
      eventFilter
    }
  );
  return { stop: stop2, pause, resume, isActive };
}
__name(watchPausable, "watchPausable");
function syncRef(left, right, ...[options3]) {
  const {
    flush = "sync",
    deep = false,
    immediate = true,
    direction = "both",
    transform: transform2 = {}
  } = options3 || {};
  const watchers = [];
  const transformLTR = "ltr" in transform2 && transform2.ltr || ((v2) => v2);
  const transformRTL = "rtl" in transform2 && transform2.rtl || ((v2) => v2);
  if (direction === "both" || direction === "ltr") {
    watchers.push(watchPausable(
      left,
      (newValue) => {
        watchers.forEach((w2) => w2.pause());
        right.value = transformLTR(newValue);
        watchers.forEach((w2) => w2.resume());
      },
      { flush, deep, immediate }
    ));
  }
  if (direction === "both" || direction === "rtl") {
    watchers.push(watchPausable(
      right,
      (newValue) => {
        watchers.forEach((w2) => w2.pause());
        left.value = transformRTL(newValue);
        watchers.forEach((w2) => w2.resume());
      },
      { flush, deep, immediate }
    ));
  }
  const stop2 = /* @__PURE__ */ __name(() => {
    watchers.forEach((w2) => w2.stop());
  }, "stop");
  return stop2;
}
__name(syncRef, "syncRef");
function syncRefs(source, targets, options3 = {}) {
  const {
    flush = "sync",
    deep = false,
    immediate = true
  } = options3;
  if (!Array.isArray(targets))
    targets = [targets];
  return watch(
    source,
    (newValue) => targets.forEach((target) => target.value = newValue),
    { flush, deep, immediate }
  );
}
__name(syncRefs, "syncRefs");
function toRefs(objectRef, options3 = {}) {
  if (!isRef(objectRef))
    return toRefs$1(objectRef);
  const result = Array.isArray(objectRef.value) ? Array.from({ length: objectRef.value.length }) : {};
  for (const key in objectRef.value) {
    result[key] = customRef(() => ({
      get() {
        return objectRef.value[key];
      },
      set(v2) {
        var _a;
        const replaceRef = (_a = toValue(options3.replaceRef)) != null ? _a : true;
        if (replaceRef) {
          if (Array.isArray(objectRef.value)) {
            const copy = [...objectRef.value];
            copy[key] = v2;
            objectRef.value = copy;
          } else {
            const newObject = { ...objectRef.value, [key]: v2 };
            Object.setPrototypeOf(newObject, Object.getPrototypeOf(objectRef.value));
            objectRef.value = newObject;
          }
        } else {
          objectRef.value[key] = v2;
        }
      }
    }));
  }
  return result;
}
__name(toRefs, "toRefs");
function tryOnBeforeMount(fn, sync = true, target) {
  const instance = getLifeCycleTarget(target);
  if (instance)
    onBeforeMount(fn, target);
  else if (sync)
    fn();
  else
    nextTick(fn);
}
__name(tryOnBeforeMount, "tryOnBeforeMount");
function tryOnBeforeUnmount(fn, target) {
  const instance = getLifeCycleTarget(target);
  if (instance)
    onBeforeUnmount(fn, target);
}
__name(tryOnBeforeUnmount, "tryOnBeforeUnmount");
function tryOnMounted(fn, sync = true, target) {
  const instance = getLifeCycleTarget();
  if (instance)
    onMounted(fn, target);
  else if (sync)
    fn();
  else
    nextTick(fn);
}
__name(tryOnMounted, "tryOnMounted");
function tryOnUnmounted(fn, target) {
  const instance = getLifeCycleTarget(target);
  if (instance)
    onUnmounted(fn, target);
}
__name(tryOnUnmounted, "tryOnUnmounted");
function createUntil(r, isNot = false) {
  function toMatch(condition, { flush = "sync", deep = false, timeout, throwOnTimeout } = {}) {
    let stop2 = null;
    const watcher = new Promise((resolve8) => {
      stop2 = watch(
        r,
        (v2) => {
          if (condition(v2) !== isNot) {
            if (stop2)
              stop2();
            else
              nextTick(() => stop2 == null ? void 0 : stop2());
            resolve8(v2);
          }
        },
        {
          flush,
          deep,
          immediate: true
        }
      );
    });
    const promises = [watcher];
    if (timeout != null) {
      promises.push(
        promiseTimeout(timeout, throwOnTimeout).then(() => toValue(r)).finally(() => stop2 == null ? void 0 : stop2())
      );
    }
    return Promise.race(promises);
  }
  __name(toMatch, "toMatch");
  function toBe(value3, options3) {
    if (!isRef(value3))
      return toMatch((v2) => v2 === value3, options3);
    const { flush = "sync", deep = false, timeout, throwOnTimeout } = options3 != null ? options3 : {};
    let stop2 = null;
    const watcher = new Promise((resolve8) => {
      stop2 = watch(
        [r, value3],
        ([v1, v2]) => {
          if (isNot !== (v1 === v2)) {
            if (stop2)
              stop2();
            else
              nextTick(() => stop2 == null ? void 0 : stop2());
            resolve8(v1);
          }
        },
        {
          flush,
          deep,
          immediate: true
        }
      );
    });
    const promises = [watcher];
    if (timeout != null) {
      promises.push(
        promiseTimeout(timeout, throwOnTimeout).then(() => toValue(r)).finally(() => {
          stop2 == null ? void 0 : stop2();
          return toValue(r);
        })
      );
    }
    return Promise.race(promises);
  }
  __name(toBe, "toBe");
  function toBeTruthy(options3) {
    return toMatch((v2) => Boolean(v2), options3);
  }
  __name(toBeTruthy, "toBeTruthy");
  function toBeNull(options3) {
    return toBe(null, options3);
  }
  __name(toBeNull, "toBeNull");
  function toBeUndefined(options3) {
    return toBe(void 0, options3);
  }
  __name(toBeUndefined, "toBeUndefined");
  function toBeNaN(options3) {
    return toMatch(Number.isNaN, options3);
  }
  __name(toBeNaN, "toBeNaN");
  function toContains(value3, options3) {
    return toMatch((v2) => {
      const array = Array.from(v2);
      return array.includes(value3) || array.includes(toValue(value3));
    }, options3);
  }
  __name(toContains, "toContains");
  function changed(options3) {
    return changedTimes(1, options3);
  }
  __name(changed, "changed");
  function changedTimes(n = 1, options3) {
    let count = -1;
    return toMatch(() => {
      count += 1;
      return count >= n;
    }, options3);
  }
  __name(changedTimes, "changedTimes");
  if (Array.isArray(toValue(r))) {
    const instance = {
      toMatch,
      toContains,
      changed,
      changedTimes,
      get not() {
        return createUntil(r, !isNot);
      }
    };
    return instance;
  } else {
    const instance = {
      toMatch,
      toBe,
      toBeTruthy,
      toBeNull,
      toBeNaN,
      toBeUndefined,
      changed,
      changedTimes,
      get not() {
        return createUntil(r, !isNot);
      }
    };
    return instance;
  }
}
__name(createUntil, "createUntil");
function until(r) {
  return createUntil(r);
}
__name(until, "until");
function defaultComparator(value3, othVal) {
  return value3 === othVal;
}
__name(defaultComparator, "defaultComparator");
function useArrayDifference(...args) {
  var _a;
  const list = args[0];
  const values2 = args[1];
  let compareFn = (_a = args[2]) != null ? _a : defaultComparator;
  if (typeof compareFn === "string") {
    const key = compareFn;
    compareFn = /* @__PURE__ */ __name((value3, othVal) => value3[key] === othVal[key], "compareFn");
  }
  return computed(() => toValue(list).filter((x2) => toValue(values2).findIndex((y2) => compareFn(x2, y2)) === -1));
}
__name(useArrayDifference, "useArrayDifference");
function useArrayEvery(list, fn) {
  return computed(() => toValue(list).every((element, index2, array) => fn(toValue(element), index2, array)));
}
__name(useArrayEvery, "useArrayEvery");
function useArrayFilter(list, fn) {
  return computed(() => toValue(list).map((i2) => toValue(i2)).filter(fn));
}
__name(useArrayFilter, "useArrayFilter");
function useArrayFind(list, fn) {
  return computed(() => toValue(
    toValue(list).find((element, index2, array) => fn(toValue(element), index2, array))
  ));
}
__name(useArrayFind, "useArrayFind");
function useArrayFindIndex(list, fn) {
  return computed(() => toValue(list).findIndex((element, index2, array) => fn(toValue(element), index2, array)));
}
__name(useArrayFindIndex, "useArrayFindIndex");
function findLast(arr, cb) {
  let index2 = arr.length;
  while (index2-- > 0) {
    if (cb(arr[index2], index2, arr))
      return arr[index2];
  }
  return void 0;
}
__name(findLast, "findLast");
function useArrayFindLast(list, fn) {
  return computed(() => toValue(
    !Array.prototype.findLast ? findLast(toValue(list), (element, index2, array) => fn(toValue(element), index2, array)) : toValue(list).findLast((element, index2, array) => fn(toValue(element), index2, array))
  ));
}
__name(useArrayFindLast, "useArrayFindLast");
function isArrayIncludesOptions(obj) {
  return isObject$3(obj) && containsProp(obj, "formIndex", "comparator");
}
__name(isArrayIncludesOptions, "isArrayIncludesOptions");
function useArrayIncludes(...args) {
  var _a;
  const list = args[0];
  const value3 = args[1];
  let comparator2 = args[2];
  let formIndex = 0;
  if (isArrayIncludesOptions(comparator2)) {
    formIndex = (_a = comparator2.fromIndex) != null ? _a : 0;
    comparator2 = comparator2.comparator;
  }
  if (typeof comparator2 === "string") {
    const key = comparator2;
    comparator2 = /* @__PURE__ */ __name((element, value22) => element[key] === toValue(value22), "comparator");
  }
  comparator2 = comparator2 != null ? comparator2 : (element, value22) => element === toValue(value22);
  return computed(() => toValue(list).slice(formIndex).some((element, index2, array) => comparator2(
    toValue(element),
    toValue(value3),
    index2,
    toValue(array)
  )));
}
__name(useArrayIncludes, "useArrayIncludes");
function useArrayJoin(list, separator) {
  return computed(() => toValue(list).map((i2) => toValue(i2)).join(toValue(separator)));
}
__name(useArrayJoin, "useArrayJoin");
function useArrayMap(list, fn) {
  return computed(() => toValue(list).map((i2) => toValue(i2)).map(fn));
}
__name(useArrayMap, "useArrayMap");
function useArrayReduce(list, reducer, ...args) {
  const reduceCallback = /* @__PURE__ */ __name((sum, value3, index2) => reducer(toValue(sum), toValue(value3), index2), "reduceCallback");
  return computed(() => {
    const resolved = toValue(list);
    return args.length ? resolved.reduce(reduceCallback, toValue(args[0])) : resolved.reduce(reduceCallback);
  });
}
__name(useArrayReduce, "useArrayReduce");
function useArraySome(list, fn) {
  return computed(() => toValue(list).some((element, index2, array) => fn(toValue(element), index2, array)));
}
__name(useArraySome, "useArraySome");
function uniq(array) {
  return Array.from(new Set(array));
}
__name(uniq, "uniq");
function uniqueElementsBy(array, fn) {
  return array.reduce((acc, v2) => {
    if (!acc.some((x2) => fn(v2, x2, array)))
      acc.push(v2);
    return acc;
  }, []);
}
__name(uniqueElementsBy, "uniqueElementsBy");
function useArrayUnique(list, compareFn) {
  return computed(() => {
    const resolvedList = toValue(list).map((element) => toValue(element));
    return compareFn ? uniqueElementsBy(resolvedList, compareFn) : uniq(resolvedList);
  });
}
__name(useArrayUnique, "useArrayUnique");
function useCounter(initialValue = 0, options3 = {}) {
  let _initialValue = unref(initialValue);
  const count = ref(initialValue);
  const {
    max = Number.POSITIVE_INFINITY,
    min = Number.NEGATIVE_INFINITY
  } = options3;
  const inc2 = /* @__PURE__ */ __name((delta2 = 1) => count.value = Math.max(Math.min(max, count.value + delta2), min), "inc");
  const dec = /* @__PURE__ */ __name((delta2 = 1) => count.value = Math.min(Math.max(min, count.value - delta2), max), "dec");
  const get2 = /* @__PURE__ */ __name(() => count.value, "get2");
  const set2 = /* @__PURE__ */ __name((val) => count.value = Math.max(min, Math.min(max, val)), "set2");
  const reset = /* @__PURE__ */ __name((val = _initialValue) => {
    _initialValue = val;
    return set2(val);
  }, "reset");
  return { count, inc: inc2, dec, get: get2, set: set2, reset };
}
__name(useCounter, "useCounter");
const REGEX_PARSE = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[T\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/i;
const REGEX_FORMAT = /[YMDHhms]o|\[([^\]]+)\]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a{1,2}|A{1,2}|m{1,2}|s{1,2}|Z{1,2}|SSS/g;
function defaultMeridiem(hours, minutes, isLowercase, hasPeriod) {
  let m = hours < 12 ? "AM" : "PM";
  if (hasPeriod)
    m = m.split("").reduce((acc, curr) => acc += `${curr}.`, "");
  return isLowercase ? m.toLowerCase() : m;
}
__name(defaultMeridiem, "defaultMeridiem");
function formatOrdinal(num) {
  const suffixes = ["th", "st", "nd", "rd"];
  const v2 = num % 100;
  return num + (suffixes[(v2 - 20) % 10] || suffixes[v2] || suffixes[0]);
}
__name(formatOrdinal, "formatOrdinal");
function formatDate$1(date, formatStr, options3 = {}) {
  var _a;
  const years = date.getFullYear();
  const month = date.getMonth();
  const days = date.getDate();
  const hours = date.getHours();
  const minutes = date.getMinutes();
  const seconds = date.getSeconds();
  const milliseconds = date.getMilliseconds();
  const day = date.getDay();
  const meridiem = (_a = options3.customMeridiem) != null ? _a : defaultMeridiem;
  const matches2 = {
    Yo: /* @__PURE__ */ __name(() => formatOrdinal(years), "Yo"),
    YY: /* @__PURE__ */ __name(() => String(years).slice(-2), "YY"),
    YYYY: /* @__PURE__ */ __name(() => years, "YYYY"),
    M: /* @__PURE__ */ __name(() => month + 1, "M"),
    Mo: /* @__PURE__ */ __name(() => formatOrdinal(month + 1), "Mo"),
    MM: /* @__PURE__ */ __name(() => `${month + 1}`.padStart(2, "0"), "MM"),
    MMM: /* @__PURE__ */ __name(() => date.toLocaleDateString(toValue(options3.locales), { month: "short" }), "MMM"),
    MMMM: /* @__PURE__ */ __name(() => date.toLocaleDateString(toValue(options3.locales), { month: "long" }), "MMMM"),
    D: /* @__PURE__ */ __name(() => String(days), "D"),
    Do: /* @__PURE__ */ __name(() => formatOrdinal(days), "Do"),
    DD: /* @__PURE__ */ __name(() => `${days}`.padStart(2, "0"), "DD"),
    H: /* @__PURE__ */ __name(() => String(hours), "H"),
    Ho: /* @__PURE__ */ __name(() => formatOrdinal(hours), "Ho"),
    HH: /* @__PURE__ */ __name(() => `${hours}`.padStart(2, "0"), "HH"),
    h: /* @__PURE__ */ __name(() => `${hours % 12 || 12}`.padStart(1, "0"), "h"),
    ho: /* @__PURE__ */ __name(() => formatOrdinal(hours % 12 || 12), "ho"),
    hh: /* @__PURE__ */ __name(() => `${hours % 12 || 12}`.padStart(2, "0"), "hh"),
    m: /* @__PURE__ */ __name(() => String(minutes), "m"),
    mo: /* @__PURE__ */ __name(() => formatOrdinal(minutes), "mo"),
    mm: /* @__PURE__ */ __name(() => `${minutes}`.padStart(2, "0"), "mm"),
    s: /* @__PURE__ */ __name(() => String(seconds), "s"),
    so: /* @__PURE__ */ __name(() => formatOrdinal(seconds), "so"),
    ss: /* @__PURE__ */ __name(() => `${seconds}`.padStart(2, "0"), "ss"),
    SSS: /* @__PURE__ */ __name(() => `${milliseconds}`.padStart(3, "0"), "SSS"),
    d: /* @__PURE__ */ __name(() => day, "d"),
    dd: /* @__PURE__ */ __name(() => date.toLocaleDateString(toValue(options3.locales), { weekday: "narrow" }), "dd"),
    ddd: /* @__PURE__ */ __name(() => date.toLocaleDateString(toValue(options3.locales), { weekday: "short" }), "ddd"),
    dddd: /* @__PURE__ */ __name(() => date.toLocaleDateString(toValue(options3.locales), { weekday: "long" }), "dddd"),
    A: /* @__PURE__ */ __name(() => meridiem(hours, minutes), "A"),
    AA: /* @__PURE__ */ __name(() => meridiem(hours, minutes, false, true), "AA"),
    a: /* @__PURE__ */ __name(() => meridiem(hours, minutes, true), "a"),
    aa: /* @__PURE__ */ __name(() => meridiem(hours, minutes, true, true), "aa")
  };
  return formatStr.replace(REGEX_FORMAT, (match, $1) => {
    var _a2, _b;
    return (_b = $1 != null ? $1 : (_a2 = matches2[match]) == null ? void 0 : _a2.call(matches2)) != null ? _b : match;
  });
}
__name(formatDate$1, "formatDate$1");
function normalizeDate(date) {
  if (date === null)
    return new Date(Number.NaN);
  if (date === void 0)
    return /* @__PURE__ */ new Date();
  if (date instanceof Date)
    return new Date(date);
  if (typeof date === "string" && !/Z$/i.test(date)) {
    const d = date.match(REGEX_PARSE);
    if (d) {
      const m = d[2] - 1 || 0;
      const ms = (d[7] || "0").substring(0, 3);
      return new Date(d[1], m, d[3] || 1, d[4] || 0, d[5] || 0, d[6] || 0, ms);
    }
  }
  return new Date(date);
}
__name(normalizeDate, "normalizeDate");
function useDateFormat(date, formatStr = "HH:mm:ss", options3 = {}) {
  return computed(() => formatDate$1(normalizeDate(toValue(date)), toValue(formatStr), options3));
}
__name(useDateFormat, "useDateFormat");
function useIntervalFn(cb, interval = 1e3, options3 = {}) {
  const {
    immediate = true,
    immediateCallback = false
  } = options3;
  let timer = null;
  const isActive = ref(false);
  function clean() {
    if (timer) {
      clearInterval(timer);
      timer = null;
    }
  }
  __name(clean, "clean");
  function pause() {
    isActive.value = false;
    clean();
  }
  __name(pause, "pause");
  function resume() {
    const intervalValue = toValue(interval);
    if (intervalValue <= 0)
      return;
    isActive.value = true;
    if (immediateCallback)
      cb();
    clean();
    timer = setInterval(cb, intervalValue);
  }
  __name(resume, "resume");
  if (immediate && isClient)
    resume();
  if (isRef(interval) || typeof interval === "function") {
    const stopWatch = watch(interval, () => {
      if (isActive.value && isClient)
        resume();
    });
    tryOnScopeDispose(stopWatch);
  }
  tryOnScopeDispose(pause);
  return {
    isActive,
    pause,
    resume
  };
}
__name(useIntervalFn, "useIntervalFn");
function useInterval(interval = 1e3, options3 = {}) {
  const {
    controls: exposeControls = false,
    immediate = true,
    callback
  } = options3;
  const counter = ref(0);
  const update2 = /* @__PURE__ */ __name(() => counter.value += 1, "update");
  const reset = /* @__PURE__ */ __name(() => {
    counter.value = 0;
  }, "reset");
  const controls = useIntervalFn(
    callback ? () => {
      update2();
      callback(counter.value);
    } : update2,
    interval,
    { immediate }
  );
  if (exposeControls) {
    return {
      counter,
      reset,
      ...controls
    };
  } else {
    return counter;
  }
}
__name(useInterval, "useInterval");
function useLastChanged(source, options3 = {}) {
  var _a;
  const ms = ref((_a = options3.initialValue) != null ? _a : null);
  watch(
    source,
    () => ms.value = timestamp(),
    options3
  );
  return ms;
}
__name(useLastChanged, "useLastChanged");
function useTimeoutFn(cb, interval, options3 = {}) {
  const {
    immediate = true
  } = options3;
  const isPending = ref(false);
  let timer = null;
  function clear3() {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  }
  __name(clear3, "clear");
  function stop2() {
    isPending.value = false;
    clear3();
  }
  __name(stop2, "stop");
  function start2(...args) {
    clear3();
    isPending.value = true;
    timer = setTimeout(() => {
      isPending.value = false;
      timer = null;
      cb(...args);
    }, toValue(interval));
  }
  __name(start2, "start");
  if (immediate) {
    isPending.value = true;
    if (isClient)
      start2();
  }
  tryOnScopeDispose(stop2);
  return {
    isPending: readonly(isPending),
    start: start2,
    stop: stop2
  };
}
__name(useTimeoutFn, "useTimeoutFn");
function useTimeout(interval = 1e3, options3 = {}) {
  const {
    controls: exposeControls = false,
    callback
  } = options3;
  const controls = useTimeoutFn(
    callback != null ? callback : noop,
    interval,
    options3
  );
  const ready = computed(() => !controls.isPending.value);
  if (exposeControls) {
    return {
      ready,
      ...controls
    };
  } else {
    return ready;
  }
}
__name(useTimeout, "useTimeout");
function useToNumber(value3, options3 = {}) {
  const {
    method = "parseFloat",
    radix,
    nanToZero
  } = options3;
  return computed(() => {
    let resolved = toValue(value3);
    if (typeof resolved === "string")
      resolved = Number[method](resolved, radix);
    if (nanToZero && Number.isNaN(resolved))
      resolved = 0;
    return resolved;
  });
}
__name(useToNumber, "useToNumber");
function useToString(value3) {
  return computed(() => `${toValue(value3)}`);
}
__name(useToString, "useToString");
function useToggle(initialValue = false, options3 = {}) {
  const {
    truthyValue = true,
    falsyValue = false
  } = options3;
  const valueIsRef = isRef(initialValue);
  const _value = ref(initialValue);
  function toggle4(value3) {
    if (arguments.length) {
      _value.value = value3;
      return _value.value;
    } else {
      const truthy = toValue(truthyValue);
      _value.value = _value.value === truthy ? toValue(falsyValue) : truthy;
      return _value.value;
    }
  }
  __name(toggle4, "toggle");
  if (valueIsRef)
    return toggle4;
  else
    return [_value, toggle4];
}
__name(useToggle, "useToggle");
function watchArray(source, cb, options3) {
  let oldList = (options3 == null ? void 0 : options3.immediate) ? [] : [...source instanceof Function ? source() : Array.isArray(source) ? source : toValue(source)];
  return watch(source, (newList, _2, onCleanup) => {
    const oldListRemains = Array.from({ length: oldList.length });
    const added = [];
    for (const obj of newList) {
      let found = false;
      for (let i2 = 0; i2 < oldList.length; i2++) {
        if (!oldListRemains[i2] && obj === oldList[i2]) {
          oldListRemains[i2] = true;
          found = true;
          break;
        }
      }
      if (!found)
        added.push(obj);
    }
    const removed = oldList.filter((_22, i2) => !oldListRemains[i2]);
    cb(newList, oldList, added, removed, onCleanup);
    oldList = [...newList];
  }, options3);
}
__name(watchArray, "watchArray");
function watchAtMost(source, cb, options3) {
  const {
    count,
    ...watchOptions
  } = options3;
  const current = ref(0);
  const stop2 = watchWithFilter(
    source,
    (...args) => {
      current.value += 1;
      if (current.value >= toValue(count))
        nextTick(() => stop2());
      cb(...args);
    },
    watchOptions
  );
  return { count: current, stop: stop2 };
}
__name(watchAtMost, "watchAtMost");
function watchDebounced(source, cb, options3 = {}) {
  const {
    debounce = 0,
    maxWait = void 0,
    ...watchOptions
  } = options3;
  return watchWithFilter(
    source,
    cb,
    {
      ...watchOptions,
      eventFilter: debounceFilter(debounce, { maxWait })
    }
  );
}
__name(watchDebounced, "watchDebounced");
function watchDeep(source, cb, options3) {
  return watch(
    source,
    cb,
    {
      ...options3,
      deep: true
    }
  );
}
__name(watchDeep, "watchDeep");
function watchIgnorable(source, cb, options3 = {}) {
  const {
    eventFilter = bypassFilter,
    ...watchOptions
  } = options3;
  const filteredCb = createFilterWrapper(
    eventFilter,
    cb
  );
  let ignoreUpdates;
  let ignorePrevAsyncUpdates;
  let stop2;
  if (watchOptions.flush === "sync") {
    const ignore = ref(false);
    ignorePrevAsyncUpdates = /* @__PURE__ */ __name(() => {
    }, "ignorePrevAsyncUpdates");
    ignoreUpdates = /* @__PURE__ */ __name((updater) => {
      ignore.value = true;
      updater();
      ignore.value = false;
    }, "ignoreUpdates");
    stop2 = watch(
      source,
      (...args) => {
        if (!ignore.value)
          filteredCb(...args);
      },
      watchOptions
    );
  } else {
    const disposables = [];
    const ignoreCounter = ref(0);
    const syncCounter = ref(0);
    ignorePrevAsyncUpdates = /* @__PURE__ */ __name(() => {
      ignoreCounter.value = syncCounter.value;
    }, "ignorePrevAsyncUpdates");
    disposables.push(
      watch(
        source,
        () => {
          syncCounter.value++;
        },
        { ...watchOptions, flush: "sync" }
      )
    );
    ignoreUpdates = /* @__PURE__ */ __name((updater) => {
      const syncCounterPrev = syncCounter.value;
      updater();
      ignoreCounter.value += syncCounter.value - syncCounterPrev;
    }, "ignoreUpdates");
    disposables.push(
      watch(
        source,
        (...args) => {
          const ignore = ignoreCounter.value > 0 && ignoreCounter.value === syncCounter.value;
          ignoreCounter.value = 0;
          syncCounter.value = 0;
          if (ignore)
            return;
          filteredCb(...args);
        },
        watchOptions
      )
    );
    stop2 = /* @__PURE__ */ __name(() => {
      disposables.forEach((fn) => fn());
    }, "stop");
  }
  return { stop: stop2, ignoreUpdates, ignorePrevAsyncUpdates };
}
__name(watchIgnorable, "watchIgnorable");
function watchImmediate(source, cb, options3) {
  return watch(
    source,
    cb,
    {
      ...options3,
      immediate: true
    }
  );
}
__name(watchImmediate, "watchImmediate");
function watchOnce(source, cb, options3) {
  const stop2 = watch(source, (...args) => {
    nextTick(() => stop2());
    return cb(...args);
  }, options3);
  return stop2;
}
__name(watchOnce, "watchOnce");
function watchThrottled(source, cb, options3 = {}) {
  const {
    throttle: throttle2 = 0,
    trailing = true,
    leading = true,
    ...watchOptions
  } = options3;
  return watchWithFilter(
    source,
    cb,
    {
      ...watchOptions,
      eventFilter: throttleFilter(throttle2, trailing, leading)
    }
  );
}
__name(watchThrottled, "watchThrottled");
function watchTriggerable(source, cb, options3 = {}) {
  let cleanupFn;
  function onEffect() {
    if (!cleanupFn)
      return;
    const fn = cleanupFn;
    cleanupFn = void 0;
    fn();
  }
  __name(onEffect, "onEffect");
  function onCleanup(callback) {
    cleanupFn = callback;
  }
  __name(onCleanup, "onCleanup");
  const _cb = /* @__PURE__ */ __name((value3, oldValue) => {
    onEffect();
    return cb(value3, oldValue, onCleanup);
  }, "_cb");
  const res = watchIgnorable(source, _cb, options3);
  const { ignoreUpdates } = res;
  const trigger2 = /* @__PURE__ */ __name(() => {
    let res2;
    ignoreUpdates(() => {
      res2 = _cb(getWatchSources(source), getOldValue(source));
    });
    return res2;
  }, "trigger");
  return {
    ...res,
    trigger: trigger2
  };
}
__name(watchTriggerable, "watchTriggerable");
function getWatchSources(sources) {
  if (isReactive(sources))
    return sources;
  if (Array.isArray(sources))
    return sources.map((item2) => toValue(item2));
  return toValue(sources);
}
__name(getWatchSources, "getWatchSources");
function getOldValue(source) {
  return Array.isArray(source) ? source.map(() => void 0) : void 0;
}
__name(getOldValue, "getOldValue");
function whenever(source, cb, options3) {
  const stop2 = watch(
    source,
    (v2, ov, onInvalidate) => {
      if (v2) {
        if (options3 == null ? void 0 : options3.once)
          nextTick(() => stop2());
        cb(v2, ov, onInvalidate);
      }
    },
    {
      ...options3,
      once: false
    }
  );
  return stop2;
}
__name(whenever, "whenever");
var isVue2 = false;
var isVue3 = true;
var Vue2 = void 0;
function install() {
}
__name(install, "install");
function set(target, key, val) {
  if (Array.isArray(target)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val;
  }
  target[key] = val;
  return val;
}
__name(set, "set");
function del(target, key) {
  if (Array.isArray(target)) {
    target.splice(key, 1);
    return;
  }
  delete target[key];
}
__name(del, "del");
function computedAsync(evaluationCallback, initialState, optionsOrRef) {
  let options3;
  if (isRef(optionsOrRef)) {
    options3 = {
      evaluating: optionsOrRef
    };
  } else {
    options3 = optionsOrRef || {};
  }
  const {
    lazy = false,
    evaluating = void 0,
    shallow = true,
    onError = noop
  } = options3;
  const started = ref(!lazy);
  const current = shallow ? shallowRef(initialState) : ref(initialState);
  let counter = 0;
  watchEffect(async (onInvalidate) => {
    if (!started.value)
      return;
    counter++;
    const counterAtBeginning = counter;
    let hasFinished = false;
    if (evaluating) {
      Promise.resolve().then(() => {
        evaluating.value = true;
      });
    }
    try {
      const result = await evaluationCallback((cancelCallback) => {
        onInvalidate(() => {
          if (evaluating)
            evaluating.value = false;
          if (!hasFinished)
            cancelCallback();
        });
      });
      if (counterAtBeginning === counter)
        current.value = result;
    } catch (e) {
      onError(e);
    } finally {
      if (evaluating && counterAtBeginning === counter)
        evaluating.value = false;
      hasFinished = true;
    }
  });
  if (lazy) {
    return computed(() => {
      started.value = true;
      return current.value;
    });
  } else {
    return current;
  }
}
__name(computedAsync, "computedAsync");
function computedInject(key, options3, defaultSource, treatDefaultAsFactory) {
  let source = inject(key);
  if (defaultSource)
    source = inject(key, defaultSource);
  if (treatDefaultAsFactory)
    source = inject(key, defaultSource, treatDefaultAsFactory);
  if (typeof options3 === "function") {
    return computed((ctx) => options3(source, ctx));
  } else {
    return computed({
      get: /* @__PURE__ */ __name((ctx) => options3.get(source, ctx), "get"),
      set: options3.set
    });
  }
}
__name(computedInject, "computedInject");
function createReusableTemplate(options3 = {}) {
  if (!isVue3 && !version.startsWith("2.7.")) {
    if (false)
      throw new Error("[VueUse] createReusableTemplate only works in Vue 2.7 or above.");
    return;
  }
  const {
    inheritAttrs = true
  } = options3;
  const render2 = shallowRef();
  const define = /* @__PURE__ */ defineComponent({
    setup(_2, { slots }) {
      return () => {
        render2.value = slots.default;
      };
    }
  });
  const reuse = /* @__PURE__ */ defineComponent({
    inheritAttrs,
    setup(_2, { attrs: attrs3, slots }) {
      return () => {
        var _a;
        if (!render2.value && false)
          throw new Error("[VueUse] Failed to find the definition of reusable template");
        const vnode = (_a = render2.value) == null ? void 0 : _a.call(render2, { ...keysToCamelKebabCase(attrs3), $slots: slots });
        return inheritAttrs && (vnode == null ? void 0 : vnode.length) === 1 ? vnode[0] : vnode;
      };
    }
  });
  return makeDestructurable(
    { define, reuse },
    [define, reuse]
  );
}
__name(createReusableTemplate, "createReusableTemplate");
function keysToCamelKebabCase(obj) {
  const newObj = {};
  for (const key in obj)
    newObj[camelize(key)] = obj[key];
  return newObj;
}
__name(keysToCamelKebabCase, "keysToCamelKebabCase");
function createTemplatePromise(options3 = {}) {
  if (!isVue3) {
    if (false)
      throw new Error("[VueUse] createTemplatePromise only works in Vue 3 or above.");
    return;
  }
  let index2 = 0;
  const instances = ref([]);
  function create2(...args) {
    const props = shallowReactive({
      key: index2++,
      args,
      promise: void 0,
      resolve: /* @__PURE__ */ __name(() => {
      }, "resolve"),
      reject: /* @__PURE__ */ __name(() => {
      }, "reject"),
      isResolving: false,
      options: options3
    });
    instances.value.push(props);
    props.promise = new Promise((_resolve, _reject) => {
      props.resolve = (v2) => {
        props.isResolving = true;
        return _resolve(v2);
      };
      props.reject = _reject;
    }).finally(() => {
      props.promise = void 0;
      const index22 = instances.value.indexOf(props);
      if (index22 !== -1)
        instances.value.splice(index22, 1);
    });
    return props.promise;
  }
  __name(create2, "create");
  function start2(...args) {
    if (options3.singleton && instances.value.length > 0)
      return instances.value[0].promise;
    return create2(...args);
  }
  __name(start2, "start");
  const component = /* @__PURE__ */ defineComponent((_2, { slots }) => {
    const renderList2 = /* @__PURE__ */ __name(() => instances.value.map((props) => {
      var _a;
      return h(Fragment, { key: props.key }, (_a = slots.default) == null ? void 0 : _a.call(slots, props));
    }), "renderList");
    if (options3.transition)
      return () => h(TransitionGroup, options3.transition, renderList2);
    return renderList2;
  });
  component.start = start2;
  return component;
}
__name(createTemplatePromise, "createTemplatePromise");
function createUnrefFn(fn) {
  return function(...args) {
    return fn.apply(this, args.map((i2) => toValue(i2)));
  };
}
__name(createUnrefFn, "createUnrefFn");
function unrefElement(elRef) {
  var _a;
  const plain = toValue(elRef);
  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;
}
__name(unrefElement, "unrefElement");
const defaultWindow = isClient ? window : void 0;
const defaultDocument = isClient ? window.document : void 0;
const defaultNavigator = isClient ? window.navigator : void 0;
const defaultLocation = isClient ? window.location : void 0;
function useEventListener(...args) {
  let target;
  let events2;
  let listeners;
  let options3;
  if (typeof args[0] === "string" || Array.isArray(args[0])) {
    [events2, listeners, options3] = args;
    target = defaultWindow;
  } else {
    [target, events2, listeners, options3] = args;
  }
  if (!target)
    return noop;
  if (!Array.isArray(events2))
    events2 = [events2];
  if (!Array.isArray(listeners))
    listeners = [listeners];
  const cleanups = [];
  const cleanup = /* @__PURE__ */ __name(() => {
    cleanups.forEach((fn) => fn());
    cleanups.length = 0;
  }, "cleanup");
  const register3 = /* @__PURE__ */ __name((el, event2, listener, options22) => {
    el.addEventListener(event2, listener, options22);
    return () => el.removeEventListener(event2, listener, options22);
  }, "register");
  const stopWatch = watch(
    () => [unrefElement(target), toValue(options3)],
    ([el, options22]) => {
      cleanup();
      if (!el)
        return;
      const optionsClone = isObject$3(options22) ? { ...options22 } : options22;
      cleanups.push(
        ...events2.flatMap((event2) => {
          return listeners.map((listener) => register3(el, event2, listener, optionsClone));
        })
      );
    },
    { immediate: true, flush: "post" }
  );
  const stop2 = /* @__PURE__ */ __name(() => {
    stopWatch();
    cleanup();
  }, "stop");
  tryOnScopeDispose(stop2);
  return stop2;
}
__name(useEventListener, "useEventListener");
let _iOSWorkaround = false;
function onClickOutside(target, handler6, options3 = {}) {
  const { window: window2 = defaultWindow, ignore = [], capture = true, detectIframe = false } = options3;
  if (!window2)
    return noop;
  if (isIOS && !_iOSWorkaround) {
    _iOSWorkaround = true;
    Array.from(window2.document.body.children).forEach((el) => el.addEventListener("click", noop));
    window2.document.documentElement.addEventListener("click", noop);
  }
  let shouldListen = true;
  const shouldIgnore = /* @__PURE__ */ __name((event2) => {
    return ignore.some((target2) => {
      if (typeof target2 === "string") {
        return Array.from(window2.document.querySelectorAll(target2)).some((el) => el === event2.target || event2.composedPath().includes(el));
      } else {
        const el = unrefElement(target2);
        return el && (event2.target === el || event2.composedPath().includes(el));
      }
    });
  }, "shouldIgnore");
  const listener = /* @__PURE__ */ __name((event2) => {
    const el = unrefElement(target);
    if (!el || el === event2.target || event2.composedPath().includes(el))
      return;
    if (event2.detail === 0)
      shouldListen = !shouldIgnore(event2);
    if (!shouldListen) {
      shouldListen = true;
      return;
    }
    handler6(event2);
  }, "listener");
  const cleanup = [
    useEventListener(window2, "click", listener, { passive: true, capture }),
    useEventListener(window2, "pointerdown", (e) => {
      const el = unrefElement(target);
      shouldListen = !shouldIgnore(e) && !!(el && !e.composedPath().includes(el));
    }, { passive: true }),
    detectIframe && useEventListener(window2, "blur", (event2) => {
      setTimeout(() => {
        var _a;
        const el = unrefElement(target);
        if (((_a = window2.document.activeElement) == null ? void 0 : _a.tagName) === "IFRAME" && !(el == null ? void 0 : el.contains(window2.document.activeElement))) {
          handler6(event2);
        }
      }, 0);
    })
  ].filter(Boolean);
  const stop2 = /* @__PURE__ */ __name(() => cleanup.forEach((fn) => fn()), "stop");
  return stop2;
}
__name(onClickOutside, "onClickOutside");
function createKeyPredicate(keyFilter) {
  if (typeof keyFilter === "function")
    return keyFilter;
  else if (typeof keyFilter === "string")
    return (event2) => event2.key === keyFilter;
  else if (Array.isArray(keyFilter))
    return (event2) => keyFilter.includes(event2.key);
  return () => true;
}
__name(createKeyPredicate, "createKeyPredicate");
function onKeyStroke(...args) {
  let key;
  let handler6;
  let options3 = {};
  if (args.length === 3) {
    key = args[0];
    handler6 = args[1];
    options3 = args[2];
  } else if (args.length === 2) {
    if (typeof args[1] === "object") {
      key = true;
      handler6 = args[0];
      options3 = args[1];
    } else {
      key = args[0];
      handler6 = args[1];
    }
  } else {
    key = true;
    handler6 = args[0];
  }
  const {
    target = defaultWindow,
    eventName = "keydown",
    passive = false,
    dedupe = false
  } = options3;
  const predicate = createKeyPredicate(key);
  const listener = /* @__PURE__ */ __name((e) => {
    if (e.repeat && toValue(dedupe))
      return;
    if (predicate(e))
      handler6(e);
  }, "listener");
  return useEventListener(target, eventName, listener, passive);
}
__name(onKeyStroke, "onKeyStroke");
function onKeyDown(key, handler6, options3 = {}) {
  return onKeyStroke(key, handler6, { ...options3, eventName: "keydown" });
}
__name(onKeyDown, "onKeyDown");
function onKeyPressed(key, handler6, options3 = {}) {
  return onKeyStroke(key, handler6, { ...options3, eventName: "keypress" });
}
__name(onKeyPressed, "onKeyPressed");
function onKeyUp(key, handler6, options3 = {}) {
  return onKeyStroke(key, handler6, { ...options3, eventName: "keyup" });
}
__name(onKeyUp, "onKeyUp");
const DEFAULT_DELAY = 500;
const DEFAULT_THRESHOLD = 10;
function onLongPress(target, handler6, options3) {
  var _a, _b;
  const elementRef2 = computed(() => unrefElement(target));
  let timeout;
  let posStart;
  let startTimestamp;
  let hasLongPressed = false;
  function clear3() {
    if (timeout) {
      clearTimeout(timeout);
      timeout = void 0;
    }
    posStart = void 0;
    startTimestamp = void 0;
    hasLongPressed = false;
  }
  __name(clear3, "clear");
  function onRelease(ev) {
    var _a2, _b2, _c;
    const [_startTimestamp, _posStart, _hasLongPressed] = [startTimestamp, posStart, hasLongPressed];
    clear3();
    if (!(options3 == null ? void 0 : options3.onMouseUp) || !_posStart || !_startTimestamp)
      return;
    if (((_a2 = options3 == null ? void 0 : options3.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef2.value)
      return;
    if ((_b2 = options3 == null ? void 0 : options3.modifiers) == null ? void 0 : _b2.prevent)
      ev.preventDefault();
    if ((_c = options3 == null ? void 0 : options3.modifiers) == null ? void 0 : _c.stop)
      ev.stopPropagation();
    const dx = ev.x - _posStart.x;
    const dy = ev.y - _posStart.y;
    const distance2 = Math.sqrt(dx * dx + dy * dy);
    options3.onMouseUp(ev.timeStamp - _startTimestamp, distance2, _hasLongPressed);
  }
  __name(onRelease, "onRelease");
  function onDown(ev) {
    var _a2, _b2, _c, _d;
    if (((_a2 = options3 == null ? void 0 : options3.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef2.value)
      return;
    clear3();
    if ((_b2 = options3 == null ? void 0 : options3.modifiers) == null ? void 0 : _b2.prevent)
      ev.preventDefault();
    if ((_c = options3 == null ? void 0 : options3.modifiers) == null ? void 0 : _c.stop)
      ev.stopPropagation();
    posStart = {
      x: ev.x,
      y: ev.y
    };
    startTimestamp = ev.timeStamp;
    timeout = setTimeout(
      () => {
        hasLongPressed = true;
        handler6(ev);
      },
      (_d = options3 == null ? void 0 : options3.delay) != null ? _d : DEFAULT_DELAY
    );
  }
  __name(onDown, "onDown");
  function onMove(ev) {
    var _a2, _b2, _c, _d;
    if (((_a2 = options3 == null ? void 0 : options3.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef2.value)
      return;
    if (!posStart || (options3 == null ? void 0 : options3.distanceThreshold) === false)
      return;
    if ((_b2 = options3 == null ? void 0 : options3.modifiers) == null ? void 0 : _b2.prevent)
      ev.preventDefault();
    if ((_c = options3 == null ? void 0 : options3.modifiers) == null ? void 0 : _c.stop)
      ev.stopPropagation();
    const dx = ev.x - posStart.x;
    const dy = ev.y - posStart.y;
    const distance2 = Math.sqrt(dx * dx + dy * dy);
    if (distance2 >= ((_d = options3 == null ? void 0 : options3.distanceThreshold) != null ? _d : DEFAULT_THRESHOLD))
      clear3();
  }
  __name(onMove, "onMove");
  const listenerOptions = {
    capture: (_a = options3 == null ? void 0 : options3.modifiers) == null ? void 0 : _a.capture,
    once: (_b = options3 == null ? void 0 : options3.modifiers) == null ? void 0 : _b.once
  };
  const cleanup = [
    useEventListener(elementRef2, "pointerdown", onDown, listenerOptions),
    useEventListener(elementRef2, "pointermove", onMove, listenerOptions),
    useEventListener(elementRef2, ["pointerup", "pointerleave"], onRelease, listenerOptions)
  ];
  const stop2 = /* @__PURE__ */ __name(() => cleanup.forEach((fn) => fn()), "stop");
  return stop2;
}
__name(onLongPress, "onLongPress");
function isFocusedElementEditable() {
  const { activeElement, body } = document;
  if (!activeElement)
    return false;
  if (activeElement === body)
    return false;
  switch (activeElement.tagName) {
    case "INPUT":
    case "TEXTAREA":
      return true;
  }
  return activeElement.hasAttribute("contenteditable");
}
__name(isFocusedElementEditable, "isFocusedElementEditable");
function isTypedCharValid({
  keyCode,
  metaKey,
  ctrlKey,
  altKey
}) {
  if (metaKey || ctrlKey || altKey)
    return false;
  if (keyCode >= 48 && keyCode <= 57)
    return true;
  if (keyCode >= 65 && keyCode <= 90)
    return true;
  if (keyCode >= 97 && keyCode <= 122)
    return true;
  return false;
}
__name(isTypedCharValid, "isTypedCharValid");
function onStartTyping(callback, options3 = {}) {
  const { document: document2 = defaultDocument } = options3;
  const keydown = /* @__PURE__ */ __name((event2) => {
    if (!isFocusedElementEditable() && isTypedCharValid(event2)) {
      callback(event2);
    }
  }, "keydown");
  if (document2)
    useEventListener(document2, "keydown", keydown, { passive: true });
}
__name(onStartTyping, "onStartTyping");
function templateRef(key, initialValue = null) {
  const instance = getCurrentInstance();
  let _trigger = /* @__PURE__ */ __name(() => {
  }, "_trigger");
  const element = customRef((track2, trigger2) => {
    _trigger = trigger2;
    return {
      get() {
        var _a, _b;
        track2();
        return (_b = (_a = instance == null ? void 0 : instance.proxy) == null ? void 0 : _a.$refs[key]) != null ? _b : initialValue;
      },
      set() {
      }
    };
  });
  tryOnMounted(_trigger);
  onUpdated(_trigger);
  return element;
}
__name(templateRef, "templateRef");
function useMounted() {
  const isMounted = ref(false);
  const instance = getCurrentInstance();
  if (instance) {
    onMounted(() => {
      isMounted.value = true;
    }, isVue2 ? void 0 : instance);
  }
  return isMounted;
}
__name(useMounted, "useMounted");
function useSupported(callback) {
  const isMounted = useMounted();
  return computed(() => {
    isMounted.value;
    return Boolean(callback());
  });
}
__name(useSupported, "useSupported");
function useMutationObserver(target, callback, options3 = {}) {
  const { window: window2 = defaultWindow, ...mutationOptions } = options3;
  let observer;
  const isSupported2 = useSupported(() => window2 && "MutationObserver" in window2);
  const cleanup = /* @__PURE__ */ __name(() => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  }, "cleanup");
  const targets = computed(() => {
    const value3 = toValue(target);
    const items2 = (Array.isArray(value3) ? value3 : [value3]).map(unrefElement).filter(notNullish);
    return new Set(items2);
  });
  const stopWatch = watch(
    () => targets.value,
    (targets2) => {
      cleanup();
      if (isSupported2.value && targets2.size) {
        observer = new MutationObserver(callback);
        targets2.forEach((el) => observer.observe(el, mutationOptions));
      }
    },
    { immediate: true, flush: "post" }
  );
  const takeRecords = /* @__PURE__ */ __name(() => {
    return observer == null ? void 0 : observer.takeRecords();
  }, "takeRecords");
  const stop2 = /* @__PURE__ */ __name(() => {
    stopWatch();
    cleanup();
  }, "stop");
  tryOnScopeDispose(stop2);
  return {
    isSupported: isSupported2,
    stop: stop2,
    takeRecords
  };
}
__name(useMutationObserver, "useMutationObserver");
function useActiveElement(options3 = {}) {
  var _a;
  const {
    window: window2 = defaultWindow,
    deep = true,
    triggerOnRemoval = false
  } = options3;
  const document2 = (_a = options3.document) != null ? _a : window2 == null ? void 0 : window2.document;
  const getDeepActiveElement = /* @__PURE__ */ __name(() => {
    var _a2;
    let element = document2 == null ? void 0 : document2.activeElement;
    if (deep) {
      while (element == null ? void 0 : element.shadowRoot)
        element = (_a2 = element == null ? void 0 : element.shadowRoot) == null ? void 0 : _a2.activeElement;
    }
    return element;
  }, "getDeepActiveElement");
  const activeElement = ref();
  const trigger2 = /* @__PURE__ */ __name(() => {
    activeElement.value = getDeepActiveElement();
  }, "trigger");
  if (window2) {
    useEventListener(window2, "blur", (event2) => {
      if (event2.relatedTarget !== null)
        return;
      trigger2();
    }, true);
    useEventListener(window2, "focus", trigger2, true);
  }
  if (triggerOnRemoval) {
    useMutationObserver(document2, (mutations) => {
      mutations.filter((m) => m.removedNodes.length).map((n) => Array.from(n.removedNodes)).flat().forEach((node3) => {
        if (node3 === activeElement.value)
          trigger2();
      });
    }, {
      childList: true,
      subtree: true
    });
  }
  trigger2();
  return activeElement;
}
__name(useActiveElement, "useActiveElement");
function useRafFn(fn, options3 = {}) {
  const {
    immediate = true,
    fpsLimit = void 0,
    window: window2 = defaultWindow
  } = options3;
  const isActive = ref(false);
  const intervalLimit = fpsLimit ? 1e3 / fpsLimit : null;
  let previousFrameTimestamp = 0;
  let rafId = null;
  function loop(timestamp2) {
    if (!isActive.value || !window2)
      return;
    if (!previousFrameTimestamp)
      previousFrameTimestamp = timestamp2;
    const delta2 = timestamp2 - previousFrameTimestamp;
    if (intervalLimit && delta2 < intervalLimit) {
      rafId = window2.requestAnimationFrame(loop);
      return;
    }
    previousFrameTimestamp = timestamp2;
    fn({ delta: delta2, timestamp: timestamp2 });
    rafId = window2.requestAnimationFrame(loop);
  }
  __name(loop, "loop");
  function resume() {
    if (!isActive.value && window2) {
      isActive.value = true;
      previousFrameTimestamp = 0;
      rafId = window2.requestAnimationFrame(loop);
    }
  }
  __name(resume, "resume");
  function pause() {
    isActive.value = false;
    if (rafId != null && window2) {
      window2.cancelAnimationFrame(rafId);
      rafId = null;
    }
  }
  __name(pause, "pause");
  if (immediate)
    resume();
  tryOnScopeDispose(pause);
  return {
    isActive: readonly(isActive),
    pause,
    resume
  };
}
__name(useRafFn, "useRafFn");
function useAnimate(target, keyframes, options3) {
  let config;
  let animateOptions;
  if (isObject$3(options3)) {
    config = options3;
    animateOptions = objectOmit(options3, ["window", "immediate", "commitStyles", "persist", "onReady", "onError"]);
  } else {
    config = { duration: options3 };
    animateOptions = options3;
  }
  const {
    window: window2 = defaultWindow,
    immediate = true,
    commitStyles,
    persist,
    playbackRate: _playbackRate = 1,
    onReady,
    onError = /* @__PURE__ */ __name((e) => {
      console.error(e);
    }, "onError")
  } = config;
  const isSupported2 = useSupported(() => window2 && HTMLElement && "animate" in HTMLElement.prototype);
  const animate = shallowRef(void 0);
  const store = shallowReactive({
    startTime: null,
    currentTime: null,
    timeline: null,
    playbackRate: _playbackRate,
    pending: false,
    playState: immediate ? "idle" : "paused",
    replaceState: "active"
  });
  const pending = computed(() => store.pending);
  const playState = computed(() => store.playState);
  const replaceState = computed(() => store.replaceState);
  const startTime = computed({
    get() {
      return store.startTime;
    },
    set(value3) {
      store.startTime = value3;
      if (animate.value)
        animate.value.startTime = value3;
    }
  });
  const currentTime = computed({
    get() {
      return store.currentTime;
    },
    set(value3) {
      store.currentTime = value3;
      if (animate.value) {
        animate.value.currentTime = value3;
        syncResume();
      }
    }
  });
  const timeline = computed({
    get() {
      return store.timeline;
    },
    set(value3) {
      store.timeline = value3;
      if (animate.value)
        animate.value.timeline = value3;
    }
  });
  const playbackRate = computed({
    get() {
      return store.playbackRate;
    },
    set(value3) {
      store.playbackRate = value3;
      if (animate.value)
        animate.value.playbackRate = value3;
    }
  });
  const play = /* @__PURE__ */ __name(() => {
    if (animate.value) {
      try {
        animate.value.play();
        syncResume();
      } catch (e) {
        syncPause();
        onError(e);
      }
    } else {
      update2();
    }
  }, "play");
  const pause = /* @__PURE__ */ __name(() => {
    var _a;
    try {
      (_a = animate.value) == null ? void 0 : _a.pause();
      syncPause();
    } catch (e) {
      onError(e);
    }
  }, "pause");
  const reverse = /* @__PURE__ */ __name(() => {
    var _a;
    if (!animate.value)
      update2();
    try {
      (_a = animate.value) == null ? void 0 : _a.reverse();
      syncResume();
    } catch (e) {
      syncPause();
      onError(e);
    }
  }, "reverse");
  const finish = /* @__PURE__ */ __name(() => {
    var _a;
    try {
      (_a = animate.value) == null ? void 0 : _a.finish();
      syncPause();
    } catch (e) {
      onError(e);
    }
  }, "finish");
  const cancel = /* @__PURE__ */ __name(() => {
    var _a;
    try {
      (_a = animate.value) == null ? void 0 : _a.cancel();
      syncPause();
    } catch (e) {
      onError(e);
    }
  }, "cancel");
  watch(() => unrefElement(target), (el) => {
    if (el)
      update2();
  });
  watch(() => keyframes, (value3) => {
    if (animate.value)
      update2();
    if (!unrefElement(target) && animate.value) {
      animate.value.effect = new KeyframeEffect(
        unrefElement(target),
        toValue(value3),
        animateOptions
      );
    }
  }, { deep: true });
  tryOnMounted(() => update2(true), false);
  tryOnScopeDispose(cancel);
  function update2(init2) {
    const el = unrefElement(target);
    if (!isSupported2.value || !el)
      return;
    if (!animate.value)
      animate.value = el.animate(toValue(keyframes), animateOptions);
    if (persist)
      animate.value.persist();
    if (_playbackRate !== 1)
      animate.value.playbackRate = _playbackRate;
    if (init2 && !immediate)
      animate.value.pause();
    else
      syncResume();
    onReady == null ? void 0 : onReady(animate.value);
  }
  __name(update2, "update");
  useEventListener(animate, ["cancel", "finish", "remove"], syncPause);
  useEventListener(animate, "finish", () => {
    var _a;
    if (commitStyles)
      (_a = animate.value) == null ? void 0 : _a.commitStyles();
  });
  const { resume: resumeRef, pause: pauseRef } = useRafFn(() => {
    if (!animate.value)
      return;
    store.pending = animate.value.pending;
    store.playState = animate.value.playState;
    store.replaceState = animate.value.replaceState;
    store.startTime = animate.value.startTime;
    store.currentTime = animate.value.currentTime;
    store.timeline = animate.value.timeline;
    store.playbackRate = animate.value.playbackRate;
  }, { immediate: false });
  function syncResume() {
    if (isSupported2.value)
      resumeRef();
  }
  __name(syncResume, "syncResume");
  function syncPause() {
    if (isSupported2.value && window2)
      window2.requestAnimationFrame(pauseRef);
  }
  __name(syncPause, "syncPause");
  return {
    isSupported: isSupported2,
    animate,
    // actions
    play,
    pause,
    reverse,
    finish,
    cancel,
    // state
    pending,
    playState,
    replaceState,
    startTime,
    currentTime,
    timeline,
    playbackRate
  };
}
__name(useAnimate, "useAnimate");
function useAsyncQueue(tasks, options3) {
  const {
    interrupt = true,
    onError = noop,
    onFinished = noop,
    signal
  } = options3 || {};
  const promiseState = {
    aborted: "aborted",
    fulfilled: "fulfilled",
    pending: "pending",
    rejected: "rejected"
  };
  const initialResult = Array.from(Array.from({ length: tasks.length }), () => ({ state: promiseState.pending, data: null }));
  const result = reactive(initialResult);
  const activeIndex2 = ref(-1);
  if (!tasks || tasks.length === 0) {
    onFinished();
    return {
      activeIndex: activeIndex2,
      result
    };
  }
  function updateResult(state, res) {
    activeIndex2.value++;
    result[activeIndex2.value].data = res;
    result[activeIndex2.value].state = state;
  }
  __name(updateResult, "updateResult");
  tasks.reduce((prev2, curr) => {
    return prev2.then((prevRes) => {
      var _a;
      if (signal == null ? void 0 : signal.aborted) {
        updateResult(promiseState.aborted, new Error("aborted"));
        return;
      }
      if (((_a = result[activeIndex2.value]) == null ? void 0 : _a.state) === promiseState.rejected && interrupt) {
        onFinished();
        return;
      }
      const done = curr(prevRes).then((currentRes) => {
        updateResult(promiseState.fulfilled, currentRes);
        if (activeIndex2.value === tasks.length - 1)
          onFinished();
        return currentRes;
      });
      if (!signal)
        return done;
      return Promise.race([done, whenAborted(signal)]);
    }).catch((e) => {
      if (signal == null ? void 0 : signal.aborted) {
        updateResult(promiseState.aborted, e);
        return e;
      }
      updateResult(promiseState.rejected, e);
      onError();
      return e;
    });
  }, Promise.resolve());
  return {
    activeIndex: activeIndex2,
    result
  };
}
__name(useAsyncQueue, "useAsyncQueue");
function whenAborted(signal) {
  return new Promise((resolve8, reject2) => {
    const error = new Error("aborted");
    if (signal.aborted)
      reject2(error);
    else
      signal.addEventListener("abort", () => reject2(error), { once: true });
  });
}
__name(whenAborted, "whenAborted");
function useAsyncState(promise, initialState, options3) {
  const {
    immediate = true,
    delay = 0,
    onError = noop,
    onSuccess = noop,
    resetOnExecute = true,
    shallow = true,
    throwError
  } = options3 != null ? options3 : {};
  const state = shallow ? shallowRef(initialState) : ref(initialState);
  const isReady = ref(false);
  const isLoading = ref(false);
  const error = shallowRef(void 0);
  async function execute(delay2 = 0, ...args) {
    if (resetOnExecute)
      state.value = initialState;
    error.value = void 0;
    isReady.value = false;
    isLoading.value = true;
    if (delay2 > 0)
      await promiseTimeout(delay2);
    const _promise = typeof promise === "function" ? promise(...args) : promise;
    try {
      const data24 = await _promise;
      state.value = data24;
      isReady.value = true;
      onSuccess(data24);
    } catch (e) {
      error.value = e;
      onError(e);
      if (throwError)
        throw e;
    } finally {
      isLoading.value = false;
    }
    return state.value;
  }
  __name(execute, "execute");
  if (immediate)
    execute(delay);
  const shell = {
    state,
    isReady,
    isLoading,
    error,
    execute
  };
  function waitUntilIsLoaded() {
    return new Promise((resolve8, reject2) => {
      until(isLoading).toBe(false).then(() => resolve8(shell)).catch(reject2);
    });
  }
  __name(waitUntilIsLoaded, "waitUntilIsLoaded");
  return {
    ...shell,
    then(onFulfilled, onRejected) {
      return waitUntilIsLoaded().then(onFulfilled, onRejected);
    }
  };
}
__name(useAsyncState, "useAsyncState");
const defaults = {
  array: /* @__PURE__ */ __name((v2) => JSON.stringify(v2), "array"),
  object: /* @__PURE__ */ __name((v2) => JSON.stringify(v2), "object"),
  set: /* @__PURE__ */ __name((v2) => JSON.stringify(Array.from(v2)), "set"),
  map: /* @__PURE__ */ __name((v2) => JSON.stringify(Object.fromEntries(v2)), "map"),
  null: /* @__PURE__ */ __name(() => "", "null")
};
function getDefaultSerialization(target) {
  if (!target)
    return defaults.null;
  if (target instanceof Map)
    return defaults.map;
  else if (target instanceof Set)
    return defaults.set;
  else if (Array.isArray(target))
    return defaults.array;
  else
    return defaults.object;
}
__name(getDefaultSerialization, "getDefaultSerialization");
function useBase64(target, options3) {
  const base64 = ref("");
  const promise = ref();
  function execute() {
    if (!isClient)
      return;
    promise.value = new Promise((resolve8, reject2) => {
      try {
        const _target = toValue(target);
        if (_target == null) {
          resolve8("");
        } else if (typeof _target === "string") {
          resolve8(blobToBase64(new Blob([_target], { type: "text/plain" })));
        } else if (_target instanceof Blob) {
          resolve8(blobToBase64(_target));
        } else if (_target instanceof ArrayBuffer) {
          resolve8(window.btoa(String.fromCharCode(...new Uint8Array(_target))));
        } else if (_target instanceof HTMLCanvasElement) {
          resolve8(_target.toDataURL(options3 == null ? void 0 : options3.type, options3 == null ? void 0 : options3.quality));
        } else if (_target instanceof HTMLImageElement) {
          const img = _target.cloneNode(false);
          img.crossOrigin = "Anonymous";
          imgLoaded(img).then(() => {
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            resolve8(canvas.toDataURL(options3 == null ? void 0 : options3.type, options3 == null ? void 0 : options3.quality));
          }).catch(reject2);
        } else if (typeof _target === "object") {
          const _serializeFn = (options3 == null ? void 0 : options3.serializer) || getDefaultSerialization(_target);
          const serialized = _serializeFn(_target);
          return resolve8(blobToBase64(new Blob([serialized], { type: "application/json" })));
        } else {
          reject2(new Error("target is unsupported types"));
        }
      } catch (error) {
        reject2(error);
      }
    });
    promise.value.then((res) => base64.value = res);
    return promise.value;
  }
  __name(execute, "execute");
  if (isRef(target) || typeof target === "function")
    watch(target, execute, { immediate: true });
  else
    execute();
  return {
    base64,
    promise,
    execute
  };
}
__name(useBase64, "useBase64");
function imgLoaded(img) {
  return new Promise((resolve8, reject2) => {
    if (!img.complete) {
      img.onload = () => {
        resolve8();
      };
      img.onerror = reject2;
    } else {
      resolve8();
    }
  });
}
__name(imgLoaded, "imgLoaded");
function blobToBase64(blob) {
  return new Promise((resolve8, reject2) => {
    const fr = new FileReader();
    fr.onload = (e) => {
      resolve8(e.target.result);
    };
    fr.onerror = reject2;
    fr.readAsDataURL(blob);
  });
}
__name(blobToBase64, "blobToBase64");
function useBattery(options3 = {}) {
  const { navigator: navigator2 = defaultNavigator } = options3;
  const events2 = ["chargingchange", "chargingtimechange", "dischargingtimechange", "levelchange"];
  const isSupported2 = useSupported(() => navigator2 && "getBattery" in navigator2 && typeof navigator2.getBattery === "function");
  const charging = ref(false);
  const chargingTime = ref(0);
  const dischargingTime = ref(0);
  const level = ref(1);
  let battery;
  function updateBatteryInfo() {
    charging.value = this.charging;
    chargingTime.value = this.chargingTime || 0;
    dischargingTime.value = this.dischargingTime || 0;
    level.value = this.level;
  }
  __name(updateBatteryInfo, "updateBatteryInfo");
  if (isSupported2.value) {
    navigator2.getBattery().then((_battery) => {
      battery = _battery;
      updateBatteryInfo.call(battery);
      useEventListener(battery, events2, updateBatteryInfo, { passive: true });
    });
  }
  return {
    isSupported: isSupported2,
    charging,
    chargingTime,
    dischargingTime,
    level
  };
}
__name(useBattery, "useBattery");
function useBluetooth(options3) {
  let {
    acceptAllDevices = false
  } = options3 || {};
  const {
    filters = void 0,
    optionalServices = void 0,
    navigator: navigator2 = defaultNavigator
  } = options3 || {};
  const isSupported2 = useSupported(() => navigator2 && "bluetooth" in navigator2);
  const device = shallowRef(void 0);
  const error = shallowRef(null);
  watch(device, () => {
    connectToBluetoothGATTServer();
  });
  async function requestDevice() {
    if (!isSupported2.value)
      return;
    error.value = null;
    if (filters && filters.length > 0)
      acceptAllDevices = false;
    try {
      device.value = await (navigator2 == null ? void 0 : navigator2.bluetooth.requestDevice({
        acceptAllDevices,
        filters,
        optionalServices
      }));
    } catch (err) {
      error.value = err;
    }
  }
  __name(requestDevice, "requestDevice");
  const server = ref();
  const isConnected = computed(() => {
    var _a;
    return ((_a = server.value) == null ? void 0 : _a.connected) || false;
  });
  async function connectToBluetoothGATTServer() {
    error.value = null;
    if (device.value && device.value.gatt) {
      device.value.addEventListener("gattserverdisconnected", () => {
      });
      try {
        server.value = await device.value.gatt.connect();
      } catch (err) {
        error.value = err;
      }
    }
  }
  __name(connectToBluetoothGATTServer, "connectToBluetoothGATTServer");
  tryOnMounted(() => {
    var _a;
    if (device.value)
      (_a = device.value.gatt) == null ? void 0 : _a.connect();
  });
  tryOnScopeDispose(() => {
    var _a;
    if (device.value)
      (_a = device.value.gatt) == null ? void 0 : _a.disconnect();
  });
  return {
    isSupported: isSupported2,
    isConnected,
    // Device:
    device,
    requestDevice,
    // Server:
    server,
    // Errors:
    error
  };
}
__name(useBluetooth, "useBluetooth");
function useMediaQuery(query, options3 = {}) {
  const { window: window2 = defaultWindow } = options3;
  const isSupported2 = useSupported(() => window2 && "matchMedia" in window2 && typeof window2.matchMedia === "function");
  let mediaQuery;
  const matches2 = ref(false);
  const handler6 = /* @__PURE__ */ __name((event2) => {
    matches2.value = event2.matches;
  }, "handler");
  const cleanup = /* @__PURE__ */ __name(() => {
    if (!mediaQuery)
      return;
    if ("removeEventListener" in mediaQuery)
      mediaQuery.removeEventListener("change", handler6);
    else
      mediaQuery.removeListener(handler6);
  }, "cleanup");
  const stopWatch = watchEffect(() => {
    if (!isSupported2.value)
      return;
    cleanup();
    mediaQuery = window2.matchMedia(toValue(query));
    if ("addEventListener" in mediaQuery)
      mediaQuery.addEventListener("change", handler6);
    else
      mediaQuery.addListener(handler6);
    matches2.value = mediaQuery.matches;
  });
  tryOnScopeDispose(() => {
    stopWatch();
    cleanup();
    mediaQuery = void 0;
  });
  return matches2;
}
__name(useMediaQuery, "useMediaQuery");
const breakpointsTailwind = {
  "sm": 640,
  "md": 768,
  "lg": 1024,
  "xl": 1280,
  "2xl": 1536
};
const breakpointsBootstrapV5 = {
  xs: 0,
  sm: 576,
  md: 768,
  lg: 992,
  xl: 1200,
  xxl: 1400
};
const breakpointsVuetifyV2 = {
  xs: 0,
  sm: 600,
  md: 960,
  lg: 1264,
  xl: 1904
};
const breakpointsVuetifyV3 = {
  xs: 0,
  sm: 600,
  md: 960,
  lg: 1280,
  xl: 1920,
  xxl: 2560
};
const breakpointsVuetify = breakpointsVuetifyV2;
const breakpointsAntDesign = {
  xs: 480,
  sm: 576,
  md: 768,
  lg: 992,
  xl: 1200,
  xxl: 1600
};
const breakpointsQuasar = {
  xs: 0,
  sm: 600,
  md: 1024,
  lg: 1440,
  xl: 1920
};
const breakpointsSematic = {
  mobileS: 320,
  mobileM: 375,
  mobileL: 425,
  tablet: 768,
  laptop: 1024,
  laptopL: 1440,
  desktop4K: 2560
};
const breakpointsMasterCss = {
  "3xs": 360,
  "2xs": 480,
  "xs": 600,
  "sm": 768,
  "md": 1024,
  "lg": 1280,
  "xl": 1440,
  "2xl": 1600,
  "3xl": 1920,
  "4xl": 2560
};
const breakpointsPrimeFlex = {
  sm: 576,
  md: 768,
  lg: 992,
  xl: 1200
};
function useBreakpoints(breakpoints, options3 = {}) {
  function getValue2(k, delta2) {
    let v2 = toValue(breakpoints[toValue(k)]);
    if (delta2 != null)
      v2 = increaseWithUnit(v2, delta2);
    if (typeof v2 === "number")
      v2 = `${v2}px`;
    return v2;
  }
  __name(getValue2, "getValue2");
  const { window: window2 = defaultWindow, strategy = "min-width" } = options3;
  function match(query) {
    if (!window2)
      return false;
    return window2.matchMedia(query).matches;
  }
  __name(match, "match");
  const greaterOrEqual = /* @__PURE__ */ __name((k) => {
    return useMediaQuery(() => `(min-width: ${getValue2(k)})`, options3);
  }, "greaterOrEqual");
  const smallerOrEqual = /* @__PURE__ */ __name((k) => {
    return useMediaQuery(() => `(max-width: ${getValue2(k)})`, options3);
  }, "smallerOrEqual");
  const shortcutMethods = Object.keys(breakpoints).reduce((shortcuts, k) => {
    Object.defineProperty(shortcuts, k, {
      get: /* @__PURE__ */ __name(() => strategy === "min-width" ? greaterOrEqual(k) : smallerOrEqual(k), "get"),
      enumerable: true,
      configurable: true
    });
    return shortcuts;
  }, {});
  function current() {
    const points = Object.keys(breakpoints).map((i2) => [i2, greaterOrEqual(i2)]);
    return computed(() => points.filter(([, v2]) => v2.value).map(([k]) => k));
  }
  __name(current, "current");
  return Object.assign(shortcutMethods, {
    greaterOrEqual,
    smallerOrEqual,
    greater(k) {
      return useMediaQuery(() => `(min-width: ${getValue2(k, 0.1)})`, options3);
    },
    smaller(k) {
      return useMediaQuery(() => `(max-width: ${getValue2(k, -0.1)})`, options3);
    },
    between(a, b) {
      return useMediaQuery(() => `(min-width: ${getValue2(a)}) and (max-width: ${getValue2(b, -0.1)})`, options3);
    },
    isGreater(k) {
      return match(`(min-width: ${getValue2(k, 0.1)})`);
    },
    isGreaterOrEqual(k) {
      return match(`(min-width: ${getValue2(k)})`);
    },
    isSmaller(k) {
      return match(`(max-width: ${getValue2(k, -0.1)})`);
    },
    isSmallerOrEqual(k) {
      return match(`(max-width: ${getValue2(k)})`);
    },
    isInBetween(a, b) {
      return match(`(min-width: ${getValue2(a)}) and (max-width: ${getValue2(b, -0.1)})`);
    },
    current,
    active() {
      const bps = current();
      return computed(() => bps.value.length === 0 ? "" : bps.value.at(-1));
    }
  });
}
__name(useBreakpoints, "useBreakpoints");
function useBroadcastChannel(options3) {
  const {
    name,
    window: window2 = defaultWindow
  } = options3;
  const isSupported2 = useSupported(() => window2 && "BroadcastChannel" in window2);
  const isClosed = ref(false);
  const channel = ref();
  const data24 = ref();
  const error = shallowRef(null);
  const post = /* @__PURE__ */ __name((data25) => {
    if (channel.value)
      channel.value.postMessage(data25);
  }, "post");
  const close4 = /* @__PURE__ */ __name(() => {
    if (channel.value)
      channel.value.close();
    isClosed.value = true;
  }, "close");
  if (isSupported2.value) {
    tryOnMounted(() => {
      error.value = null;
      channel.value = new BroadcastChannel(name);
      channel.value.addEventListener("message", (e) => {
        data24.value = e.data;
      }, { passive: true });
      channel.value.addEventListener("messageerror", (e) => {
        error.value = e;
      }, { passive: true });
      channel.value.addEventListener("close", () => {
        isClosed.value = true;
      });
    });
  }
  tryOnScopeDispose(() => {
    close4();
  });
  return {
    isSupported: isSupported2,
    channel,
    data: data24,
    post,
    close: close4,
    error,
    isClosed
  };
}
__name(useBroadcastChannel, "useBroadcastChannel");
const WRITABLE_PROPERTIES = [
  "hash",
  "host",
  "hostname",
  "href",
  "pathname",
  "port",
  "protocol",
  "search"
];
function useBrowserLocation(options3 = {}) {
  const { window: window2 = defaultWindow } = options3;
  const refs = Object.fromEntries(
    WRITABLE_PROPERTIES.map((key) => [key, ref()])
  );
  for (const [key, ref2] of objectEntries(refs)) {
    watch(ref2, (value3) => {
      if (!(window2 == null ? void 0 : window2.location) || window2.location[key] === value3)
        return;
      window2.location[key] = value3;
    });
  }
  const buildState = /* @__PURE__ */ __name((trigger2) => {
    var _a;
    const { state: state2, length } = (window2 == null ? void 0 : window2.history) || {};
    const { origin: origin2 } = (window2 == null ? void 0 : window2.location) || {};
    for (const key of WRITABLE_PROPERTIES)
      refs[key].value = (_a = window2 == null ? void 0 : window2.location) == null ? void 0 : _a[key];
    return reactive({
      trigger: trigger2,
      state: state2,
      length,
      origin: origin2,
      ...refs
    });
  }, "buildState");
  const state = ref(buildState("load"));
  if (window2) {
    useEventListener(window2, "popstate", () => state.value = buildState("popstate"), { passive: true });
    useEventListener(window2, "hashchange", () => state.value = buildState("hashchange"), { passive: true });
  }
  return state;
}
__name(useBrowserLocation, "useBrowserLocation");
function useCached(refValue, comparator2 = (a, b) => a === b, watchOptions) {
  const cachedValue = ref(refValue.value);
  watch(() => refValue.value, (value3) => {
    if (!comparator2(value3, cachedValue.value))
      cachedValue.value = value3;
  }, watchOptions);
  return cachedValue;
}
__name(useCached, "useCached");
function usePermission(permissionDesc, options3 = {}) {
  const {
    controls = false,
    navigator: navigator2 = defaultNavigator
  } = options3;
  const isSupported2 = useSupported(() => navigator2 && "permissions" in navigator2);
  let permissionStatus;
  const desc = typeof permissionDesc === "string" ? { name: permissionDesc } : permissionDesc;
  const state = ref();
  const onChange5 = /* @__PURE__ */ __name(() => {
    if (permissionStatus)
      state.value = permissionStatus.state;
  }, "onChange");
  const query = createSingletonPromise(async () => {
    if (!isSupported2.value)
      return;
    if (!permissionStatus) {
      try {
        permissionStatus = await navigator2.permissions.query(desc);
        useEventListener(permissionStatus, "change", onChange5);
        onChange5();
      } catch (e) {
        state.value = "prompt";
      }
    }
    return permissionStatus;
  });
  query();
  if (controls) {
    return {
      state,
      isSupported: isSupported2,
      query
    };
  } else {
    return state;
  }
}
__name(usePermission, "usePermission");
function useClipboard(options3 = {}) {
  const {
    navigator: navigator2 = defaultNavigator,
    read = false,
    source,
    copiedDuring = 1500,
    legacy = false
  } = options3;
  const isClipboardApiSupported = useSupported(() => navigator2 && "clipboard" in navigator2);
  const permissionRead = usePermission("clipboard-read");
  const permissionWrite = usePermission("clipboard-write");
  const isSupported2 = computed(() => isClipboardApiSupported.value || legacy);
  const text = ref("");
  const copied = ref(false);
  const timeout = useTimeoutFn(() => copied.value = false, copiedDuring);
  function updateText() {
    if (isClipboardApiSupported.value && isAllowed(permissionRead.value)) {
      navigator2.clipboard.readText().then((value3) => {
        text.value = value3;
      });
    } else {
      text.value = legacyRead();
    }
  }
  __name(updateText, "updateText");
  if (isSupported2.value && read)
    useEventListener(["copy", "cut"], updateText);
  async function copy(value3 = toValue(source)) {
    if (isSupported2.value && value3 != null) {
      if (isClipboardApiSupported.value && isAllowed(permissionWrite.value))
        await navigator2.clipboard.writeText(value3);
      else
        legacyCopy(value3);
      text.value = value3;
      copied.value = true;
      timeout.start();
    }
  }
  __name(copy, "copy");
  function legacyCopy(value3) {
    const ta = document.createElement("textarea");
    ta.value = value3 != null ? value3 : "";
    ta.style.position = "absolute";
    ta.style.opacity = "0";
    document.body.appendChild(ta);
    ta.select();
    document.execCommand("copy");
    ta.remove();
  }
  __name(legacyCopy, "legacyCopy");
  function legacyRead() {
    var _a, _b, _c;
    return (_c = (_b = (_a = document == null ? void 0 : document.getSelection) == null ? void 0 : _a.call(document)) == null ? void 0 : _b.toString()) != null ? _c : "";
  }
  __name(legacyRead, "legacyRead");
  function isAllowed(status) {
    return status === "granted" || status === "prompt";
  }
  __name(isAllowed, "isAllowed");
  return {
    isSupported: isSupported2,
    text,
    copied,
    copy
  };
}
__name(useClipboard, "useClipboard");
function useClipboardItems(options3 = {}) {
  const {
    navigator: navigator2 = defaultNavigator,
    read = false,
    source,
    copiedDuring = 1500
  } = options3;
  const isSupported2 = useSupported(() => navigator2 && "clipboard" in navigator2);
  const content = ref([]);
  const copied = ref(false);
  const timeout = useTimeoutFn(() => copied.value = false, copiedDuring);
  function updateContent() {
    if (isSupported2.value) {
      navigator2.clipboard.read().then((items2) => {
        content.value = items2;
      });
    }
  }
  __name(updateContent, "updateContent");
  if (isSupported2.value && read)
    useEventListener(["copy", "cut"], updateContent);
  async function copy(value3 = toValue(source)) {
    if (isSupported2.value && value3 != null) {
      await navigator2.clipboard.write(value3);
      content.value = value3;
      copied.value = true;
      timeout.start();
    }
  }
  __name(copy, "copy");
  return {
    isSupported: isSupported2,
    content,
    copied,
    copy
  };
}
__name(useClipboardItems, "useClipboardItems");
function cloneFnJSON(source) {
  return JSON.parse(JSON.stringify(source));
}
__name(cloneFnJSON, "cloneFnJSON");
function useCloned(source, options3 = {}) {
  const cloned = ref({});
  const {
    manual,
    clone: clone2 = cloneFnJSON,
    // watch options
    deep = true,
    immediate = true
  } = options3;
  function sync() {
    cloned.value = clone2(toValue(source));
  }
  __name(sync, "sync");
  if (!manual && (isRef(source) || typeof source === "function")) {
    watch(source, sync, {
      ...options3,
      deep,
      immediate
    });
  } else {
    sync();
  }
  return { cloned, sync };
}
__name(useCloned, "useCloned");
const _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
const globalKey = "__vueuse_ssr_handlers__";
const handlers = /* @__PURE__ */ getHandlers();
function getHandlers() {
  if (!(globalKey in _global))
    _global[globalKey] = _global[globalKey] || {};
  return _global[globalKey];
}
__name(getHandlers, "getHandlers");
function getSSRHandler(key, fallback) {
  return handlers[key] || fallback;
}
__name(getSSRHandler, "getSSRHandler");
function setSSRHandler(key, fn) {
  handlers[key] = fn;
}
__name(setSSRHandler, "setSSRHandler");
function guessSerializerType(rawInit) {
  return rawInit == null ? "any" : rawInit instanceof Set ? "set" : rawInit instanceof Map ? "map" : rawInit instanceof Date ? "date" : typeof rawInit === "boolean" ? "boolean" : typeof rawInit === "string" ? "string" : typeof rawInit === "object" ? "object" : !Number.isNaN(rawInit) ? "number" : "any";
}
__name(guessSerializerType, "guessSerializerType");
const StorageSerializers = {
  boolean: {
    read: /* @__PURE__ */ __name((v2) => v2 === "true", "read"),
    write: /* @__PURE__ */ __name((v2) => String(v2), "write")
  },
  object: {
    read: /* @__PURE__ */ __name((v2) => JSON.parse(v2), "read"),
    write: /* @__PURE__ */ __name((v2) => JSON.stringify(v2), "write")
  },
  number: {
    read: /* @__PURE__ */ __name((v2) => Number.parseFloat(v2), "read"),
    write: /* @__PURE__ */ __name((v2) => String(v2), "write")
  },
  any: {
    read: /* @__PURE__ */ __name((v2) => v2, "read"),
    write: /* @__PURE__ */ __name((v2) => String(v2), "write")
  },
  string: {
    read: /* @__PURE__ */ __name((v2) => v2, "read"),
    write: /* @__PURE__ */ __name((v2) => String(v2), "write")
  },
  map: {
    read: /* @__PURE__ */ __name((v2) => new Map(JSON.parse(v2)), "read"),
    write: /* @__PURE__ */ __name((v2) => JSON.stringify(Array.from(v2.entries())), "write")
  },
  set: {
    read: /* @__PURE__ */ __name((v2) => new Set(JSON.parse(v2)), "read"),
    write: /* @__PURE__ */ __name((v2) => JSON.stringify(Array.from(v2)), "write")
  },
  date: {
    read: /* @__PURE__ */ __name((v2) => new Date(v2), "read"),
    write: /* @__PURE__ */ __name((v2) => v2.toISOString(), "write")
  }
};
const customStorageEventName = "vueuse-storage";
function useStorage(key, defaults2, storage, options3 = {}) {
  var _a;
  const {
    flush = "pre",
    deep = true,
    listenToStorageChanges = true,
    writeDefaults = true,
    mergeDefaults: mergeDefaults2 = false,
    shallow,
    window: window2 = defaultWindow,
    eventFilter,
    onError = /* @__PURE__ */ __name((e) => {
      console.error(e);
    }, "onError"),
    initOnMounted
  } = options3;
  const data24 = (shallow ? shallowRef : ref)(typeof defaults2 === "function" ? defaults2() : defaults2);
  if (!storage) {
    try {
      storage = getSSRHandler("getDefaultStorage", () => {
        var _a2;
        return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;
      })();
    } catch (e) {
      onError(e);
    }
  }
  if (!storage)
    return data24;
  const rawInit = toValue(defaults2);
  const type = guessSerializerType(rawInit);
  const serializer = (_a = options3.serializer) != null ? _a : StorageSerializers[type];
  const { pause: pauseWatch, resume: resumeWatch } = watchPausable(
    data24,
    () => write(data24.value),
    { flush, deep, eventFilter }
  );
  if (window2 && listenToStorageChanges) {
    tryOnMounted(() => {
      if (storage instanceof Storage)
        useEventListener(window2, "storage", update2);
      else
        useEventListener(window2, customStorageEventName, updateFromCustomEvent);
      if (initOnMounted)
        update2();
    });
  }
  if (!initOnMounted)
    update2();
  function dispatchWriteEvent(oldValue, newValue) {
    if (window2 && !(storage instanceof Storage)) {
      window2.dispatchEvent(new CustomEvent(customStorageEventName, {
        detail: {
          key,
          oldValue,
          newValue,
          storageArea: storage
        }
      }));
    }
  }
  __name(dispatchWriteEvent, "dispatchWriteEvent");
  function write(v2) {
    try {
      const oldValue = storage.getItem(key);
      if (v2 == null) {
        dispatchWriteEvent(oldValue, null);
        storage.removeItem(key);
      } else {
        const serialized = serializer.write(v2);
        if (oldValue !== serialized) {
          storage.setItem(key, serialized);
          dispatchWriteEvent(oldValue, serialized);
        }
      }
    } catch (e) {
      onError(e);
    }
  }
  __name(write, "write");
  function read(event2) {
    const rawValue = event2 ? event2.newValue : storage.getItem(key);
    if (rawValue == null) {
      if (writeDefaults && rawInit != null)
        storage.setItem(key, serializer.write(rawInit));
      return rawInit;
    } else if (!event2 && mergeDefaults2) {
      const value3 = serializer.read(rawValue);
      if (typeof mergeDefaults2 === "function")
        return mergeDefaults2(value3, rawInit);
      else if (type === "object" && !Array.isArray(value3))
        return { ...rawInit, ...value3 };
      return value3;
    } else if (typeof rawValue !== "string") {
      return rawValue;
    } else {
      return serializer.read(rawValue);
    }
  }
  __name(read, "read");
  function update2(event2) {
    if (event2 && event2.storageArea !== storage)
      return;
    if (event2 && event2.key == null) {
      data24.value = rawInit;
      return;
    }
    if (event2 && event2.key !== key)
      return;
    pauseWatch();
    try {
      if ((event2 == null ? void 0 : event2.newValue) !== serializer.write(data24.value))
        data24.value = read(event2);
    } catch (e) {
      onError(e);
    } finally {
      if (event2)
        nextTick(resumeWatch);
      else
        resumeWatch();
    }
  }
  __name(update2, "update");
  function updateFromCustomEvent(event2) {
    update2(event2.detail);
  }
  __name(updateFromCustomEvent, "updateFromCustomEvent");
  return data24;
}
__name(useStorage, "useStorage");
function usePreferredDark(options3) {
  return useMediaQuery("(prefers-color-scheme: dark)", options3);
}
__name(usePreferredDark, "usePreferredDark");
const CSS_DISABLE_TRANS = "*,*::before,*::after{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}";
function useColorMode(options3 = {}) {
  const {
    selector = "html",
    attribute = "class",
    initialValue = "auto",
    window: window2 = defaultWindow,
    storage,
    storageKey = "vueuse-color-scheme",
    listenToStorageChanges = true,
    storageRef,
    emitAuto,
    disableTransition = true
  } = options3;
  const modes = {
    auto: "",
    light: "light",
    dark: "dark",
    ...options3.modes || {}
  };
  const preferredDark = usePreferredDark({ window: window2 });
  const system = computed(() => preferredDark.value ? "dark" : "light");
  const store = storageRef || (storageKey == null ? toRef(initialValue) : useStorage(storageKey, initialValue, storage, { window: window2, listenToStorageChanges }));
  const state = computed(() => store.value === "auto" ? system.value : store.value);
  const updateHTMLAttrs = getSSRHandler(
    "updateHTMLAttrs",
    (selector2, attribute2, value3) => {
      const el = typeof selector2 === "string" ? window2 == null ? void 0 : window2.document.querySelector(selector2) : unrefElement(selector2);
      if (!el)
        return;
      const classesToAdd = /* @__PURE__ */ new Set();
      const classesToRemove = /* @__PURE__ */ new Set();
      let attributeToChange = null;
      if (attribute2 === "class") {
        const current = value3.split(/\s/g);
        Object.values(modes).flatMap((i2) => (i2 || "").split(/\s/g)).filter(Boolean).forEach((v2) => {
          if (current.includes(v2))
            classesToAdd.add(v2);
          else
            classesToRemove.add(v2);
        });
      } else {
        attributeToChange = { key: attribute2, value: value3 };
      }
      if (classesToAdd.size === 0 && classesToRemove.size === 0 && attributeToChange === null)
        return;
      let style;
      if (disableTransition) {
        style = window2.document.createElement("style");
        style.appendChild(document.createTextNode(CSS_DISABLE_TRANS));
        window2.document.head.appendChild(style);
      }
      for (const c of classesToAdd) {
        el.classList.add(c);
      }
      for (const c of classesToRemove) {
        el.classList.remove(c);
      }
      if (attributeToChange) {
        el.setAttribute(attributeToChange.key, attributeToChange.value);
      }
      if (disableTransition) {
        window2.getComputedStyle(style).opacity;
        document.head.removeChild(style);
      }
    }
  );
  function defaultOnChanged(mode2) {
    var _a;
    updateHTMLAttrs(selector, attribute, (_a = modes[mode2]) != null ? _a : mode2);
  }
  __name(defaultOnChanged, "defaultOnChanged");
  function onChanged(mode2) {
    if (options3.onChanged)
      options3.onChanged(mode2, defaultOnChanged);
    else
      defaultOnChanged(mode2);
  }
  __name(onChanged, "onChanged");
  watch(state, onChanged, { flush: "post", immediate: true });
  tryOnMounted(() => onChanged(state.value));
  const auto = computed({
    get() {
      return emitAuto ? store.value : state.value;
    },
    set(v2) {
      store.value = v2;
    }
  });
  try {
    return Object.assign(auto, { store, system, state });
  } catch (e) {
    return auto;
  }
}
__name(useColorMode, "useColorMode");
function useConfirmDialog(revealed = ref(false)) {
  const confirmHook = createEventHook();
  const cancelHook = createEventHook();
  const revealHook = createEventHook();
  let _resolve = noop;
  const reveal = /* @__PURE__ */ __name((data24) => {
    revealHook.trigger(data24);
    revealed.value = true;
    return new Promise((resolve8) => {
      _resolve = resolve8;
    });
  }, "reveal");
  const confirm2 = /* @__PURE__ */ __name((data24) => {
    revealed.value = false;
    confirmHook.trigger(data24);
    _resolve({ data: data24, isCanceled: false });
  }, "confirm");
  const cancel = /* @__PURE__ */ __name((data24) => {
    revealed.value = false;
    cancelHook.trigger(data24);
    _resolve({ data: data24, isCanceled: true });
  }, "cancel");
  return {
    isRevealed: computed(() => revealed.value),
    reveal,
    confirm: confirm2,
    cancel,
    onReveal: revealHook.on,
    onConfirm: confirmHook.on,
    onCancel: cancelHook.on
  };
}
__name(useConfirmDialog, "useConfirmDialog");
function useCssVar(prop2, target, options3 = {}) {
  const { window: window2 = defaultWindow, initialValue, observe = false } = options3;
  const variable = ref(initialValue);
  const elRef = computed(() => {
    var _a;
    return unrefElement(target) || ((_a = window2 == null ? void 0 : window2.document) == null ? void 0 : _a.documentElement);
  });
  function updateCssVar() {
    var _a;
    const key = toValue(prop2);
    const el = toValue(elRef);
    if (el && window2 && key) {
      const value3 = (_a = window2.getComputedStyle(el).getPropertyValue(key)) == null ? void 0 : _a.trim();
      variable.value = value3 || initialValue;
    }
  }
  __name(updateCssVar, "updateCssVar");
  if (observe) {
    useMutationObserver(elRef, updateCssVar, {
      attributeFilter: ["style", "class"],
      window: window2
    });
  }
  watch(
    [elRef, () => toValue(prop2)],
    (_2, old) => {
      if (old[0] && old[1] && window2)
        window2.getComputedStyle(old[0]).removeProperty(old[1]);
      updateCssVar();
    },
    { immediate: true }
  );
  watch(
    variable,
    (val) => {
      var _a;
      const raw_prop = toValue(prop2);
      if (((_a = elRef.value) == null ? void 0 : _a.style) && raw_prop) {
        if (val == null)
          elRef.value.style.removeProperty(raw_prop);
        else
          elRef.value.style.setProperty(raw_prop, val);
      }
    }
  );
  return variable;
}
__name(useCssVar, "useCssVar");
function useCurrentElement(rootComponent) {
  const vm = getCurrentInstance();
  const currentElement = computedWithControl(
    () => null,
    () => rootComponent ? unrefElement(rootComponent) : vm.proxy.$el
  );
  onUpdated(currentElement.trigger);
  onMounted(currentElement.trigger);
  return currentElement;
}
__name(useCurrentElement, "useCurrentElement");
function useCycleList(list, options3) {
  const state = shallowRef(getInitialValue());
  const listRef5 = toRef(list);
  const index2 = computed({
    get() {
      var _a;
      const targetList = listRef5.value;
      let index22 = (options3 == null ? void 0 : options3.getIndexOf) ? options3.getIndexOf(state.value, targetList) : targetList.indexOf(state.value);
      if (index22 < 0)
        index22 = (_a = options3 == null ? void 0 : options3.fallbackIndex) != null ? _a : 0;
      return index22;
    },
    set(v2) {
      set2(v2);
    }
  });
  function set2(i2) {
    const targetList = listRef5.value;
    const length = targetList.length;
    const index22 = (i2 % length + length) % length;
    const value3 = targetList[index22];
    state.value = value3;
    return value3;
  }
  __name(set2, "set2");
  function shift(delta2 = 1) {
    return set2(index2.value + delta2);
  }
  __name(shift, "shift");
  function next2(n = 1) {
    return shift(n);
  }
  __name(next2, "next");
  function prev2(n = 1) {
    return shift(-n);
  }
  __name(prev2, "prev");
  function getInitialValue() {
    var _a, _b;
    return (_b = toValue((_a = options3 == null ? void 0 : options3.initialValue) != null ? _a : toValue(list)[0])) != null ? _b : void 0;
  }
  __name(getInitialValue, "getInitialValue");
  watch(listRef5, () => set2(index2.value));
  return {
    state,
    index: index2,
    next: next2,
    prev: prev2,
    go: set2
  };
}
__name(useCycleList, "useCycleList");
function useDark(options3 = {}) {
  const {
    valueDark = "dark",
    valueLight = "",
    window: window2 = defaultWindow
  } = options3;
  const mode2 = useColorMode({
    ...options3,
    onChanged: /* @__PURE__ */ __name((mode22, defaultHandler) => {
      var _a;
      if (options3.onChanged)
        (_a = options3.onChanged) == null ? void 0 : _a.call(options3, mode22 === "dark", defaultHandler, mode22);
      else
        defaultHandler(mode22);
    }, "onChanged"),
    modes: {
      dark: valueDark,
      light: valueLight
    }
  });
  const system = computed(() => {
    if (mode2.system) {
      return mode2.system.value;
    } else {
      const preferredDark = usePreferredDark({ window: window2 });
      return preferredDark.value ? "dark" : "light";
    }
  });
  const isDark = computed({
    get() {
      return mode2.value === "dark";
    },
    set(v2) {
      const modeVal = v2 ? "dark" : "light";
      if (system.value === modeVal)
        mode2.value = "auto";
      else
        mode2.value = modeVal;
    }
  });
  return isDark;
}
__name(useDark, "useDark");
function fnBypass(v2) {
  return v2;
}
__name(fnBypass, "fnBypass");
function fnSetSource(source, value3) {
  return source.value = value3;
}
__name(fnSetSource, "fnSetSource");
function defaultDump(clone2) {
  return clone2 ? typeof clone2 === "function" ? clone2 : cloneFnJSON : fnBypass;
}
__name(defaultDump, "defaultDump");
function defaultParse(clone2) {
  return clone2 ? typeof clone2 === "function" ? clone2 : cloneFnJSON : fnBypass;
}
__name(defaultParse, "defaultParse");
function useManualRefHistory(source, options3 = {}) {
  const {
    clone: clone2 = false,
    dump = defaultDump(clone2),
    parse: parse2 = defaultParse(clone2),
    setSource = fnSetSource
  } = options3;
  function _createHistoryRecord() {
    return markRaw({
      snapshot: dump(source.value),
      timestamp: timestamp()
    });
  }
  __name(_createHistoryRecord, "_createHistoryRecord");
  const last = ref(_createHistoryRecord());
  const undoStack = ref([]);
  const redoStack = ref([]);
  const _setSource = /* @__PURE__ */ __name((record) => {
    setSource(source, parse2(record.snapshot));
    last.value = record;
  }, "_setSource");
  const commit = /* @__PURE__ */ __name(() => {
    undoStack.value.unshift(last.value);
    last.value = _createHistoryRecord();
    if (options3.capacity && undoStack.value.length > options3.capacity)
      undoStack.value.splice(options3.capacity, Number.POSITIVE_INFINITY);
    if (redoStack.value.length)
      redoStack.value.splice(0, redoStack.value.length);
  }, "commit");
  const clear3 = /* @__PURE__ */ __name(() => {
    undoStack.value.splice(0, undoStack.value.length);
    redoStack.value.splice(0, redoStack.value.length);
  }, "clear");
  const undo = /* @__PURE__ */ __name(() => {
    const state = undoStack.value.shift();
    if (state) {
      redoStack.value.unshift(last.value);
      _setSource(state);
    }
  }, "undo");
  const redo = /* @__PURE__ */ __name(() => {
    const state = redoStack.value.shift();
    if (state) {
      undoStack.value.unshift(last.value);
      _setSource(state);
    }
  }, "redo");
  const reset = /* @__PURE__ */ __name(() => {
    _setSource(last.value);
  }, "reset");
  const history = computed(() => [last.value, ...undoStack.value]);
  const canUndo = computed(() => undoStack.value.length > 0);
  const canRedo = computed(() => redoStack.value.length > 0);
  return {
    source,
    undoStack,
    redoStack,
    last,
    history,
    canUndo,
    canRedo,
    clear: clear3,
    commit,
    reset,
    undo,
    redo
  };
}
__name(useManualRefHistory, "useManualRefHistory");
function useRefHistory(source, options3 = {}) {
  const {
    deep = false,
    flush = "pre",
    eventFilter
  } = options3;
  const {
    eventFilter: composedFilter,
    pause,
    resume: resumeTracking,
    isActive: isTracking
  } = pausableFilter(eventFilter);
  const {
    ignoreUpdates,
    ignorePrevAsyncUpdates,
    stop: stop2
  } = watchIgnorable(
    source,
    commit,
    { deep, flush, eventFilter: composedFilter }
  );
  function setSource(source2, value3) {
    ignorePrevAsyncUpdates();
    ignoreUpdates(() => {
      source2.value = value3;
    });
  }
  __name(setSource, "setSource");
  const manualHistory = useManualRefHistory(source, { ...options3, clone: options3.clone || deep, setSource });
  const { clear: clear3, commit: manualCommit } = manualHistory;
  function commit() {
    ignorePrevAsyncUpdates();
    manualCommit();
  }
  __name(commit, "commit");
  function resume(commitNow) {
    resumeTracking();
    if (commitNow)
      commit();
  }
  __name(resume, "resume");
  function batch(fn) {
    let canceled = false;
    const cancel = /* @__PURE__ */ __name(() => canceled = true, "cancel");
    ignoreUpdates(() => {
      fn(cancel);
    });
    if (!canceled)
      commit();
  }
  __name(batch, "batch");
  function dispose() {
    stop2();
    clear3();
  }
  __name(dispose, "dispose");
  return {
    ...manualHistory,
    isTracking,
    pause,
    resume,
    commit,
    batch,
    dispose
  };
}
__name(useRefHistory, "useRefHistory");
function useDebouncedRefHistory(source, options3 = {}) {
  const filter4 = options3.debounce ? debounceFilter(options3.debounce) : void 0;
  const history = useRefHistory(source, { ...options3, eventFilter: filter4 });
  return {
    ...history
  };
}
__name(useDebouncedRefHistory, "useDebouncedRefHistory");
function useDeviceMotion(options3 = {}) {
  const {
    window: window2 = defaultWindow,
    eventFilter = bypassFilter
  } = options3;
  const acceleration = ref({ x: null, y: null, z: null });
  const rotationRate = ref({ alpha: null, beta: null, gamma: null });
  const interval = ref(0);
  const accelerationIncludingGravity = ref({
    x: null,
    y: null,
    z: null
  });
  if (window2) {
    const onDeviceMotion = createFilterWrapper(
      eventFilter,
      (event2) => {
        acceleration.value = event2.acceleration;
        accelerationIncludingGravity.value = event2.accelerationIncludingGravity;
        rotationRate.value = event2.rotationRate;
        interval.value = event2.interval;
      }
    );
    useEventListener(window2, "devicemotion", onDeviceMotion);
  }
  return {
    acceleration,
    accelerationIncludingGravity,
    rotationRate,
    interval
  };
}
__name(useDeviceMotion, "useDeviceMotion");
function useDeviceOrientation(options3 = {}) {
  const { window: window2 = defaultWindow } = options3;
  const isSupported2 = useSupported(() => window2 && "DeviceOrientationEvent" in window2);
  const isAbsolute = ref(false);
  const alpha = ref(null);
  const beta = ref(null);
  const gamma = ref(null);
  if (window2 && isSupported2.value) {
    useEventListener(window2, "deviceorientation", (event2) => {
      isAbsolute.value = event2.absolute;
      alpha.value = event2.alpha;
      beta.value = event2.beta;
      gamma.value = event2.gamma;
    });
  }
  return {
    isSupported: isSupported2,
    isAbsolute,
    alpha,
    beta,
    gamma
  };
}
__name(useDeviceOrientation, "useDeviceOrientation");
function useDevicePixelRatio(options3 = {}) {
  const {
    window: window2 = defaultWindow
  } = options3;
  const pixelRatio = ref(1);
  if (window2) {
    let observe2 = /* @__PURE__ */ __name(function() {
      pixelRatio.value = window2.devicePixelRatio;
      cleanup2();
      media = window2.matchMedia(`(resolution: ${pixelRatio.value}dppx)`);
      media.addEventListener("change", observe2, { once: true });
    }, "observe2"), cleanup2 = /* @__PURE__ */ __name(function() {
      media == null ? void 0 : media.removeEventListener("change", observe2);
    }, "cleanup2");
    let media;
    observe2();
    tryOnScopeDispose(cleanup2);
  }
  return { pixelRatio };
}
__name(useDevicePixelRatio, "useDevicePixelRatio");
function useDevicesList(options3 = {}) {
  const {
    navigator: navigator2 = defaultNavigator,
    requestPermissions = false,
    constraints = { audio: true, video: true },
    onUpdated: onUpdated2
  } = options3;
  const devices = ref([]);
  const videoInputs = computed(() => devices.value.filter((i2) => i2.kind === "videoinput"));
  const audioInputs = computed(() => devices.value.filter((i2) => i2.kind === "audioinput"));
  const audioOutputs = computed(() => devices.value.filter((i2) => i2.kind === "audiooutput"));
  const isSupported2 = useSupported(() => navigator2 && navigator2.mediaDevices && navigator2.mediaDevices.enumerateDevices);
  const permissionGranted = ref(false);
  let stream;
  async function update2() {
    if (!isSupported2.value)
      return;
    devices.value = await navigator2.mediaDevices.enumerateDevices();
    onUpdated2 == null ? void 0 : onUpdated2(devices.value);
    if (stream) {
      stream.getTracks().forEach((t) => t.stop());
      stream = null;
    }
  }
  __name(update2, "update");
  async function ensurePermissions() {
    if (!isSupported2.value)
      return false;
    if (permissionGranted.value)
      return true;
    const { state, query } = usePermission("camera", { controls: true });
    await query();
    if (state.value !== "granted") {
      stream = await navigator2.mediaDevices.getUserMedia(constraints);
      update2();
      permissionGranted.value = true;
    } else {
      permissionGranted.value = true;
    }
    return permissionGranted.value;
  }
  __name(ensurePermissions, "ensurePermissions");
  if (isSupported2.value) {
    if (requestPermissions)
      ensurePermissions();
    useEventListener(navigator2.mediaDevices, "devicechange", update2);
    update2();
  }
  return {
    devices,
    ensurePermissions,
    permissionGranted,
    videoInputs,
    audioInputs,
    audioOutputs,
    isSupported: isSupported2
  };
}
__name(useDevicesList, "useDevicesList");
function useDisplayMedia(options3 = {}) {
  var _a;
  const enabled = ref((_a = options3.enabled) != null ? _a : false);
  const video = options3.video;
  const audio = options3.audio;
  const { navigator: navigator2 = defaultNavigator } = options3;
  const isSupported2 = useSupported(() => {
    var _a2;
    return (_a2 = navigator2 == null ? void 0 : navigator2.mediaDevices) == null ? void 0 : _a2.getDisplayMedia;
  });
  const constraint = { audio, video };
  const stream = shallowRef();
  async function _start() {
    var _a2;
    if (!isSupported2.value || stream.value)
      return;
    stream.value = await navigator2.mediaDevices.getDisplayMedia(constraint);
    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => t.addEventListener("ended", stop2));
    return stream.value;
  }
  __name(_start, "_start");
  async function _stop() {
    var _a2;
    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => t.stop());
    stream.value = void 0;
  }
  __name(_stop, "_stop");
  function stop2() {
    _stop();
    enabled.value = false;
  }
  __name(stop2, "stop");
  async function start2() {
    await _start();
    if (stream.value)
      enabled.value = true;
    return stream.value;
  }
  __name(start2, "start");
  watch(
    enabled,
    (v2) => {
      if (v2)
        _start();
      else
        _stop();
    },
    { immediate: true }
  );
  return {
    isSupported: isSupported2,
    stream,
    start: start2,
    stop: stop2,
    enabled
  };
}
__name(useDisplayMedia, "useDisplayMedia");
function useDocumentVisibility(options3 = {}) {
  const { document: document2 = defaultDocument } = options3;
  if (!document2)
    return ref("visible");
  const visibility = ref(document2.visibilityState);
  useEventListener(document2, "visibilitychange", () => {
    visibility.value = document2.visibilityState;
  });
  return visibility;
}
__name(useDocumentVisibility, "useDocumentVisibility");
function useDraggable(target, options3 = {}) {
  var _a, _b;
  const {
    pointerTypes,
    preventDefault: preventDefault2,
    stopPropagation,
    exact,
    onMove,
    onEnd,
    onStart,
    initialValue,
    axis = "both",
    draggingElement = defaultWindow,
    containerElement,
    handle: draggingHandle = target,
    buttons = [0]
  } = options3;
  const position2 = ref(
    (_a = toValue(initialValue)) != null ? _a : { x: 0, y: 0 }
  );
  const pressedDelta = ref();
  const filterEvent = /* @__PURE__ */ __name((e) => {
    if (pointerTypes)
      return pointerTypes.includes(e.pointerType);
    return true;
  }, "filterEvent");
  const handleEvent = /* @__PURE__ */ __name((e) => {
    if (toValue(preventDefault2))
      e.preventDefault();
    if (toValue(stopPropagation))
      e.stopPropagation();
  }, "handleEvent");
  const start2 = /* @__PURE__ */ __name((e) => {
    var _a2;
    if (!toValue(buttons).includes(e.button))
      return;
    if (toValue(options3.disabled) || !filterEvent(e))
      return;
    if (toValue(exact) && e.target !== toValue(target))
      return;
    const container = toValue(containerElement);
    const containerRect = (_a2 = container == null ? void 0 : container.getBoundingClientRect) == null ? void 0 : _a2.call(container);
    const targetRect = toValue(target).getBoundingClientRect();
    const pos2 = {
      x: e.clientX - (container ? targetRect.left - containerRect.left + container.scrollLeft : targetRect.left),
      y: e.clientY - (container ? targetRect.top - containerRect.top + container.scrollTop : targetRect.top)
    };
    if ((onStart == null ? void 0 : onStart(pos2, e)) === false)
      return;
    pressedDelta.value = pos2;
    handleEvent(e);
  }, "start");
  const move = /* @__PURE__ */ __name((e) => {
    if (toValue(options3.disabled) || !filterEvent(e))
      return;
    if (!pressedDelta.value)
      return;
    const container = toValue(containerElement);
    const targetRect = toValue(target).getBoundingClientRect();
    let { x: x2, y: y2 } = position2.value;
    if (axis === "x" || axis === "both") {
      x2 = e.clientX - pressedDelta.value.x;
      if (container)
        x2 = Math.min(Math.max(0, x2), container.scrollWidth - targetRect.width);
    }
    if (axis === "y" || axis === "both") {
      y2 = e.clientY - pressedDelta.value.y;
      if (container)
        y2 = Math.min(Math.max(0, y2), container.scrollHeight - targetRect.height);
    }
    position2.value = {
      x: x2,
      y: y2
    };
    onMove == null ? void 0 : onMove(position2.value, e);
    handleEvent(e);
  }, "move");
  const end = /* @__PURE__ */ __name((e) => {
    if (toValue(options3.disabled) || !filterEvent(e))
      return;
    if (!pressedDelta.value)
      return;
    pressedDelta.value = void 0;
    onEnd == null ? void 0 : onEnd(position2.value, e);
    handleEvent(e);
  }, "end");
  if (isClient) {
    const config = { capture: (_b = options3.capture) != null ? _b : true };
    useEventListener(draggingHandle, "pointerdown", start2, config);
    useEventListener(draggingElement, "pointermove", move, config);
    useEventListener(draggingElement, "pointerup", end, config);
  }
  return {
    ...toRefs(position2),
    position: position2,
    isDragging: computed(() => !!pressedDelta.value),
    style: computed(
      () => `left:${position2.value.x}px;top:${position2.value.y}px;`
    )
  };
}
__name(useDraggable, "useDraggable");
function useDropZone(target, options3 = {}) {
  const isOverDropZone = ref(false);
  const files = shallowRef(null);
  let counter = 0;
  let isDataTypeIncluded = true;
  if (isClient) {
    const _options = typeof options3 === "function" ? { onDrop: options3 } : options3;
    const getFiles = /* @__PURE__ */ __name((event2) => {
      var _a, _b;
      const list = Array.from((_b = (_a = event2.dataTransfer) == null ? void 0 : _a.files) != null ? _b : []);
      return files.value = list.length === 0 ? null : list;
    }, "getFiles");
    useEventListener(target, "dragenter", (event2) => {
      var _a, _b;
      const types = Array.from(((_a = event2 == null ? void 0 : event2.dataTransfer) == null ? void 0 : _a.items) || []).map((i2) => i2.kind === "file" ? i2.type : null).filter(notNullish);
      if (_options.dataTypes && event2.dataTransfer) {
        const dataTypes = unref(_options.dataTypes);
        isDataTypeIncluded = typeof dataTypes === "function" ? dataTypes(types) : dataTypes ? dataTypes.some((item2) => types.includes(item2)) : true;
        if (!isDataTypeIncluded)
          return;
      }
      event2.preventDefault();
      counter += 1;
      isOverDropZone.value = true;
      (_b = _options.onEnter) == null ? void 0 : _b.call(_options, getFiles(event2), event2);
    });
    useEventListener(target, "dragover", (event2) => {
      var _a;
      if (!isDataTypeIncluded)
        return;
      event2.preventDefault();
      (_a = _options.onOver) == null ? void 0 : _a.call(_options, getFiles(event2), event2);
    });
    useEventListener(target, "dragleave", (event2) => {
      var _a;
      if (!isDataTypeIncluded)
        return;
      event2.preventDefault();
      counter -= 1;
      if (counter === 0)
        isOverDropZone.value = false;
      (_a = _options.onLeave) == null ? void 0 : _a.call(_options, getFiles(event2), event2);
    });
    useEventListener(target, "drop", (event2) => {
      var _a;
      event2.preventDefault();
      counter = 0;
      isOverDropZone.value = false;
      (_a = _options.onDrop) == null ? void 0 : _a.call(_options, getFiles(event2), event2);
    });
  }
  return {
    files,
    isOverDropZone
  };
}
__name(useDropZone, "useDropZone");
function useResizeObserver(target, callback, options3 = {}) {
  const { window: window2 = defaultWindow, ...observerOptions } = options3;
  let observer;
  const isSupported2 = useSupported(() => window2 && "ResizeObserver" in window2);
  const cleanup = /* @__PURE__ */ __name(() => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  }, "cleanup");
  const targets = computed(() => {
    const _targets = toValue(target);
    return Array.isArray(_targets) ? _targets.map((el) => unrefElement(el)) : [unrefElement(_targets)];
  });
  const stopWatch = watch(
    targets,
    (els) => {
      cleanup();
      if (isSupported2.value && window2) {
        observer = new ResizeObserver(callback);
        for (const _el of els) {
          if (_el)
            observer.observe(_el, observerOptions);
        }
      }
    },
    { immediate: true, flush: "post" }
  );
  const stop2 = /* @__PURE__ */ __name(() => {
    cleanup();
    stopWatch();
  }, "stop");
  tryOnScopeDispose(stop2);
  return {
    isSupported: isSupported2,
    stop: stop2
  };
}
__name(useResizeObserver, "useResizeObserver");
function useElementBounding(target, options3 = {}) {
  const {
    reset = true,
    windowResize = true,
    windowScroll = true,
    immediate = true,
    updateTiming = "sync"
  } = options3;
  const height = ref(0);
  const bottom = ref(0);
  const left = ref(0);
  const right = ref(0);
  const top = ref(0);
  const width2 = ref(0);
  const x2 = ref(0);
  const y2 = ref(0);
  function recalculate() {
    const el = unrefElement(target);
    if (!el) {
      if (reset) {
        height.value = 0;
        bottom.value = 0;
        left.value = 0;
        right.value = 0;
        top.value = 0;
        width2.value = 0;
        x2.value = 0;
        y2.value = 0;
      }
      return;
    }
    const rect = el.getBoundingClientRect();
    height.value = rect.height;
    bottom.value = rect.bottom;
    left.value = rect.left;
    right.value = rect.right;
    top.value = rect.top;
    width2.value = rect.width;
    x2.value = rect.x;
    y2.value = rect.y;
  }
  __name(recalculate, "recalculate");
  function update2() {
    if (updateTiming === "sync")
      recalculate();
    else if (updateTiming === "next-frame")
      requestAnimationFrame(() => recalculate());
  }
  __name(update2, "update");
  useResizeObserver(target, update2);
  watch(() => unrefElement(target), (ele) => !ele && update2());
  useMutationObserver(target, update2, {
    attributeFilter: ["style", "class"]
  });
  if (windowScroll)
    useEventListener("scroll", update2, { capture: true, passive: true });
  if (windowResize)
    useEventListener("resize", update2, { passive: true });
  tryOnMounted(() => {
    if (immediate)
      update2();
  });
  return {
    height,
    bottom,
    left,
    right,
    top,
    width: width2,
    x: x2,
    y: y2,
    update: update2
  };
}
__name(useElementBounding, "useElementBounding");
function useElementByPoint(options3) {
  const {
    x: x2,
    y: y2,
    document: document2 = defaultDocument,
    multiple,
    interval = "requestAnimationFrame",
    immediate = true
  } = options3;
  const isSupported2 = useSupported(() => {
    if (toValue(multiple))
      return document2 && "elementsFromPoint" in document2;
    return document2 && "elementFromPoint" in document2;
  });
  const element = ref(null);
  const cb = /* @__PURE__ */ __name(() => {
    var _a, _b;
    element.value = toValue(multiple) ? (_a = document2 == null ? void 0 : document2.elementsFromPoint(toValue(x2), toValue(y2))) != null ? _a : [] : (_b = document2 == null ? void 0 : document2.elementFromPoint(toValue(x2), toValue(y2))) != null ? _b : null;
  }, "cb");
  const controls = interval === "requestAnimationFrame" ? useRafFn(cb, { immediate }) : useIntervalFn(cb, interval, { immediate });
  return {
    isSupported: isSupported2,
    element,
    ...controls
  };
}
__name(useElementByPoint, "useElementByPoint");
function useElementHover(el, options3 = {}) {
  const {
    delayEnter = 0,
    delayLeave = 0,
    window: window2 = defaultWindow
  } = options3;
  const isHovered = ref(false);
  let timer;
  const toggle4 = /* @__PURE__ */ __name((entering) => {
    const delay = entering ? delayEnter : delayLeave;
    if (timer) {
      clearTimeout(timer);
      timer = void 0;
    }
    if (delay)
      timer = setTimeout(() => isHovered.value = entering, delay);
    else
      isHovered.value = entering;
  }, "toggle");
  if (!window2)
    return isHovered;
  useEventListener(el, "mouseenter", () => toggle4(true), { passive: true });
  useEventListener(el, "mouseleave", () => toggle4(false), { passive: true });
  return isHovered;
}
__name(useElementHover, "useElementHover");
function useElementSize(target, initialSize = { width: 0, height: 0 }, options3 = {}) {
  const { window: window2 = defaultWindow, box = "content-box" } = options3;
  const isSVG = computed(() => {
    var _a, _b;
    return (_b = (_a = unrefElement(target)) == null ? void 0 : _a.namespaceURI) == null ? void 0 : _b.includes("svg");
  });
  const width2 = ref(initialSize.width);
  const height = ref(initialSize.height);
  const { stop: stop1 } = useResizeObserver(
    target,
    ([entry]) => {
      const boxSize = box === "border-box" ? entry.borderBoxSize : box === "content-box" ? entry.contentBoxSize : entry.devicePixelContentBoxSize;
      if (window2 && isSVG.value) {
        const $elem = unrefElement(target);
        if ($elem) {
          const rect = $elem.getBoundingClientRect();
          width2.value = rect.width;
          height.value = rect.height;
        }
      } else {
        if (boxSize) {
          const formatBoxSize = Array.isArray(boxSize) ? boxSize : [boxSize];
          width2.value = formatBoxSize.reduce((acc, { inlineSize }) => acc + inlineSize, 0);
          height.value = formatBoxSize.reduce((acc, { blockSize }) => acc + blockSize, 0);
        } else {
          width2.value = entry.contentRect.width;
          height.value = entry.contentRect.height;
        }
      }
    },
    options3
  );
  tryOnMounted(() => {
    const ele = unrefElement(target);
    if (ele) {
      width2.value = "offsetWidth" in ele ? ele.offsetWidth : initialSize.width;
      height.value = "offsetHeight" in ele ? ele.offsetHeight : initialSize.height;
    }
  });
  const stop2 = watch(
    () => unrefElement(target),
    (ele) => {
      width2.value = ele ? initialSize.width : 0;
      height.value = ele ? initialSize.height : 0;
    }
  );
  function stop3() {
    stop1();
    stop2();
  }
  __name(stop3, "stop");
  return {
    width: width2,
    height,
    stop: stop3
  };
}
__name(useElementSize, "useElementSize");
function useIntersectionObserver(target, callback, options3 = {}) {
  const {
    root: root26,
    rootMargin = "0px",
    threshold = 0,
    window: window2 = defaultWindow,
    immediate = true
  } = options3;
  const isSupported2 = useSupported(() => window2 && "IntersectionObserver" in window2);
  const targets = computed(() => {
    const _target = toValue(target);
    return (Array.isArray(_target) ? _target : [_target]).map(unrefElement).filter(notNullish);
  });
  let cleanup = noop;
  const isActive = ref(immediate);
  const stopWatch = isSupported2.value ? watch(
    () => [targets.value, unrefElement(root26), isActive.value],
    ([targets2, root27]) => {
      cleanup();
      if (!isActive.value)
        return;
      if (!targets2.length)
        return;
      const observer = new IntersectionObserver(
        callback,
        {
          root: unrefElement(root27),
          rootMargin,
          threshold
        }
      );
      targets2.forEach((el) => el && observer.observe(el));
      cleanup = /* @__PURE__ */ __name(() => {
        observer.disconnect();
        cleanup = noop;
      }, "cleanup");
    },
    { immediate, flush: "post" }
  ) : noop;
  const stop2 = /* @__PURE__ */ __name(() => {
    cleanup();
    stopWatch();
    isActive.value = false;
  }, "stop");
  tryOnScopeDispose(stop2);
  return {
    isSupported: isSupported2,
    isActive,
    pause() {
      cleanup();
      isActive.value = false;
    },
    resume() {
      isActive.value = true;
    },
    stop: stop2
  };
}
__name(useIntersectionObserver, "useIntersectionObserver");
function useElementVisibility(element, options3 = {}) {
  const { window: window2 = defaultWindow, scrollTarget, threshold = 0 } = options3;
  const elementIsVisible = ref(false);
  useIntersectionObserver(
    element,
    (intersectionObserverEntries) => {
      let isIntersecting = elementIsVisible.value;
      let latestTime = 0;
      for (const entry of intersectionObserverEntries) {
        if (entry.time >= latestTime) {
          latestTime = entry.time;
          isIntersecting = entry.isIntersecting;
        }
      }
      elementIsVisible.value = isIntersecting;
    },
    {
      root: scrollTarget,
      window: window2,
      threshold
    }
  );
  return elementIsVisible;
}
__name(useElementVisibility, "useElementVisibility");
const events = /* @__PURE__ */ new Map();
function useEventBus(key) {
  const scope = getCurrentScope();
  function on(listener) {
    var _a;
    const listeners = events.get(key) || /* @__PURE__ */ new Set();
    listeners.add(listener);
    events.set(key, listeners);
    const _off = /* @__PURE__ */ __name(() => off(listener), "_off");
    (_a = scope == null ? void 0 : scope.cleanups) == null ? void 0 : _a.push(_off);
    return _off;
  }
  __name(on, "on");
  function once2(listener) {
    function _listener(...args) {
      off(_listener);
      listener(...args);
    }
    __name(_listener, "_listener");
    return on(_listener);
  }
  __name(once2, "once");
  function off(listener) {
    const listeners = events.get(key);
    if (!listeners)
      return;
    listeners.delete(listener);
    if (!listeners.size)
      reset();
  }
  __name(off, "off");
  function reset() {
    events.delete(key);
  }
  __name(reset, "reset");
  function emit2(event2, payload) {
    var _a;
    (_a = events.get(key)) == null ? void 0 : _a.forEach((v2) => v2(event2, payload));
  }
  __name(emit2, "emit");
  return { on, once: once2, off, emit: emit2, reset };
}
__name(useEventBus, "useEventBus");
function resolveNestedOptions$1(options3) {
  if (options3 === true)
    return {};
  return options3;
}
__name(resolveNestedOptions$1, "resolveNestedOptions$1");
function useEventSource(url, events2 = [], options3 = {}) {
  const event2 = ref(null);
  const data24 = ref(null);
  const status = ref("CONNECTING");
  const eventSource = ref(null);
  const error = shallowRef(null);
  const urlRef = toRef(url);
  const lastEventId = shallowRef(null);
  let explicitlyClosed = false;
  let retried = 0;
  const {
    withCredentials = false,
    immediate = true
  } = options3;
  const close4 = /* @__PURE__ */ __name(() => {
    if (isClient && eventSource.value) {
      eventSource.value.close();
      eventSource.value = null;
      status.value = "CLOSED";
      explicitlyClosed = true;
    }
  }, "close");
  const _init = /* @__PURE__ */ __name(() => {
    if (explicitlyClosed || typeof urlRef.value === "undefined")
      return;
    const es = new EventSource(urlRef.value, { withCredentials });
    status.value = "CONNECTING";
    eventSource.value = es;
    es.onopen = () => {
      status.value = "OPEN";
      error.value = null;
    };
    es.onerror = (e) => {
      status.value = "CLOSED";
      error.value = e;
      if (es.readyState === 2 && !explicitlyClosed && options3.autoReconnect) {
        es.close();
        const {
          retries = -1,
          delay = 1e3,
          onFailed
        } = resolveNestedOptions$1(options3.autoReconnect);
        retried += 1;
        if (typeof retries === "number" && (retries < 0 || retried < retries))
          setTimeout(_init, delay);
        else if (typeof retries === "function" && retries())
          setTimeout(_init, delay);
        else
          onFailed == null ? void 0 : onFailed();
      }
    };
    es.onmessage = (e) => {
      event2.value = null;
      data24.value = e.data;
      lastEventId.value = e.lastEventId;
    };
    for (const event_name of events2) {
      useEventListener(es, event_name, (e) => {
        event2.value = event_name;
        data24.value = e.data || null;
      });
    }
  }, "_init");
  const open2 = /* @__PURE__ */ __name(() => {
    if (!isClient)
      return;
    close4();
    explicitlyClosed = false;
    retried = 0;
    _init();
  }, "open");
  if (immediate)
    watch(urlRef, open2, { immediate: true });
  tryOnScopeDispose(close4);
  return {
    eventSource,
    event: event2,
    data: data24,
    status,
    error,
    open: open2,
    close: close4,
    lastEventId
  };
}
__name(useEventSource, "useEventSource");
function useEyeDropper(options3 = {}) {
  const { initialValue = "" } = options3;
  const isSupported2 = useSupported(() => typeof window !== "undefined" && "EyeDropper" in window);
  const sRGBHex = ref(initialValue);
  async function open2(openOptions) {
    if (!isSupported2.value)
      return;
    const eyeDropper = new window.EyeDropper();
    const result = await eyeDropper.open(openOptions);
    sRGBHex.value = result.sRGBHex;
    return result;
  }
  __name(open2, "open");
  return { isSupported: isSupported2, sRGBHex, open: open2 };
}
__name(useEyeDropper, "useEyeDropper");
function useFavicon(newIcon = null, options3 = {}) {
  const {
    baseUrl = "",
    rel = "icon",
    document: document2 = defaultDocument
  } = options3;
  const favicon = toRef(newIcon);
  const applyIcon = /* @__PURE__ */ __name((icon2) => {
    const elements = document2 == null ? void 0 : document2.head.querySelectorAll(`link[rel*="${rel}"]`);
    if (!elements || elements.length === 0) {
      const link = document2 == null ? void 0 : document2.createElement("link");
      if (link) {
        link.rel = rel;
        link.href = `${baseUrl}${icon2}`;
        link.type = `image/${icon2.split(".").pop()}`;
        document2 == null ? void 0 : document2.head.append(link);
      }
      return;
    }
    elements == null ? void 0 : elements.forEach((el) => el.href = `${baseUrl}${icon2}`);
  }, "applyIcon");
  watch(
    favicon,
    (i2, o) => {
      if (typeof i2 === "string" && i2 !== o)
        applyIcon(i2);
    },
    { immediate: true }
  );
  return favicon;
}
__name(useFavicon, "useFavicon");
const payloadMapping = {
  json: "application/json",
  text: "text/plain"
};
function isFetchOptions(obj) {
  return obj && containsProp(obj, "immediate", "refetch", "initialData", "timeout", "beforeFetch", "afterFetch", "onFetchError", "fetch", "updateDataOnError");
}
__name(isFetchOptions, "isFetchOptions");
const reAbsolute = /^(?:[a-z][a-z\d+\-.]*:)?\/\//i;
function isAbsoluteURL(url) {
  return reAbsolute.test(url);
}
__name(isAbsoluteURL, "isAbsoluteURL");
function headersToObject(headers) {
  if (typeof Headers !== "undefined" && headers instanceof Headers)
    return Object.fromEntries(headers.entries());
  return headers;
}
__name(headersToObject, "headersToObject");
function combineCallbacks(combination, ...callbacks) {
  if (combination === "overwrite") {
    return async (ctx) => {
      const callback = callbacks[callbacks.length - 1];
      if (callback)
        return { ...ctx, ...await callback(ctx) };
      return ctx;
    };
  } else {
    return async (ctx) => {
      for (const callback of callbacks) {
        if (callback)
          ctx = { ...ctx, ...await callback(ctx) };
      }
      return ctx;
    };
  }
}
__name(combineCallbacks, "combineCallbacks");
function createFetch(config = {}) {
  const _combination = config.combination || "chain";
  const _options = config.options || {};
  const _fetchOptions = config.fetchOptions || {};
  function useFactoryFetch(url, ...args) {
    const computedUrl = computed(() => {
      const baseUrl = toValue(config.baseUrl);
      const targetUrl = toValue(url);
      return baseUrl && !isAbsoluteURL(targetUrl) ? joinPaths(baseUrl, targetUrl) : targetUrl;
    });
    let options3 = _options;
    let fetchOptions = _fetchOptions;
    if (args.length > 0) {
      if (isFetchOptions(args[0])) {
        options3 = {
          ...options3,
          ...args[0],
          beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[0].beforeFetch),
          afterFetch: combineCallbacks(_combination, _options.afterFetch, args[0].afterFetch),
          onFetchError: combineCallbacks(_combination, _options.onFetchError, args[0].onFetchError)
        };
      } else {
        fetchOptions = {
          ...fetchOptions,
          ...args[0],
          headers: {
            ...headersToObject(fetchOptions.headers) || {},
            ...headersToObject(args[0].headers) || {}
          }
        };
      }
    }
    if (args.length > 1 && isFetchOptions(args[1])) {
      options3 = {
        ...options3,
        ...args[1],
        beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[1].beforeFetch),
        afterFetch: combineCallbacks(_combination, _options.afterFetch, args[1].afterFetch),
        onFetchError: combineCallbacks(_combination, _options.onFetchError, args[1].onFetchError)
      };
    }
    return useFetch(computedUrl, fetchOptions, options3);
  }
  __name(useFactoryFetch, "useFactoryFetch");
  return useFactoryFetch;
}
__name(createFetch, "createFetch");
function useFetch(url, ...args) {
  var _a;
  const supportsAbort = typeof AbortController === "function";
  let fetchOptions = {};
  let options3 = {
    immediate: true,
    refetch: false,
    timeout: 0,
    updateDataOnError: false
  };
  const config = {
    method: "GET",
    type: "text",
    payload: void 0
  };
  if (args.length > 0) {
    if (isFetchOptions(args[0]))
      options3 = { ...options3, ...args[0] };
    else
      fetchOptions = args[0];
  }
  if (args.length > 1) {
    if (isFetchOptions(args[1]))
      options3 = { ...options3, ...args[1] };
  }
  const {
    fetch: fetch2 = (_a = defaultWindow) == null ? void 0 : _a.fetch,
    initialData,
    timeout
  } = options3;
  const responseEvent = createEventHook();
  const errorEvent = createEventHook();
  const finallyEvent = createEventHook();
  const isFinished = ref(false);
  const isFetching = ref(false);
  const aborted = ref(false);
  const statusCode = ref(null);
  const response = shallowRef(null);
  const error = shallowRef(null);
  const data24 = shallowRef(initialData || null);
  const canAbort = computed(() => supportsAbort && isFetching.value);
  let controller;
  let timer;
  const abort = /* @__PURE__ */ __name(() => {
    if (supportsAbort) {
      controller == null ? void 0 : controller.abort();
      controller = new AbortController();
      controller.signal.onabort = () => aborted.value = true;
      fetchOptions = {
        ...fetchOptions,
        signal: controller.signal
      };
    }
  }, "abort");
  const loading2 = /* @__PURE__ */ __name((isLoading) => {
    isFetching.value = isLoading;
    isFinished.value = !isLoading;
  }, "loading");
  if (timeout)
    timer = useTimeoutFn(abort, timeout, { immediate: false });
  let executeCounter = 0;
  const execute = /* @__PURE__ */ __name(async (throwOnFailed = false) => {
    var _a2, _b;
    abort();
    loading2(true);
    error.value = null;
    statusCode.value = null;
    aborted.value = false;
    executeCounter += 1;
    const currentExecuteCounter = executeCounter;
    const defaultFetchOptions = {
      method: config.method,
      headers: {}
    };
    if (config.payload) {
      const headers = headersToObject(defaultFetchOptions.headers);
      const payload = toValue(config.payload);
      if (!config.payloadType && payload && Object.getPrototypeOf(payload) === Object.prototype && !(payload instanceof FormData))
        config.payloadType = "json";
      if (config.payloadType)
        headers["Content-Type"] = (_a2 = payloadMapping[config.payloadType]) != null ? _a2 : config.payloadType;
      defaultFetchOptions.body = config.payloadType === "json" ? JSON.stringify(payload) : payload;
    }
    let isCanceled = false;
    const context = {
      url: toValue(url),
      options: {
        ...defaultFetchOptions,
        ...fetchOptions
      },
      cancel: /* @__PURE__ */ __name(() => {
        isCanceled = true;
      }, "cancel")
    };
    if (options3.beforeFetch)
      Object.assign(context, await options3.beforeFetch(context));
    if (isCanceled || !fetch2) {
      loading2(false);
      return Promise.resolve(null);
    }
    let responseData = null;
    if (timer)
      timer.start();
    return fetch2(
      context.url,
      {
        ...defaultFetchOptions,
        ...context.options,
        headers: {
          ...headersToObject(defaultFetchOptions.headers),
          ...headersToObject((_b = context.options) == null ? void 0 : _b.headers)
        }
      }
    ).then(async (fetchResponse) => {
      response.value = fetchResponse;
      statusCode.value = fetchResponse.status;
      responseData = await fetchResponse.clone()[config.type]();
      if (!fetchResponse.ok) {
        data24.value = initialData || null;
        throw new Error(fetchResponse.statusText);
      }
      if (options3.afterFetch) {
        ({ data: responseData } = await options3.afterFetch({
          data: responseData,
          response: fetchResponse
        }));
      }
      data24.value = responseData;
      responseEvent.trigger(fetchResponse);
      return fetchResponse;
    }).catch(async (fetchError) => {
      let errorData = fetchError.message || fetchError.name;
      if (options3.onFetchError) {
        ({ error: errorData, data: responseData } = await options3.onFetchError({
          data: responseData,
          error: fetchError,
          response: response.value
        }));
      }
      error.value = errorData;
      if (options3.updateDataOnError)
        data24.value = responseData;
      errorEvent.trigger(fetchError);
      if (throwOnFailed)
        throw fetchError;
      return null;
    }).finally(() => {
      if (currentExecuteCounter === executeCounter)
        loading2(false);
      if (timer)
        timer.stop();
      finallyEvent.trigger(null);
    });
  }, "execute");
  const refetch = toRef(options3.refetch);
  watch(
    [
      refetch,
      toRef(url)
    ],
    ([refetch2]) => refetch2 && execute(),
    { deep: true }
  );
  const shell = {
    isFinished: readonly(isFinished),
    isFetching: readonly(isFetching),
    statusCode,
    response,
    error,
    data: data24,
    canAbort,
    aborted,
    abort,
    execute,
    onFetchResponse: responseEvent.on,
    onFetchError: errorEvent.on,
    onFetchFinally: finallyEvent.on,
    // method
    get: setMethod("GET"),
    put: setMethod("PUT"),
    post: setMethod("POST"),
    delete: setMethod("DELETE"),
    patch: setMethod("PATCH"),
    head: setMethod("HEAD"),
    options: setMethod("OPTIONS"),
    // type
    json: setType2("json"),
    text: setType2("text"),
    blob: setType2("blob"),
    arrayBuffer: setType2("arrayBuffer"),
    formData: setType2("formData")
  };
  function setMethod(method) {
    return (payload, payloadType) => {
      if (!isFetching.value) {
        config.method = method;
        config.payload = payload;
        config.payloadType = payloadType;
        if (isRef(config.payload)) {
          watch(
            [
              refetch,
              toRef(config.payload)
            ],
            ([refetch2]) => refetch2 && execute(),
            { deep: true }
          );
        }
        return {
          ...shell,
          then(onFulfilled, onRejected) {
            return waitUntilFinished().then(onFulfilled, onRejected);
          }
        };
      }
      return void 0;
    };
  }
  __name(setMethod, "setMethod");
  function waitUntilFinished() {
    return new Promise((resolve8, reject2) => {
      until(isFinished).toBe(true).then(() => resolve8(shell)).catch((error2) => reject2(error2));
    });
  }
  __name(waitUntilFinished, "waitUntilFinished");
  function setType2(type) {
    return () => {
      if (!isFetching.value) {
        config.type = type;
        return {
          ...shell,
          then(onFulfilled, onRejected) {
            return waitUntilFinished().then(onFulfilled, onRejected);
          }
        };
      }
      return void 0;
    };
  }
  __name(setType2, "setType");
  if (options3.immediate)
    Promise.resolve().then(() => execute());
  return {
    ...shell,
    then(onFulfilled, onRejected) {
      return waitUntilFinished().then(onFulfilled, onRejected);
    }
  };
}
__name(useFetch, "useFetch");
function joinPaths(start2, end) {
  if (!start2.endsWith("/") && !end.startsWith("/"))
    return `${start2}/${end}`;
  return `${start2}${end}`;
}
__name(joinPaths, "joinPaths");
const DEFAULT_OPTIONS = {
  multiple: true,
  accept: "*",
  reset: false,
  directory: false
};
function useFileDialog(options3 = {}) {
  const {
    document: document2 = defaultDocument
  } = options3;
  const files = ref(null);
  const { on: onChange5, trigger: trigger2 } = createEventHook();
  let input;
  if (document2) {
    input = document2.createElement("input");
    input.type = "file";
    input.onchange = (event2) => {
      const result = event2.target;
      files.value = result.files;
      trigger2(files.value);
    };
  }
  const reset = /* @__PURE__ */ __name(() => {
    files.value = null;
    if (input && input.value) {
      input.value = "";
      trigger2(null);
    }
  }, "reset");
  const open2 = /* @__PURE__ */ __name((localOptions) => {
    if (!input)
      return;
    const _options = {
      ...DEFAULT_OPTIONS,
      ...options3,
      ...localOptions
    };
    input.multiple = _options.multiple;
    input.accept = _options.accept;
    input.webkitdirectory = _options.directory;
    if (hasOwn$2(_options, "capture"))
      input.capture = _options.capture;
    if (_options.reset)
      reset();
    input.click();
  }, "open");
  return {
    files: readonly(files),
    open: open2,
    reset,
    onChange: onChange5
  };
}
__name(useFileDialog, "useFileDialog");
function useFileSystemAccess(options3 = {}) {
  const {
    window: _window = defaultWindow,
    dataType = "Text"
  } = options3;
  const window2 = _window;
  const isSupported2 = useSupported(() => window2 && "showSaveFilePicker" in window2 && "showOpenFilePicker" in window2);
  const fileHandle = ref();
  const data24 = ref();
  const file = ref();
  const fileName = computed(() => {
    var _a, _b;
    return (_b = (_a = file.value) == null ? void 0 : _a.name) != null ? _b : "";
  });
  const fileMIME = computed(() => {
    var _a, _b;
    return (_b = (_a = file.value) == null ? void 0 : _a.type) != null ? _b : "";
  });
  const fileSize = computed(() => {
    var _a, _b;
    return (_b = (_a = file.value) == null ? void 0 : _a.size) != null ? _b : 0;
  });
  const fileLastModified = computed(() => {
    var _a, _b;
    return (_b = (_a = file.value) == null ? void 0 : _a.lastModified) != null ? _b : 0;
  });
  async function open2(_options = {}) {
    if (!isSupported2.value)
      return;
    const [handle] = await window2.showOpenFilePicker({ ...toValue(options3), ..._options });
    fileHandle.value = handle;
    await updateData();
  }
  __name(open2, "open");
  async function create2(_options = {}) {
    if (!isSupported2.value)
      return;
    fileHandle.value = await window2.showSaveFilePicker({ ...options3, ..._options });
    data24.value = void 0;
    await updateData();
  }
  __name(create2, "create");
  async function save(_options = {}) {
    if (!isSupported2.value)
      return;
    if (!fileHandle.value)
      return saveAs2(_options);
    if (data24.value) {
      const writableStream = await fileHandle.value.createWritable();
      await writableStream.write(data24.value);
      await writableStream.close();
    }
    await updateFile();
  }
  __name(save, "save");
  async function saveAs2(_options = {}) {
    if (!isSupported2.value)
      return;
    fileHandle.value = await window2.showSaveFilePicker({ ...options3, ..._options });
    if (data24.value) {
      const writableStream = await fileHandle.value.createWritable();
      await writableStream.write(data24.value);
      await writableStream.close();
    }
    await updateFile();
  }
  __name(saveAs2, "saveAs");
  async function updateFile() {
    var _a;
    file.value = await ((_a = fileHandle.value) == null ? void 0 : _a.getFile());
  }
  __name(updateFile, "updateFile");
  async function updateData() {
    var _a, _b;
    await updateFile();
    const type = toValue(dataType);
    if (type === "Text")
      data24.value = await ((_a = file.value) == null ? void 0 : _a.text());
    else if (type === "ArrayBuffer")
      data24.value = await ((_b = file.value) == null ? void 0 : _b.arrayBuffer());
    else if (type === "Blob")
      data24.value = file.value;
  }
  __name(updateData, "updateData");
  watch(() => toValue(dataType), updateData);
  return {
    isSupported: isSupported2,
    data: data24,
    file,
    fileName,
    fileMIME,
    fileSize,
    fileLastModified,
    open: open2,
    create: create2,
    save,
    saveAs: saveAs2,
    updateData
  };
}
__name(useFileSystemAccess, "useFileSystemAccess");
function useFocus(target, options3 = {}) {
  const { initialValue = false, focusVisible = false, preventScroll = false } = options3;
  const innerFocused = ref(false);
  const targetElement = computed(() => unrefElement(target));
  useEventListener(targetElement, "focus", (event2) => {
    var _a, _b;
    if (!focusVisible || ((_b = (_a = event2.target).matches) == null ? void 0 : _b.call(_a, ":focus-visible")))
      innerFocused.value = true;
  });
  useEventListener(targetElement, "blur", () => innerFocused.value = false);
  const focused = computed({
    get: /* @__PURE__ */ __name(() => innerFocused.value, "get"),
    set(value3) {
      var _a, _b;
      if (!value3 && innerFocused.value)
        (_a = targetElement.value) == null ? void 0 : _a.blur();
      else if (value3 && !innerFocused.value)
        (_b = targetElement.value) == null ? void 0 : _b.focus({ preventScroll });
    }
  });
  watch(
    targetElement,
    () => {
      focused.value = initialValue;
    },
    { immediate: true, flush: "post" }
  );
  return { focused };
}
__name(useFocus, "useFocus");
function useFocusWithin(target, options3 = {}) {
  const activeElement = useActiveElement(options3);
  const targetElement = computed(() => unrefElement(target));
  const focused = computed(() => targetElement.value && activeElement.value ? targetElement.value.contains(activeElement.value) : false);
  return { focused };
}
__name(useFocusWithin, "useFocusWithin");
function useFps(options3) {
  var _a;
  const fps = ref(0);
  if (typeof performance === "undefined")
    return fps;
  const every = (_a = options3 == null ? void 0 : options3.every) != null ? _a : 10;
  let last = performance.now();
  let ticks = 0;
  useRafFn(() => {
    ticks += 1;
    if (ticks >= every) {
      const now2 = performance.now();
      const diff = now2 - last;
      fps.value = Math.round(1e3 / (diff / ticks));
      last = now2;
      ticks = 0;
    }
  });
  return fps;
}
__name(useFps, "useFps");
const eventHandlers = [
  "fullscreenchange",
  "webkitfullscreenchange",
  "webkitendfullscreen",
  "mozfullscreenchange",
  "MSFullscreenChange"
];
function useFullscreen(target, options3 = {}) {
  const {
    document: document2 = defaultDocument,
    autoExit = false
  } = options3;
  const targetRef = computed(() => {
    var _a;
    return (_a = unrefElement(target)) != null ? _a : document2 == null ? void 0 : document2.querySelector("html");
  });
  const isFullscreen = ref(false);
  const requestMethod = computed(() => {
    return [
      "requestFullscreen",
      "webkitRequestFullscreen",
      "webkitEnterFullscreen",
      "webkitEnterFullScreen",
      "webkitRequestFullScreen",
      "mozRequestFullScreen",
      "msRequestFullscreen"
    ].find((m) => document2 && m in document2 || targetRef.value && m in targetRef.value);
  });
  const exitMethod = computed(() => {
    return [
      "exitFullscreen",
      "webkitExitFullscreen",
      "webkitExitFullScreen",
      "webkitCancelFullScreen",
      "mozCancelFullScreen",
      "msExitFullscreen"
    ].find((m) => document2 && m in document2 || targetRef.value && m in targetRef.value);
  });
  const fullscreenEnabled = computed(() => {
    return [
      "fullScreen",
      "webkitIsFullScreen",
      "webkitDisplayingFullscreen",
      "mozFullScreen",
      "msFullscreenElement"
    ].find((m) => document2 && m in document2 || targetRef.value && m in targetRef.value);
  });
  const fullscreenElementMethod = [
    "fullscreenElement",
    "webkitFullscreenElement",
    "mozFullScreenElement",
    "msFullscreenElement"
  ].find((m) => document2 && m in document2);
  const isSupported2 = useSupported(() => targetRef.value && document2 && requestMethod.value !== void 0 && exitMethod.value !== void 0 && fullscreenEnabled.value !== void 0);
  const isCurrentElementFullScreen = /* @__PURE__ */ __name(() => {
    if (fullscreenElementMethod)
      return (document2 == null ? void 0 : document2[fullscreenElementMethod]) === targetRef.value;
    return false;
  }, "isCurrentElementFullScreen");
  const isElementFullScreen = /* @__PURE__ */ __name(() => {
    if (fullscreenEnabled.value) {
      if (document2 && document2[fullscreenEnabled.value] != null) {
        return document2[fullscreenEnabled.value];
      } else {
        const target2 = targetRef.value;
        if ((target2 == null ? void 0 : target2[fullscreenEnabled.value]) != null) {
          return Boolean(target2[fullscreenEnabled.value]);
        }
      }
    }
    return false;
  }, "isElementFullScreen");
  async function exit() {
    if (!isSupported2.value || !isFullscreen.value)
      return;
    if (exitMethod.value) {
      if ((document2 == null ? void 0 : document2[exitMethod.value]) != null) {
        await document2[exitMethod.value]();
      } else {
        const target2 = targetRef.value;
        if ((target2 == null ? void 0 : target2[exitMethod.value]) != null)
          await target2[exitMethod.value]();
      }
    }
    isFullscreen.value = false;
  }
  __name(exit, "exit");
  async function enter() {
    if (!isSupported2.value || isFullscreen.value)
      return;
    if (isElementFullScreen())
      await exit();
    const target2 = targetRef.value;
    if (requestMethod.value && (target2 == null ? void 0 : target2[requestMethod.value]) != null) {
      await target2[requestMethod.value]();
      isFullscreen.value = true;
    }
  }
  __name(enter, "enter");
  async function toggle4() {
    await (isFullscreen.value ? exit() : enter());
  }
  __name(toggle4, "toggle");
  const handlerCallback = /* @__PURE__ */ __name(() => {
    const isElementFullScreenValue = isElementFullScreen();
    if (!isElementFullScreenValue || isElementFullScreenValue && isCurrentElementFullScreen())
      isFullscreen.value = isElementFullScreenValue;
  }, "handlerCallback");
  useEventListener(document2, eventHandlers, handlerCallback, false);
  useEventListener(() => unrefElement(targetRef), eventHandlers, handlerCallback, false);
  if (autoExit)
    tryOnScopeDispose(exit);
  return {
    isSupported: isSupported2,
    isFullscreen,
    enter,
    exit,
    toggle: toggle4
  };
}
__name(useFullscreen, "useFullscreen");
function mapGamepadToXbox360Controller(gamepad) {
  return computed(() => {
    if (gamepad.value) {
      return {
        buttons: {
          a: gamepad.value.buttons[0],
          b: gamepad.value.buttons[1],
          x: gamepad.value.buttons[2],
          y: gamepad.value.buttons[3]
        },
        bumper: {
          left: gamepad.value.buttons[4],
          right: gamepad.value.buttons[5]
        },
        triggers: {
          left: gamepad.value.buttons[6],
          right: gamepad.value.buttons[7]
        },
        stick: {
          left: {
            horizontal: gamepad.value.axes[0],
            vertical: gamepad.value.axes[1],
            button: gamepad.value.buttons[10]
          },
          right: {
            horizontal: gamepad.value.axes[2],
            vertical: gamepad.value.axes[3],
            button: gamepad.value.buttons[11]
          }
        },
        dpad: {
          up: gamepad.value.buttons[12],
          down: gamepad.value.buttons[13],
          left: gamepad.value.buttons[14],
          right: gamepad.value.buttons[15]
        },
        back: gamepad.value.buttons[8],
        start: gamepad.value.buttons[9]
      };
    }
    return null;
  });
}
__name(mapGamepadToXbox360Controller, "mapGamepadToXbox360Controller");
function useGamepad(options3 = {}) {
  const {
    navigator: navigator2 = defaultNavigator
  } = options3;
  const isSupported2 = useSupported(() => navigator2 && "getGamepads" in navigator2);
  const gamepads = ref([]);
  const onConnectedHook = createEventHook();
  const onDisconnectedHook = createEventHook();
  const stateFromGamepad = /* @__PURE__ */ __name((gamepad) => {
    const hapticActuators = [];
    const vibrationActuator = "vibrationActuator" in gamepad ? gamepad.vibrationActuator : null;
    if (vibrationActuator)
      hapticActuators.push(vibrationActuator);
    if (gamepad.hapticActuators)
      hapticActuators.push(...gamepad.hapticActuators);
    return {
      id: gamepad.id,
      index: gamepad.index,
      connected: gamepad.connected,
      mapping: gamepad.mapping,
      timestamp: gamepad.timestamp,
      vibrationActuator: gamepad.vibrationActuator,
      hapticActuators,
      axes: gamepad.axes.map((axes) => axes),
      buttons: gamepad.buttons.map((button) => ({ pressed: button.pressed, touched: button.touched, value: button.value }))
    };
  }, "stateFromGamepad");
  const updateGamepadState = /* @__PURE__ */ __name(() => {
    const _gamepads = (navigator2 == null ? void 0 : navigator2.getGamepads()) || [];
    for (const gamepad of _gamepads) {
      if (gamepad && gamepads.value[gamepad.index])
        gamepads.value[gamepad.index] = stateFromGamepad(gamepad);
    }
  }, "updateGamepadState");
  const { isActive, pause, resume } = useRafFn(updateGamepadState);
  const onGamepadConnected = /* @__PURE__ */ __name((gamepad) => {
    if (!gamepads.value.some(({ index: index2 }) => index2 === gamepad.index)) {
      gamepads.value.push(stateFromGamepad(gamepad));
      onConnectedHook.trigger(gamepad.index);
    }
    resume();
  }, "onGamepadConnected");
  const onGamepadDisconnected = /* @__PURE__ */ __name((gamepad) => {
    gamepads.value = gamepads.value.filter((x2) => x2.index !== gamepad.index);
    onDisconnectedHook.trigger(gamepad.index);
  }, "onGamepadDisconnected");
  useEventListener("gamepadconnected", (e) => onGamepadConnected(e.gamepad));
  useEventListener("gamepaddisconnected", (e) => onGamepadDisconnected(e.gamepad));
  tryOnMounted(() => {
    const _gamepads = (navigator2 == null ? void 0 : navigator2.getGamepads()) || [];
    for (const gamepad of _gamepads) {
      if (gamepad && gamepads.value[gamepad.index])
        onGamepadConnected(gamepad);
    }
  });
  pause();
  return {
    isSupported: isSupported2,
    onConnected: onConnectedHook.on,
    onDisconnected: onDisconnectedHook.on,
    gamepads,
    pause,
    resume,
    isActive
  };
}
__name(useGamepad, "useGamepad");
function useGeolocation(options3 = {}) {
  const {
    enableHighAccuracy = true,
    maximumAge = 3e4,
    timeout = 27e3,
    navigator: navigator2 = defaultNavigator,
    immediate = true
  } = options3;
  const isSupported2 = useSupported(() => navigator2 && "geolocation" in navigator2);
  const locatedAt = ref(null);
  const error = shallowRef(null);
  const coords = ref({
    accuracy: 0,
    latitude: Number.POSITIVE_INFINITY,
    longitude: Number.POSITIVE_INFINITY,
    altitude: null,
    altitudeAccuracy: null,
    heading: null,
    speed: null
  });
  function updatePosition(position2) {
    locatedAt.value = position2.timestamp;
    coords.value = position2.coords;
    error.value = null;
  }
  __name(updatePosition, "updatePosition");
  let watcher;
  function resume() {
    if (isSupported2.value) {
      watcher = navigator2.geolocation.watchPosition(
        updatePosition,
        (err) => error.value = err,
        {
          enableHighAccuracy,
          maximumAge,
          timeout
        }
      );
    }
  }
  __name(resume, "resume");
  if (immediate)
    resume();
  function pause() {
    if (watcher && navigator2)
      navigator2.geolocation.clearWatch(watcher);
  }
  __name(pause, "pause");
  tryOnScopeDispose(() => {
    pause();
  });
  return {
    isSupported: isSupported2,
    coords,
    locatedAt,
    error,
    resume,
    pause
  };
}
__name(useGeolocation, "useGeolocation");
const defaultEvents$1 = ["mousemove", "mousedown", "resize", "keydown", "touchstart", "wheel"];
const oneMinute = 6e4;
function useIdle(timeout = oneMinute, options3 = {}) {
  const {
    initialState = false,
    listenForVisibilityChange = true,
    events: events2 = defaultEvents$1,
    window: window2 = defaultWindow,
    eventFilter = throttleFilter(50)
  } = options3;
  const idle = ref(initialState);
  const lastActive = ref(timestamp());
  let timer;
  const reset = /* @__PURE__ */ __name(() => {
    idle.value = false;
    clearTimeout(timer);
    timer = setTimeout(() => idle.value = true, timeout);
  }, "reset");
  const onEvent = createFilterWrapper(
    eventFilter,
    () => {
      lastActive.value = timestamp();
      reset();
    }
  );
  if (window2) {
    const document2 = window2.document;
    for (const event2 of events2)
      useEventListener(window2, event2, onEvent, { passive: true });
    if (listenForVisibilityChange) {
      useEventListener(document2, "visibilitychange", () => {
        if (!document2.hidden)
          onEvent();
      });
    }
    reset();
  }
  return {
    idle,
    lastActive,
    reset
  };
}
__name(useIdle, "useIdle");
async function loadImage(options3) {
  return new Promise((resolve8, reject2) => {
    const img = new Image();
    const { src, srcset, sizes, class: clazz, loading: loading2, crossorigin, referrerPolicy } = options3;
    img.src = src;
    if (srcset)
      img.srcset = srcset;
    if (sizes)
      img.sizes = sizes;
    if (clazz)
      img.className = clazz;
    if (loading2)
      img.loading = loading2;
    if (crossorigin)
      img.crossOrigin = crossorigin;
    if (referrerPolicy)
      img.referrerPolicy = referrerPolicy;
    img.onload = () => resolve8(img);
    img.onerror = reject2;
  });
}
__name(loadImage, "loadImage");
function useImage(options3, asyncStateOptions = {}) {
  const state = useAsyncState(
    () => loadImage(toValue(options3)),
    void 0,
    {
      resetOnExecute: true,
      ...asyncStateOptions
    }
  );
  watch(
    () => toValue(options3),
    () => state.execute(asyncStateOptions.delay),
    { deep: true }
  );
  return state;
}
__name(useImage, "useImage");
const ARRIVED_STATE_THRESHOLD_PIXELS = 1;
function useScroll(element, options3 = {}) {
  const {
    throttle: throttle2 = 0,
    idle = 200,
    onStop = noop,
    onScroll: onScroll3 = noop,
    offset = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    },
    eventListenerOptions = {
      capture: false,
      passive: true
    },
    behavior = "auto",
    window: window2 = defaultWindow,
    onError = /* @__PURE__ */ __name((e) => {
      console.error(e);
    }, "onError")
  } = options3;
  const internalX = ref(0);
  const internalY = ref(0);
  const x2 = computed({
    get() {
      return internalX.value;
    },
    set(x22) {
      scrollTo22(x22, void 0);
    }
  });
  const y2 = computed({
    get() {
      return internalY.value;
    },
    set(y22) {
      scrollTo22(void 0, y22);
    }
  });
  function scrollTo22(_x, _y) {
    var _a, _b, _c, _d;
    if (!window2)
      return;
    const _element = toValue(element);
    if (!_element)
      return;
    (_c = _element instanceof Document ? window2.document.body : _element) == null ? void 0 : _c.scrollTo({
      top: (_a = toValue(_y)) != null ? _a : y2.value,
      left: (_b = toValue(_x)) != null ? _b : x2.value,
      behavior: toValue(behavior)
    });
    const scrollContainer = ((_d = _element == null ? void 0 : _element.document) == null ? void 0 : _d.documentElement) || (_element == null ? void 0 : _element.documentElement) || _element;
    if (x2 != null)
      internalX.value = scrollContainer.scrollLeft;
    if (y2 != null)
      internalY.value = scrollContainer.scrollTop;
  }
  __name(scrollTo22, "scrollTo2");
  const isScrolling = ref(false);
  const arrivedState = reactive({
    left: true,
    right: false,
    top: true,
    bottom: false
  });
  const directions = reactive({
    left: false,
    right: false,
    top: false,
    bottom: false
  });
  const onScrollEnd = /* @__PURE__ */ __name((e) => {
    if (!isScrolling.value)
      return;
    isScrolling.value = false;
    directions.left = false;
    directions.right = false;
    directions.top = false;
    directions.bottom = false;
    onStop(e);
  }, "onScrollEnd");
  const onScrollEndDebounced = useDebounceFn(onScrollEnd, throttle2 + idle);
  const setArrivedState = /* @__PURE__ */ __name((target) => {
    var _a;
    if (!window2)
      return;
    const el = ((_a = target == null ? void 0 : target.document) == null ? void 0 : _a.documentElement) || (target == null ? void 0 : target.documentElement) || unrefElement(target);
    const { display, flexDirection } = getComputedStyle(el);
    const scrollLeft = el.scrollLeft;
    directions.left = scrollLeft < internalX.value;
    directions.right = scrollLeft > internalX.value;
    const left = Math.abs(scrollLeft) <= (offset.left || 0);
    const right = Math.abs(scrollLeft) + el.clientWidth >= el.scrollWidth - (offset.right || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;
    if (display === "flex" && flexDirection === "row-reverse") {
      arrivedState.left = right;
      arrivedState.right = left;
    } else {
      arrivedState.left = left;
      arrivedState.right = right;
    }
    internalX.value = scrollLeft;
    let scrollTop2 = el.scrollTop;
    if (target === window2.document && !scrollTop2)
      scrollTop2 = window2.document.body.scrollTop;
    directions.top = scrollTop2 < internalY.value;
    directions.bottom = scrollTop2 > internalY.value;
    const top = Math.abs(scrollTop2) <= (offset.top || 0);
    const bottom = Math.abs(scrollTop2) + el.clientHeight >= el.scrollHeight - (offset.bottom || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;
    if (display === "flex" && flexDirection === "column-reverse") {
      arrivedState.top = bottom;
      arrivedState.bottom = top;
    } else {
      arrivedState.top = top;
      arrivedState.bottom = bottom;
    }
    internalY.value = scrollTop2;
  }, "setArrivedState");
  const onScrollHandler = /* @__PURE__ */ __name((e) => {
    var _a;
    if (!window2)
      return;
    const eventTarget = (_a = e.target.documentElement) != null ? _a : e.target;
    setArrivedState(eventTarget);
    isScrolling.value = true;
    onScrollEndDebounced(e);
    onScroll3(e);
  }, "onScrollHandler");
  useEventListener(
    element,
    "scroll",
    throttle2 ? useThrottleFn(onScrollHandler, throttle2, true, false) : onScrollHandler,
    eventListenerOptions
  );
  tryOnMounted(() => {
    try {
      const _element = toValue(element);
      if (!_element)
        return;
      setArrivedState(_element);
    } catch (e) {
      onError(e);
    }
  });
  useEventListener(
    element,
    "scrollend",
    onScrollEnd,
    eventListenerOptions
  );
  return {
    x: x2,
    y: y2,
    isScrolling,
    arrivedState,
    directions,
    measure() {
      const _element = toValue(element);
      if (window2 && _element)
        setArrivedState(_element);
    }
  };
}
__name(useScroll, "useScroll");
function resolveElement(el) {
  if (typeof Window !== "undefined" && el instanceof Window)
    return el.document.documentElement;
  if (typeof Document !== "undefined" && el instanceof Document)
    return el.documentElement;
  return el;
}
__name(resolveElement, "resolveElement");
function useInfiniteScroll(element, onLoadMore, options3 = {}) {
  var _a;
  const {
    direction = "bottom",
    interval = 100,
    canLoadMore = /* @__PURE__ */ __name(() => true, "canLoadMore")
  } = options3;
  const state = reactive(useScroll(
    element,
    {
      ...options3,
      offset: {
        [direction]: (_a = options3.distance) != null ? _a : 0,
        ...options3.offset
      }
    }
  ));
  const promise = ref();
  const isLoading = computed(() => !!promise.value);
  const observedElement = computed(() => {
    return resolveElement(toValue(element));
  });
  const isElementVisible = useElementVisibility(observedElement);
  function checkAndLoad() {
    state.measure();
    if (!observedElement.value || !isElementVisible.value || !canLoadMore(observedElement.value))
      return;
    const { scrollHeight: scrollHeight2, clientHeight, scrollWidth: scrollWidth2, clientWidth } = observedElement.value;
    const isNarrower = direction === "bottom" || direction === "top" ? scrollHeight2 <= clientHeight : scrollWidth2 <= clientWidth;
    if (state.arrivedState[direction] || isNarrower) {
      if (!promise.value) {
        promise.value = Promise.all([
          onLoadMore(state),
          new Promise((resolve8) => setTimeout(resolve8, interval))
        ]).finally(() => {
          promise.value = null;
          nextTick(() => checkAndLoad());
        });
      }
    }
  }
  __name(checkAndLoad, "checkAndLoad");
  watch(
    () => [state.arrivedState[direction], isElementVisible.value],
    checkAndLoad,
    { immediate: true }
  );
  return {
    isLoading,
    reset() {
      nextTick(() => checkAndLoad());
    }
  };
}
__name(useInfiniteScroll, "useInfiniteScroll");
const defaultEvents = ["mousedown", "mouseup", "keydown", "keyup"];
function useKeyModifier(modifier, options3 = {}) {
  const {
    events: events2 = defaultEvents,
    document: document2 = defaultDocument,
    initial = null
  } = options3;
  const state = ref(initial);
  if (document2) {
    events2.forEach((listenerEvent) => {
      useEventListener(document2, listenerEvent, (evt) => {
        if (typeof evt.getModifierState === "function")
          state.value = evt.getModifierState(modifier);
      });
    });
  }
  return state;
}
__name(useKeyModifier, "useKeyModifier");
function useLocalStorage(key, initialValue, options3 = {}) {
  const { window: window2 = defaultWindow } = options3;
  return useStorage(key, initialValue, window2 == null ? void 0 : window2.localStorage, options3);
}
__name(useLocalStorage, "useLocalStorage");
const DefaultMagicKeysAliasMap = {
  ctrl: "control",
  command: "meta",
  cmd: "meta",
  option: "alt",
  up: "arrowup",
  down: "arrowdown",
  left: "arrowleft",
  right: "arrowright"
};
function useMagicKeys(options3 = {}) {
  const {
    reactive: useReactive = false,
    target = defaultWindow,
    aliasMap = DefaultMagicKeysAliasMap,
    passive = true,
    onEventFired = noop
  } = options3;
  const current = reactive(/* @__PURE__ */ new Set());
  const obj = {
    toJSON() {
      return {};
    },
    current
  };
  const refs = useReactive ? reactive(obj) : obj;
  const metaDeps = /* @__PURE__ */ new Set();
  const usedKeys = /* @__PURE__ */ new Set();
  function setRefs(key, value3) {
    if (key in refs) {
      if (useReactive)
        refs[key] = value3;
      else
        refs[key].value = value3;
    }
  }
  __name(setRefs, "setRefs");
  function reset() {
    current.clear();
    for (const key of usedKeys)
      setRefs(key, false);
  }
  __name(reset, "reset");
  function updateRefs(e, value3) {
    var _a, _b;
    const key = (_a = e.key) == null ? void 0 : _a.toLowerCase();
    const code2 = (_b = e.code) == null ? void 0 : _b.toLowerCase();
    const values2 = [code2, key].filter(Boolean);
    if (key) {
      if (value3)
        current.add(key);
      else
        current.delete(key);
    }
    for (const key2 of values2) {
      usedKeys.add(key2);
      setRefs(key2, value3);
    }
    if (key === "meta" && !value3) {
      metaDeps.forEach((key2) => {
        current.delete(key2);
        setRefs(key2, false);
      });
      metaDeps.clear();
    } else if (typeof e.getModifierState === "function" && e.getModifierState("Meta") && value3) {
      [...current, ...values2].forEach((key2) => metaDeps.add(key2));
    }
  }
  __name(updateRefs, "updateRefs");
  useEventListener(target, "keydown", (e) => {
    updateRefs(e, true);
    return onEventFired(e);
  }, { passive });
  useEventListener(target, "keyup", (e) => {
    updateRefs(e, false);
    return onEventFired(e);
  }, { passive });
  useEventListener("blur", reset, { passive: true });
  useEventListener("focus", reset, { passive: true });
  const proxy = new Proxy(
    refs,
    {
      get(target2, prop2, rec) {
        if (typeof prop2 !== "string")
          return Reflect.get(target2, prop2, rec);
        prop2 = prop2.toLowerCase();
        if (prop2 in aliasMap)
          prop2 = aliasMap[prop2];
        if (!(prop2 in refs)) {
          if (/[+_-]/.test(prop2)) {
            const keys2 = prop2.split(/[+_-]/g).map((i2) => i2.trim());
            refs[prop2] = computed(() => keys2.every((key) => toValue(proxy[key])));
          } else {
            refs[prop2] = ref(false);
          }
        }
        const r = Reflect.get(target2, prop2, rec);
        return useReactive ? toValue(r) : r;
      }
    }
  );
  return proxy;
}
__name(useMagicKeys, "useMagicKeys");
function usingElRef(source, cb) {
  if (toValue(source))
    cb(toValue(source));
}
__name(usingElRef, "usingElRef");
function timeRangeToArray(timeRanges) {
  let ranges = [];
  for (let i2 = 0; i2 < timeRanges.length; ++i2)
    ranges = [...ranges, [timeRanges.start(i2), timeRanges.end(i2)]];
  return ranges;
}
__name(timeRangeToArray, "timeRangeToArray");
function tracksToArray(tracks) {
  return Array.from(tracks).map(({ label: label5, kind, language, mode: mode2, activeCues, cues, inBandMetadataTrackDispatchType }, id2) => ({ id: id2, label: label5, kind, language, mode: mode2, activeCues, cues, inBandMetadataTrackDispatchType }));
}
__name(tracksToArray, "tracksToArray");
const defaultOptions$1 = {
  src: "",
  tracks: []
};
function useMediaControls(target, options3 = {}) {
  target = toRef(target);
  options3 = {
    ...defaultOptions$1,
    ...options3
  };
  const {
    document: document2 = defaultDocument
  } = options3;
  const currentTime = ref(0);
  const duration = ref(0);
  const seeking = ref(false);
  const volume = ref(1);
  const waiting = ref(false);
  const ended = ref(false);
  const playing = ref(false);
  const rate = ref(1);
  const stalled = ref(false);
  const buffered = ref([]);
  const tracks = ref([]);
  const selectedTrack = ref(-1);
  const isPictureInPicture = ref(false);
  const muted = ref(false);
  const supportsPictureInPicture = document2 && "pictureInPictureEnabled" in document2;
  const sourceErrorEvent = createEventHook();
  const disableTrack = /* @__PURE__ */ __name((track2) => {
    usingElRef(target, (el) => {
      if (track2) {
        const id2 = typeof track2 === "number" ? track2 : track2.id;
        el.textTracks[id2].mode = "disabled";
      } else {
        for (let i2 = 0; i2 < el.textTracks.length; ++i2)
          el.textTracks[i2].mode = "disabled";
      }
      selectedTrack.value = -1;
    });
  }, "disableTrack");
  const enableTrack = /* @__PURE__ */ __name((track2, disableTracks = true) => {
    usingElRef(target, (el) => {
      const id2 = typeof track2 === "number" ? track2 : track2.id;
      if (disableTracks)
        disableTrack();
      el.textTracks[id2].mode = "showing";
      selectedTrack.value = id2;
    });
  }, "enableTrack");
  const togglePictureInPicture = /* @__PURE__ */ __name(() => {
    return new Promise((resolve8, reject2) => {
      usingElRef(target, async (el) => {
        if (supportsPictureInPicture) {
          if (!isPictureInPicture.value) {
            el.requestPictureInPicture().then(resolve8).catch(reject2);
          } else {
            document2.exitPictureInPicture().then(resolve8).catch(reject2);
          }
        }
      });
    });
  }, "togglePictureInPicture");
  watchEffect(() => {
    if (!document2)
      return;
    const el = toValue(target);
    if (!el)
      return;
    const src = toValue(options3.src);
    let sources = [];
    if (!src)
      return;
    if (typeof src === "string")
      sources = [{ src }];
    else if (Array.isArray(src))
      sources = src;
    else if (isObject$3(src))
      sources = [src];
    el.querySelectorAll("source").forEach((e) => {
      e.removeEventListener("error", sourceErrorEvent.trigger);
      e.remove();
    });
    sources.forEach(({ src: src2, type }) => {
      const source = document2.createElement("source");
      source.setAttribute("src", src2);
      source.setAttribute("type", type || "");
      source.addEventListener("error", sourceErrorEvent.trigger);
      el.appendChild(source);
    });
    el.load();
  });
  tryOnScopeDispose(() => {
    const el = toValue(target);
    if (!el)
      return;
    el.querySelectorAll("source").forEach((e) => e.removeEventListener("error", sourceErrorEvent.trigger));
  });
  watch([target, volume], () => {
    const el = toValue(target);
    if (!el)
      return;
    el.volume = volume.value;
  });
  watch([target, muted], () => {
    const el = toValue(target);
    if (!el)
      return;
    el.muted = muted.value;
  });
  watch([target, rate], () => {
    const el = toValue(target);
    if (!el)
      return;
    el.playbackRate = rate.value;
  });
  watchEffect(() => {
    if (!document2)
      return;
    const textTracks = toValue(options3.tracks);
    const el = toValue(target);
    if (!textTracks || !textTracks.length || !el)
      return;
    el.querySelectorAll("track").forEach((e) => e.remove());
    textTracks.forEach(({ default: isDefault, kind, label: label5, src, srcLang }, i2) => {
      const track2 = document2.createElement("track");
      track2.default = isDefault || false;
      track2.kind = kind;
      track2.label = label5;
      track2.src = src;
      track2.srclang = srcLang;
      if (track2.default)
        selectedTrack.value = i2;
      el.appendChild(track2);
    });
  });
  const { ignoreUpdates: ignoreCurrentTimeUpdates } = watchIgnorable(currentTime, (time) => {
    const el = toValue(target);
    if (!el)
      return;
    el.currentTime = time;
  });
  const { ignoreUpdates: ignorePlayingUpdates } = watchIgnorable(playing, (isPlaying) => {
    const el = toValue(target);
    if (!el)
      return;
    if (isPlaying)
      el.play();
    else
      el.pause();
  });
  useEventListener(target, "timeupdate", () => ignoreCurrentTimeUpdates(() => currentTime.value = toValue(target).currentTime));
  useEventListener(target, "durationchange", () => duration.value = toValue(target).duration);
  useEventListener(target, "progress", () => buffered.value = timeRangeToArray(toValue(target).buffered));
  useEventListener(target, "seeking", () => seeking.value = true);
  useEventListener(target, "seeked", () => seeking.value = false);
  useEventListener(target, ["waiting", "loadstart"], () => {
    waiting.value = true;
    ignorePlayingUpdates(() => playing.value = false);
  });
  useEventListener(target, "loadeddata", () => waiting.value = false);
  useEventListener(target, "playing", () => {
    waiting.value = false;
    ended.value = false;
    ignorePlayingUpdates(() => playing.value = true);
  });
  useEventListener(target, "ratechange", () => rate.value = toValue(target).playbackRate);
  useEventListener(target, "stalled", () => stalled.value = true);
  useEventListener(target, "ended", () => ended.value = true);
  useEventListener(target, "pause", () => ignorePlayingUpdates(() => playing.value = false));
  useEventListener(target, "play", () => ignorePlayingUpdates(() => playing.value = true));
  useEventListener(target, "enterpictureinpicture", () => isPictureInPicture.value = true);
  useEventListener(target, "leavepictureinpicture", () => isPictureInPicture.value = false);
  useEventListener(target, "volumechange", () => {
    const el = toValue(target);
    if (!el)
      return;
    volume.value = el.volume;
    muted.value = el.muted;
  });
  const listeners = [];
  const stop2 = watch([target], () => {
    const el = toValue(target);
    if (!el)
      return;
    stop2();
    listeners[0] = useEventListener(el.textTracks, "addtrack", () => tracks.value = tracksToArray(el.textTracks));
    listeners[1] = useEventListener(el.textTracks, "removetrack", () => tracks.value = tracksToArray(el.textTracks));
    listeners[2] = useEventListener(el.textTracks, "change", () => tracks.value = tracksToArray(el.textTracks));
  });
  tryOnScopeDispose(() => listeners.forEach((listener) => listener()));
  return {
    currentTime,
    duration,
    waiting,
    seeking,
    ended,
    stalled,
    buffered,
    playing,
    rate,
    // Volume
    volume,
    muted,
    // Tracks
    tracks,
    selectedTrack,
    enableTrack,
    disableTrack,
    // Picture in Picture
    supportsPictureInPicture,
    togglePictureInPicture,
    isPictureInPicture,
    // Events
    onSourceError: sourceErrorEvent.on
  };
}
__name(useMediaControls, "useMediaControls");
function getMapVue2Compat() {
  const data24 = shallowReactive({});
  return {
    get: /* @__PURE__ */ __name((key) => data24[key], "get"),
    set: /* @__PURE__ */ __name((key, value3) => set(data24, key, value3), "set"),
    has: /* @__PURE__ */ __name((key) => hasOwn$2(data24, key), "has"),
    delete: /* @__PURE__ */ __name((key) => del(data24, key), "delete"),
    clear: /* @__PURE__ */ __name(() => {
      Object.keys(data24).forEach((key) => {
        del(data24, key);
      });
    }, "clear")
  };
}
__name(getMapVue2Compat, "getMapVue2Compat");
function useMemoize(resolver, options3) {
  const initCache = /* @__PURE__ */ __name(() => {
    if (options3 == null ? void 0 : options3.cache)
      return shallowReactive(options3.cache);
    if (isVue2)
      return getMapVue2Compat();
    return shallowReactive(/* @__PURE__ */ new Map());
  }, "initCache");
  const cache2 = initCache();
  const generateKey = /* @__PURE__ */ __name((...args) => (options3 == null ? void 0 : options3.getKey) ? options3.getKey(...args) : JSON.stringify(args), "generateKey");
  const _loadData = /* @__PURE__ */ __name((key, ...args) => {
    cache2.set(key, resolver(...args));
    return cache2.get(key);
  }, "_loadData");
  const loadData = /* @__PURE__ */ __name((...args) => _loadData(generateKey(...args), ...args), "loadData");
  const deleteData = /* @__PURE__ */ __name((...args) => {
    cache2.delete(generateKey(...args));
  }, "deleteData");
  const clearData = /* @__PURE__ */ __name(() => {
    cache2.clear();
  }, "clearData");
  const memoized = /* @__PURE__ */ __name((...args) => {
    const key = generateKey(...args);
    if (cache2.has(key))
      return cache2.get(key);
    return _loadData(key, ...args);
  }, "memoized");
  memoized.load = loadData;
  memoized.delete = deleteData;
  memoized.clear = clearData;
  memoized.generateKey = generateKey;
  memoized.cache = cache2;
  return memoized;
}
__name(useMemoize, "useMemoize");
function useMemory(options3 = {}) {
  const memory = ref();
  const isSupported2 = useSupported(() => typeof performance !== "undefined" && "memory" in performance);
  if (isSupported2.value) {
    const { interval = 1e3 } = options3;
    useIntervalFn(() => {
      memory.value = performance.memory;
    }, interval, { immediate: options3.immediate, immediateCallback: options3.immediateCallback });
  }
  return { isSupported: isSupported2, memory };
}
__name(useMemory, "useMemory");
const UseMouseBuiltinExtractors = {
  page: /* @__PURE__ */ __name((event2) => [event2.pageX, event2.pageY], "page"),
  client: /* @__PURE__ */ __name((event2) => [event2.clientX, event2.clientY], "client"),
  screen: /* @__PURE__ */ __name((event2) => [event2.screenX, event2.screenY], "screen"),
  movement: /* @__PURE__ */ __name((event2) => event2 instanceof Touch ? null : [event2.movementX, event2.movementY], "movement")
};
function useMouse(options3 = {}) {
  const {
    type = "page",
    touch = true,
    resetOnTouchEnds = false,
    initialValue = { x: 0, y: 0 },
    window: window2 = defaultWindow,
    target = window2,
    scroll = true,
    eventFilter
  } = options3;
  let _prevMouseEvent = null;
  const x2 = ref(initialValue.x);
  const y2 = ref(initialValue.y);
  const sourceType = ref(null);
  const extractor = typeof type === "function" ? type : UseMouseBuiltinExtractors[type];
  const mouseHandler = /* @__PURE__ */ __name((event2) => {
    const result = extractor(event2);
    _prevMouseEvent = event2;
    if (result) {
      [x2.value, y2.value] = result;
      sourceType.value = "mouse";
    }
  }, "mouseHandler");
  const touchHandler = /* @__PURE__ */ __name((event2) => {
    if (event2.touches.length > 0) {
      const result = extractor(event2.touches[0]);
      if (result) {
        [x2.value, y2.value] = result;
        sourceType.value = "touch";
      }
    }
  }, "touchHandler");
  const scrollHandler = /* @__PURE__ */ __name(() => {
    if (!_prevMouseEvent || !window2)
      return;
    const pos2 = extractor(_prevMouseEvent);
    if (_prevMouseEvent instanceof MouseEvent && pos2) {
      x2.value = pos2[0] + window2.scrollX;
      y2.value = pos2[1] + window2.scrollY;
    }
  }, "scrollHandler");
  const reset = /* @__PURE__ */ __name(() => {
    x2.value = initialValue.x;
    y2.value = initialValue.y;
  }, "reset");
  const mouseHandlerWrapper = eventFilter ? (event2) => eventFilter(() => mouseHandler(event2), {}) : (event2) => mouseHandler(event2);
  const touchHandlerWrapper = eventFilter ? (event2) => eventFilter(() => touchHandler(event2), {}) : (event2) => touchHandler(event2);
  const scrollHandlerWrapper = eventFilter ? () => eventFilter(() => scrollHandler(), {}) : () => scrollHandler();
  if (target) {
    const listenerOptions = { passive: true };
    useEventListener(target, ["mousemove", "dragover"], mouseHandlerWrapper, listenerOptions);
    if (touch && type !== "movement") {
      useEventListener(target, ["touchstart", "touchmove"], touchHandlerWrapper, listenerOptions);
      if (resetOnTouchEnds)
        useEventListener(target, "touchend", reset, listenerOptions);
    }
    if (scroll && type === "page")
      useEventListener(window2, "scroll", scrollHandlerWrapper, { passive: true });
  }
  return {
    x: x2,
    y: y2,
    sourceType
  };
}
__name(useMouse, "useMouse");
function useMouseInElement(target, options3 = {}) {
  const {
    handleOutside = true,
    window: window2 = defaultWindow
  } = options3;
  const type = options3.type || "page";
  const { x: x2, y: y2, sourceType } = useMouse(options3);
  const targetRef = ref(target != null ? target : window2 == null ? void 0 : window2.document.body);
  const elementX = ref(0);
  const elementY = ref(0);
  const elementPositionX = ref(0);
  const elementPositionY = ref(0);
  const elementHeight = ref(0);
  const elementWidth = ref(0);
  const isOutside = ref(true);
  let stop2 = /* @__PURE__ */ __name(() => {
  }, "stop");
  if (window2) {
    stop2 = watch(
      [targetRef, x2, y2],
      () => {
        const el = unrefElement(targetRef);
        if (!el || !(el instanceof HTMLElement))
          return;
        const {
          left,
          top,
          width: width2,
          height
        } = el.getBoundingClientRect();
        elementPositionX.value = left + (type === "page" ? window2.pageXOffset : 0);
        elementPositionY.value = top + (type === "page" ? window2.pageYOffset : 0);
        elementHeight.value = height;
        elementWidth.value = width2;
        const elX = x2.value - elementPositionX.value;
        const elY = y2.value - elementPositionY.value;
        isOutside.value = width2 === 0 || height === 0 || elX < 0 || elY < 0 || elX > width2 || elY > height;
        if (handleOutside || !isOutside.value) {
          elementX.value = elX;
          elementY.value = elY;
        }
      },
      { immediate: true }
    );
    useEventListener(document, "mouseleave", () => {
      isOutside.value = true;
    });
  }
  return {
    x: x2,
    y: y2,
    sourceType,
    elementX,
    elementY,
    elementPositionX,
    elementPositionY,
    elementHeight,
    elementWidth,
    isOutside,
    stop: stop2
  };
}
__name(useMouseInElement, "useMouseInElement");
function useMousePressed(options3 = {}) {
  const {
    touch = true,
    drag = true,
    capture = false,
    initialValue = false,
    window: window2 = defaultWindow
  } = options3;
  const pressed = ref(initialValue);
  const sourceType = ref(null);
  if (!window2) {
    return {
      pressed,
      sourceType
    };
  }
  const onPressed = /* @__PURE__ */ __name((srcType) => () => {
    pressed.value = true;
    sourceType.value = srcType;
  }, "onPressed");
  const onReleased = /* @__PURE__ */ __name(() => {
    pressed.value = false;
    sourceType.value = null;
  }, "onReleased");
  const target = computed(() => unrefElement(options3.target) || window2);
  useEventListener(target, "mousedown", onPressed("mouse"), { passive: true, capture });
  useEventListener(window2, "mouseleave", onReleased, { passive: true, capture });
  useEventListener(window2, "mouseup", onReleased, { passive: true, capture });
  if (drag) {
    useEventListener(target, "dragstart", onPressed("mouse"), { passive: true, capture });
    useEventListener(window2, "drop", onReleased, { passive: true, capture });
    useEventListener(window2, "dragend", onReleased, { passive: true, capture });
  }
  if (touch) {
    useEventListener(target, "touchstart", onPressed("touch"), { passive: true, capture });
    useEventListener(window2, "touchend", onReleased, { passive: true, capture });
    useEventListener(window2, "touchcancel", onReleased, { passive: true, capture });
  }
  return {
    pressed,
    sourceType
  };
}
__name(useMousePressed, "useMousePressed");
function useNavigatorLanguage(options3 = {}) {
  const { window: window2 = defaultWindow } = options3;
  const navigator2 = window2 == null ? void 0 : window2.navigator;
  const isSupported2 = useSupported(() => navigator2 && "language" in navigator2);
  const language = ref(navigator2 == null ? void 0 : navigator2.language);
  useEventListener(window2, "languagechange", () => {
    if (navigator2)
      language.value = navigator2.language;
  });
  return {
    isSupported: isSupported2,
    language
  };
}
__name(useNavigatorLanguage, "useNavigatorLanguage");
function useNetwork(options3 = {}) {
  const { window: window2 = defaultWindow } = options3;
  const navigator2 = window2 == null ? void 0 : window2.navigator;
  const isSupported2 = useSupported(() => navigator2 && "connection" in navigator2);
  const isOnline = ref(true);
  const saveData = ref(false);
  const offlineAt = ref(void 0);
  const onlineAt = ref(void 0);
  const downlink = ref(void 0);
  const downlinkMax = ref(void 0);
  const rtt = ref(void 0);
  const effectiveType = ref(void 0);
  const type = ref("unknown");
  const connection = isSupported2.value && navigator2.connection;
  function updateNetworkInformation() {
    if (!navigator2)
      return;
    isOnline.value = navigator2.onLine;
    offlineAt.value = isOnline.value ? void 0 : Date.now();
    onlineAt.value = isOnline.value ? Date.now() : void 0;
    if (connection) {
      downlink.value = connection.downlink;
      downlinkMax.value = connection.downlinkMax;
      effectiveType.value = connection.effectiveType;
      rtt.value = connection.rtt;
      saveData.value = connection.saveData;
      type.value = connection.type;
    }
  }
  __name(updateNetworkInformation, "updateNetworkInformation");
  if (window2) {
    useEventListener(window2, "offline", () => {
      isOnline.value = false;
      offlineAt.value = Date.now();
    });
    useEventListener(window2, "online", () => {
      isOnline.value = true;
      onlineAt.value = Date.now();
    });
  }
  if (connection)
    useEventListener(connection, "change", updateNetworkInformation, false);
  updateNetworkInformation();
  return {
    isSupported: isSupported2,
    isOnline,
    saveData,
    offlineAt,
    onlineAt,
    downlink,
    downlinkMax,
    effectiveType,
    rtt,
    type
  };
}
__name(useNetwork, "useNetwork");
function useNow(options3 = {}) {
  const {
    controls: exposeControls = false,
    interval = "requestAnimationFrame"
  } = options3;
  const now2 = ref(/* @__PURE__ */ new Date());
  const update2 = /* @__PURE__ */ __name(() => now2.value = /* @__PURE__ */ new Date(), "update");
  const controls = interval === "requestAnimationFrame" ? useRafFn(update2, { immediate: true }) : useIntervalFn(update2, interval, { immediate: true });
  if (exposeControls) {
    return {
      now: now2,
      ...controls
    };
  } else {
    return now2;
  }
}
__name(useNow, "useNow");
function useObjectUrl(object) {
  const url = ref();
  const release = /* @__PURE__ */ __name(() => {
    if (url.value)
      URL.revokeObjectURL(url.value);
    url.value = void 0;
  }, "release");
  watch(
    () => toValue(object),
    (newObject) => {
      release();
      if (newObject)
        url.value = URL.createObjectURL(newObject);
    },
    { immediate: true }
  );
  tryOnScopeDispose(release);
  return readonly(url);
}
__name(useObjectUrl, "useObjectUrl");
function useClamp(value3, min, max) {
  if (typeof value3 === "function" || isReadonly(value3))
    return computed(() => clamp(toValue(value3), toValue(min), toValue(max)));
  const _value = ref(value3);
  return computed({
    get() {
      return _value.value = clamp(_value.value, toValue(min), toValue(max));
    },
    set(value22) {
      _value.value = clamp(value22, toValue(min), toValue(max));
    }
  });
}
__name(useClamp, "useClamp");
function useOffsetPagination(options3) {
  const {
    total = Number.POSITIVE_INFINITY,
    pageSize = 10,
    page = 1,
    onPageChange = noop,
    onPageSizeChange = noop,
    onPageCountChange = noop
  } = options3;
  const currentPageSize = useClamp(pageSize, 1, Number.POSITIVE_INFINITY);
  const pageCount = computed(() => Math.max(
    1,
    Math.ceil(toValue(total) / toValue(currentPageSize))
  ));
  const currentPage = useClamp(page, 1, pageCount);
  const isFirstPage = computed(() => currentPage.value === 1);
  const isLastPage = computed(() => currentPage.value === pageCount.value);
  if (isRef(page)) {
    syncRef(page, currentPage, {
      direction: isReadonly(page) ? "ltr" : "both"
    });
  }
  if (isRef(pageSize)) {
    syncRef(pageSize, currentPageSize, {
      direction: isReadonly(pageSize) ? "ltr" : "both"
    });
  }
  function prev2() {
    currentPage.value--;
  }
  __name(prev2, "prev");
  function next2() {
    currentPage.value++;
  }
  __name(next2, "next");
  const returnValue = {
    currentPage,
    currentPageSize,
    pageCount,
    isFirstPage,
    isLastPage,
    prev: prev2,
    next: next2
  };
  watch(currentPage, () => {
    onPageChange(reactive(returnValue));
  });
  watch(currentPageSize, () => {
    onPageSizeChange(reactive(returnValue));
  });
  watch(pageCount, () => {
    onPageCountChange(reactive(returnValue));
  });
  return returnValue;
}
__name(useOffsetPagination, "useOffsetPagination");
function useOnline(options3 = {}) {
  const { isOnline } = useNetwork(options3);
  return isOnline;
}
__name(useOnline, "useOnline");
function usePageLeave(options3 = {}) {
  const { window: window2 = defaultWindow } = options3;
  const isLeft = ref(false);
  const handler6 = /* @__PURE__ */ __name((event2) => {
    if (!window2)
      return;
    event2 = event2 || window2.event;
    const from = event2.relatedTarget || event2.toElement;
    isLeft.value = !from;
  }, "handler");
  if (window2) {
    useEventListener(window2, "mouseout", handler6, { passive: true });
    useEventListener(window2.document, "mouseleave", handler6, { passive: true });
    useEventListener(window2.document, "mouseenter", handler6, { passive: true });
  }
  return isLeft;
}
__name(usePageLeave, "usePageLeave");
function useScreenOrientation(options3 = {}) {
  const {
    window: window2 = defaultWindow
  } = options3;
  const isSupported2 = useSupported(() => window2 && "screen" in window2 && "orientation" in window2.screen);
  const screenOrientation = isSupported2.value ? window2.screen.orientation : {};
  const orientation2 = ref(screenOrientation.type);
  const angle = ref(screenOrientation.angle || 0);
  if (isSupported2.value) {
    useEventListener(window2, "orientationchange", () => {
      orientation2.value = screenOrientation.type;
      angle.value = screenOrientation.angle;
    });
  }
  const lockOrientation = /* @__PURE__ */ __name((type) => {
    if (isSupported2.value && typeof screenOrientation.lock === "function")
      return screenOrientation.lock(type);
    return Promise.reject(new Error("Not supported"));
  }, "lockOrientation");
  const unlockOrientation = /* @__PURE__ */ __name(() => {
    if (isSupported2.value && typeof screenOrientation.unlock === "function")
      screenOrientation.unlock();
  }, "unlockOrientation");
  return {
    isSupported: isSupported2,
    orientation: orientation2,
    angle,
    lockOrientation,
    unlockOrientation
  };
}
__name(useScreenOrientation, "useScreenOrientation");
function useParallax(target, options3 = {}) {
  const {
    deviceOrientationTiltAdjust = /* @__PURE__ */ __name((i2) => i2, "deviceOrientationTiltAdjust"),
    deviceOrientationRollAdjust = /* @__PURE__ */ __name((i2) => i2, "deviceOrientationRollAdjust"),
    mouseTiltAdjust = /* @__PURE__ */ __name((i2) => i2, "mouseTiltAdjust"),
    mouseRollAdjust = /* @__PURE__ */ __name((i2) => i2, "mouseRollAdjust"),
    window: window2 = defaultWindow
  } = options3;
  const orientation2 = reactive(useDeviceOrientation({ window: window2 }));
  const screenOrientation = reactive(useScreenOrientation({ window: window2 }));
  const {
    elementX: x2,
    elementY: y2,
    elementWidth: width2,
    elementHeight: height
  } = useMouseInElement(target, { handleOutside: false, window: window2 });
  const source = computed(() => {
    if (orientation2.isSupported && (orientation2.alpha != null && orientation2.alpha !== 0 || orientation2.gamma != null && orientation2.gamma !== 0)) {
      return "deviceOrientation";
    }
    return "mouse";
  });
  const roll = computed(() => {
    if (source.value === "deviceOrientation") {
      let value3;
      switch (screenOrientation.orientation) {
        case "landscape-primary":
          value3 = orientation2.gamma / 90;
          break;
        case "landscape-secondary":
          value3 = -orientation2.gamma / 90;
          break;
        case "portrait-primary":
          value3 = -orientation2.beta / 90;
          break;
        case "portrait-secondary":
          value3 = orientation2.beta / 90;
          break;
        default:
          value3 = -orientation2.beta / 90;
      }
      return deviceOrientationRollAdjust(value3);
    } else {
      const value3 = -(y2.value - height.value / 2) / height.value;
      return mouseRollAdjust(value3);
    }
  });
  const tilt = computed(() => {
    if (source.value === "deviceOrientation") {
      let value3;
      switch (screenOrientation.orientation) {
        case "landscape-primary":
          value3 = orientation2.beta / 90;
          break;
        case "landscape-secondary":
          value3 = -orientation2.beta / 90;
          break;
        case "portrait-primary":
          value3 = orientation2.gamma / 90;
          break;
        case "portrait-secondary":
          value3 = -orientation2.gamma / 90;
          break;
        default:
          value3 = orientation2.gamma / 90;
      }
      return deviceOrientationTiltAdjust(value3);
    } else {
      const value3 = (x2.value - width2.value / 2) / width2.value;
      return mouseTiltAdjust(value3);
    }
  });
  return { roll, tilt, source };
}
__name(useParallax, "useParallax");
function useParentElement(element = useCurrentElement()) {
  const parentElement = shallowRef();
  const update2 = /* @__PURE__ */ __name(() => {
    const el = unrefElement(element);
    if (el)
      parentElement.value = el.parentElement;
  }, "update");
  tryOnMounted(update2);
  watch(() => toValue(element), update2);
  return parentElement;
}
__name(useParentElement, "useParentElement");
function usePerformanceObserver(options3, callback) {
  const {
    window: window2 = defaultWindow,
    immediate = true,
    ...performanceOptions
  } = options3;
  const isSupported2 = useSupported(() => window2 && "PerformanceObserver" in window2);
  let observer;
  const stop2 = /* @__PURE__ */ __name(() => {
    observer == null ? void 0 : observer.disconnect();
  }, "stop");
  const start2 = /* @__PURE__ */ __name(() => {
    if (isSupported2.value) {
      stop2();
      observer = new PerformanceObserver(callback);
      observer.observe(performanceOptions);
    }
  }, "start");
  tryOnScopeDispose(stop2);
  if (immediate)
    start2();
  return {
    isSupported: isSupported2,
    start: start2,
    stop: stop2
  };
}
__name(usePerformanceObserver, "usePerformanceObserver");
const defaultState = {
  x: 0,
  y: 0,
  pointerId: 0,
  pressure: 0,
  tiltX: 0,
  tiltY: 0,
  width: 0,
  height: 0,
  twist: 0,
  pointerType: null
};
const keys = /* @__PURE__ */ Object.keys(defaultState);
function usePointer(options3 = {}) {
  const {
    target = defaultWindow
  } = options3;
  const isInside = ref(false);
  const state = ref(options3.initialValue || {});
  Object.assign(state.value, defaultState, state.value);
  const handler6 = /* @__PURE__ */ __name((event2) => {
    isInside.value = true;
    if (options3.pointerTypes && !options3.pointerTypes.includes(event2.pointerType))
      return;
    state.value = objectPick(event2, keys, false);
  }, "handler");
  if (target) {
    const listenerOptions = { passive: true };
    useEventListener(target, ["pointerdown", "pointermove", "pointerup"], handler6, listenerOptions);
    useEventListener(target, "pointerleave", () => isInside.value = false, listenerOptions);
  }
  return {
    ...toRefs(state),
    isInside
  };
}
__name(usePointer, "usePointer");
function usePointerLock(target, options3 = {}) {
  const { document: document2 = defaultDocument } = options3;
  const isSupported2 = useSupported(() => document2 && "pointerLockElement" in document2);
  const element = ref();
  const triggerElement = ref();
  let targetElement;
  if (isSupported2.value) {
    useEventListener(document2, "pointerlockchange", () => {
      var _a;
      const currentElement = (_a = document2.pointerLockElement) != null ? _a : element.value;
      if (targetElement && currentElement === targetElement) {
        element.value = document2.pointerLockElement;
        if (!element.value)
          targetElement = triggerElement.value = null;
      }
    });
    useEventListener(document2, "pointerlockerror", () => {
      var _a;
      const currentElement = (_a = document2.pointerLockElement) != null ? _a : element.value;
      if (targetElement && currentElement === targetElement) {
        const action = document2.pointerLockElement ? "release" : "acquire";
        throw new Error(`Failed to ${action} pointer lock.`);
      }
    });
  }
  async function lock(e) {
    var _a;
    if (!isSupported2.value)
      throw new Error("Pointer Lock API is not supported by your browser.");
    triggerElement.value = e instanceof Event ? e.currentTarget : null;
    targetElement = e instanceof Event ? (_a = unrefElement(target)) != null ? _a : triggerElement.value : unrefElement(e);
    if (!targetElement)
      throw new Error("Target element undefined.");
    targetElement.requestPointerLock();
    return await until(element).toBe(targetElement);
  }
  __name(lock, "lock");
  async function unlock() {
    if (!element.value)
      return false;
    document2.exitPointerLock();
    await until(element).toBeNull();
    return true;
  }
  __name(unlock, "unlock");
  return {
    isSupported: isSupported2,
    element,
    triggerElement,
    lock,
    unlock
  };
}
__name(usePointerLock, "usePointerLock");
function usePointerSwipe(target, options3 = {}) {
  const targetRef = toRef(target);
  const {
    threshold = 50,
    onSwipe,
    onSwipeEnd,
    onSwipeStart,
    disableTextSelect = false
  } = options3;
  const posStart = reactive({ x: 0, y: 0 });
  const updatePosStart = /* @__PURE__ */ __name((x2, y2) => {
    posStart.x = x2;
    posStart.y = y2;
  }, "updatePosStart");
  const posEnd = reactive({ x: 0, y: 0 });
  const updatePosEnd = /* @__PURE__ */ __name((x2, y2) => {
    posEnd.x = x2;
    posEnd.y = y2;
  }, "updatePosEnd");
  const distanceX = computed(() => posStart.x - posEnd.x);
  const distanceY = computed(() => posStart.y - posEnd.y);
  const { max, abs } = Math;
  const isThresholdExceeded = computed(() => max(abs(distanceX.value), abs(distanceY.value)) >= threshold);
  const isSwiping = ref(false);
  const isPointerDown = ref(false);
  const direction = computed(() => {
    if (!isThresholdExceeded.value)
      return "none";
    if (abs(distanceX.value) > abs(distanceY.value)) {
      return distanceX.value > 0 ? "left" : "right";
    } else {
      return distanceY.value > 0 ? "up" : "down";
    }
  });
  const eventIsAllowed = /* @__PURE__ */ __name((e) => {
    var _a, _b, _c;
    const isReleasingButton = e.buttons === 0;
    const isPrimaryButton = e.buttons === 1;
    return (_c = (_b = (_a = options3.pointerTypes) == null ? void 0 : _a.includes(e.pointerType)) != null ? _b : isReleasingButton || isPrimaryButton) != null ? _c : true;
  }, "eventIsAllowed");
  const stops = [
    useEventListener(target, "pointerdown", (e) => {
      if (!eventIsAllowed(e))
        return;
      isPointerDown.value = true;
      const eventTarget = e.target;
      eventTarget == null ? void 0 : eventTarget.setPointerCapture(e.pointerId);
      const { clientX: x2, clientY: y2 } = e;
      updatePosStart(x2, y2);
      updatePosEnd(x2, y2);
      onSwipeStart == null ? void 0 : onSwipeStart(e);
    }),
    useEventListener(target, "pointermove", (e) => {
      if (!eventIsAllowed(e))
        return;
      if (!isPointerDown.value)
        return;
      const { clientX: x2, clientY: y2 } = e;
      updatePosEnd(x2, y2);
      if (!isSwiping.value && isThresholdExceeded.value)
        isSwiping.value = true;
      if (isSwiping.value)
        onSwipe == null ? void 0 : onSwipe(e);
    }),
    useEventListener(target, "pointerup", (e) => {
      if (!eventIsAllowed(e))
        return;
      if (isSwiping.value)
        onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction.value);
      isPointerDown.value = false;
      isSwiping.value = false;
    })
  ];
  tryOnMounted(() => {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    (_b = (_a = targetRef.value) == null ? void 0 : _a.style) == null ? void 0 : _b.setProperty("touch-action", "none");
    if (disableTextSelect) {
      (_d = (_c = targetRef.value) == null ? void 0 : _c.style) == null ? void 0 : _d.setProperty("-webkit-user-select", "none");
      (_f = (_e = targetRef.value) == null ? void 0 : _e.style) == null ? void 0 : _f.setProperty("-ms-user-select", "none");
      (_h = (_g = targetRef.value) == null ? void 0 : _g.style) == null ? void 0 : _h.setProperty("user-select", "none");
    }
  });
  const stop2 = /* @__PURE__ */ __name(() => stops.forEach((s) => s()), "stop");
  return {
    isSwiping: readonly(isSwiping),
    direction: readonly(direction),
    posStart: readonly(posStart),
    posEnd: readonly(posEnd),
    distanceX,
    distanceY,
    stop: stop2
  };
}
__name(usePointerSwipe, "usePointerSwipe");
function usePreferredColorScheme(options3) {
  const isLight = useMediaQuery("(prefers-color-scheme: light)", options3);
  const isDark = useMediaQuery("(prefers-color-scheme: dark)", options3);
  return computed(() => {
    if (isDark.value)
      return "dark";
    if (isLight.value)
      return "light";
    return "no-preference";
  });
}
__name(usePreferredColorScheme, "usePreferredColorScheme");
function usePreferredContrast(options3) {
  const isMore = useMediaQuery("(prefers-contrast: more)", options3);
  const isLess = useMediaQuery("(prefers-contrast: less)", options3);
  const isCustom = useMediaQuery("(prefers-contrast: custom)", options3);
  return computed(() => {
    if (isMore.value)
      return "more";
    if (isLess.value)
      return "less";
    if (isCustom.value)
      return "custom";
    return "no-preference";
  });
}
__name(usePreferredContrast, "usePreferredContrast");
function usePreferredLanguages(options3 = {}) {
  const { window: window2 = defaultWindow } = options3;
  if (!window2)
    return ref(["en"]);
  const navigator2 = window2.navigator;
  const value3 = ref(navigator2.languages);
  useEventListener(window2, "languagechange", () => {
    value3.value = navigator2.languages;
  });
  return value3;
}
__name(usePreferredLanguages, "usePreferredLanguages");
function usePreferredReducedMotion(options3) {
  const isReduced = useMediaQuery("(prefers-reduced-motion: reduce)", options3);
  return computed(() => {
    if (isReduced.value)
      return "reduce";
    return "no-preference";
  });
}
__name(usePreferredReducedMotion, "usePreferredReducedMotion");
function usePrevious(value3, initialValue) {
  const previous = shallowRef(initialValue);
  watch(
    toRef(value3),
    (_2, oldValue) => {
      previous.value = oldValue;
    },
    { flush: "sync" }
  );
  return readonly(previous);
}
__name(usePrevious, "usePrevious");
const topVarName = "--vueuse-safe-area-top";
const rightVarName = "--vueuse-safe-area-right";
const bottomVarName = "--vueuse-safe-area-bottom";
const leftVarName = "--vueuse-safe-area-left";
function useScreenSafeArea() {
  const top = ref("");
  const right = ref("");
  const bottom = ref("");
  const left = ref("");
  if (isClient) {
    const topCssVar = useCssVar(topVarName);
    const rightCssVar = useCssVar(rightVarName);
    const bottomCssVar = useCssVar(bottomVarName);
    const leftCssVar = useCssVar(leftVarName);
    topCssVar.value = "env(safe-area-inset-top, 0px)";
    rightCssVar.value = "env(safe-area-inset-right, 0px)";
    bottomCssVar.value = "env(safe-area-inset-bottom, 0px)";
    leftCssVar.value = "env(safe-area-inset-left, 0px)";
    update2();
    useEventListener("resize", useDebounceFn(update2));
  }
  function update2() {
    top.value = getValue(topVarName);
    right.value = getValue(rightVarName);
    bottom.value = getValue(bottomVarName);
    left.value = getValue(leftVarName);
  }
  __name(update2, "update");
  return {
    top,
    right,
    bottom,
    left,
    update: update2
  };
}
__name(useScreenSafeArea, "useScreenSafeArea");
function getValue(position2) {
  return getComputedStyle(document.documentElement).getPropertyValue(position2);
}
__name(getValue, "getValue");
function useScriptTag(src, onLoaded = noop, options3 = {}) {
  const {
    immediate = true,
    manual = false,
    type = "text/javascript",
    async = true,
    crossOrigin,
    referrerPolicy,
    noModule,
    defer,
    document: document2 = defaultDocument,
    attrs: attrs3 = {}
  } = options3;
  const scriptTag = ref(null);
  let _promise = null;
  const loadScript = /* @__PURE__ */ __name((waitForScriptLoad) => new Promise((resolve8, reject2) => {
    const resolveWithElement = /* @__PURE__ */ __name((el2) => {
      scriptTag.value = el2;
      resolve8(el2);
      return el2;
    }, "resolveWithElement");
    if (!document2) {
      resolve8(false);
      return;
    }
    let shouldAppend = false;
    let el = document2.querySelector(`script[src="${toValue(src)}"]`);
    if (!el) {
      el = document2.createElement("script");
      el.type = type;
      el.async = async;
      el.src = toValue(src);
      if (defer)
        el.defer = defer;
      if (crossOrigin)
        el.crossOrigin = crossOrigin;
      if (noModule)
        el.noModule = noModule;
      if (referrerPolicy)
        el.referrerPolicy = referrerPolicy;
      Object.entries(attrs3).forEach(([name, value3]) => el == null ? void 0 : el.setAttribute(name, value3));
      shouldAppend = true;
    } else if (el.hasAttribute("data-loaded")) {
      resolveWithElement(el);
    }
    el.addEventListener("error", (event2) => reject2(event2));
    el.addEventListener("abort", (event2) => reject2(event2));
    el.addEventListener("load", () => {
      el.setAttribute("data-loaded", "true");
      onLoaded(el);
      resolveWithElement(el);
    });
    if (shouldAppend)
      el = document2.head.appendChild(el);
    if (!waitForScriptLoad)
      resolveWithElement(el);
  }), "loadScript");
  const load2 = /* @__PURE__ */ __name((waitForScriptLoad = true) => {
    if (!_promise)
      _promise = loadScript(waitForScriptLoad);
    return _promise;
  }, "load");
  const unload = /* @__PURE__ */ __name(() => {
    if (!document2)
      return;
    _promise = null;
    if (scriptTag.value)
      scriptTag.value = null;
    const el = document2.querySelector(`script[src="${toValue(src)}"]`);
    if (el)
      document2.head.removeChild(el);
  }, "unload");
  if (immediate && !manual)
    tryOnMounted(load2);
  if (!manual)
    tryOnUnmounted(unload);
  return { scriptTag, load: load2, unload };
}
__name(useScriptTag, "useScriptTag");
function checkOverflowScroll(ele) {
  const style = window.getComputedStyle(ele);
  if (style.overflowX === "scroll" || style.overflowY === "scroll" || style.overflowX === "auto" && ele.clientWidth < ele.scrollWidth || style.overflowY === "auto" && ele.clientHeight < ele.scrollHeight) {
    return true;
  } else {
    const parent = ele.parentNode;
    if (!parent || parent.tagName === "BODY")
      return false;
    return checkOverflowScroll(parent);
  }
}
__name(checkOverflowScroll, "checkOverflowScroll");
function preventDefault(rawEvent) {
  const e = rawEvent || window.event;
  const _target = e.target;
  if (checkOverflowScroll(_target))
    return false;
  if (e.touches.length > 1)
    return true;
  if (e.preventDefault)
    e.preventDefault();
  return false;
}
__name(preventDefault, "preventDefault");
const elInitialOverflow = /* @__PURE__ */ new WeakMap();
function useScrollLock(element, initialState = false) {
  const isLocked = ref(initialState);
  let stopTouchMoveListener = null;
  let initialOverflow = "";
  watch(toRef(element), (el) => {
    const target = resolveElement(toValue(el));
    if (target) {
      const ele = target;
      if (!elInitialOverflow.get(ele))
        elInitialOverflow.set(ele, ele.style.overflow);
      if (ele.style.overflow !== "hidden")
        initialOverflow = ele.style.overflow;
      if (ele.style.overflow === "hidden")
        return isLocked.value = true;
      if (isLocked.value)
        return ele.style.overflow = "hidden";
    }
  }, {
    immediate: true
  });
  const lock = /* @__PURE__ */ __name(() => {
    const el = resolveElement(toValue(element));
    if (!el || isLocked.value)
      return;
    if (isIOS) {
      stopTouchMoveListener = useEventListener(
        el,
        "touchmove",
        (e) => {
          preventDefault(e);
        },
        { passive: false }
      );
    }
    el.style.overflow = "hidden";
    isLocked.value = true;
  }, "lock");
  const unlock = /* @__PURE__ */ __name(() => {
    const el = resolveElement(toValue(element));
    if (!el || !isLocked.value)
      return;
    if (isIOS)
      stopTouchMoveListener == null ? void 0 : stopTouchMoveListener();
    el.style.overflow = initialOverflow;
    elInitialOverflow.delete(el);
    isLocked.value = false;
  }, "unlock");
  tryOnScopeDispose(unlock);
  return computed({
    get() {
      return isLocked.value;
    },
    set(v2) {
      if (v2)
        lock();
      else unlock();
    }
  });
}
__name(useScrollLock, "useScrollLock");
function useSessionStorage(key, initialValue, options3 = {}) {
  const { window: window2 = defaultWindow } = options3;
  return useStorage(key, initialValue, window2 == null ? void 0 : window2.sessionStorage, options3);
}
__name(useSessionStorage, "useSessionStorage");
function useShare(shareOptions = {}, options3 = {}) {
  const { navigator: navigator2 = defaultNavigator } = options3;
  const _navigator2 = navigator2;
  const isSupported2 = useSupported(() => _navigator2 && "canShare" in _navigator2);
  const share = /* @__PURE__ */ __name(async (overrideOptions = {}) => {
    if (isSupported2.value) {
      const data24 = {
        ...toValue(shareOptions),
        ...toValue(overrideOptions)
      };
      let granted = true;
      if (data24.files && _navigator2.canShare)
        granted = _navigator2.canShare({ files: data24.files });
      if (granted)
        return _navigator2.share(data24);
    }
  }, "share");
  return {
    isSupported: isSupported2,
    share
  };
}
__name(useShare, "useShare");
const defaultSortFn = /* @__PURE__ */ __name((source, compareFn) => source.sort(compareFn), "defaultSortFn");
const defaultCompare = /* @__PURE__ */ __name((a, b) => a - b, "defaultCompare");
function useSorted(...args) {
  var _a, _b, _c, _d;
  const [source] = args;
  let compareFn = defaultCompare;
  let options3 = {};
  if (args.length === 2) {
    if (typeof args[1] === "object") {
      options3 = args[1];
      compareFn = (_a = options3.compareFn) != null ? _a : defaultCompare;
    } else {
      compareFn = (_b = args[1]) != null ? _b : defaultCompare;
    }
  } else if (args.length > 2) {
    compareFn = (_c = args[1]) != null ? _c : defaultCompare;
    options3 = (_d = args[2]) != null ? _d : {};
  }
  const {
    dirty = false,
    sortFn = defaultSortFn
  } = options3;
  if (!dirty)
    return computed(() => sortFn([...toValue(source)], compareFn));
  watchEffect(() => {
    const result = sortFn(toValue(source), compareFn);
    if (isRef(source))
      source.value = result;
    else
      source.splice(0, source.length, ...result);
  });
  return source;
}
__name(useSorted, "useSorted");
function useSpeechRecognition(options3 = {}) {
  const {
    interimResults = true,
    continuous = true,
    maxAlternatives = 1,
    window: window2 = defaultWindow
  } = options3;
  const lang = toRef(options3.lang || "en-US");
  const isListening = ref(false);
  const isFinal = ref(false);
  const result = ref("");
  const error = shallowRef(void 0);
  const toggle4 = /* @__PURE__ */ __name((value3 = !isListening.value) => {
    isListening.value = value3;
  }, "toggle");
  const start2 = /* @__PURE__ */ __name(() => {
    isListening.value = true;
  }, "start");
  const stop2 = /* @__PURE__ */ __name(() => {
    isListening.value = false;
  }, "stop");
  const SpeechRecognition = window2 && (window2.SpeechRecognition || window2.webkitSpeechRecognition);
  const isSupported2 = useSupported(() => SpeechRecognition);
  let recognition;
  if (isSupported2.value) {
    recognition = new SpeechRecognition();
    recognition.continuous = continuous;
    recognition.interimResults = interimResults;
    recognition.lang = toValue(lang);
    recognition.maxAlternatives = maxAlternatives;
    recognition.onstart = () => {
      isFinal.value = false;
    };
    watch(lang, (lang2) => {
      if (recognition && !isListening.value)
        recognition.lang = lang2;
    });
    recognition.onresult = (event2) => {
      const currentResult = event2.results[event2.resultIndex];
      const { transcript } = currentResult[0];
      isFinal.value = currentResult.isFinal;
      result.value = transcript;
      error.value = void 0;
    };
    recognition.onerror = (event2) => {
      error.value = event2;
    };
    recognition.onend = () => {
      isListening.value = false;
      recognition.lang = toValue(lang);
    };
    watch(isListening, () => {
      if (isListening.value)
        recognition.start();
      else
        recognition.stop();
    });
  }
  tryOnScopeDispose(() => {
    isListening.value = false;
  });
  return {
    isSupported: isSupported2,
    isListening,
    isFinal,
    recognition,
    result,
    error,
    toggle: toggle4,
    start: start2,
    stop: stop2
  };
}
__name(useSpeechRecognition, "useSpeechRecognition");
function useSpeechSynthesis(text, options3 = {}) {
  const {
    pitch = 1,
    rate = 1,
    volume = 1,
    window: window2 = defaultWindow
  } = options3;
  const synth = window2 && window2.speechSynthesis;
  const isSupported2 = useSupported(() => synth);
  const isPlaying = ref(false);
  const status = ref("init");
  const spokenText = toRef(text || "");
  const lang = toRef(options3.lang || "en-US");
  const error = shallowRef(void 0);
  const toggle4 = /* @__PURE__ */ __name((value3 = !isPlaying.value) => {
    isPlaying.value = value3;
  }, "toggle");
  const bindEventsForUtterance = /* @__PURE__ */ __name((utterance2) => {
    utterance2.lang = toValue(lang);
    utterance2.voice = toValue(options3.voice) || null;
    utterance2.pitch = toValue(pitch);
    utterance2.rate = toValue(rate);
    utterance2.volume = volume;
    utterance2.onstart = () => {
      isPlaying.value = true;
      status.value = "play";
    };
    utterance2.onpause = () => {
      isPlaying.value = false;
      status.value = "pause";
    };
    utterance2.onresume = () => {
      isPlaying.value = true;
      status.value = "play";
    };
    utterance2.onend = () => {
      isPlaying.value = false;
      status.value = "end";
    };
    utterance2.onerror = (event2) => {
      error.value = event2;
    };
  }, "bindEventsForUtterance");
  const utterance = computed(() => {
    isPlaying.value = false;
    status.value = "init";
    const newUtterance = new SpeechSynthesisUtterance(spokenText.value);
    bindEventsForUtterance(newUtterance);
    return newUtterance;
  });
  const speak = /* @__PURE__ */ __name(() => {
    synth.cancel();
    if (utterance)
      synth.speak(utterance.value);
  }, "speak");
  const stop2 = /* @__PURE__ */ __name(() => {
    synth.cancel();
    isPlaying.value = false;
  }, "stop");
  if (isSupported2.value) {
    bindEventsForUtterance(utterance.value);
    watch(lang, (lang2) => {
      if (utterance.value && !isPlaying.value)
        utterance.value.lang = lang2;
    });
    if (options3.voice) {
      watch(options3.voice, () => {
        synth.cancel();
      });
    }
    watch(isPlaying, () => {
      if (isPlaying.value)
        synth.resume();
      else
        synth.pause();
    });
  }
  tryOnScopeDispose(() => {
    isPlaying.value = false;
  });
  return {
    isSupported: isSupported2,
    isPlaying,
    status,
    utterance,
    error,
    stop: stop2,
    toggle: toggle4,
    speak
  };
}
__name(useSpeechSynthesis, "useSpeechSynthesis");
function useStepper(steps, initialStep) {
  const stepsRef = ref(steps);
  const stepNames = computed(() => Array.isArray(stepsRef.value) ? stepsRef.value : Object.keys(stepsRef.value));
  const index2 = ref(stepNames.value.indexOf(initialStep != null ? initialStep : stepNames.value[0]));
  const current = computed(() => at(index2.value));
  const isFirst = computed(() => index2.value === 0);
  const isLast = computed(() => index2.value === stepNames.value.length - 1);
  const next2 = computed(() => stepNames.value[index2.value + 1]);
  const previous = computed(() => stepNames.value[index2.value - 1]);
  function at(index22) {
    if (Array.isArray(stepsRef.value))
      return stepsRef.value[index22];
    return stepsRef.value[stepNames.value[index22]];
  }
  __name(at, "at");
  function get2(step2) {
    if (!stepNames.value.includes(step2))
      return;
    return at(stepNames.value.indexOf(step2));
  }
  __name(get2, "get");
  function goTo(step2) {
    if (stepNames.value.includes(step2))
      index2.value = stepNames.value.indexOf(step2);
  }
  __name(goTo, "goTo");
  function goToNext() {
    if (isLast.value)
      return;
    index2.value++;
  }
  __name(goToNext, "goToNext");
  function goToPrevious() {
    if (isFirst.value)
      return;
    index2.value--;
  }
  __name(goToPrevious, "goToPrevious");
  function goBackTo(step2) {
    if (isAfter(step2))
      goTo(step2);
  }
  __name(goBackTo, "goBackTo");
  function isNext(step2) {
    return stepNames.value.indexOf(step2) === index2.value + 1;
  }
  __name(isNext, "isNext");
  function isPrevious(step2) {
    return stepNames.value.indexOf(step2) === index2.value - 1;
  }
  __name(isPrevious, "isPrevious");
  function isCurrent(step2) {
    return stepNames.value.indexOf(step2) === index2.value;
  }
  __name(isCurrent, "isCurrent");
  function isBefore(step2) {
    return index2.value < stepNames.value.indexOf(step2);
  }
  __name(isBefore, "isBefore");
  function isAfter(step2) {
    return index2.value > stepNames.value.indexOf(step2);
  }
  __name(isAfter, "isAfter");
  return {
    steps: stepsRef,
    stepNames,
    index: index2,
    current,
    next: next2,
    previous,
    isFirst,
    isLast,
    at,
    get: get2,
    goTo,
    goToNext,
    goToPrevious,
    goBackTo,
    isNext,
    isPrevious,
    isCurrent,
    isBefore,
    isAfter
  };
}
__name(useStepper, "useStepper");
function useStorageAsync(key, initialValue, storage, options3 = {}) {
  var _a;
  const {
    flush = "pre",
    deep = true,
    listenToStorageChanges = true,
    writeDefaults = true,
    mergeDefaults: mergeDefaults2 = false,
    shallow,
    window: window2 = defaultWindow,
    eventFilter,
    onError = /* @__PURE__ */ __name((e) => {
      console.error(e);
    }, "onError")
  } = options3;
  const rawInit = toValue(initialValue);
  const type = guessSerializerType(rawInit);
  const data24 = (shallow ? shallowRef : ref)(initialValue);
  const serializer = (_a = options3.serializer) != null ? _a : StorageSerializers[type];
  if (!storage) {
    try {
      storage = getSSRHandler("getDefaultStorageAsync", () => {
        var _a2;
        return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;
      })();
    } catch (e) {
      onError(e);
    }
  }
  async function read(event2) {
    if (!storage || event2 && event2.key !== key)
      return;
    try {
      const rawValue = event2 ? event2.newValue : await storage.getItem(key);
      if (rawValue == null) {
        data24.value = rawInit;
        if (writeDefaults && rawInit !== null)
          await storage.setItem(key, await serializer.write(rawInit));
      } else if (mergeDefaults2) {
        const value3 = await serializer.read(rawValue);
        if (typeof mergeDefaults2 === "function")
          data24.value = mergeDefaults2(value3, rawInit);
        else if (type === "object" && !Array.isArray(value3))
          data24.value = { ...rawInit, ...value3 };
        else data24.value = value3;
      } else {
        data24.value = await serializer.read(rawValue);
      }
    } catch (e) {
      onError(e);
    }
  }
  __name(read, "read");
  read();
  if (window2 && listenToStorageChanges)
    useEventListener(window2, "storage", (e) => Promise.resolve().then(() => read(e)));
  if (storage) {
    watchWithFilter(
      data24,
      async () => {
        try {
          if (data24.value == null)
            await storage.removeItem(key);
          else
            await storage.setItem(key, await serializer.write(data24.value));
        } catch (e) {
          onError(e);
        }
      },
      {
        flush,
        deep,
        eventFilter
      }
    );
  }
  return data24;
}
__name(useStorageAsync, "useStorageAsync");
let _id = 0;
function useStyleTag(css4, options3 = {}) {
  const isLoaded = ref(false);
  const {
    document: document2 = defaultDocument,
    immediate = true,
    manual = false,
    id: id2 = `vueuse_styletag_${++_id}`
  } = options3;
  const cssRef = ref(css4);
  let stop2 = /* @__PURE__ */ __name(() => {
  }, "stop");
  const load2 = /* @__PURE__ */ __name(() => {
    if (!document2)
      return;
    const el = document2.getElementById(id2) || document2.createElement("style");
    if (!el.isConnected) {
      el.id = id2;
      if (options3.media)
        el.media = options3.media;
      document2.head.appendChild(el);
    }
    if (isLoaded.value)
      return;
    stop2 = watch(
      cssRef,
      (value3) => {
        el.textContent = value3;
      },
      { immediate: true }
    );
    isLoaded.value = true;
  }, "load");
  const unload = /* @__PURE__ */ __name(() => {
    if (!document2 || !isLoaded.value)
      return;
    stop2();
    document2.head.removeChild(document2.getElementById(id2));
    isLoaded.value = false;
  }, "unload");
  if (immediate && !manual)
    tryOnMounted(load2);
  if (!manual)
    tryOnScopeDispose(unload);
  return {
    id: id2,
    css: cssRef,
    unload,
    load: load2,
    isLoaded: readonly(isLoaded)
  };
}
__name(useStyleTag, "useStyleTag");
function useSwipe(target, options3 = {}) {
  const {
    threshold = 50,
    onSwipe,
    onSwipeEnd,
    onSwipeStart,
    passive = true,
    window: window2 = defaultWindow
  } = options3;
  const coordsStart = reactive({ x: 0, y: 0 });
  const coordsEnd = reactive({ x: 0, y: 0 });
  const diffX = computed(() => coordsStart.x - coordsEnd.x);
  const diffY = computed(() => coordsStart.y - coordsEnd.y);
  const { max, abs } = Math;
  const isThresholdExceeded = computed(() => max(abs(diffX.value), abs(diffY.value)) >= threshold);
  const isSwiping = ref(false);
  const direction = computed(() => {
    if (!isThresholdExceeded.value)
      return "none";
    if (abs(diffX.value) > abs(diffY.value)) {
      return diffX.value > 0 ? "left" : "right";
    } else {
      return diffY.value > 0 ? "up" : "down";
    }
  });
  const getTouchEventCoords = /* @__PURE__ */ __name((e) => [e.touches[0].clientX, e.touches[0].clientY], "getTouchEventCoords");
  const updateCoordsStart = /* @__PURE__ */ __name((x2, y2) => {
    coordsStart.x = x2;
    coordsStart.y = y2;
  }, "updateCoordsStart");
  const updateCoordsEnd = /* @__PURE__ */ __name((x2, y2) => {
    coordsEnd.x = x2;
    coordsEnd.y = y2;
  }, "updateCoordsEnd");
  let listenerOptions;
  const isPassiveEventSupported = checkPassiveEventSupport(window2 == null ? void 0 : window2.document);
  if (!passive)
    listenerOptions = isPassiveEventSupported ? { passive: false, capture: true } : { capture: true };
  else
    listenerOptions = isPassiveEventSupported ? { passive: true } : { capture: false };
  const onTouchEnd3 = /* @__PURE__ */ __name((e) => {
    if (isSwiping.value)
      onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction.value);
    isSwiping.value = false;
  }, "onTouchEnd");
  const stops = [
    useEventListener(target, "touchstart", (e) => {
      if (e.touches.length !== 1)
        return;
      if (listenerOptions.capture && !listenerOptions.passive)
        e.preventDefault();
      const [x2, y2] = getTouchEventCoords(e);
      updateCoordsStart(x2, y2);
      updateCoordsEnd(x2, y2);
      onSwipeStart == null ? void 0 : onSwipeStart(e);
    }, listenerOptions),
    useEventListener(target, "touchmove", (e) => {
      if (e.touches.length !== 1)
        return;
      const [x2, y2] = getTouchEventCoords(e);
      updateCoordsEnd(x2, y2);
      if (!isSwiping.value && isThresholdExceeded.value)
        isSwiping.value = true;
      if (isSwiping.value)
        onSwipe == null ? void 0 : onSwipe(e);
    }, listenerOptions),
    useEventListener(target, ["touchend", "touchcancel"], onTouchEnd3, listenerOptions)
  ];
  const stop2 = /* @__PURE__ */ __name(() => stops.forEach((s) => s()), "stop");
  return {
    isPassiveEventSupported,
    isSwiping,
    direction,
    coordsStart,
    coordsEnd,
    lengthX: diffX,
    lengthY: diffY,
    stop: stop2
  };
}
__name(useSwipe, "useSwipe");
function checkPassiveEventSupport(document2) {
  if (!document2)
    return false;
  let supportsPassive = false;
  const optionsBlock = {
    get passive() {
      supportsPassive = true;
      return false;
    }
  };
  document2.addEventListener("x", noop, optionsBlock);
  document2.removeEventListener("x", noop);
  return supportsPassive;
}
__name(checkPassiveEventSupport, "checkPassiveEventSupport");
function useTemplateRefsList() {
  const refs = ref([]);
  refs.value.set = (el) => {
    if (el)
      refs.value.push(el);
  };
  onBeforeUpdate(() => {
    refs.value.length = 0;
  });
  return refs;
}
__name(useTemplateRefsList, "useTemplateRefsList");
function useTextDirection(options3 = {}) {
  const {
    document: document2 = defaultDocument,
    selector = "html",
    observe = false,
    initialValue = "ltr"
  } = options3;
  function getValue2() {
    var _a, _b;
    return (_b = (_a = document2 == null ? void 0 : document2.querySelector(selector)) == null ? void 0 : _a.getAttribute("dir")) != null ? _b : initialValue;
  }
  __name(getValue2, "getValue2");
  const dir = ref(getValue2());
  tryOnMounted(() => dir.value = getValue2());
  if (observe && document2) {
    useMutationObserver(
      document2.querySelector(selector),
      () => dir.value = getValue2(),
      { attributes: true }
    );
  }
  return computed({
    get() {
      return dir.value;
    },
    set(v2) {
      var _a, _b;
      dir.value = v2;
      if (!document2)
        return;
      if (dir.value)
        (_a = document2.querySelector(selector)) == null ? void 0 : _a.setAttribute("dir", dir.value);
      else
        (_b = document2.querySelector(selector)) == null ? void 0 : _b.removeAttribute("dir");
    }
  });
}
__name(useTextDirection, "useTextDirection");
function getRangesFromSelection(selection) {
  var _a;
  const rangeCount = (_a = selection.rangeCount) != null ? _a : 0;
  return Array.from({ length: rangeCount }, (_2, i2) => selection.getRangeAt(i2));
}
__name(getRangesFromSelection, "getRangesFromSelection");
function useTextSelection(options3 = {}) {
  const {
    window: window2 = defaultWindow
  } = options3;
  const selection = ref(null);
  const text = computed(() => {
    var _a, _b;
    return (_b = (_a = selection.value) == null ? void 0 : _a.toString()) != null ? _b : "";
  });
  const ranges = computed(() => selection.value ? getRangesFromSelection(selection.value) : []);
  const rects = computed(() => ranges.value.map((range2) => range2.getBoundingClientRect()));
  function onSelectionChange() {
    selection.value = null;
    if (window2)
      selection.value = window2.getSelection();
  }
  __name(onSelectionChange, "onSelectionChange");
  if (window2)
    useEventListener(window2.document, "selectionchange", onSelectionChange);
  return {
    text,
    rects,
    ranges,
    selection
  };
}
__name(useTextSelection, "useTextSelection");
function useTextareaAutosize(options3) {
  var _a;
  const textarea = ref(options3 == null ? void 0 : options3.element);
  const input = ref(options3 == null ? void 0 : options3.input);
  const styleProp = (_a = options3 == null ? void 0 : options3.styleProp) != null ? _a : "height";
  const textareaScrollHeight = ref(1);
  const textareaOldWidth = ref(0);
  function triggerResize() {
    var _a2;
    if (!textarea.value)
      return;
    let height = "";
    textarea.value.style[styleProp] = "1px";
    textareaScrollHeight.value = (_a2 = textarea.value) == null ? void 0 : _a2.scrollHeight;
    const _styleTarget = toValue(options3 == null ? void 0 : options3.styleTarget);
    if (_styleTarget)
      _styleTarget.style[styleProp] = `${textareaScrollHeight.value}px`;
    else
      height = `${textareaScrollHeight.value}px`;
    textarea.value.style[styleProp] = height;
  }
  __name(triggerResize, "triggerResize");
  watch([input, textarea], () => nextTick(triggerResize), { immediate: true });
  watch(textareaScrollHeight, () => {
    var _a2;
    return (_a2 = options3 == null ? void 0 : options3.onResize) == null ? void 0 : _a2.call(options3);
  });
  useResizeObserver(textarea, ([{ contentRect }]) => {
    if (textareaOldWidth.value === contentRect.width)
      return;
    textareaOldWidth.value = contentRect.width;
    triggerResize();
  });
  if (options3 == null ? void 0 : options3.watch)
    watch(options3.watch, triggerResize, { immediate: true, deep: true });
  return {
    textarea,
    input,
    triggerResize
  };
}
__name(useTextareaAutosize, "useTextareaAutosize");
function useThrottledRefHistory(source, options3 = {}) {
  const { throttle: throttle2 = 200, trailing = true } = options3;
  const filter4 = throttleFilter(throttle2, trailing);
  const history = useRefHistory(source, { ...options3, eventFilter: filter4 });
  return {
    ...history
  };
}
__name(useThrottledRefHistory, "useThrottledRefHistory");
const DEFAULT_UNITS = [
  { max: 6e4, value: 1e3, name: "second" },
  { max: 276e4, value: 6e4, name: "minute" },
  { max: 72e6, value: 36e5, name: "hour" },
  { max: 5184e5, value: 864e5, name: "day" },
  { max: 24192e5, value: 6048e5, name: "week" },
  { max: 28512e6, value: 2592e6, name: "month" },
  { max: Number.POSITIVE_INFINITY, value: 31536e6, name: "year" }
];
const DEFAULT_MESSAGES = {
  justNow: "just now",
  past: /* @__PURE__ */ __name((n) => n.match(/\d/) ? `${n} ago` : n, "past"),
  future: /* @__PURE__ */ __name((n) => n.match(/\d/) ? `in ${n}` : n, "future"),
  month: /* @__PURE__ */ __name((n, past) => n === 1 ? past ? "last month" : "next month" : `${n} month${n > 1 ? "s" : ""}`, "month"),
  year: /* @__PURE__ */ __name((n, past) => n === 1 ? past ? "last year" : "next year" : `${n} year${n > 1 ? "s" : ""}`, "year"),
  day: /* @__PURE__ */ __name((n, past) => n === 1 ? past ? "yesterday" : "tomorrow" : `${n} day${n > 1 ? "s" : ""}`, "day"),
  week: /* @__PURE__ */ __name((n, past) => n === 1 ? past ? "last week" : "next week" : `${n} week${n > 1 ? "s" : ""}`, "week"),
  hour: /* @__PURE__ */ __name((n) => `${n} hour${n > 1 ? "s" : ""}`, "hour"),
  minute: /* @__PURE__ */ __name((n) => `${n} minute${n > 1 ? "s" : ""}`, "minute"),
  second: /* @__PURE__ */ __name((n) => `${n} second${n > 1 ? "s" : ""}`, "second"),
  invalid: ""
};
function DEFAULT_FORMATTER(date) {
  return date.toISOString().slice(0, 10);
}
__name(DEFAULT_FORMATTER, "DEFAULT_FORMATTER");
function useTimeAgo(time, options3 = {}) {
  const {
    controls: exposeControls = false,
    updateInterval = 3e4
  } = options3;
  const { now: now2, ...controls } = useNow({ interval: updateInterval, controls: true });
  const timeAgo = computed(() => formatTimeAgo(new Date(toValue(time)), options3, toValue(now2)));
  if (exposeControls) {
    return {
      timeAgo,
      ...controls
    };
  } else {
    return timeAgo;
  }
}
__name(useTimeAgo, "useTimeAgo");
function formatTimeAgo(from, options3 = {}, now2 = Date.now()) {
  var _a;
  const {
    max,
    messages: messages2 = DEFAULT_MESSAGES,
    fullDateFormatter = DEFAULT_FORMATTER,
    units = DEFAULT_UNITS,
    showSecond = false,
    rounding = "round"
  } = options3;
  const roundFn = typeof rounding === "number" ? (n) => +n.toFixed(rounding) : Math[rounding];
  const diff = +now2 - +from;
  const absDiff = Math.abs(diff);
  function getValue2(diff2, unit) {
    return roundFn(Math.abs(diff2) / unit.value);
  }
  __name(getValue2, "getValue2");
  function format2(diff2, unit) {
    const val = getValue2(diff2, unit);
    const past = diff2 > 0;
    const str = applyFormat(unit.name, val, past);
    return applyFormat(past ? "past" : "future", str, past);
  }
  __name(format2, "format");
  function applyFormat(name, val, isPast) {
    const formatter = messages2[name];
    if (typeof formatter === "function")
      return formatter(val, isPast);
    return formatter.replace("{0}", val.toString());
  }
  __name(applyFormat, "applyFormat");
  if (absDiff < 6e4 && !showSecond)
    return messages2.justNow;
  if (typeof max === "number" && absDiff > max)
    return fullDateFormatter(new Date(from));
  if (typeof max === "string") {
    const unitMax = (_a = units.find((i2) => i2.name === max)) == null ? void 0 : _a.max;
    if (unitMax && absDiff > unitMax)
      return fullDateFormatter(new Date(from));
  }
  for (const [idx, unit] of units.entries()) {
    const val = getValue2(diff, unit);
    if (val <= 0 && units[idx - 1])
      return format2(diff, units[idx - 1]);
    if (absDiff < unit.max)
      return format2(diff, unit);
  }
  return messages2.invalid;
}
__name(formatTimeAgo, "formatTimeAgo");
function useTimeoutPoll(fn, interval, timeoutPollOptions) {
  const { start: start2 } = useTimeoutFn(loop, interval, { immediate: false });
  const isActive = ref(false);
  async function loop() {
    if (!isActive.value)
      return;
    await fn();
    start2();
  }
  __name(loop, "loop");
  function resume() {
    if (!isActive.value) {
      isActive.value = true;
      loop();
    }
  }
  __name(resume, "resume");
  function pause() {
    isActive.value = false;
  }
  __name(pause, "pause");
  if (timeoutPollOptions == null ? void 0 : timeoutPollOptions.immediate)
    resume();
  tryOnScopeDispose(pause);
  return {
    isActive,
    pause,
    resume
  };
}
__name(useTimeoutPoll, "useTimeoutPoll");
function useTimestamp(options3 = {}) {
  const {
    controls: exposeControls = false,
    offset = 0,
    immediate = true,
    interval = "requestAnimationFrame",
    callback
  } = options3;
  const ts = ref(timestamp() + offset);
  const update2 = /* @__PURE__ */ __name(() => ts.value = timestamp() + offset, "update");
  const cb = callback ? () => {
    update2();
    callback(ts.value);
  } : update2;
  const controls = interval === "requestAnimationFrame" ? useRafFn(cb, { immediate }) : useIntervalFn(cb, interval, { immediate });
  if (exposeControls) {
    return {
      timestamp: ts,
      ...controls
    };
  } else {
    return ts;
  }
}
__name(useTimestamp, "useTimestamp");
function useTitle(newTitle = null, options3 = {}) {
  var _a, _b, _c;
  const {
    document: document2 = defaultDocument,
    restoreOnUnmount = /* @__PURE__ */ __name((t) => t, "restoreOnUnmount")
  } = options3;
  const originalTitle = (_a = document2 == null ? void 0 : document2.title) != null ? _a : "";
  const title = toRef((_b = newTitle != null ? newTitle : document2 == null ? void 0 : document2.title) != null ? _b : null);
  const isReadonly2 = newTitle && typeof newTitle === "function";
  function format2(t) {
    if (!("titleTemplate" in options3))
      return t;
    const template = options3.titleTemplate || "%s";
    return typeof template === "function" ? template(t) : toValue(template).replace(/%s/g, t);
  }
  __name(format2, "format");
  watch(
    title,
    (t, o) => {
      if (t !== o && document2)
        document2.title = format2(typeof t === "string" ? t : "");
    },
    { immediate: true }
  );
  if (options3.observe && !options3.titleTemplate && document2 && !isReadonly2) {
    useMutationObserver(
      (_c = document2.head) == null ? void 0 : _c.querySelector("title"),
      () => {
        if (document2 && document2.title !== title.value)
          title.value = format2(document2.title);
      },
      { childList: true }
    );
  }
  tryOnBeforeUnmount(() => {
    if (restoreOnUnmount) {
      const restoredTitle = restoreOnUnmount(originalTitle, title.value || "");
      if (restoredTitle != null && document2)
        document2.title = restoredTitle;
    }
  });
  return title;
}
__name(useTitle, "useTitle");
const _TransitionPresets = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
const TransitionPresets = /* @__PURE__ */ Object.assign({}, { linear: identity }, _TransitionPresets);
function createEasingFunction([p0, p1, p2, p3]) {
  const a = /* @__PURE__ */ __name((a1, a2) => 1 - 3 * a2 + 3 * a1, "a");
  const b = /* @__PURE__ */ __name((a1, a2) => 3 * a2 - 6 * a1, "b");
  const c = /* @__PURE__ */ __name((a1) => 3 * a1, "c");
  const calcBezier = /* @__PURE__ */ __name((t, a1, a2) => ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t, "calcBezier");
  const getSlope = /* @__PURE__ */ __name((t, a1, a2) => 3 * a(a1, a2) * t * t + 2 * b(a1, a2) * t + c(a1), "getSlope");
  const getTforX = /* @__PURE__ */ __name((x2) => {
    let aGuessT = x2;
    for (let i2 = 0; i2 < 4; ++i2) {
      const currentSlope = getSlope(aGuessT, p0, p2);
      if (currentSlope === 0)
        return aGuessT;
      const currentX = calcBezier(aGuessT, p0, p2) - x2;
      aGuessT -= currentX / currentSlope;
    }
    return aGuessT;
  }, "getTforX");
  return (x2) => p0 === p1 && p2 === p3 ? x2 : calcBezier(getTforX(x2), p1, p3);
}
__name(createEasingFunction, "createEasingFunction");
function lerp(a, b, alpha) {
  return a + alpha * (b - a);
}
__name(lerp, "lerp");
function toVec(t) {
  return (typeof t === "number" ? [t] : t) || [];
}
__name(toVec, "toVec");
function executeTransition(source, from, to, options3 = {}) {
  var _a, _b;
  const fromVal = toValue(from);
  const toVal = toValue(to);
  const v1 = toVec(fromVal);
  const v2 = toVec(toVal);
  const duration = (_a = toValue(options3.duration)) != null ? _a : 1e3;
  const startedAt = Date.now();
  const endAt = Date.now() + duration;
  const trans = typeof options3.transition === "function" ? options3.transition : (_b = toValue(options3.transition)) != null ? _b : identity;
  const ease = typeof trans === "function" ? trans : createEasingFunction(trans);
  return new Promise((resolve8) => {
    source.value = fromVal;
    const tick = /* @__PURE__ */ __name(() => {
      var _a2;
      if ((_a2 = options3.abort) == null ? void 0 : _a2.call(options3)) {
        resolve8();
        return;
      }
      const now2 = Date.now();
      const alpha = ease((now2 - startedAt) / duration);
      const arr = toVec(source.value).map((n, i2) => lerp(v1[i2], v2[i2], alpha));
      if (Array.isArray(source.value))
        source.value = arr.map((n, i2) => {
          var _a3, _b2;
          return lerp((_a3 = v1[i2]) != null ? _a3 : 0, (_b2 = v2[i2]) != null ? _b2 : 0, alpha);
        });
      else if (typeof source.value === "number")
        source.value = arr[0];
      if (now2 < endAt) {
        requestAnimationFrame(tick);
      } else {
        source.value = toVal;
        resolve8();
      }
    }, "tick");
    tick();
  });
}
__name(executeTransition, "executeTransition");
function useTransition(source, options3 = {}) {
  let currentId = 0;
  const sourceVal = /* @__PURE__ */ __name(() => {
    const v2 = toValue(source);
    return typeof v2 === "number" ? v2 : v2.map(toValue);
  }, "sourceVal");
  const outputRef = ref(sourceVal());
  watch(sourceVal, async (to) => {
    var _a, _b;
    if (toValue(options3.disabled))
      return;
    const id2 = ++currentId;
    if (options3.delay)
      await promiseTimeout(toValue(options3.delay));
    if (id2 !== currentId)
      return;
    const toVal = Array.isArray(to) ? to.map(toValue) : toValue(to);
    (_a = options3.onStarted) == null ? void 0 : _a.call(options3);
    await executeTransition(outputRef, outputRef.value, toVal, {
      ...options3,
      abort: /* @__PURE__ */ __name(() => {
        var _a2;
        return id2 !== currentId || ((_a2 = options3.abort) == null ? void 0 : _a2.call(options3));
      }, "abort")
    });
    (_b = options3.onFinished) == null ? void 0 : _b.call(options3);
  }, { deep: true });
  watch(() => toValue(options3.disabled), (disabled2) => {
    if (disabled2) {
      currentId++;
      outputRef.value = sourceVal();
    }
  });
  tryOnScopeDispose(() => {
    currentId++;
  });
  return computed(() => toValue(options3.disabled) ? sourceVal() : outputRef.value);
}
__name(useTransition, "useTransition");
function useUrlSearchParams(mode2 = "history", options3 = {}) {
  const {
    initialValue = {},
    removeNullishValues = true,
    removeFalsyValues = false,
    write: enableWrite = true,
    window: window2 = defaultWindow
  } = options3;
  if (!window2)
    return reactive(initialValue);
  const state = reactive({});
  function getRawParams() {
    if (mode2 === "history") {
      return window2.location.search || "";
    } else if (mode2 === "hash") {
      const hash = window2.location.hash || "";
      const index2 = hash.indexOf("?");
      return index2 > 0 ? hash.slice(index2) : "";
    } else {
      return (window2.location.hash || "").replace(/^#/, "");
    }
  }
  __name(getRawParams, "getRawParams");
  function constructQuery(params) {
    const stringified = params.toString();
    if (mode2 === "history")
      return `${stringified ? `?${stringified}` : ""}${window2.location.hash || ""}`;
    if (mode2 === "hash-params")
      return `${window2.location.search || ""}${stringified ? `#${stringified}` : ""}`;
    const hash = window2.location.hash || "#";
    const index2 = hash.indexOf("?");
    if (index2 > 0)
      return `${hash.slice(0, index2)}${stringified ? `?${stringified}` : ""}`;
    return `${hash}${stringified ? `?${stringified}` : ""}`;
  }
  __name(constructQuery, "constructQuery");
  function read() {
    return new URLSearchParams(getRawParams());
  }
  __name(read, "read");
  function updateState(params) {
    const unusedKeys = new Set(Object.keys(state));
    for (const key of params.keys()) {
      const paramsForKey = params.getAll(key);
      state[key] = paramsForKey.length > 1 ? paramsForKey : params.get(key) || "";
      unusedKeys.delete(key);
    }
    Array.from(unusedKeys).forEach((key) => delete state[key]);
  }
  __name(updateState, "updateState");
  const { pause, resume } = watchPausable(
    state,
    () => {
      const params = new URLSearchParams("");
      Object.keys(state).forEach((key) => {
        const mapEntry = state[key];
        if (Array.isArray(mapEntry))
          mapEntry.forEach((value3) => params.append(key, value3));
        else if (removeNullishValues && mapEntry == null)
          params.delete(key);
        else if (removeFalsyValues && !mapEntry)
          params.delete(key);
        else
          params.set(key, mapEntry);
      });
      write(params);
    },
    { deep: true }
  );
  function write(params, shouldUpdate) {
    pause();
    if (shouldUpdate)
      updateState(params);
    window2.history.replaceState(
      window2.history.state,
      window2.document.title,
      window2.location.pathname + constructQuery(params)
    );
    resume();
  }
  __name(write, "write");
  function onChanged() {
    if (!enableWrite)
      return;
    write(read(), true);
  }
  __name(onChanged, "onChanged");
  useEventListener(window2, "popstate", onChanged, false);
  if (mode2 !== "history")
    useEventListener(window2, "hashchange", onChanged, false);
  const initial = read();
  if (initial.keys().next().value)
    updateState(initial);
  else
    Object.assign(state, initialValue);
  return state;
}
__name(useUrlSearchParams, "useUrlSearchParams");
function useUserMedia(options3 = {}) {
  var _a, _b;
  const enabled = ref((_a = options3.enabled) != null ? _a : false);
  const autoSwitch = ref((_b = options3.autoSwitch) != null ? _b : true);
  const constraints = ref(options3.constraints);
  const { navigator: navigator2 = defaultNavigator } = options3;
  const isSupported2 = useSupported(() => {
    var _a2;
    return (_a2 = navigator2 == null ? void 0 : navigator2.mediaDevices) == null ? void 0 : _a2.getUserMedia;
  });
  const stream = shallowRef();
  function getDeviceOptions(type) {
    switch (type) {
      case "video": {
        if (constraints.value)
          return constraints.value.video || false;
        break;
      }
      case "audio": {
        if (constraints.value)
          return constraints.value.audio || false;
        break;
      }
    }
  }
  __name(getDeviceOptions, "getDeviceOptions");
  async function _start() {
    if (!isSupported2.value || stream.value)
      return;
    stream.value = await navigator2.mediaDevices.getUserMedia({
      video: getDeviceOptions("video"),
      audio: getDeviceOptions("audio")
    });
    return stream.value;
  }
  __name(_start, "_start");
  function _stop() {
    var _a2;
    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => t.stop());
    stream.value = void 0;
  }
  __name(_stop, "_stop");
  function stop2() {
    _stop();
    enabled.value = false;
  }
  __name(stop2, "stop");
  async function start2() {
    await _start();
    if (stream.value)
      enabled.value = true;
    return stream.value;
  }
  __name(start2, "start");
  async function restart() {
    _stop();
    return await start2();
  }
  __name(restart, "restart");
  watch(
    enabled,
    (v2) => {
      if (v2)
        _start();
      else _stop();
    },
    { immediate: true }
  );
  watch(
    constraints,
    () => {
      if (autoSwitch.value && stream.value)
        restart();
    },
    { immediate: true }
  );
  tryOnScopeDispose(() => {
    stop2();
  });
  return {
    isSupported: isSupported2,
    stream,
    start: start2,
    stop: stop2,
    restart,
    constraints,
    enabled,
    autoSwitch
  };
}
__name(useUserMedia, "useUserMedia");
function useVModel(props, key, emit2, options3 = {}) {
  var _a, _b, _c, _d, _e;
  const {
    clone: clone2 = false,
    passive = false,
    eventName,
    deep = false,
    defaultValue,
    shouldEmit
  } = options3;
  const vm = getCurrentInstance();
  const _emit = emit2 || (vm == null ? void 0 : vm.emit) || ((_a = vm == null ? void 0 : vm.$emit) == null ? void 0 : _a.bind(vm)) || ((_c = (_b = vm == null ? void 0 : vm.proxy) == null ? void 0 : _b.$emit) == null ? void 0 : _c.bind(vm == null ? void 0 : vm.proxy));
  let event2 = eventName;
  if (!key) {
    if (isVue2) {
      const modelOptions = (_e = (_d = vm == null ? void 0 : vm.proxy) == null ? void 0 : _d.$options) == null ? void 0 : _e.model;
      key = (modelOptions == null ? void 0 : modelOptions.value) || "value";
      if (!eventName)
        event2 = (modelOptions == null ? void 0 : modelOptions.event) || "input";
    } else {
      key = "modelValue";
    }
  }
  event2 = event2 || `update:${key.toString()}`;
  const cloneFn = /* @__PURE__ */ __name((val) => !clone2 ? val : typeof clone2 === "function" ? clone2(val) : cloneFnJSON(val), "cloneFn");
  const getValue2 = /* @__PURE__ */ __name(() => isDef(props[key]) ? cloneFn(props[key]) : defaultValue, "getValue2");
  const triggerEmit = /* @__PURE__ */ __name((value3) => {
    if (shouldEmit) {
      if (shouldEmit(value3))
        _emit(event2, value3);
    } else {
      _emit(event2, value3);
    }
  }, "triggerEmit");
  if (passive) {
    const initialValue = getValue2();
    const proxy = ref(initialValue);
    let isUpdating = false;
    watch(
      () => props[key],
      (v2) => {
        if (!isUpdating) {
          isUpdating = true;
          proxy.value = cloneFn(v2);
          nextTick(() => isUpdating = false);
        }
      }
    );
    watch(
      proxy,
      (v2) => {
        if (!isUpdating && (v2 !== props[key] || deep))
          triggerEmit(v2);
      },
      { deep }
    );
    return proxy;
  } else {
    return computed({
      get() {
        return getValue2();
      },
      set(value3) {
        triggerEmit(value3);
      }
    });
  }
}
__name(useVModel, "useVModel");
function useVModels(props, emit2, options3 = {}) {
  const ret = {};
  for (const key in props) {
    ret[key] = useVModel(
      props,
      key,
      emit2,
      options3
    );
  }
  return ret;
}
__name(useVModels, "useVModels");
function useVibrate(options3) {
  const {
    pattern = [],
    interval = 0,
    navigator: navigator2 = defaultNavigator
  } = options3 || {};
  const isSupported2 = useSupported(() => typeof navigator2 !== "undefined" && "vibrate" in navigator2);
  const patternRef = toRef(pattern);
  let intervalControls;
  const vibrate = /* @__PURE__ */ __name((pattern2 = patternRef.value) => {
    if (isSupported2.value)
      navigator2.vibrate(pattern2);
  }, "vibrate");
  const stop2 = /* @__PURE__ */ __name(() => {
    if (isSupported2.value)
      navigator2.vibrate(0);
    intervalControls == null ? void 0 : intervalControls.pause();
  }, "stop");
  if (interval > 0) {
    intervalControls = useIntervalFn(
      vibrate,
      interval,
      {
        immediate: false,
        immediateCallback: false
      }
    );
  }
  return {
    isSupported: isSupported2,
    pattern,
    intervalControls,
    vibrate,
    stop: stop2
  };
}
__name(useVibrate, "useVibrate");
function useVirtualList(list, options3) {
  const { containerStyle, wrapperProps, scrollTo: scrollTo22, calculateRange, currentList, containerRef: containerRef6 } = "itemHeight" in options3 ? useVerticalVirtualList(options3, list) : useHorizontalVirtualList(options3, list);
  return {
    list: currentList,
    scrollTo: scrollTo22,
    containerProps: {
      ref: containerRef6,
      onScroll: /* @__PURE__ */ __name(() => {
        calculateRange();
      }, "onScroll"),
      style: containerStyle
    },
    wrapperProps
  };
}
__name(useVirtualList, "useVirtualList");
function useVirtualListResources(list) {
  const containerRef6 = ref(null);
  const size2 = useElementSize(containerRef6);
  const currentList = ref([]);
  const source = shallowRef(list);
  const state = ref({ start: 0, end: 10 });
  return { state, source, currentList, size: size2, containerRef: containerRef6 };
}
__name(useVirtualListResources, "useVirtualListResources");
function createGetViewCapacity(state, source, itemSize2) {
  return (containerSize) => {
    if (typeof itemSize2 === "number")
      return Math.ceil(containerSize / itemSize2);
    const { start: start2 = 0 } = state.value;
    let sum = 0;
    let capacity = 0;
    for (let i2 = start2; i2 < source.value.length; i2++) {
      const size2 = itemSize2(i2);
      sum += size2;
      capacity = i2;
      if (sum > containerSize)
        break;
    }
    return capacity - start2;
  };
}
__name(createGetViewCapacity, "createGetViewCapacity");
function createGetOffset(source, itemSize2) {
  return (scrollDirection) => {
    if (typeof itemSize2 === "number")
      return Math.floor(scrollDirection / itemSize2) + 1;
    let sum = 0;
    let offset = 0;
    for (let i2 = 0; i2 < source.value.length; i2++) {
      const size2 = itemSize2(i2);
      sum += size2;
      if (sum >= scrollDirection) {
        offset = i2;
        break;
      }
    }
    return offset + 1;
  };
}
__name(createGetOffset, "createGetOffset");
function createCalculateRange(type, overscan, getOffset2, getViewCapacity, { containerRef: containerRef6, state, currentList, source }) {
  return () => {
    const element = containerRef6.value;
    if (element) {
      const offset = getOffset2(type === "vertical" ? element.scrollTop : element.scrollLeft);
      const viewCapacity = getViewCapacity(type === "vertical" ? element.clientHeight : element.clientWidth);
      const from = offset - overscan;
      const to = offset + viewCapacity + overscan;
      state.value = {
        start: from < 0 ? 0 : from,
        end: to > source.value.length ? source.value.length : to
      };
      currentList.value = source.value.slice(state.value.start, state.value.end).map((ele, index2) => ({
        data: ele,
        index: index2 + state.value.start
      }));
    }
  };
}
__name(createCalculateRange, "createCalculateRange");
function createGetDistance(itemSize2, source) {
  return (index2) => {
    if (typeof itemSize2 === "number") {
      const size22 = index2 * itemSize2;
      return size22;
    }
    const size2 = source.value.slice(0, index2).reduce((sum, _2, i2) => sum + itemSize2(i2), 0);
    return size2;
  };
}
__name(createGetDistance, "createGetDistance");
function useWatchForSizes(size2, list, containerRef6, calculateRange) {
  watch([size2.width, size2.height, list, containerRef6], () => {
    calculateRange();
  });
}
__name(useWatchForSizes, "useWatchForSizes");
function createComputedTotalSize(itemSize2, source) {
  return computed(() => {
    if (typeof itemSize2 === "number")
      return source.value.length * itemSize2;
    return source.value.reduce((sum, _2, index2) => sum + itemSize2(index2), 0);
  });
}
__name(createComputedTotalSize, "createComputedTotalSize");
const scrollToDictionaryForElementScrollKey = {
  horizontal: "scrollLeft",
  vertical: "scrollTop"
};
function createScrollTo(type, calculateRange, getDistance, containerRef6) {
  return (index2) => {
    if (containerRef6.value) {
      containerRef6.value[scrollToDictionaryForElementScrollKey[type]] = getDistance(index2);
      calculateRange();
    }
  };
}
__name(createScrollTo, "createScrollTo");
function useHorizontalVirtualList(options3, list) {
  const resources = useVirtualListResources(list);
  const { state, source, currentList, size: size2, containerRef: containerRef6 } = resources;
  const containerStyle = { overflowX: "auto" };
  const { itemWidth, overscan = 5 } = options3;
  const getViewCapacity = createGetViewCapacity(state, source, itemWidth);
  const getOffset2 = createGetOffset(source, itemWidth);
  const calculateRange = createCalculateRange("horizontal", overscan, getOffset2, getViewCapacity, resources);
  const getDistanceLeft = createGetDistance(itemWidth, source);
  const offsetLeft = computed(() => getDistanceLeft(state.value.start));
  const totalWidth = createComputedTotalSize(itemWidth, source);
  useWatchForSizes(size2, list, containerRef6, calculateRange);
  const scrollTo22 = createScrollTo("horizontal", calculateRange, getDistanceLeft, containerRef6);
  const wrapperProps = computed(() => {
    return {
      style: {
        height: "100%",
        width: `${totalWidth.value - offsetLeft.value}px`,
        marginLeft: `${offsetLeft.value}px`,
        display: "flex"
      }
    };
  });
  return {
    scrollTo: scrollTo22,
    calculateRange,
    wrapperProps,
    containerStyle,
    currentList,
    containerRef: containerRef6
  };
}
__name(useHorizontalVirtualList, "useHorizontalVirtualList");
function useVerticalVirtualList(options3, list) {
  const resources = useVirtualListResources(list);
  const { state, source, currentList, size: size2, containerRef: containerRef6 } = resources;
  const containerStyle = { overflowY: "auto" };
  const { itemHeight, overscan = 5 } = options3;
  const getViewCapacity = createGetViewCapacity(state, source, itemHeight);
  const getOffset2 = createGetOffset(source, itemHeight);
  const calculateRange = createCalculateRange("vertical", overscan, getOffset2, getViewCapacity, resources);
  const getDistanceTop = createGetDistance(itemHeight, source);
  const offsetTop = computed(() => getDistanceTop(state.value.start));
  const totalHeight = createComputedTotalSize(itemHeight, source);
  useWatchForSizes(size2, list, containerRef6, calculateRange);
  const scrollTo22 = createScrollTo("vertical", calculateRange, getDistanceTop, containerRef6);
  const wrapperProps = computed(() => {
    return {
      style: {
        width: "100%",
        height: `${totalHeight.value - offsetTop.value}px`,
        marginTop: `${offsetTop.value}px`
      }
    };
  });
  return {
    calculateRange,
    scrollTo: scrollTo22,
    containerStyle,
    wrapperProps,
    currentList,
    containerRef: containerRef6
  };
}
__name(useVerticalVirtualList, "useVerticalVirtualList");
function useWakeLock(options3 = {}) {
  const {
    navigator: navigator2 = defaultNavigator,
    document: document2 = defaultDocument
  } = options3;
  const requestedType = ref(false);
  const sentinel = shallowRef(null);
  const documentVisibility = useDocumentVisibility({ document: document2 });
  const isSupported2 = useSupported(() => navigator2 && "wakeLock" in navigator2);
  const isActive = computed(() => !!sentinel.value && documentVisibility.value === "visible");
  if (isSupported2.value) {
    useEventListener(sentinel, "release", () => {
      var _a, _b;
      requestedType.value = (_b = (_a = sentinel.value) == null ? void 0 : _a.type) != null ? _b : false;
    });
    whenever(
      () => documentVisibility.value === "visible" && (document2 == null ? void 0 : document2.visibilityState) === "visible" && requestedType.value,
      (type) => {
        requestedType.value = false;
        forceRequest(type);
      }
    );
  }
  async function forceRequest(type) {
    var _a;
    await ((_a = sentinel.value) == null ? void 0 : _a.release());
    sentinel.value = isSupported2.value ? await navigator2.wakeLock.request(type) : null;
  }
  __name(forceRequest, "forceRequest");
  async function request(type) {
    if (documentVisibility.value === "visible")
      await forceRequest(type);
    else
      requestedType.value = type;
  }
  __name(request, "request");
  async function release() {
    requestedType.value = false;
    const s = sentinel.value;
    sentinel.value = null;
    await (s == null ? void 0 : s.release());
  }
  __name(release, "release");
  return {
    sentinel,
    isSupported: isSupported2,
    isActive,
    request,
    forceRequest,
    release
  };
}
__name(useWakeLock, "useWakeLock");
function useWebNotification(options3 = {}) {
  const {
    window: window2 = defaultWindow,
    requestPermissions: _requestForPermissions = true
  } = options3;
  const defaultWebNotificationOptions = options3;
  const isSupported2 = useSupported(() => {
    if (!window2 || !("Notification" in window2))
      return false;
    try {
      new Notification("");
    } catch (e) {
      return false;
    }
    return true;
  });
  const permissionGranted = ref(isSupported2.value && "permission" in Notification && Notification.permission === "granted");
  const notification = ref(null);
  const ensurePermissions = /* @__PURE__ */ __name(async () => {
    if (!isSupported2.value)
      return;
    if (!permissionGranted.value && Notification.permission !== "denied") {
      const result = await Notification.requestPermission();
      if (result === "granted")
        permissionGranted.value = true;
    }
    return permissionGranted.value;
  }, "ensurePermissions");
  const { on: onClick3, trigger: clickTrigger } = createEventHook();
  const { on: onShow, trigger: showTrigger } = createEventHook();
  const { on: onError, trigger: errorTrigger } = createEventHook();
  const { on: onClose, trigger: closeTrigger } = createEventHook();
  const show6 = /* @__PURE__ */ __name(async (overrides) => {
    if (!isSupported2.value || !permissionGranted.value)
      return;
    const options22 = Object.assign({}, defaultWebNotificationOptions, overrides);
    notification.value = new Notification(options22.title || "", options22);
    notification.value.onclick = clickTrigger;
    notification.value.onshow = showTrigger;
    notification.value.onerror = errorTrigger;
    notification.value.onclose = closeTrigger;
    return notification.value;
  }, "show");
  const close4 = /* @__PURE__ */ __name(() => {
    if (notification.value)
      notification.value.close();
    notification.value = null;
  }, "close");
  if (_requestForPermissions)
    tryOnMounted(ensurePermissions);
  tryOnScopeDispose(close4);
  if (isSupported2.value && window2) {
    const document2 = window2.document;
    useEventListener(document2, "visibilitychange", (e) => {
      e.preventDefault();
      if (document2.visibilityState === "visible") {
        close4();
      }
    });
  }
  return {
    isSupported: isSupported2,
    notification,
    ensurePermissions,
    permissionGranted,
    show: show6,
    close: close4,
    onClick: onClick3,
    onShow,
    onError,
    onClose
  };
}
__name(useWebNotification, "useWebNotification");
const DEFAULT_PING_MESSAGE = "ping";
function resolveNestedOptions(options3) {
  if (options3 === true)
    return {};
  return options3;
}
__name(resolveNestedOptions, "resolveNestedOptions");
function useWebSocket(url, options3 = {}) {
  const {
    onConnected,
    onDisconnected,
    onError,
    onMessage,
    immediate = true,
    autoClose = true,
    protocols = []
  } = options3;
  const data24 = ref(null);
  const status = ref("CLOSED");
  const wsRef = ref();
  const urlRef = toRef(url);
  let heartbeatPause;
  let heartbeatResume;
  let explicitlyClosed = false;
  let retried = 0;
  let bufferedData = [];
  let pongTimeoutWait;
  const _sendBuffer = /* @__PURE__ */ __name(() => {
    if (bufferedData.length && wsRef.value && status.value === "OPEN") {
      for (const buffer2 of bufferedData)
        wsRef.value.send(buffer2);
      bufferedData = [];
    }
  }, "_sendBuffer");
  const resetHeartbeat = /* @__PURE__ */ __name(() => {
    clearTimeout(pongTimeoutWait);
    pongTimeoutWait = void 0;
  }, "resetHeartbeat");
  const close4 = /* @__PURE__ */ __name((code2 = 1e3, reason) => {
    if (!isClient || !wsRef.value)
      return;
    explicitlyClosed = true;
    resetHeartbeat();
    heartbeatPause == null ? void 0 : heartbeatPause();
    wsRef.value.close(code2, reason);
    wsRef.value = void 0;
  }, "close");
  const send = /* @__PURE__ */ __name((data25, useBuffer = true) => {
    if (!wsRef.value || status.value !== "OPEN") {
      if (useBuffer)
        bufferedData.push(data25);
      return false;
    }
    _sendBuffer();
    wsRef.value.send(data25);
    return true;
  }, "send");
  const _init = /* @__PURE__ */ __name(() => {
    if (explicitlyClosed || typeof urlRef.value === "undefined")
      return;
    const ws = new WebSocket(urlRef.value, protocols);
    wsRef.value = ws;
    status.value = "CONNECTING";
    ws.onopen = () => {
      status.value = "OPEN";
      onConnected == null ? void 0 : onConnected(ws);
      heartbeatResume == null ? void 0 : heartbeatResume();
      _sendBuffer();
    };
    ws.onclose = (ev) => {
      status.value = "CLOSED";
      onDisconnected == null ? void 0 : onDisconnected(ws, ev);
      if (!explicitlyClosed && options3.autoReconnect) {
        const {
          retries = -1,
          delay = 1e3,
          onFailed
        } = resolveNestedOptions(options3.autoReconnect);
        retried += 1;
        if (typeof retries === "number" && (retries < 0 || retried < retries))
          setTimeout(_init, delay);
        else if (typeof retries === "function" && retries())
          setTimeout(_init, delay);
        else
          onFailed == null ? void 0 : onFailed();
      }
    };
    ws.onerror = (e) => {
      onError == null ? void 0 : onError(ws, e);
    };
    ws.onmessage = (e) => {
      if (options3.heartbeat) {
        resetHeartbeat();
        const {
          message: message3 = DEFAULT_PING_MESSAGE,
          responseMessage = message3
        } = resolveNestedOptions(options3.heartbeat);
        if (e.data === responseMessage)
          return;
      }
      data24.value = e.data;
      onMessage == null ? void 0 : onMessage(ws, e);
    };
  }, "_init");
  if (options3.heartbeat) {
    const {
      message: message3 = DEFAULT_PING_MESSAGE,
      interval = 1e3,
      pongTimeout = 1e3
    } = resolveNestedOptions(options3.heartbeat);
    const { pause, resume } = useIntervalFn(
      () => {
        send(message3, false);
        if (pongTimeoutWait != null)
          return;
        pongTimeoutWait = setTimeout(() => {
          close4();
          explicitlyClosed = false;
        }, pongTimeout);
      },
      interval,
      { immediate: false }
    );
    heartbeatPause = pause;
    heartbeatResume = resume;
  }
  if (autoClose) {
    if (isClient)
      useEventListener("beforeunload", () => close4());
    tryOnScopeDispose(close4);
  }
  const open2 = /* @__PURE__ */ __name(() => {
    if (!isClient && !isWorker)
      return;
    close4();
    explicitlyClosed = false;
    retried = 0;
    _init();
  }, "open");
  if (immediate)
    open2();
  watch(urlRef, open2);
  return {
    data: data24,
    status,
    close: close4,
    send,
    open: open2,
    ws: wsRef
  };
}
__name(useWebSocket, "useWebSocket");
function useWebWorker(arg0, workerOptions, options3) {
  const {
    window: window2 = defaultWindow
  } = options3 != null ? options3 : {};
  const data24 = ref(null);
  const worker = shallowRef();
  const post = /* @__PURE__ */ __name((...args) => {
    if (!worker.value)
      return;
    worker.value.postMessage(...args);
  }, "post");
  const terminate = /* @__PURE__ */ __name(function terminate2() {
    if (!worker.value)
      return;
    worker.value.terminate();
  }, "terminate2");
  if (window2) {
    if (typeof arg0 === "string")
      worker.value = new Worker(arg0, workerOptions);
    else if (typeof arg0 === "function")
      worker.value = arg0();
    else
      worker.value = arg0;
    worker.value.onmessage = (e) => {
      data24.value = e.data;
    };
    tryOnScopeDispose(() => {
      if (worker.value)
        worker.value.terminate();
    });
  }
  return {
    data: data24,
    post,
    terminate,
    worker
  };
}
__name(useWebWorker, "useWebWorker");
function jobRunner(userFunc) {
  return (e) => {
    const userFuncArgs = e.data[0];
    return Promise.resolve(userFunc.apply(void 0, userFuncArgs)).then((result) => {
      postMessage(["SUCCESS", result]);
    }).catch((error) => {
      postMessage(["ERROR", error]);
    });
  };
}
__name(jobRunner, "jobRunner");
function depsParser(deps, localDeps) {
  if (deps.length === 0 && localDeps.length === 0)
    return "";
  const depsString = deps.map((dep) => `'${dep}'`).toString();
  const depsFunctionString = localDeps.filter((dep) => typeof dep === "function").map((fn) => {
    const str = fn.toString();
    if (str.trim().startsWith("function")) {
      return str;
    } else {
      const name = fn.name;
      return `const ${name} = ${str}`;
    }
  }).join(";");
  const importString = `importScripts(${depsString});`;
  return `${depsString.trim() === "" ? "" : importString} ${depsFunctionString}`;
}
__name(depsParser, "depsParser");
function createWorkerBlobUrl(fn, deps, localDeps) {
  const blobCode = `${depsParser(deps, localDeps)}; onmessage=(${jobRunner})(${fn})`;
  const blob = new Blob([blobCode], { type: "text/javascript" });
  const url = URL.createObjectURL(blob);
  return url;
}
__name(createWorkerBlobUrl, "createWorkerBlobUrl");
function useWebWorkerFn(fn, options3 = {}) {
  const {
    dependencies = [],
    localDependencies = [],
    timeout,
    window: window2 = defaultWindow
  } = options3;
  const worker = ref();
  const workerStatus = ref("PENDING");
  const promise = ref({});
  const timeoutId = ref();
  const workerTerminate = /* @__PURE__ */ __name((status = "PENDING") => {
    if (worker.value && worker.value._url && window2) {
      worker.value.terminate();
      URL.revokeObjectURL(worker.value._url);
      promise.value = {};
      worker.value = void 0;
      window2.clearTimeout(timeoutId.value);
      workerStatus.value = status;
    }
  }, "workerTerminate");
  workerTerminate();
  tryOnScopeDispose(workerTerminate);
  const generateWorker = /* @__PURE__ */ __name(() => {
    const blobUrl = createWorkerBlobUrl(fn, dependencies, localDependencies);
    const newWorker = new Worker(blobUrl);
    newWorker._url = blobUrl;
    newWorker.onmessage = (e) => {
      const { resolve: resolve8 = /* @__PURE__ */ __name(() => {
      }, "resolve"), reject: reject2 = /* @__PURE__ */ __name(() => {
      }, "reject") } = promise.value;
      const [status, result] = e.data;
      switch (status) {
        case "SUCCESS":
          resolve8(result);
          workerTerminate(status);
          break;
        default:
          reject2(result);
          workerTerminate("ERROR");
          break;
      }
    };
    newWorker.onerror = (e) => {
      const { reject: reject2 = /* @__PURE__ */ __name(() => {
      }, "reject") } = promise.value;
      e.preventDefault();
      reject2(e);
      workerTerminate("ERROR");
    };
    if (timeout) {
      timeoutId.value = setTimeout(
        () => workerTerminate("TIMEOUT_EXPIRED"),
        timeout
      );
    }
    return newWorker;
  }, "generateWorker");
  const callWorker = /* @__PURE__ */ __name((...fnArgs) => new Promise((resolve8, reject2) => {
    var _a;
    promise.value = {
      resolve: resolve8,
      reject: reject2
    };
    (_a = worker.value) == null ? void 0 : _a.postMessage([[...fnArgs]]);
    workerStatus.value = "RUNNING";
  }), "callWorker");
  const workerFn = /* @__PURE__ */ __name((...fnArgs) => {
    if (workerStatus.value === "RUNNING") {
      console.error(
        "[useWebWorkerFn] You can only run one instance of the worker at a time."
      );
      return Promise.reject();
    }
    worker.value = generateWorker();
    return callWorker(...fnArgs);
  }, "workerFn");
  return {
    workerFn,
    workerStatus,
    workerTerminate
  };
}
__name(useWebWorkerFn, "useWebWorkerFn");
function useWindowFocus(options3 = {}) {
  const { window: window2 = defaultWindow } = options3;
  if (!window2)
    return ref(false);
  const focused = ref(window2.document.hasFocus());
  useEventListener(window2, "blur", () => {
    focused.value = false;
  });
  useEventListener(window2, "focus", () => {
    focused.value = true;
  });
  return focused;
}
__name(useWindowFocus, "useWindowFocus");
function useWindowScroll(options3 = {}) {
  const { window: window2 = defaultWindow, behavior = "auto" } = options3;
  if (!window2) {
    return {
      x: ref(0),
      y: ref(0)
    };
  }
  const internalX = ref(window2.scrollX);
  const internalY = ref(window2.scrollY);
  const x2 = computed({
    get() {
      return internalX.value;
    },
    set(x22) {
      scrollTo({ left: x22, behavior });
    }
  });
  const y2 = computed({
    get() {
      return internalY.value;
    },
    set(y22) {
      scrollTo({ top: y22, behavior });
    }
  });
  useEventListener(
    window2,
    "scroll",
    () => {
      internalX.value = window2.scrollX;
      internalY.value = window2.scrollY;
    },
    {
      capture: false,
      passive: true
    }
  );
  return { x: x2, y: y2 };
}
__name(useWindowScroll, "useWindowScroll");
function useWindowSize(options3 = {}) {
  const {
    window: window2 = defaultWindow,
    initialWidth = Number.POSITIVE_INFINITY,
    initialHeight = Number.POSITIVE_INFINITY,
    listenOrientation = true,
    includeScrollbar = true,
    type = "inner"
  } = options3;
  const width2 = ref(initialWidth);
  const height = ref(initialHeight);
  const update2 = /* @__PURE__ */ __name(() => {
    if (window2) {
      if (type === "outer") {
        width2.value = window2.outerWidth;
        height.value = window2.outerHeight;
      } else if (includeScrollbar) {
        width2.value = window2.innerWidth;
        height.value = window2.innerHeight;
      } else {
        width2.value = window2.document.documentElement.clientWidth;
        height.value = window2.document.documentElement.clientHeight;
      }
    }
  }, "update");
  update2();
  tryOnMounted(update2);
  useEventListener("resize", update2, { passive: true });
  if (listenOrientation) {
    const matches2 = useMediaQuery("(orientation: portrait)");
    watch(matches2, () => update2());
  }
  return { width: width2, height };
}
__name(useWindowSize, "useWindowSize");
var theme$f = /* @__PURE__ */ __name(function theme22(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-scrollpanel-content-container {\n    overflow: hidden;\n    width: 100%;\n    height: 100%;\n    position: relative;\n    z-index: 1;\n    float: left;\n}\n\n.p-scrollpanel-content {\n    height: calc(100% + calc(2 * ".concat(dt3("scrollpanel.bar.size"), "));\n    width: calc(100% + calc(2 * ").concat(dt3("scrollpanel.bar.size"), "));\n    padding: 0 calc(2 * ").concat(dt3("scrollpanel.bar.size"), ") calc(2 * ").concat(dt3("scrollpanel.bar.size"), ") 0;\n    position: relative;\n    overflow: auto;\n    box-sizing: border-box;\n    scrollbar-width: none;\n}\n\n.p-scrollpanel-content::-webkit-scrollbar {\n    display: none;\n}\n\n.p-scrollpanel-bar {\n    position: relative;\n    border-radius: ").concat(dt3("scrollpanel.bar.border.radius"), ";\n    z-index: 2;\n    cursor: pointer;\n    opacity: 0;\n    outline-color: transparent;\n    transition: outline-color ").concat(dt3("scrollpanel.transition.duration"), ";\n    background: ").concat(dt3("scrollpanel.bar.background"), ";\n    border: 0 none;\n    transition: outline-color ").concat(dt3("scrollpanel.transition.duration"), ", opacity ").concat(dt3("scrollpanel.transition.duration"), ";\n}\n\n.p-scrollpanel-bar:focus-visible {\n    box-shadow: ").concat(dt3("scrollpanel.bar.focus.ring.shadow"), ";\n    outline: ").concat(dt3("scrollpanel.barfocus.ring.width"), " ").concat(dt3("scrollpanel.bar.focus.ring.style"), " ").concat(dt3("scrollpanel.bar.focus.ring.color"), ";\n    outline-offset: ").concat(dt3("scrollpanel.barfocus.ring.offset"), ";\n}\n\n.p-scrollpanel-bar-y {\n    width: ").concat(dt3("scrollpanel.bar.size"), ";\n    top: 0;\n}\n\n.p-scrollpanel-bar-x {\n    height: ").concat(dt3("scrollpanel.bar.size"), ";\n    bottom: 0;\n}\n\n.p-scrollpanel-hidden {\n    visibility: hidden;\n}\n\n.p-scrollpanel:hover .p-scrollpanel-bar,\n.p-scrollpanel:active .p-scrollpanel-bar {\n    opacity: 1;\n}\n\n.p-scrollpanel-grabbed {\n    user-select: none;\n}\n");
}, "theme");
var classes$g = {
  root: "p-scrollpanel p-component",
  contentContainer: "p-scrollpanel-content-container",
  content: "p-scrollpanel-content",
  barX: "p-scrollpanel-bar p-scrollpanel-bar-x",
  barY: "p-scrollpanel-bar p-scrollpanel-bar-y"
};
var ScrollPanelStyle = BaseStyle.extend({
  name: "scrollpanel",
  theme: theme$f,
  classes: classes$g
});
var script$1$g = {
  name: "BaseScrollPanel",
  "extends": script$X,
  props: {
    step: {
      type: Number,
      "default": 5
    }
  },
  style: ScrollPanelStyle,
  provide: /* @__PURE__ */ __name(function provide23() {
    return {
      $pcScrollPanel: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$r = {
  name: "ScrollPanel",
  "extends": script$1$g,
  inheritAttrs: false,
  initialized: false,
  documentResizeListener: null,
  documentMouseMoveListener: null,
  documentMouseUpListener: null,
  frame: null,
  scrollXRatio: null,
  scrollYRatio: null,
  isXBarClicked: false,
  isYBarClicked: false,
  lastPageX: null,
  lastPageY: null,
  timer: null,
  outsideClickListener: null,
  data: /* @__PURE__ */ __name(function data9() {
    return {
      id: this.$attrs.id,
      orientation: "vertical",
      lastScrollTop: 0,
      lastScrollLeft: 0
    };
  }, "data"),
  watch: {
    "$attrs.id": /* @__PURE__ */ __name(function $attrsId4(newValue) {
      this.id = newValue || UniqueComponentId();
    }, "$attrsId")
  },
  mounted: /* @__PURE__ */ __name(function mounted8() {
    this.id = this.id || UniqueComponentId();
    if (this.$el.offsetParent) {
      this.initialize();
    }
  }, "mounted"),
  updated: /* @__PURE__ */ __name(function updated5() {
    if (!this.initialized && this.$el.offsetParent) {
      this.initialize();
    }
  }, "updated"),
  beforeUnmount: /* @__PURE__ */ __name(function beforeUnmount4() {
    this.unbindDocumentResizeListener();
    if (this.frame) {
      window.cancelAnimationFrame(this.frame);
    }
  }, "beforeUnmount"),
  methods: {
    initialize: /* @__PURE__ */ __name(function initialize() {
      this.moveBar();
      this.bindDocumentResizeListener();
      this.calculateContainerHeight();
    }, "initialize"),
    calculateContainerHeight: /* @__PURE__ */ __name(function calculateContainerHeight() {
      var containerStyles = getComputedStyle(this.$el), xBarStyles = getComputedStyle(this.$refs.xBar), pureContainerHeight = getHeight(this.$el) - parseInt(xBarStyles["height"], 10);
      if (containerStyles["max-height"] !== "none" && pureContainerHeight === 0) {
        if (this.$refs.content.offsetHeight + parseInt(xBarStyles["height"], 10) > parseInt(containerStyles["max-height"], 10)) {
          this.$el.style.height = containerStyles["max-height"];
        } else {
          this.$el.style.height = this.$refs.content.offsetHeight + parseFloat(containerStyles.paddingTop) + parseFloat(containerStyles.paddingBottom) + parseFloat(containerStyles.borderTopWidth) + parseFloat(containerStyles.borderBottomWidth) + "px";
        }
      }
    }, "calculateContainerHeight"),
    moveBar: /* @__PURE__ */ __name(function moveBar() {
      var _this = this;
      if (this.$refs.content) {
        var totalWidth = this.$refs.content.scrollWidth;
        var ownWidth = this.$refs.content.clientWidth;
        var bottom = (this.$el.clientHeight - this.$refs.xBar.clientHeight) * -1;
        this.scrollXRatio = ownWidth / totalWidth;
        var totalHeight = this.$refs.content.scrollHeight;
        var ownHeight = this.$refs.content.clientHeight;
        var right = (this.$el.clientWidth - this.$refs.yBar.clientWidth) * -1;
        this.scrollYRatio = ownHeight / totalHeight;
        this.frame = this.requestAnimationFrame(function() {
          if (_this.$refs.xBar) {
            if (_this.scrollXRatio >= 1) {
              _this.$refs.xBar.setAttribute("data-p-scrollpanel-hidden", "true");
              !_this.isUnstyled && addClass(_this.$refs.xBar, "p-scrollpanel-hidden");
            } else {
              _this.$refs.xBar.setAttribute("data-p-scrollpanel-hidden", "false");
              !_this.isUnstyled && removeClass(_this.$refs.xBar, "p-scrollpanel-hidden");
              _this.$refs.xBar.style.cssText = "width:" + Math.max(_this.scrollXRatio * 100, 10) + "%; left:" + _this.$refs.content.scrollLeft / totalWidth * 100 + "%;bottom:" + bottom + "px;";
            }
          }
          if (_this.$refs.yBar) {
            if (_this.scrollYRatio >= 1) {
              _this.$refs.yBar.setAttribute("data-p-scrollpanel-hidden", "true");
              !_this.isUnstyled && addClass(_this.$refs.yBar, "p-scrollpanel-hidden");
            } else {
              _this.$refs.yBar.setAttribute("data-p-scrollpanel-hidden", "false");
              !_this.isUnstyled && removeClass(_this.$refs.yBar, "p-scrollpanel-hidden");
              _this.$refs.yBar.style.cssText = "height:" + Math.max(_this.scrollYRatio * 100, 10) + "%; top: calc(" + _this.$refs.content.scrollTop / totalHeight * 100 + "% - " + _this.$refs.xBar.clientHeight + "px);right:" + right + "px;";
            }
          }
        });
      }
    }, "moveBar"),
    onYBarMouseDown: /* @__PURE__ */ __name(function onYBarMouseDown(e) {
      this.isYBarClicked = true;
      this.$refs.yBar.focus();
      this.lastPageY = e.pageY;
      this.$refs.yBar.setAttribute("data-p-scrollpanel-grabbed", "true");
      !this.isUnstyled && addClass(this.$refs.yBar, "p-scrollpanel-grabbed");
      document.body.setAttribute("data-p-scrollpanel-grabbed", "true");
      !this.isUnstyled && addClass(document.body, "p-scrollpanel-grabbed");
      this.bindDocumentMouseListeners();
      e.preventDefault();
    }, "onYBarMouseDown"),
    onXBarMouseDown: /* @__PURE__ */ __name(function onXBarMouseDown(e) {
      this.isXBarClicked = true;
      this.$refs.xBar.focus();
      this.lastPageX = e.pageX;
      this.$refs.yBar.setAttribute("data-p-scrollpanel-grabbed", "false");
      !this.isUnstyled && addClass(this.$refs.xBar, "p-scrollpanel-grabbed");
      document.body.setAttribute("data-p-scrollpanel-grabbed", "false");
      !this.isUnstyled && addClass(document.body, "p-scrollpanel-grabbed");
      this.bindDocumentMouseListeners();
      e.preventDefault();
    }, "onXBarMouseDown"),
    onScroll: /* @__PURE__ */ __name(function onScroll2(event2) {
      if (this.lastScrollLeft !== event2.target.scrollLeft) {
        this.lastScrollLeft = event2.target.scrollLeft;
        this.orientation = "horizontal";
      } else if (this.lastScrollTop !== event2.target.scrollTop) {
        this.lastScrollTop = event2.target.scrollTop;
        this.orientation = "vertical";
      }
      this.moveBar();
    }, "onScroll"),
    onKeyDown: /* @__PURE__ */ __name(function onKeyDown4(event2) {
      if (this.orientation === "vertical") {
        switch (event2.code) {
          case "ArrowDown": {
            this.setTimer("scrollTop", this.step);
            event2.preventDefault();
            break;
          }
          case "ArrowUp": {
            this.setTimer("scrollTop", this.step * -1);
            event2.preventDefault();
            break;
          }
          case "ArrowLeft":
          case "ArrowRight": {
            event2.preventDefault();
            break;
          }
        }
      } else if (this.orientation === "horizontal") {
        switch (event2.code) {
          case "ArrowRight": {
            this.setTimer("scrollLeft", this.step);
            event2.preventDefault();
            break;
          }
          case "ArrowLeft": {
            this.setTimer("scrollLeft", this.step * -1);
            event2.preventDefault();
            break;
          }
          case "ArrowDown":
          case "ArrowUp": {
            event2.preventDefault();
            break;
          }
        }
      }
    }, "onKeyDown"),
    onKeyUp: /* @__PURE__ */ __name(function onKeyUp2() {
      this.clearTimer();
    }, "onKeyUp"),
    repeat: /* @__PURE__ */ __name(function repeat2(bar, step2) {
      this.$refs.content[bar] += step2;
      this.moveBar();
    }, "repeat"),
    setTimer: /* @__PURE__ */ __name(function setTimer(bar, step2) {
      var _this2 = this;
      this.clearTimer();
      this.timer = setTimeout(function() {
        _this2.repeat(bar, step2);
      }, 40);
    }, "setTimer"),
    clearTimer: /* @__PURE__ */ __name(function clearTimer2() {
      if (this.timer) {
        clearTimeout(this.timer);
      }
    }, "clearTimer"),
    onDocumentMouseMove: /* @__PURE__ */ __name(function onDocumentMouseMove(e) {
      if (this.isXBarClicked) {
        this.onMouseMoveForXBar(e);
      } else if (this.isYBarClicked) {
        this.onMouseMoveForYBar(e);
      } else {
        this.onMouseMoveForXBar(e);
        this.onMouseMoveForYBar(e);
      }
    }, "onDocumentMouseMove"),
    onMouseMoveForXBar: /* @__PURE__ */ __name(function onMouseMoveForXBar(e) {
      var _this3 = this;
      var deltaX = e.pageX - this.lastPageX;
      this.lastPageX = e.pageX;
      this.frame = this.requestAnimationFrame(function() {
        _this3.$refs.content.scrollLeft += deltaX / _this3.scrollXRatio;
      });
    }, "onMouseMoveForXBar"),
    onMouseMoveForYBar: /* @__PURE__ */ __name(function onMouseMoveForYBar(e) {
      var _this4 = this;
      var deltaY = e.pageY - this.lastPageY;
      this.lastPageY = e.pageY;
      this.frame = this.requestAnimationFrame(function() {
        _this4.$refs.content.scrollTop += deltaY / _this4.scrollYRatio;
      });
    }, "onMouseMoveForYBar"),
    onFocus: /* @__PURE__ */ __name(function onFocus4(event2) {
      if (this.$refs.xBar.isSameNode(event2.target)) {
        this.orientation = "horizontal";
      } else if (this.$refs.yBar.isSameNode(event2.target)) {
        this.orientation = "vertical";
      }
    }, "onFocus"),
    onBlur: /* @__PURE__ */ __name(function onBlur4() {
      if (this.orientation === "horizontal") {
        this.orientation = "vertical";
      }
    }, "onBlur"),
    onDocumentMouseUp: /* @__PURE__ */ __name(function onDocumentMouseUp() {
      this.$refs.yBar.setAttribute("data-p-scrollpanel-grabbed", "false");
      !this.isUnstyled && removeClass(this.$refs.yBar, "p-scrollpanel-grabbed");
      this.$refs.xBar.setAttribute("data-p-scrollpanel-grabbed", "false");
      !this.isUnstyled && removeClass(this.$refs.xBar, "p-scrollpanel-grabbed");
      document.body.setAttribute("data-p-scrollpanel-grabbed", "false");
      !this.isUnstyled && removeClass(document.body, "p-scrollpanel-grabbed");
      this.unbindDocumentMouseListeners();
      this.isXBarClicked = false;
      this.isYBarClicked = false;
    }, "onDocumentMouseUp"),
    requestAnimationFrame: /* @__PURE__ */ __name(function requestAnimationFrame2(f) {
      var frame = window.requestAnimationFrame || this.timeoutFrame;
      return frame(f);
    }, "requestAnimationFrame"),
    refresh: /* @__PURE__ */ __name(function refresh() {
      this.moveBar();
    }, "refresh"),
    scrollTop: /* @__PURE__ */ __name(function scrollTop(_scrollTop) {
      var scrollableHeight = this.$refs.content.scrollHeight - this.$refs.content.clientHeight;
      _scrollTop = _scrollTop > scrollableHeight ? scrollableHeight : _scrollTop > 0 ? _scrollTop : 0;
      this.$refs.content.scrollTop = _scrollTop;
    }, "scrollTop"),
    timeoutFrame: /* @__PURE__ */ __name(function timeoutFrame(fn) {
      setTimeout(fn, 0);
    }, "timeoutFrame"),
    bindDocumentMouseListeners: /* @__PURE__ */ __name(function bindDocumentMouseListeners() {
      var _this5 = this;
      if (!this.documentMouseMoveListener) {
        this.documentMouseMoveListener = function(e) {
          _this5.onDocumentMouseMove(e);
        };
        document.addEventListener("mousemove", this.documentMouseMoveListener);
      }
      if (!this.documentMouseUpListener) {
        this.documentMouseUpListener = function(e) {
          _this5.onDocumentMouseUp(e);
        };
        document.addEventListener("mouseup", this.documentMouseUpListener);
      }
    }, "bindDocumentMouseListeners"),
    unbindDocumentMouseListeners: /* @__PURE__ */ __name(function unbindDocumentMouseListeners() {
      if (this.documentMouseMoveListener) {
        document.removeEventListener("mousemove", this.documentMouseMoveListener);
        this.documentMouseMoveListener = null;
      }
      if (this.documentMouseUpListener) {
        document.removeEventListener("mouseup", this.documentMouseUpListener);
        this.documentMouseUpListener = null;
      }
    }, "unbindDocumentMouseListeners"),
    bindDocumentResizeListener: /* @__PURE__ */ __name(function bindDocumentResizeListener() {
      var _this6 = this;
      if (!this.documentResizeListener) {
        this.documentResizeListener = function() {
          _this6.moveBar();
        };
        window.addEventListener("resize", this.documentResizeListener);
      }
    }, "bindDocumentResizeListener"),
    unbindDocumentResizeListener: /* @__PURE__ */ __name(function unbindDocumentResizeListener() {
      if (this.documentResizeListener) {
        window.removeEventListener("resize", this.documentResizeListener);
        this.documentResizeListener = null;
      }
    }, "unbindDocumentResizeListener")
  },
  computed: {
    contentId: /* @__PURE__ */ __name(function contentId() {
      return this.id + "_content";
    }, "contentId")
  }
};
var _hoisted_1$D = ["id"];
var _hoisted_2$t = ["aria-controls", "aria-valuenow"];
var _hoisted_3$e = ["aria-controls", "aria-valuenow"];
function render$q(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("root")
  }, _ctx.ptmi("root")), [createBaseVNode("div", mergeProps({
    "class": _ctx.cx("contentContainer")
  }, _ctx.ptm("contentContainer")), [createBaseVNode("div", mergeProps({
    ref: "content",
    id: $options.contentId,
    "class": _ctx.cx("content"),
    onScroll: _cache[0] || (_cache[0] = function() {
      return $options.onScroll && $options.onScroll.apply($options, arguments);
    }),
    onMouseenter: _cache[1] || (_cache[1] = function() {
      return $options.moveBar && $options.moveBar.apply($options, arguments);
    })
  }, _ctx.ptm("content")), [renderSlot(_ctx.$slots, "default")], 16, _hoisted_1$D)], 16), createBaseVNode("div", mergeProps({
    ref: "xBar",
    "class": _ctx.cx("barx"),
    tabindex: "0",
    role: "scrollbar",
    "aria-orientation": "horizontal",
    "aria-controls": $options.contentId,
    "aria-valuenow": $data.lastScrollLeft,
    onMousedown: _cache[2] || (_cache[2] = function() {
      return $options.onXBarMouseDown && $options.onXBarMouseDown.apply($options, arguments);
    }),
    onKeydown: _cache[3] || (_cache[3] = function($event) {
      return $options.onKeyDown($event);
    }),
    onKeyup: _cache[4] || (_cache[4] = function() {
      return $options.onKeyUp && $options.onKeyUp.apply($options, arguments);
    }),
    onFocus: _cache[5] || (_cache[5] = function() {
      return $options.onFocus && $options.onFocus.apply($options, arguments);
    }),
    onBlur: _cache[6] || (_cache[6] = function() {
      return $options.onBlur && $options.onBlur.apply($options, arguments);
    })
  }, _ctx.ptm("barx"), {
    "data-pc-group-section": "bar"
  }), null, 16, _hoisted_2$t), createBaseVNode("div", mergeProps({
    ref: "yBar",
    "class": _ctx.cx("bary"),
    tabindex: "0",
    role: "scrollbar",
    "aria-orientation": "vertical",
    "aria-controls": $options.contentId,
    "aria-valuenow": $data.lastScrollTop,
    onMousedown: _cache[7] || (_cache[7] = function() {
      return $options.onYBarMouseDown && $options.onYBarMouseDown.apply($options, arguments);
    }),
    onKeydown: _cache[8] || (_cache[8] = function($event) {
      return $options.onKeyDown($event);
    }),
    onKeyup: _cache[9] || (_cache[9] = function() {
      return $options.onKeyUp && $options.onKeyUp.apply($options, arguments);
    }),
    onFocus: _cache[10] || (_cache[10] = function() {
      return $options.onFocus && $options.onFocus.apply($options, arguments);
    })
  }, _ctx.ptm("bary"), {
    "data-pc-group-section": "bar"
  }), null, 16, _hoisted_3$e)], 16);
}
__name(render$q, "render$q");
script$r.render = render$q;
const _sfc_main$x = /* @__PURE__ */ defineComponent({
  __name: "FindIssueButton",
  props: {
    errorMessage: {},
    repoOwner: {},
    repoName: {}
  },
  setup(__props) {
    const props = __props;
    const queryString = computed(() => props.errorMessage + " is:issue");
    const openGitHubIssues = /* @__PURE__ */ __name(() => {
      const query = encodeURIComponent(queryString.value);
      const url = `https://github.com/${props.repoOwner}/${props.repoName}/issues?q=${query}`;
      window.open(url, "_blank");
    }, "openGitHubIssues");
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(script$J), {
        onClick: openGitHubIssues,
        label: _ctx.$t("findIssues"),
        severity: "secondary",
        icon: "pi pi-github"
      }, null, 8, ["label"]);
    };
  }
});
const _withScopeId$e = /* @__PURE__ */ __name((n) => (pushScopeId("data-v-a103fd62"), n = n(), popScopeId(), n), "_withScopeId$e");
const _hoisted_1$C = { class: "comfy-error-report" };
const _hoisted_2$s = { class: "wrapper-pre" };
const _hoisted_3$d = { class: "action-container" };
const repoOwner = "comfyanonymous";
const repoName = "ComfyUI";
const _sfc_main$w = /* @__PURE__ */ defineComponent({
  __name: "ExecutionErrorDialogContent",
  props: {
    error: {}
  },
  setup(__props) {
    const props = __props;
    const reportContent = ref("");
    const reportOpen = ref(false);
    const showReport = /* @__PURE__ */ __name(() => {
      reportOpen.value = true;
    }, "showReport");
    const toast = useToast();
    const { copy, isSupported: isSupported2 } = useClipboard();
    onMounted(async () => {
      try {
        const [systemStats, logs] = await Promise.all([
          api.getSystemStats(),
          api.getLogs()
        ]);
        generateReport(systemStats, logs);
      } catch (error) {
        console.error("Error fetching system stats or logs:", error);
        toast.add({
          severity: "error",
          summary: "Error",
          detail: "Failed to fetch system information",
          life: 5e3
        });
      }
    });
    const generateReport = /* @__PURE__ */ __name((systemStats, logs) => {
      const MAX_JSON_LENGTH = 2e4;
      const workflowJSONString = JSON.stringify(app$1.graph.serialize());
      const workflowText = workflowJSONString.length > MAX_JSON_LENGTH ? "Workflow too large. Please manually upload the workflow from local file system." : workflowJSONString;
      reportContent.value = `
# ComfyUI Error Report
## Error Details
- **Node Type:** ${props.error.node_type}
- **Exception Type:** ${props.error.exception_type}
- **Exception Message:** ${props.error.exception_message}
## Stack Trace
\`\`\`
${props.error.traceback.join("\n")}
\`\`\`
## System Information
- **ComfyUI Version:** ${systemStats.system.comfyui_version}
- **Arguments:** ${systemStats.system.argv.join(" ")}
- **OS:** ${systemStats.system.os}
- **Python Version:** ${systemStats.system.python_version}
- **Embedded Python:** ${systemStats.system.embedded_python}
- **PyTorch Version:** ${systemStats.system.pytorch_version}
## Devices
${systemStats.devices.map(
        (device) => `
- **Name:** ${device.name}
  - **Type:** ${device.type}
  - **VRAM Total:** ${device.vram_total}
  - **VRAM Free:** ${device.vram_free}
  - **Torch VRAM Total:** ${device.torch_vram_total}
  - **Torch VRAM Free:** ${device.torch_vram_free}
`
      ).join("\n")}
## Logs
\`\`\`
${logs}
\`\`\`
## Attached Workflow
Please make sure that workflow does not contain any sensitive information such as API keys or passwords.
\`\`\`
${workflowText}
\`\`\`

## Additional Context
(Please add any additional context or steps to reproduce the error here)
`;
    }, "generateReport");
    const copyReportToClipboard = /* @__PURE__ */ __name(async () => {
      if (isSupported2) {
        try {
          await copy(reportContent.value);
          toast.add({
            severity: "success",
            summary: "Success",
            detail: "Report copied to clipboard",
            life: 3e3
          });
        } catch (err) {
          toast.add({
            severity: "error",
            summary: "Error",
            detail: "Failed to copy report"
          });
        }
      } else {
        toast.add({
          severity: "error",
          summary: "Error",
          detail: "Clipboard API not supported in your browser"
        });
      }
    }, "copyReportToClipboard");
    const openNewGithubIssue = /* @__PURE__ */ __name(async () => {
      await copyReportToClipboard();
      const issueTitle = encodeURIComponent(
        `[Bug]: ${props.error.exception_type} in ${props.error.node_type}`
      );
      const issueBody = encodeURIComponent(
        "The report has been copied to the clipboard. Please paste it here."
      );
      const url = `https://github.com/${repoOwner}/${repoName}/issues/new?title=${issueTitle}&body=${issueBody}`;
      window.open(url, "_blank");
    }, "openNewGithubIssue");
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        createVNode(NoResultsPlaceholder, {
          icon: "pi pi-exclamation-circle",
          title: props.error.node_type,
          message: props.error.exception_message
        }, null, 8, ["title", "message"]),
        createBaseVNode("div", _hoisted_1$C, [
          withDirectives(createVNode(unref(script$J), {
            label: _ctx.$t("showReport"),
            onClick: showReport,
            text: ""
          }, null, 8, ["label"]), [
            [vShow, !reportOpen.value]
          ]),
          reportOpen.value ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createVNode(unref(script$F)),
            createVNode(unref(script$r), { style: { "width": "100%", "height": "400px", "max-width": "80vw" } }, {
              default: withCtx(() => [
                createBaseVNode("pre", _hoisted_2$s, toDisplayString$1(reportContent.value), 1)
              ]),
              _: 1
            }),
            createVNode(unref(script$F))
          ], 64)) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_3$d, [
            createVNode(_sfc_main$x, {
              errorMessage: props.error.exception_message,
              repoOwner,
              repoName
            }, null, 8, ["errorMessage"]),
            reportOpen.value ? (openBlock(), createBlock(unref(script$J), {
              key: 0,
              label: _ctx.$t("copyToClipboard"),
              icon: "pi pi-copy",
              onClick: copyReportToClipboard
            }, null, 8, ["label"])) : createCommentVNode("", true)
          ])
        ])
      ], 64);
    };
  }
});
const ExecutionErrorDialogContent = /* @__PURE__ */ _export_sfc(_sfc_main$w, [["__scopeId", "data-v-a103fd62"]]);
function showLoadWorkflowWarning(props) {
  const dialogStore = useDialogStore();
  dialogStore.showDialog({
    component: LoadWorkflowWarning,
    props
  });
}
__name(showLoadWorkflowWarning, "showLoadWorkflowWarning");
function showMissingModelsWarning(props) {
  const dialogStore = useDialogStore();
  dialogStore.showDialog({
    component: MissingModelsWarning,
    props
  });
}
__name(showMissingModelsWarning, "showMissingModelsWarning");
function showSettingsDialog() {
  useDialogStore().showDialog({
    headerComponent: SettingDialogHeader,
    component: SettingDialogContent
  });
}
__name(showSettingsDialog, "showSettingsDialog");
function showExecutionErrorDialog(error) {
  useDialogStore().showDialog({
    component: ExecutionErrorDialogContent,
    props: {
      error
    }
  });
}
__name(showExecutionErrorDialog, "showExecutionErrorDialog");
const useToastStore = defineStore("toast", {
  state: /* @__PURE__ */ __name(() => ({
    messagesToAdd: [],
    messagesToRemove: [],
    removeAllRequested: false
  }), "state"),
  actions: {
    add(message3) {
      this.messagesToAdd = [...this.messagesToAdd, message3];
    },
    remove(message3) {
      this.messagesToRemove = [...this.messagesToRemove, message3];
    },
    removeAll() {
      this.removeAllRequested = true;
    }
  }
});
var __defProp$1 = Object.defineProperty;
var __typeError = /* @__PURE__ */ __name((msg) => {
  throw TypeError(msg);
}, "__typeError");
var __defNormalProp = /* @__PURE__ */ __name((obj, key, value3) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value: value3 }) : obj[key] = value3, "__defNormalProp");
var __publicField = /* @__PURE__ */ __name((obj, key, value3) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value3), "__publicField");
var __accessCheck = /* @__PURE__ */ __name((obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg), "__accessCheck");
var __privateGet = /* @__PURE__ */ __name((obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj)), "__privateGet");
var __privateAdd = /* @__PURE__ */ __name((obj, member, value3) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value3), "__privateAdd");
const globalExport = {};
(function(globalThis) {
  var _temp, _temp_vec2, _tmp_area, _margin_area, _link_bounding, _tempA, _tempB;
  var LiteGraph = globalThis.LiteGraph = {
    VERSION: 0.4,
    CANVAS_GRID_SIZE: 10,
    NODE_TITLE_HEIGHT: 30,
    NODE_TITLE_TEXT_Y: 20,
    NODE_SLOT_HEIGHT: 20,
    NODE_WIDGET_HEIGHT: 20,
    NODE_WIDTH: 140,
    NODE_MIN_WIDTH: 50,
    NODE_COLLAPSED_RADIUS: 10,
    NODE_COLLAPSED_WIDTH: 80,
    NODE_TITLE_COLOR: "#999",
    NODE_SELECTED_TITLE_COLOR: "#FFF",
    NODE_TEXT_SIZE: 14,
    NODE_TEXT_COLOR: "#AAA",
    NODE_SUBTEXT_SIZE: 12,
    NODE_DEFAULT_COLOR: "#333",
    NODE_DEFAULT_BGCOLOR: "#353535",
    NODE_DEFAULT_BOXCOLOR: "#666",
    NODE_DEFAULT_SHAPE: "box",
    NODE_BOX_OUTLINE_COLOR: "#FFF",
    DEFAULT_SHADOW_COLOR: "rgba(0,0,0,0.5)",
    DEFAULT_GROUP_FONT: 24,
    WIDGET_BGCOLOR: "#222",
    WIDGET_OUTLINE_COLOR: "#666",
    WIDGET_TEXT_COLOR: "#DDD",
    WIDGET_SECONDARY_TEXT_COLOR: "#999",
    LINK_COLOR: "#9A9",
    EVENT_LINK_COLOR: "#A86",
    CONNECTING_LINK_COLOR: "#AFA",
    MAX_NUMBER_OF_NODES: 1e4,
    //avoid infinite loops
    DEFAULT_POSITION: [100, 100],
    //default node position
    VALID_SHAPES: ["default", "box", "round", "card"],
    //,"circle"
    //shapes are used for nodes but also for slots
    BOX_SHAPE: 1,
    ROUND_SHAPE: 2,
    CIRCLE_SHAPE: 3,
    CARD_SHAPE: 4,
    ARROW_SHAPE: 5,
    GRID_SHAPE: 6,
    // intended for slot arrays
    //enums
    INPUT: 1,
    OUTPUT: 2,
    EVENT: -1,
    //for outputs
    ACTION: -1,
    //for inputs
    NODE_MODES: ["Always", "On Event", "Never", "On Trigger"],
    // helper, will add "On Request" and more in the future
    NODE_MODES_COLORS: ["#666", "#422", "#333", "#224", "#626"],
    // use with node_box_coloured_by_mode
    ALWAYS: 0,
    ON_EVENT: 1,
    NEVER: 2,
    ON_TRIGGER: 3,
    UP: 1,
    DOWN: 2,
    LEFT: 3,
    RIGHT: 4,
    CENTER: 5,
    LINK_RENDER_MODES: ["Straight", "Linear", "Spline"],
    // helper
    STRAIGHT_LINK: 0,
    LINEAR_LINK: 1,
    SPLINE_LINK: 2,
    NORMAL_TITLE: 0,
    NO_TITLE: 1,
    TRANSPARENT_TITLE: 2,
    AUTOHIDE_TITLE: 3,
    VERTICAL_LAYOUT: "vertical",
    // arrange nodes vertically
    proxy: null,
    //used to redirect calls
    node_images_path: "",
    debug: false,
    catch_exceptions: true,
    throw_errors: true,
    allow_scripts: false,
    //if set to true some nodes like Formula would be allowed to evaluate code that comes from unsafe sources (like node configuration), which could lead to exploits
    registered_node_types: {},
    //nodetypes by string
    node_types_by_file_extension: {},
    //used for dropping files in the canvas
    Nodes: {},
    //node types by classname
    Globals: {},
    //used to store vars between graphs
    searchbox_extras: {},
    //used to add extra features to the search box
    auto_sort_node_types: false,
    // [true!] If set to true, will automatically sort node types / categories in the context menus
    node_box_coloured_when_on: false,
    // [true!] this make the nodes box (top left circle) coloured when triggered (execute/action), visual feedback
    node_box_coloured_by_mode: false,
    // [true!] nodebox based on node mode, visual feedback
    dialog_close_on_mouse_leave: false,
    // [false on mobile] better true if not touch device, TODO add an helper/listener to close if false
    dialog_close_on_mouse_leave_delay: 500,
    shift_click_do_break_link_from: false,
    // [false!] prefer false if results too easy to break links - implement with ALT or TODO custom keys
    click_do_break_link_to: false,
    // [false!]prefer false, way too easy to break links
    ctrl_alt_click_do_break_link: true,
    // [true!] who accidentally ctrl-alt-clicks on an in/output? nobody! that's who!
    search_hide_on_mouse_leave: true,
    // [false on mobile] better true if not touch device, TODO add an helper/listener to close if false
    search_filter_enabled: false,
    // [true!] enable filtering slots type in the search widget, !requires auto_load_slot_types or manual set registered_slot_[in/out]_types and slot_types_[in/out]
    search_show_all_on_open: true,
    // [true!] opens the results list when opening the search widget
    auto_load_slot_types: false,
    // [if want false, use true, run, get vars values to be statically set, than disable] nodes types and nodeclass association with node types need to be calculated, if dont want this, calculate once and set registered_slot_[in/out]_types and slot_types_[in/out]
    // set these values if not using auto_load_slot_types
    registered_slot_in_types: {},
    // slot types for nodeclass
    registered_slot_out_types: {},
    // slot types for nodeclass
    slot_types_in: [],
    // slot types IN
    slot_types_out: [],
    // slot types OUT
    slot_types_default_in: [],
    // specify for each IN slot type a(/many) default node(s), use single string, array, or object (with node, title, parameters, ..) like for search
    slot_types_default_out: [],
    // specify for each OUT slot type a(/many) default node(s), use single string, array, or object (with node, title, parameters, ..) like for search
    alt_drag_do_clone_nodes: false,
    // [true!] very handy, ALT click to clone and drag the new node
    do_add_triggers_slots: false,
    // [true!] will create and connect event slots when using action/events connections, !WILL CHANGE node mode when using onTrigger (enable mode colors), onExecuted does not need this
    allow_multi_output_for_events: true,
    // [false!] being events, it is strongly reccomended to use them sequentially, one by one
    middle_click_slot_add_default_node: false,
    //[true!] allows to create and connect a ndoe clicking with the third button (wheel)
    release_link_on_empty_shows_menu: false,
    //[true!] dragging a link to empty space will open a menu, add from list, search or defaults
    pointerevents_method: "pointer",
    // "mouse"|"pointer" use mouse for retrocompatibility issues? (none found @ now)
    // TODO implement pointercancel, gotpointercapture, lostpointercapture, (pointerover, pointerout if necessary)
    ctrl_shift_v_paste_connect_unselected_outputs: true,
    //[true!] allows ctrl + shift + v to paste nodes with the outputs of the unselected nodes connected with the inputs of the newly pasted nodes
    // if true, all newly created nodes/links will use string UUIDs for their id fields instead of integers.
    // use this if you must have node IDs that are unique across all graphs and subgraphs.
    use_uuids: false,
    // Whether to highlight the bounding box of selected groups
    highlight_selected_group: false,
    /**
     * Register a node class so it can be listed when the user wants to create a new one
     * @method registerNodeType
     * @param {String} type name of the node and path
     * @param {Class} base_class class containing the structure of a node
     */
    registerNodeType: /* @__PURE__ */ __name(function(type, base_class) {
      if (!base_class.prototype) {
        throw "Cannot register a simple object, it must be a class with a prototype";
      }
      base_class.type = type;
      if (LiteGraph.debug) {
        console.log("Node registered: " + type);
      }
      const classname = base_class.name;
      const pos2 = type.lastIndexOf("/");
      base_class.category = type.substring(0, pos2);
      if (!base_class.title) {
        base_class.title = classname;
      }
      for (var i2 in LGraphNode.prototype) {
        if (!base_class.prototype[i2]) {
          base_class.prototype[i2] = LGraphNode.prototype[i2];
        }
      }
      const prev2 = this.registered_node_types[type];
      if (prev2) {
        console.log("replacing node type: " + type);
      }
      if (!Object.prototype.hasOwnProperty.call(base_class.prototype, "shape")) {
        Object.defineProperty(base_class.prototype, "shape", {
          set: /* @__PURE__ */ __name(function(v2) {
            switch (v2) {
              case "default":
                delete this._shape;
                break;
              case "box":
                this._shape = LiteGraph.BOX_SHAPE;
                break;
              case "round":
                this._shape = LiteGraph.ROUND_SHAPE;
                break;
              case "circle":
                this._shape = LiteGraph.CIRCLE_SHAPE;
                break;
              case "card":
                this._shape = LiteGraph.CARD_SHAPE;
                break;
              default:
                this._shape = v2;
            }
          }, "set"),
          get: /* @__PURE__ */ __name(function() {
            return this._shape;
          }, "get"),
          enumerable: true,
          configurable: true
        });
        if (base_class.supported_extensions) {
          for (let i3 in base_class.supported_extensions) {
            const ext = base_class.supported_extensions[i3];
            if (ext && ext.constructor === String) {
              this.node_types_by_file_extension[ext.toLowerCase()] = base_class;
            }
          }
        }
      }
      this.registered_node_types[type] = base_class;
      if (base_class.constructor.name) {
        this.Nodes[classname] = base_class;
      }
      if (LiteGraph.onNodeTypeRegistered) {
        LiteGraph.onNodeTypeRegistered(type, base_class);
      }
      if (prev2 && LiteGraph.onNodeTypeReplaced) {
        LiteGraph.onNodeTypeReplaced(type, base_class, prev2);
      }
      if (base_class.prototype.onPropertyChange) {
        console.warn(
          "LiteGraph node class " + type + " has onPropertyChange method, it must be called onPropertyChanged with d at the end"
        );
      }
      if (this.auto_load_slot_types) {
        new base_class(base_class.title || "tmpnode");
      }
    }, "registerNodeType"),
    /**
     * removes a node type from the system
     * @method unregisterNodeType
     * @param {String|Object} type name of the node or the node constructor itself
     */
    unregisterNodeType: /* @__PURE__ */ __name(function(type) {
      const base_class = type.constructor === String ? this.registered_node_types[type] : type;
      if (!base_class) {
        throw "node type not found: " + type;
      }
      delete this.registered_node_types[base_class.type];
      if (base_class.constructor.name) {
        delete this.Nodes[base_class.constructor.name];
      }
    }, "unregisterNodeType"),
    /**
    * Save a slot type and his node
    * @method registerSlotType
    * @param {String|Object} type name of the node or the node constructor itself
    * @param {String} slot_type name of the slot type (variable type), eg. string, number, array, boolean, ..
    */
    registerNodeAndSlotType: /* @__PURE__ */ __name(function(type, slot_type, out) {
      out = out || false;
      const base_class = type.constructor === String && this.registered_node_types[type] !== "anonymous" ? this.registered_node_types[type] : type;
      const class_type = base_class.constructor.type;
      let allTypes = [];
      if (typeof slot_type === "string") {
        allTypes = slot_type.split(",");
      } else if (slot_type == this.EVENT || slot_type == this.ACTION) {
        allTypes = ["_event_"];
      } else {
        allTypes = ["*"];
      }
      for (let i2 = 0; i2 < allTypes.length; ++i2) {
        let slotType = allTypes[i2];
        if (slotType === "") {
          slotType = "*";
        }
        const registerTo = out ? "registered_slot_out_types" : "registered_slot_in_types";
        if (this[registerTo][slotType] === void 0) {
          this[registerTo][slotType] = { nodes: [] };
        }
        if (!this[registerTo][slotType].nodes.includes(class_type)) {
          this[registerTo][slotType].nodes.push(class_type);
        }
        if (!out) {
          if (!this.slot_types_in.includes(slotType.toLowerCase())) {
            this.slot_types_in.push(slotType.toLowerCase());
            this.slot_types_in.sort();
          }
        } else {
          if (!this.slot_types_out.includes(slotType.toLowerCase())) {
            this.slot_types_out.push(slotType.toLowerCase());
            this.slot_types_out.sort();
          }
        }
      }
    }, "registerNodeAndSlotType"),
    /**
     * Create a new nodetype by passing a function, it wraps it with a proper class and generates inputs according to the parameters of the function.
     * Useful to wrap simple methods that do not require properties, and that only process some input to generate an output.
     * @method wrapFunctionAsNode
     * @param {String} name node name with namespace (p.e.: 'math/sum')
     * @param {Function} func
     * @param {Array} param_types [optional] an array containing the type of every parameter, otherwise parameters will accept any type
     * @param {String} return_type [optional] string with the return type, otherwise it will be generic
     * @param {Object} properties [optional] properties to be configurable
     */
    wrapFunctionAsNode: /* @__PURE__ */ __name(function(name, func, param_types, return_type, properties) {
      var params = Array(func.length);
      var code2 = "";
      var names = LiteGraph.getParameterNames(func);
      for (var i2 = 0; i2 < names.length; ++i2) {
        code2 += "this.addInput('" + names[i2] + "'," + (param_types && param_types[i2] ? "'" + param_types[i2] + "'" : "0") + ");\n";
      }
      code2 += "this.addOutput('out'," + (return_type ? "'" + return_type + "'" : 0) + ");\n";
      if (properties) {
        code2 += "this.properties = " + JSON.stringify(properties) + ";\n";
      }
      var classobj = Function(code2);
      classobj.title = name.split("/").pop();
      classobj.desc = "Generated from " + func.name;
      classobj.prototype.onExecute = /* @__PURE__ */ __name(function onExecute() {
        for (var i3 = 0; i3 < params.length; ++i3) {
          params[i3] = this.getInputData(i3);
        }
        var r = func.apply(this, params);
        this.setOutputData(0, r);
      }, "onExecute");
      this.registerNodeType(name, classobj);
    }, "wrapFunctionAsNode"),
    /**
     * Removes all previously registered node's types
     */
    clearRegisteredTypes: /* @__PURE__ */ __name(function() {
      this.registered_node_types = {};
      this.node_types_by_file_extension = {};
      this.Nodes = {};
      this.searchbox_extras = {};
    }, "clearRegisteredTypes"),
    /**
     * Adds this method to all nodetypes, existing and to be created
     * (You can add it to LGraphNode.prototype but then existing node types wont have it)
     * @method addNodeMethod
     * @param {Function} func
     */
    addNodeMethod: /* @__PURE__ */ __name(function(name, func) {
      LGraphNode.prototype[name] = func;
      for (var i2 in this.registered_node_types) {
        var type = this.registered_node_types[i2];
        if (type.prototype[name]) {
          type.prototype["_" + name] = type.prototype[name];
        }
        type.prototype[name] = func;
      }
    }, "addNodeMethod"),
    /**
     * Create a node of a given type with a name. The node is not attached to any graph yet.
     * @method createNode
     * @param {String} type full name of the node class. p.e. "math/sin"
     * @param {String} name a name to distinguish from other nodes
     * @param {Object} options to set options
     */
    createNode: /* @__PURE__ */ __name(function(type, title, options3) {
      var base_class = this.registered_node_types[type];
      if (!base_class) {
        if (LiteGraph.debug) {
          console.log(
            'GraphNode type "' + type + '" not registered.'
          );
        }
        return null;
      }
      base_class.prototype || base_class;
      title = title || base_class.title || type;
      var node22 = null;
      if (LiteGraph.catch_exceptions) {
        try {
          node22 = new base_class(title);
        } catch (err) {
          console.error(err);
          return null;
        }
      } else {
        node22 = new base_class(title);
      }
      node22.type = type;
      if (!node22.title && title) {
        node22.title = title;
      }
      if (!node22.properties) {
        node22.properties = {};
      }
      if (!node22.properties_info) {
        node22.properties_info = [];
      }
      if (!node22.flags) {
        node22.flags = {};
      }
      if (!node22.size) {
        node22.size = node22.computeSize();
      }
      if (!node22.pos) {
        node22.pos = LiteGraph.DEFAULT_POSITION.concat();
      }
      if (!node22.mode) {
        node22.mode = LiteGraph.ALWAYS;
      }
      if (options3) {
        for (var i2 in options3) {
          node22[i2] = options3[i2];
        }
      }
      if (node22.onNodeCreated) {
        node22.onNodeCreated();
      }
      return node22;
    }, "createNode"),
    /**
     * Returns a registered node type with a given name
     * @method getNodeType
     * @param {String} type full name of the node class. p.e. "math/sin"
     * @return {Class} the node class
     */
    getNodeType: /* @__PURE__ */ __name(function(type) {
      return this.registered_node_types[type];
    }, "getNodeType"),
    /**
     * Returns a list of node types matching one category
     * @method getNodeType
     * @param {String} category category name
     * @return {Array} array with all the node classes
     */
    getNodeTypesInCategory: /* @__PURE__ */ __name(function(category, filter4) {
      var r = [];
      for (var i2 in this.registered_node_types) {
        var type = this.registered_node_types[i2];
        if (type.filter != filter4) {
          continue;
        }
        if (category == "") {
          if (type.category == null) {
            r.push(type);
          }
        } else if (type.category == category) {
          r.push(type);
        }
      }
      if (this.auto_sort_node_types) {
        r.sort(function(a, b) {
          return a.title.localeCompare(b.title);
        });
      }
      return r;
    }, "getNodeTypesInCategory"),
    /**
     * Returns a list with all the node type categories
     * @method getNodeTypesCategories
     * @param {String} filter only nodes with ctor.filter equal can be shown
     * @return {Array} array with all the names of the categories
     */
    getNodeTypesCategories: /* @__PURE__ */ __name(function(filter4) {
      var categories = { "": 1 };
      for (var i2 in this.registered_node_types) {
        var type = this.registered_node_types[i2];
        if (type.category && !type.skip_list) {
          if (type.filter != filter4)
            continue;
          categories[type.category] = 1;
        }
      }
      var result = [];
      for (var i2 in categories) {
        result.push(i2);
      }
      return this.auto_sort_node_types ? result.sort() : result;
    }, "getNodeTypesCategories"),
    //debug purposes: reloads all the js scripts that matches a wildcard
    reloadNodes: /* @__PURE__ */ __name(function(folder_wildcard) {
      var tmp = document.getElementsByTagName("script");
      var script_files = [];
      for (var i2 = 0; i2 < tmp.length; i2++) {
        script_files.push(tmp[i2]);
      }
      var docHeadObj = document.getElementsByTagName("head")[0];
      folder_wildcard = document.location.href + folder_wildcard;
      for (var i2 = 0; i2 < script_files.length; i2++) {
        var src = script_files[i2].src;
        if (!src || src.substr(0, folder_wildcard.length) != folder_wildcard) {
          continue;
        }
        try {
          if (LiteGraph.debug) {
            console.log("Reloading: " + src);
          }
          var dynamicScript = document.createElement("script");
          dynamicScript.type = "text/javascript";
          dynamicScript.src = src;
          docHeadObj.appendChild(dynamicScript);
          docHeadObj.removeChild(script_files[i2]);
        } catch (err) {
          if (LiteGraph.throw_errors) {
            throw err;
          }
          if (LiteGraph.debug) {
            console.log("Error while reloading " + src);
          }
        }
      }
      if (LiteGraph.debug) {
        console.log("Nodes reloaded");
      }
    }, "reloadNodes"),
    //separated just to improve if it doesn't work
    cloneObject: /* @__PURE__ */ __name(function(obj, target) {
      if (obj == null) {
        return null;
      }
      var r = JSON.parse(JSON.stringify(obj));
      if (!target) {
        return r;
      }
      for (var i2 in r) {
        target[i2] = r[i2];
      }
      return target;
    }, "cloneObject"),
    /*
     * https://gist.github.com/jed/982883?permalink_comment_id=852670#gistcomment-852670
     */
    uuidv4: /* @__PURE__ */ __name(function() {
      return ("10000000-1000-4000-8000" + -1e11).replace(/[018]/g, (a) => (a ^ Math.random() * 16 >> a / 4).toString(16));
    }, "uuidv4"),
    /**
     * Returns if the types of two slots are compatible (taking into account wildcards, etc)
     * @method isValidConnection
     * @param {String} type_a
     * @param {String} type_b
     * @return {Boolean} true if they can be connected
     */
    isValidConnection: /* @__PURE__ */ __name(function(type_a, type_b) {
      if (type_a == "" || type_a === "*") type_a = 0;
      if (type_b == "" || type_b === "*") type_b = 0;
      if (!type_a || !type_b || type_a == type_b || type_a == LiteGraph.EVENT && type_b == LiteGraph.ACTION) {
        return true;
      }
      type_a = String(type_a);
      type_b = String(type_b);
      type_a = type_a.toLowerCase();
      type_b = type_b.toLowerCase();
      if (type_a.indexOf(",") == -1 && type_b.indexOf(",") == -1) {
        return type_a == type_b;
      }
      var supported_types_a = type_a.split(",");
      var supported_types_b = type_b.split(",");
      for (var i2 = 0; i2 < supported_types_a.length; ++i2) {
        for (var j = 0; j < supported_types_b.length; ++j) {
          if (this.isValidConnection(supported_types_a[i2], supported_types_b[j])) {
            return true;
          }
        }
      }
      return false;
    }, "isValidConnection"),
    /**
     * Register a string in the search box so when the user types it it will recommend this node
     * @method registerSearchboxExtra
     * @param {String} node_type the node recommended
     * @param {String} description text to show next to it
     * @param {Object} data it could contain info of how the node should be configured
     * @return {Boolean} true if they can be connected
     */
    registerSearchboxExtra: /* @__PURE__ */ __name(function(node_type, description, data24) {
      this.searchbox_extras[description.toLowerCase()] = {
        type: node_type,
        desc: description,
        data: data24
      };
    }, "registerSearchboxExtra"),
    /**
     * Wrapper to load files (from url using fetch or from file using FileReader)
     * @method fetchFile
     * @param {String|File|Blob} url the url of the file (or the file itself)
     * @param {String} type an string to know how to fetch it: "text","arraybuffer","json","blob"
     * @param {Function} on_complete callback(data)
     * @param {Function} on_error in case of an error
     * @return {FileReader|Promise} returns the object used to 
     */
    fetchFile: /* @__PURE__ */ __name(function(url, type, on_complete, on_error) {
      if (!url)
        return null;
      type = type || "text";
      if (url.constructor === String) {
        if (url.substr(0, 4) == "http" && LiteGraph.proxy) {
          url = LiteGraph.proxy + url.substr(url.indexOf(":") + 3);
        }
        return fetch(url).then(function(response) {
          if (!response.ok)
            throw new Error("File not found");
          if (type == "arraybuffer")
            return response.arrayBuffer();
          else if (type == "text" || type == "string")
            return response.text();
          else if (type == "json")
            return response.json();
          else if (type == "blob")
            return response.blob();
        }).then(function(data24) {
          if (on_complete)
            on_complete(data24);
        }).catch(function(error) {
          console.error("error fetching file:", url);
          if (on_error)
            on_error(error);
        });
      } else if (url.constructor === File || url.constructor === Blob) {
        var reader = new FileReader();
        reader.onload = function(e) {
          var v2 = e.target.result;
          if (type == "json")
            v2 = JSON.parse(v2);
          if (on_complete)
            on_complete(v2);
        };
        if (type == "arraybuffer")
          return reader.readAsArrayBuffer(url);
        else if (type == "text" || type == "json")
          return reader.readAsText(url);
        else if (type == "blob")
          return reader.readAsBinaryString(url);
      }
      return null;
    }, "fetchFile")
  };
  if (typeof performance != "undefined") {
    LiteGraph.getTime = performance.now.bind(performance);
  } else if (typeof Date != "undefined" && Date.now) {
    LiteGraph.getTime = Date.now.bind(Date);
  } else if (typeof process != "undefined") {
    LiteGraph.getTime = function() {
      var t = process.hrtime();
      return t[0] * 1e-3 + t[1] * 1e-6;
    };
  } else {
    LiteGraph.getTime = /* @__PURE__ */ __name(function getTime() {
      return (/* @__PURE__ */ new Date()).getTime();
    }, "getTime");
  }
  const _LGraph = class _LGraph2 {
    static {
      __name(this, "_LGraph");
    }
    constructor(o) {
      if (LiteGraph.debug) {
        console.log("Graph created");
      }
      this.list_of_graphcanvas = null;
      this.clear();
      if (o) {
        this.configure(o);
      }
    }
    //used to know which types of connections support this graph (some graphs do not allow certain types)
    getSupportedTypes() {
      return this.supported_types || _LGraph2.supported_types;
    }
    /**
         * Removes all nodes from this graph
         * @method clear
         */
    clear() {
      this.stop();
      this.status = _LGraph2.STATUS_STOPPED;
      this.last_node_id = 0;
      this.last_link_id = 0;
      this._version = -1;
      if (this._nodes) {
        for (var i2 = 0; i2 < this._nodes.length; ++i2) {
          var node22 = this._nodes[i2];
          if (node22.onRemoved) {
            node22.onRemoved();
          }
        }
      }
      this._nodes = [];
      this._nodes_by_id = {};
      this._nodes_in_order = [];
      this._nodes_executable = null;
      this._groups = [];
      this.links = {};
      this.iteration = 0;
      this.config = {};
      this.vars = {};
      this.extra = {};
      this.globaltime = 0;
      this.runningtime = 0;
      this.fixedtime = 0;
      this.fixedtime_lapse = 0.01;
      this.elapsed_time = 0.01;
      this.last_update_time = 0;
      this.starttime = 0;
      this.catch_errors = true;
      this.nodes_executing = [];
      this.nodes_actioning = [];
      this.nodes_executedAction = [];
      this.inputs = {};
      this.outputs = {};
      this.change();
      this.sendActionToCanvas("clear");
    }
    /**
         * Attach Canvas to this graph
         * @method attachCanvas
         * @param {GraphCanvas} graph_canvas
         */
    attachCanvas(graphcanvas) {
      if (graphcanvas.constructor != LGraphCanvas) {
        throw "attachCanvas expects a LGraphCanvas instance";
      }
      if (graphcanvas.graph && graphcanvas.graph != this) {
        graphcanvas.graph.detachCanvas(graphcanvas);
      }
      graphcanvas.graph = this;
      if (!this.list_of_graphcanvas) {
        this.list_of_graphcanvas = [];
      }
      this.list_of_graphcanvas.push(graphcanvas);
    }
    /**
         * Detach Canvas from this graph
         * @method detachCanvas
         * @param {GraphCanvas} graph_canvas
         */
    detachCanvas(graphcanvas) {
      if (!this.list_of_graphcanvas) {
        return;
      }
      var pos2 = this.list_of_graphcanvas.indexOf(graphcanvas);
      if (pos2 == -1) {
        return;
      }
      graphcanvas.graph = null;
      this.list_of_graphcanvas.splice(pos2, 1);
    }
    /**
         * Starts running this graph every interval milliseconds.
         * @method start
         * @param {number} interval amount of milliseconds between executions, if 0 then it renders to the monitor refresh rate
         */
    start(interval) {
      if (this.status == _LGraph2.STATUS_RUNNING) {
        return;
      }
      this.status = _LGraph2.STATUS_RUNNING;
      if (this.onPlayEvent) {
        this.onPlayEvent();
      }
      this.sendEventToAllNodes("onStart");
      this.starttime = LiteGraph.getTime();
      this.last_update_time = this.starttime;
      interval = interval || 0;
      var that2 = this;
      if (interval == 0 && typeof window != "undefined" && window.requestAnimationFrame) {
        let on_frame = /* @__PURE__ */ __name(function() {
          if (that2.execution_timer_id != -1) {
            return;
          }
          window.requestAnimationFrame(on_frame);
          if (that2.onBeforeStep)
            that2.onBeforeStep();
          that2.runStep(1, !that2.catch_errors);
          if (that2.onAfterStep)
            that2.onAfterStep();
        }, "on_frame");
        this.execution_timer_id = -1;
        on_frame();
      } else {
        this.execution_timer_id = setInterval(function() {
          if (that2.onBeforeStep)
            that2.onBeforeStep();
          that2.runStep(1, !that2.catch_errors);
          if (that2.onAfterStep)
            that2.onAfterStep();
        }, interval);
      }
    }
    /**
         * Stops the execution loop of the graph
         * @method stop execution
         */
    stop() {
      if (this.status == _LGraph2.STATUS_STOPPED) {
        return;
      }
      this.status = _LGraph2.STATUS_STOPPED;
      if (this.onStopEvent) {
        this.onStopEvent();
      }
      if (this.execution_timer_id != null) {
        if (this.execution_timer_id != -1) {
          clearInterval(this.execution_timer_id);
        }
        this.execution_timer_id = null;
      }
      this.sendEventToAllNodes("onStop");
    }
    /**
         * Run N steps (cycles) of the graph
         * @method runStep
         * @param {number} num number of steps to run, default is 1
         * @param {Boolean} do_not_catch_errors [optional] if you want to try/catch errors
         * @param {number} limit max number of nodes to execute (used to execute from start to a node)
         */
    runStep(num, do_not_catch_errors, limit) {
      num = num || 1;
      var start2 = LiteGraph.getTime();
      this.globaltime = 1e-3 * (start2 - this.starttime);
      var nodes = this._nodes_executable ? this._nodes_executable : this._nodes;
      if (!nodes) {
        return;
      }
      limit = limit || nodes.length;
      if (do_not_catch_errors) {
        for (var i2 = 0; i2 < num; i2++) {
          for (var j = 0; j < limit; ++j) {
            var node22 = nodes[j];
            if (node22.mode == LiteGraph.ALWAYS && node22.onExecute) {
              node22.doExecute();
            }
          }
          this.fixedtime += this.fixedtime_lapse;
          if (this.onExecuteStep) {
            this.onExecuteStep();
          }
        }
        if (this.onAfterExecute) {
          this.onAfterExecute();
        }
      } else {
        try {
          for (var i2 = 0; i2 < num; i2++) {
            for (var j = 0; j < limit; ++j) {
              var node22 = nodes[j];
              if (node22.mode == LiteGraph.ALWAYS && node22.onExecute) {
                node22.onExecute();
              }
            }
            this.fixedtime += this.fixedtime_lapse;
            if (this.onExecuteStep) {
              this.onExecuteStep();
            }
          }
          if (this.onAfterExecute) {
            this.onAfterExecute();
          }
          this.errors_in_execution = false;
        } catch (err) {
          this.errors_in_execution = true;
          if (LiteGraph.throw_errors) {
            throw err;
          }
          if (LiteGraph.debug) {
            console.log("Error during execution: " + err);
          }
          this.stop();
        }
      }
      var now2 = LiteGraph.getTime();
      var elapsed = now2 - start2;
      if (elapsed == 0) {
        elapsed = 1;
      }
      this.execution_time = 1e-3 * elapsed;
      this.globaltime += 1e-3 * elapsed;
      this.iteration += 1;
      this.elapsed_time = (now2 - this.last_update_time) * 1e-3;
      this.last_update_time = now2;
      this.nodes_executing = [];
      this.nodes_actioning = [];
      this.nodes_executedAction = [];
    }
    /**
         * Updates the graph execution order according to relevance of the nodes (nodes with only outputs have more relevance than
         * nodes with only inputs.
         * @method updateExecutionOrder
         */
    updateExecutionOrder() {
      this._nodes_in_order = this.computeExecutionOrder(false);
      this._nodes_executable = [];
      for (var i2 = 0; i2 < this._nodes_in_order.length; ++i2) {
        if (this._nodes_in_order[i2].onExecute) {
          this._nodes_executable.push(this._nodes_in_order[i2]);
        }
      }
    }
    //This is more internal, it computes the executable nodes in order and returns it
    computeExecutionOrder(only_onExecute, set_level) {
      var L = [];
      var S = [];
      var M = {};
      var visited_links = {};
      var remaining_links = {};
      for (var i2 = 0, l = this._nodes.length; i2 < l; ++i2) {
        var node22 = this._nodes[i2];
        if (only_onExecute && !node22.onExecute) {
          continue;
        }
        M[node22.id] = node22;
        var num = 0;
        if (node22.inputs) {
          for (var j = 0, l2 = node22.inputs.length; j < l2; j++) {
            if (node22.inputs[j] && node22.inputs[j].link != null) {
              num += 1;
            }
          }
        }
        if (num == 0) {
          S.push(node22);
          if (set_level) {
            node22._level = 1;
          }
        } else {
          if (set_level) {
            node22._level = 0;
          }
          remaining_links[node22.id] = num;
        }
      }
      while (true) {
        if (S.length == 0) {
          break;
        }
        var node22 = S.shift();
        L.push(node22);
        delete M[node22.id];
        if (!node22.outputs) {
          continue;
        }
        for (var i2 = 0; i2 < node22.outputs.length; i2++) {
          var output = node22.outputs[i2];
          if (output == null || output.links == null || output.links.length == 0) {
            continue;
          }
          for (var j = 0; j < output.links.length; j++) {
            var link_id = output.links[j];
            var link = this.links[link_id];
            if (!link) {
              continue;
            }
            if (visited_links[link.id]) {
              continue;
            }
            var target_node = this.getNodeById(link.target_id);
            if (target_node == null) {
              visited_links[link.id] = true;
              continue;
            }
            if (set_level && (!target_node._level || target_node._level <= node22._level)) {
              target_node._level = node22._level + 1;
            }
            visited_links[link.id] = true;
            remaining_links[target_node.id] -= 1;
            if (remaining_links[target_node.id] == 0) {
              S.push(target_node);
            }
          }
        }
      }
      for (var i2 in M) {
        L.push(M[i2]);
      }
      if (L.length != this._nodes.length && LiteGraph.debug) {
        console.warn("something went wrong, nodes missing");
      }
      var l = L.length;
      for (var i2 = 0; i2 < l; ++i2) {
        L[i2].order = i2;
      }
      L = L.sort(function(A, B) {
        var Ap = A.constructor.priority || A.priority || 0;
        var Bp = B.constructor.priority || B.priority || 0;
        if (Ap == Bp) {
          return A.order - B.order;
        }
        return Ap - Bp;
      });
      for (var i2 = 0; i2 < l; ++i2) {
        L[i2].order = i2;
      }
      return L;
    }
    /**
         * Returns all the nodes that could affect this one (ancestors) by crawling all the inputs recursively.
         * It doesn't include the node itself
         * @method getAncestors
         * @return {Array} an array with all the LGraphNodes that affect this node, in order of execution
         */
    getAncestors(node22) {
      var ancestors = [];
      var pending = [node22];
      var visited = {};
      while (pending.length) {
        var current = pending.shift();
        if (!current.inputs) {
          continue;
        }
        if (!visited[current.id] && current != node22) {
          visited[current.id] = true;
          ancestors.push(current);
        }
        for (var i2 = 0; i2 < current.inputs.length; ++i2) {
          var input = current.getInputNode(i2);
          if (input && ancestors.indexOf(input) == -1) {
            pending.push(input);
          }
        }
      }
      ancestors.sort(function(a, b) {
        return a.order - b.order;
      });
      return ancestors;
    }
    /**
         * Positions every node in a more readable manner
         * @method arrange
         */
    arrange(margin, layout) {
      margin = margin || 100;
      const nodes = this.computeExecutionOrder(false, true);
      const columns = [];
      for (let i2 = 0; i2 < nodes.length; ++i2) {
        const node22 = nodes[i2];
        const col = node22._level || 1;
        if (!columns[col]) {
          columns[col] = [];
        }
        columns[col].push(node22);
      }
      let x2 = margin;
      for (let i2 = 0; i2 < columns.length; ++i2) {
        const column = columns[i2];
        if (!column) {
          continue;
        }
        let max_size = 100;
        let y2 = margin + LiteGraph.NODE_TITLE_HEIGHT;
        for (let j = 0; j < column.length; ++j) {
          const node22 = column[j];
          node22.pos[0] = layout == LiteGraph.VERTICAL_LAYOUT ? y2 : x2;
          node22.pos[1] = layout == LiteGraph.VERTICAL_LAYOUT ? x2 : y2;
          const max_size_index = layout == LiteGraph.VERTICAL_LAYOUT ? 1 : 0;
          if (node22.size[max_size_index] > max_size) {
            max_size = node22.size[max_size_index];
          }
          const node_size_index = layout == LiteGraph.VERTICAL_LAYOUT ? 0 : 1;
          y2 += node22.size[node_size_index] + margin + LiteGraph.NODE_TITLE_HEIGHT;
        }
        x2 += max_size + margin;
      }
      this.setDirtyCanvas(true, true);
    }
    /**
         * Returns the amount of time the graph has been running in milliseconds
         * @method getTime
         * @return {number} number of milliseconds the graph has been running
         */
    getTime() {
      return this.globaltime;
    }
    /**
         * Returns the amount of time accumulated using the fixedtime_lapse var. This is used in context where the time increments should be constant
         * @method getFixedTime
         * @return {number} number of milliseconds the graph has been running
         */
    getFixedTime() {
      return this.fixedtime;
    }
    /**
         * Returns the amount of time it took to compute the latest iteration. Take into account that this number could be not correct
         * if the nodes are using graphical actions
         * @method getElapsedTime
         * @return {number} number of milliseconds it took the last cycle
         */
    getElapsedTime() {
      return this.elapsed_time;
    }
    /**
         * Sends an event to all the nodes, useful to trigger stuff
         * @method sendEventToAllNodes
         * @param {String} eventname the name of the event (function to be called)
         * @param {Array} params parameters in array format
         */
    sendEventToAllNodes(eventname, params, mode2) {
      mode2 = mode2 || LiteGraph.ALWAYS;
      var nodes = this._nodes_in_order ? this._nodes_in_order : this._nodes;
      if (!nodes) {
        return;
      }
      for (var j = 0, l = nodes.length; j < l; ++j) {
        var node22 = nodes[j];
        if (node22.constructor === LiteGraph.Subgraph && eventname != "onExecute") {
          if (node22.mode == mode2) {
            node22.sendEventToAllNodes(eventname, params, mode2);
          }
          continue;
        }
        if (!node22[eventname] || node22.mode != mode2) {
          continue;
        }
        if (params === void 0) {
          node22[eventname]();
        } else if (params && params.constructor === Array) {
          node22[eventname].apply(node22, params);
        } else {
          node22[eventname](params);
        }
      }
    }
    sendActionToCanvas(action, params) {
      if (!this.list_of_graphcanvas) {
        return;
      }
      for (var i2 = 0; i2 < this.list_of_graphcanvas.length; ++i2) {
        var c = this.list_of_graphcanvas[i2];
        if (c[action]) {
          c[action].apply(c, params);
        }
      }
    }
    /**
         * Adds a new node instance to this graph
         * @method add
         * @param {LGraphNode} node the instance of the node
         */
    add(node22, skip_compute_order) {
      if (!node22) {
        return;
      }
      if (node22.constructor === LGraphGroup) {
        this._groups.push(node22);
        this.setDirtyCanvas(true);
        this.change();
        node22.graph = this;
        this._version++;
        return;
      }
      if (node22.id != -1 && this._nodes_by_id[node22.id] != null) {
        console.warn(
          "LiteGraph: there is already a node with this ID, changing it"
        );
        if (LiteGraph.use_uuids) {
          node22.id = LiteGraph.uuidv4();
        } else {
          node22.id = ++this.last_node_id;
        }
      }
      if (this._nodes.length >= LiteGraph.MAX_NUMBER_OF_NODES) {
        throw "LiteGraph: max number of nodes in a graph reached";
      }
      if (LiteGraph.use_uuids) {
        if (node22.id == null || node22.id == -1)
          node22.id = LiteGraph.uuidv4();
      } else {
        if (node22.id == null || node22.id == -1) {
          node22.id = ++this.last_node_id;
        } else if (this.last_node_id < node22.id) {
          this.last_node_id = node22.id;
        }
      }
      node22.graph = this;
      this._version++;
      this._nodes.push(node22);
      this._nodes_by_id[node22.id] = node22;
      if (node22.onAdded) {
        node22.onAdded(this);
      }
      if (this.config.align_to_grid) {
        node22.alignToGrid();
      }
      if (!skip_compute_order) {
        this.updateExecutionOrder();
      }
      if (this.onNodeAdded) {
        this.onNodeAdded(node22);
      }
      this.setDirtyCanvas(true);
      this.change();
      return node22;
    }
    /**
         * Removes a node from the graph
         * @method remove
         * @param {LGraphNode} node the instance of the node
         */
    remove(node22) {
      if (node22.constructor === LiteGraph.LGraphGroup) {
        var index2 = this._groups.indexOf(node22);
        if (index2 != -1) {
          this._groups.splice(index2, 1);
        }
        node22.graph = null;
        this._version++;
        this.setDirtyCanvas(true, true);
        this.change();
        return;
      }
      if (this._nodes_by_id[node22.id] == null) {
        return;
      }
      if (node22.ignore_remove) {
        return;
      }
      this.beforeChange();
      if (node22.inputs) {
        for (var i2 = 0; i2 < node22.inputs.length; i2++) {
          var slot = node22.inputs[i2];
          if (slot.link != null) {
            node22.disconnectInput(i2);
          }
        }
      }
      if (node22.outputs) {
        for (var i2 = 0; i2 < node22.outputs.length; i2++) {
          var slot = node22.outputs[i2];
          if (slot.links != null && slot.links.length) {
            node22.disconnectOutput(i2);
          }
        }
      }
      if (node22.onRemoved) {
        node22.onRemoved();
      }
      node22.graph = null;
      this._version++;
      if (this.list_of_graphcanvas) {
        for (var i2 = 0; i2 < this.list_of_graphcanvas.length; ++i2) {
          var canvas = this.list_of_graphcanvas[i2];
          if (canvas.selected_nodes[node22.id]) {
            delete canvas.selected_nodes[node22.id];
          }
          if (canvas.node_dragged == node22) {
            canvas.node_dragged = null;
          }
        }
      }
      var pos2 = this._nodes.indexOf(node22);
      if (pos2 != -1) {
        this._nodes.splice(pos2, 1);
      }
      delete this._nodes_by_id[node22.id];
      if (this.onNodeRemoved) {
        this.onNodeRemoved(node22);
      }
      this.sendActionToCanvas("checkPanels");
      this.setDirtyCanvas(true, true);
      this.afterChange();
      this.change();
      this.updateExecutionOrder();
    }
    /**
         * Returns a node by its id.
         * @method getNodeById
         * @param {Number} id
         */
    getNodeById(id2) {
      if (id2 == null) {
        return null;
      }
      return this._nodes_by_id[id2];
    }
    /**
         * Returns a list of nodes that matches a class
         * @method findNodesByClass
         * @param {Class} classObject the class itself (not an string)
         * @return {Array} a list with all the nodes of this type
         */
    findNodesByClass(classObject, result) {
      result = result || [];
      result.length = 0;
      for (var i2 = 0, l = this._nodes.length; i2 < l; ++i2) {
        if (this._nodes[i2].constructor === classObject) {
          result.push(this._nodes[i2]);
        }
      }
      return result;
    }
    /**
         * Returns a list of nodes that matches a type
         * @method findNodesByType
         * @param {String} type the name of the node type
         * @return {Array} a list with all the nodes of this type
         */
    findNodesByType(type, result) {
      var type = type.toLowerCase();
      result = result || [];
      result.length = 0;
      for (var i2 = 0, l = this._nodes.length; i2 < l; ++i2) {
        if (this._nodes[i2].type.toLowerCase() == type) {
          result.push(this._nodes[i2]);
        }
      }
      return result;
    }
    /**
         * Returns the first node that matches a name in its title
         * @method findNodeByTitle
         * @param {String} name the name of the node to search
         * @return {Node} the node or null
         */
    findNodeByTitle(title) {
      for (var i2 = 0, l = this._nodes.length; i2 < l; ++i2) {
        if (this._nodes[i2].title == title) {
          return this._nodes[i2];
        }
      }
      return null;
    }
    /**
         * Returns a list of nodes that matches a name
         * @method findNodesByTitle
         * @param {String} name the name of the node to search
         * @return {Array} a list with all the nodes with this name
         */
    findNodesByTitle(title) {
      var result = [];
      for (var i2 = 0, l = this._nodes.length; i2 < l; ++i2) {
        if (this._nodes[i2].title == title) {
          result.push(this._nodes[i2]);
        }
      }
      return result;
    }
    /**
         * Returns the top-most node in this position of the canvas
         * @method getNodeOnPos
         * @param {number} x the x coordinate in canvas space
         * @param {number} y the y coordinate in canvas space
         * @param {Array} nodes_list a list with all the nodes to search from, by default is all the nodes in the graph
         * @return {LGraphNode} the node at this position or null
         */
    getNodeOnPos(x2, y2, nodes_list, margin) {
      nodes_list = nodes_list || this._nodes;
      var nRet = null;
      for (var i2 = nodes_list.length - 1; i2 >= 0; i2--) {
        var n = nodes_list[i2];
        var skip_title = n.constructor.title_mode == LiteGraph.NO_TITLE;
        if (n.isPointInside(x2, y2, margin, skip_title)) {
          return n;
        }
      }
      return nRet;
    }
    /**
         * Returns the top-most group in that position
         * @method getGroupOnPos
         * @param {number} x the x coordinate in canvas space
         * @param {number} y the y coordinate in canvas space
         * @return {LGraphGroup | null} the group or null
         */
    getGroupOnPos(x2, y2, { margin = 2 } = {}) {
      return this._groups.reverse().find((g) => g.isPointInside(
        x2,
        y2,
        margin,
        /* skip_title */
        true
      ));
    }
    /**
         * Checks that the node type matches the node type registered, used when replacing a nodetype by a newer version during execution
         * this replaces the ones using the old version with the new version
         * @method checkNodeTypes
         */
    checkNodeTypes() {
      for (var i2 = 0; i2 < this._nodes.length; i2++) {
        var node22 = this._nodes[i2];
        var ctor = LiteGraph.registered_node_types[node22.type];
        if (node22.constructor == ctor) {
          continue;
        }
        console.log("node being replaced by newer version: " + node22.type);
        var newnode = LiteGraph.createNode(node22.type);
        this._nodes[i2] = newnode;
        newnode.configure(node22.serialize());
        newnode.graph = this;
        this._nodes_by_id[newnode.id] = newnode;
        if (node22.inputs) {
          newnode.inputs = node22.inputs.concat();
        }
        if (node22.outputs) {
          newnode.outputs = node22.outputs.concat();
        }
      }
      this.updateExecutionOrder();
    }
    // ********** GLOBALS *****************
    onAction(action, param, options3) {
      this._input_nodes = this.findNodesByClass(
        LiteGraph.GraphInput,
        this._input_nodes
      );
      for (var i2 = 0; i2 < this._input_nodes.length; ++i2) {
        var node22 = this._input_nodes[i2];
        if (node22.properties.name != action) {
          continue;
        }
        node22.actionDo(action, param, options3);
        break;
      }
    }
    trigger(action, param) {
      if (this.onTrigger) {
        this.onTrigger(action, param);
      }
    }
    /**
         * Tell this graph it has a global graph input of this type
         * @method addGlobalInput
         * @param {String} name
         * @param {String} type
         * @param {*} value [optional]
         */
    addInput(name, type, value3) {
      var input = this.inputs[name];
      if (input) {
        return;
      }
      this.beforeChange();
      this.inputs[name] = { name, type, value: value3 };
      this._version++;
      this.afterChange();
      if (this.onInputAdded) {
        this.onInputAdded(name, type);
      }
      if (this.onInputsOutputsChange) {
        this.onInputsOutputsChange();
      }
    }
    /**
         * Assign a data to the global graph input
         * @method setGlobalInputData
         * @param {String} name
         * @param {*} data
         */
    setInputData(name, data24) {
      var input = this.inputs[name];
      if (!input) {
        return;
      }
      input.value = data24;
    }
    /**
         * Returns the current value of a global graph input
         * @method getInputData
         * @param {String} name
         * @return {*} the data
         */
    getInputData(name) {
      var input = this.inputs[name];
      if (!input) {
        return null;
      }
      return input.value;
    }
    /**
         * Changes the name of a global graph input
         * @method renameInput
         * @param {String} old_name
         * @param {String} new_name
         */
    renameInput(old_name, name) {
      if (name == old_name) {
        return;
      }
      if (!this.inputs[old_name]) {
        return false;
      }
      if (this.inputs[name]) {
        console.error("there is already one input with that name");
        return false;
      }
      this.inputs[name] = this.inputs[old_name];
      delete this.inputs[old_name];
      this._version++;
      if (this.onInputRenamed) {
        this.onInputRenamed(old_name, name);
      }
      if (this.onInputsOutputsChange) {
        this.onInputsOutputsChange();
      }
    }
    /**
         * Changes the type of a global graph input
         * @method changeInputType
         * @param {String} name
         * @param {String} type
         */
    changeInputType(name, type) {
      if (!this.inputs[name]) {
        return false;
      }
      if (this.inputs[name].type && String(this.inputs[name].type).toLowerCase() == String(type).toLowerCase()) {
        return;
      }
      this.inputs[name].type = type;
      this._version++;
      if (this.onInputTypeChanged) {
        this.onInputTypeChanged(name, type);
      }
    }
    /**
         * Removes a global graph input
         * @method removeInput
         * @param {String} name
         * @param {String} type
         */
    removeInput(name) {
      if (!this.inputs[name]) {
        return false;
      }
      delete this.inputs[name];
      this._version++;
      if (this.onInputRemoved) {
        this.onInputRemoved(name);
      }
      if (this.onInputsOutputsChange) {
        this.onInputsOutputsChange();
      }
      return true;
    }
    /**
         * Creates a global graph output
         * @method addOutput
         * @param {String} name
         * @param {String} type
         * @param {*} value
         */
    addOutput(name, type, value3) {
      this.outputs[name] = { name, type, value: value3 };
      this._version++;
      if (this.onOutputAdded) {
        this.onOutputAdded(name, type);
      }
      if (this.onInputsOutputsChange) {
        this.onInputsOutputsChange();
      }
    }
    /**
         * Assign a data to the global output
         * @method setOutputData
         * @param {String} name
         * @param {String} value
         */
    setOutputData(name, value3) {
      var output = this.outputs[name];
      if (!output) {
        return;
      }
      output.value = value3;
    }
    /**
         * Returns the current value of a global graph output
         * @method getOutputData
         * @param {String} name
         * @return {*} the data
         */
    getOutputData(name) {
      var output = this.outputs[name];
      if (!output) {
        return null;
      }
      return output.value;
    }
    /**
         * Renames a global graph output
         * @method renameOutput
         * @param {String} old_name
         * @param {String} new_name
         */
    renameOutput(old_name, name) {
      if (!this.outputs[old_name]) {
        return false;
      }
      if (this.outputs[name]) {
        console.error("there is already one output with that name");
        return false;
      }
      this.outputs[name] = this.outputs[old_name];
      delete this.outputs[old_name];
      this._version++;
      if (this.onOutputRenamed) {
        this.onOutputRenamed(old_name, name);
      }
      if (this.onInputsOutputsChange) {
        this.onInputsOutputsChange();
      }
    }
    /**
         * Changes the type of a global graph output
         * @method changeOutputType
         * @param {String} name
         * @param {String} type
         */
    changeOutputType(name, type) {
      if (!this.outputs[name]) {
        return false;
      }
      if (this.outputs[name].type && String(this.outputs[name].type).toLowerCase() == String(type).toLowerCase()) {
        return;
      }
      this.outputs[name].type = type;
      this._version++;
      if (this.onOutputTypeChanged) {
        this.onOutputTypeChanged(name, type);
      }
    }
    /**
         * Removes a global graph output
         * @method removeOutput
         * @param {String} name
         */
    removeOutput(name) {
      if (!this.outputs[name]) {
        return false;
      }
      delete this.outputs[name];
      this._version++;
      if (this.onOutputRemoved) {
        this.onOutputRemoved(name);
      }
      if (this.onInputsOutputsChange) {
        this.onInputsOutputsChange();
      }
      return true;
    }
    triggerInput(name, value3) {
      var nodes = this.findNodesByTitle(name);
      for (var i2 = 0; i2 < nodes.length; ++i2) {
        nodes[i2].onTrigger(value3);
      }
    }
    setCallback(name, func) {
      var nodes = this.findNodesByTitle(name);
      for (var i2 = 0; i2 < nodes.length; ++i2) {
        nodes[i2].setTrigger(func);
      }
    }
    //used for undo, called before any change is made to the graph
    beforeChange(info) {
      if (this.onBeforeChange) {
        this.onBeforeChange(this, info);
      }
      this.sendActionToCanvas("onBeforeChange", this);
    }
    //used to resend actions, called after any change is made to the graph
    afterChange(info) {
      if (this.onAfterChange) {
        this.onAfterChange(this, info);
      }
      this.sendActionToCanvas("onAfterChange", this);
    }
    connectionChange(node22, link_info) {
      this.updateExecutionOrder();
      if (this.onConnectionChange) {
        this.onConnectionChange(node22);
      }
      this._version++;
      this.sendActionToCanvas("onConnectionChange");
    }
    /**
         * returns if the graph is in live mode
         * @method isLive
         */
    isLive() {
      if (!this.list_of_graphcanvas) {
        return false;
      }
      for (var i2 = 0; i2 < this.list_of_graphcanvas.length; ++i2) {
        var c = this.list_of_graphcanvas[i2];
        if (c.live_mode) {
          return true;
        }
      }
      return false;
    }
    /**
         * clears the triggered slot animation in all links (stop visual animation)
         * @method clearTriggeredSlots
         */
    clearTriggeredSlots() {
      for (var i2 in this.links) {
        var link_info = this.links[i2];
        if (!link_info) {
          continue;
        }
        if (link_info._last_time) {
          link_info._last_time = 0;
        }
      }
    }
    /* Called when something visually changed (not the graph!) */
    change() {
      if (LiteGraph.debug) {
        console.log("Graph changed");
      }
      this.sendActionToCanvas("setDirty", [true, true]);
      if (this.on_change) {
        this.on_change(this);
      }
    }
    setDirtyCanvas(fg, bg) {
      this.sendActionToCanvas("setDirty", [fg, bg]);
    }
    /**
         * Destroys a link
         * @method removeLink
         * @param {Number} link_id
         */
    removeLink(link_id) {
      var link = this.links[link_id];
      if (!link) {
        return;
      }
      var node22 = this.getNodeById(link.target_id);
      if (node22) {
        node22.disconnectInput(link.target_slot);
      }
    }
    //save and recover app state ***************************************
    /**
         * Creates a Object containing all the info about this graph, it can be serialized
         * @method serialize
         * @return {Object} value of the node
         */
    serialize(option4 = { sortNodes: false }) {
      var nodes_info = [];
      nodes_info = ((option4 == null ? void 0 : option4.sortNodes) ? [...this._nodes].sort((a, b) => a.id - b.id) : this._nodes).map((node22) => node22.serialize());
      var links = [];
      for (var i2 in this.links) {
        var link = this.links[i2];
        if (!link.serialize) {
          console.warn(
            "weird LLink bug, link info is not a LLink but a regular object"
          );
          var link2 = new LLink();
          for (var j in link) {
            link2[j] = link[j];
          }
          this.links[i2] = link2;
          link = link2;
        }
        links.push(link.serialize());
      }
      var groups_info = [];
      for (var i2 = 0; i2 < this._groups.length; ++i2) {
        groups_info.push(this._groups[i2].serialize());
      }
      var data24 = {
        last_node_id: this.last_node_id,
        last_link_id: this.last_link_id,
        nodes: nodes_info,
        links,
        groups: groups_info,
        config: this.config,
        extra: this.extra,
        version: LiteGraph.VERSION
      };
      if (this.onSerialize)
        this.onSerialize(data24);
      return data24;
    }
    /**
         * Configure a graph from a JSON string
         * @method configure
         * @param {String} str configure a graph from a JSON string
         * @param {Boolean} returns if there was any error parsing
         */
    configure(data24, keep_old) {
      if (!data24) {
        return;
      }
      if (!keep_old) {
        this.clear();
      }
      var nodes = data24.nodes;
      if (data24.links && data24.links.constructor === Array) {
        var links = [];
        for (var i2 = 0; i2 < data24.links.length; ++i2) {
          var link_data = data24.links[i2];
          if (!link_data) {
            console.warn("serialized graph link data contains errors, skipping.");
            continue;
          }
          var link = new LLink();
          link.configure(link_data);
          links[link.id] = link;
        }
        data24.links = links;
      }
      for (var i2 in data24) {
        if (i2 == "nodes" || i2 == "groups")
          continue;
        this[i2] = data24[i2];
      }
      var error = false;
      this._nodes = [];
      if (nodes) {
        for (var i2 = 0, l = nodes.length; i2 < l; ++i2) {
          var n_info = nodes[i2];
          var node22 = LiteGraph.createNode(n_info.type, n_info.title);
          if (!node22) {
            if (LiteGraph.debug) {
              console.log(
                "Node not found or has errors: " + n_info.type
              );
            }
            node22 = new LGraphNode();
            node22.last_serialization = n_info;
            node22.has_errors = true;
            error = true;
          }
          node22.id = n_info.id;
          this.add(node22, true);
        }
        for (var i2 = 0, l = nodes.length; i2 < l; ++i2) {
          var n_info = nodes[i2];
          var node22 = this.getNodeById(n_info.id);
          if (node22) {
            node22.configure(n_info);
          }
        }
      }
      this._groups.length = 0;
      if (data24.groups) {
        for (var i2 = 0; i2 < data24.groups.length; ++i2) {
          var group = new LiteGraph.LGraphGroup();
          group.configure(data24.groups[i2]);
          this.add(group);
        }
      }
      this.updateExecutionOrder();
      this.extra = data24.extra || {};
      if (this.onConfigure)
        this.onConfigure(data24);
      this._version++;
      this.setDirtyCanvas(true, true);
      return error;
    }
    load(url, callback) {
      var that2 = this;
      if (url.constructor === File || url.constructor === Blob) {
        var reader = new FileReader();
        reader.addEventListener("load", function(event2) {
          var data24 = JSON.parse(event2.target.result);
          that2.configure(data24);
          if (callback)
            callback();
        });
        reader.readAsText(url);
        return;
      }
      var req = new XMLHttpRequest();
      req.open("GET", url, true);
      req.send(null);
      req.onload = function(oEvent) {
        if (req.status !== 200) {
          console.error("Error loading graph:", req.status, req.response);
          return;
        }
        var data24 = JSON.parse(req.response);
        that2.configure(data24);
        if (callback)
          callback();
      };
      req.onerror = function(err) {
        console.error("Error loading graph:", err);
      };
    }
    onNodeTrace(node22, msg, color) {
    }
  };
  __publicField(_LGraph, "supported_types", ["number", "string", "boolean"]);
  __publicField(_LGraph, "STATUS_STOPPED", 1);
  __publicField(_LGraph, "STATUS_RUNNING", 2);
  let LGraph = _LGraph;
  globalThis.LGraph = LiteGraph.LGraph = LGraph;
  class LLink {
    static {
      __name(this, "LLink");
    }
    constructor(id2, type, origin_id, origin_slot, target_id, target_slot) {
      this.id = id2;
      this.type = type;
      this.origin_id = origin_id;
      this.origin_slot = origin_slot;
      this.target_id = target_id;
      this.target_slot = target_slot;
      this._data = null;
      this._pos = new Float32Array(2);
    }
    configure(o) {
      if (o.constructor === Array) {
        this.id = o[0];
        this.origin_id = o[1];
        this.origin_slot = o[2];
        this.target_id = o[3];
        this.target_slot = o[4];
        this.type = o[5];
      } else {
        this.id = o.id;
        this.type = o.type;
        this.origin_id = o.origin_id;
        this.origin_slot = o.origin_slot;
        this.target_id = o.target_id;
        this.target_slot = o.target_slot;
      }
    }
    serialize() {
      return [
        this.id,
        this.origin_id,
        this.origin_slot,
        this.target_id,
        this.target_slot,
        this.type
      ];
    }
  }
  LiteGraph.LLink = LLink;
  class LGraphNode {
    static {
      __name(this, "LGraphNode");
    }
    constructor(title) {
      this._ctor(title);
    }
    _ctor(title) {
      this.title = title || "Unnamed";
      this.size = [LiteGraph.NODE_WIDTH, 60];
      this.graph = null;
      this._pos = new Float32Array([10, 10]);
      Object.defineProperty(this, "pos", {
        set: /* @__PURE__ */ __name(function(v2) {
          if (!v2 || v2.length < 2) {
            return;
          }
          this._pos[0] = v2[0];
          this._pos[1] = v2[1];
        }, "set"),
        get: /* @__PURE__ */ __name(function() {
          return this._pos;
        }, "get"),
        enumerable: true
      });
      if (LiteGraph.use_uuids) {
        this.id = LiteGraph.uuidv4();
      } else {
        this.id = -1;
      }
      this.type = null;
      this.inputs = [];
      this.outputs = [];
      this.connections = [];
      this.properties = {};
      this.properties_info = [];
      this.flags = {};
    }
    /**
         * configure a node from an object containing the serialized info
         * @method configure
         */
    configure(info) {
      if (this.graph) {
        this.graph._version++;
      }
      for (var j in info) {
        if (j == "properties") {
          for (var k in info.properties) {
            this.properties[k] = info.properties[k];
            if (this.onPropertyChanged) {
              this.onPropertyChanged(k, info.properties[k]);
            }
          }
          continue;
        }
        if (info[j] == null) {
          continue;
        } else if (typeof info[j] == "object") {
          if (this[j] && this[j].configure) {
            this[j].configure(info[j]);
          } else {
            this[j] = LiteGraph.cloneObject(info[j], this[j]);
          }
        } else {
          this[j] = info[j];
        }
      }
      if (!info.title) {
        this.title = this.constructor.title;
      }
      if (this.inputs) {
        for (var i2 = 0; i2 < this.inputs.length; ++i2) {
          var input = this.inputs[i2];
          var link_info = this.graph ? this.graph.links[input.link] : null;
          if (this.onConnectionsChange)
            this.onConnectionsChange(LiteGraph.INPUT, i2, true, link_info, input);
          if (this.onInputAdded)
            this.onInputAdded(input);
        }
      }
      if (this.outputs) {
        for (var i2 = 0; i2 < this.outputs.length; ++i2) {
          var output = this.outputs[i2];
          if (!output.links) {
            continue;
          }
          for (var j = 0; j < output.links.length; ++j) {
            var link_info = this.graph ? this.graph.links[output.links[j]] : null;
            if (this.onConnectionsChange)
              this.onConnectionsChange(LiteGraph.OUTPUT, i2, true, link_info, output);
          }
          if (this.onOutputAdded)
            this.onOutputAdded(output);
        }
      }
      if (this.widgets) {
        for (var i2 = 0; i2 < this.widgets.length; ++i2) {
          var w2 = this.widgets[i2];
          if (!w2)
            continue;
          if (w2.options && w2.options.property && this.properties[w2.options.property] != void 0)
            w2.value = JSON.parse(JSON.stringify(this.properties[w2.options.property]));
        }
        if (info.widgets_values) {
          for (var i2 = 0; i2 < info.widgets_values.length; ++i2) {
            if (this.widgets[i2]) {
              this.widgets[i2].value = info.widgets_values[i2];
            }
          }
        }
      }
      if (this.pinned) {
        this.pin(true);
      }
      if (this.onConfigure) {
        this.onConfigure(info);
      }
    }
    /**
         * serialize the content
         * @method serialize
         */
    serialize() {
      var o = {
        id: this.id,
        type: this.type,
        pos: this.pos,
        size: this.size,
        flags: LiteGraph.cloneObject(this.flags),
        order: this.order,
        mode: this.mode
      };
      if (this.constructor === LGraphNode && this.last_serialization) {
        return this.last_serialization;
      }
      if (this.inputs) {
        o.inputs = this.inputs;
      }
      if (this.outputs) {
        for (var i2 = 0; i2 < this.outputs.length; i2++) {
          delete this.outputs[i2]._data;
        }
        o.outputs = this.outputs;
      }
      if (this.title && this.title != this.constructor.title) {
        o.title = this.title;
      }
      if (this.properties) {
        o.properties = LiteGraph.cloneObject(this.properties);
      }
      if (this.widgets && this.serialize_widgets) {
        o.widgets_values = [];
        for (var i2 = 0; i2 < this.widgets.length; ++i2) {
          if (this.widgets[i2])
            o.widgets_values[i2] = this.widgets[i2].value;
          else
            o.widgets_values[i2] = null;
        }
      }
      if (!o.type) {
        o.type = this.constructor.type;
      }
      if (this.color) {
        o.color = this.color;
      }
      if (this.bgcolor) {
        o.bgcolor = this.bgcolor;
      }
      if (this.boxcolor) {
        o.boxcolor = this.boxcolor;
      }
      if (this.shape) {
        o.shape = this.shape;
      }
      if (this.onSerialize) {
        if (this.onSerialize(o)) {
          console.warn(
            "node onSerialize shouldnt return anything, data should be stored in the object pass in the first parameter"
          );
        }
      }
      return o;
    }
    /* Creates a clone of this node */
    clone() {
      var node22 = LiteGraph.createNode(this.type);
      if (!node22) {
        return null;
      }
      var data24 = LiteGraph.cloneObject(this.serialize());
      if (data24.inputs) {
        for (var i2 = 0; i2 < data24.inputs.length; ++i2) {
          data24.inputs[i2].link = null;
        }
      }
      if (data24.outputs) {
        for (var i2 = 0; i2 < data24.outputs.length; ++i2) {
          if (data24.outputs[i2].links) {
            data24.outputs[i2].links.length = 0;
          }
        }
      }
      delete data24["id"];
      if (LiteGraph.use_uuids) {
        data24["id"] = LiteGraph.uuidv4();
      }
      node22.configure(data24);
      return node22;
    }
    /**
         * serialize and stringify
         * @method toString
         */
    toString() {
      return JSON.stringify(this.serialize());
    }
    //LGraphNode.prototype.deserialize = function(info) {} //this cannot be done from within, must be done in LiteGraph
    /**
         * get the title string
         * @method getTitle
         */
    getTitle() {
      return this.title || this.constructor.title;
    }
    /**
         * sets the value of a property
         * @method setProperty
         * @param {String} name
         * @param {*} value
         */
    setProperty(name, value3) {
      if (!this.properties) {
        this.properties = {};
      }
      if (value3 === this.properties[name])
        return;
      var prev_value = this.properties[name];
      this.properties[name] = value3;
      if (this.onPropertyChanged) {
        if (this.onPropertyChanged(name, value3, prev_value) === false)
          this.properties[name] = prev_value;
      }
      if (this.widgets)
        for (var i2 = 0; i2 < this.widgets.length; ++i2) {
          var w2 = this.widgets[i2];
          if (!w2)
            continue;
          if (w2.options.property == name) {
            w2.value = value3;
            break;
          }
        }
    }
    // Execution *************************
    /**
         * sets the output data
         * @method setOutputData
         * @param {number} slot
         * @param {*} data
         */
    setOutputData(slot, data24) {
      if (!this.outputs) {
        return;
      }
      if (slot == -1 || slot >= this.outputs.length) {
        return;
      }
      var output_info = this.outputs[slot];
      if (!output_info) {
        return;
      }
      output_info._data = data24;
      if (this.outputs[slot].links) {
        for (var i2 = 0; i2 < this.outputs[slot].links.length; i2++) {
          var link_id = this.outputs[slot].links[i2];
          var link = this.graph.links[link_id];
          if (link)
            link.data = data24;
        }
      }
    }
    /**
         * sets the output data type, useful when you want to be able to overwrite the data type
         * @method setOutputDataType
         * @param {number} slot
         * @param {String} datatype
         */
    setOutputDataType(slot, type) {
      if (!this.outputs) {
        return;
      }
      if (slot == -1 || slot >= this.outputs.length) {
        return;
      }
      var output_info = this.outputs[slot];
      if (!output_info) {
        return;
      }
      output_info.type = type;
      if (this.outputs[slot].links) {
        for (var i2 = 0; i2 < this.outputs[slot].links.length; i2++) {
          var link_id = this.outputs[slot].links[i2];
          this.graph.links[link_id].type = type;
        }
      }
    }
    /**
         * Retrieves the input data (data traveling through the connection) from one slot
         * @method getInputData
         * @param {number} slot
         * @param {boolean} force_update if set to true it will force the connected node of this slot to output data into this link
         * @return {*} data or if it is not connected returns undefined
         */
    getInputData(slot, force_update) {
      if (!this.inputs) {
        return;
      }
      if (slot >= this.inputs.length || this.inputs[slot].link == null) {
        return;
      }
      var link_id = this.inputs[slot].link;
      var link = this.graph.links[link_id];
      if (!link) {
        return null;
      }
      if (!force_update) {
        return link.data;
      }
      var node22 = this.graph.getNodeById(link.origin_id);
      if (!node22) {
        return link.data;
      }
      if (node22.updateOutputData) {
        node22.updateOutputData(link.origin_slot);
      } else if (node22.onExecute) {
        node22.onExecute();
      }
      return link.data;
    }
    /**
         * Retrieves the input data type (in case this supports multiple input types)
         * @method getInputDataType
         * @param {number} slot
         * @return {String} datatype in string format
         */
    getInputDataType(slot) {
      if (!this.inputs) {
        return null;
      }
      if (slot >= this.inputs.length || this.inputs[slot].link == null) {
        return null;
      }
      var link_id = this.inputs[slot].link;
      var link = this.graph.links[link_id];
      if (!link) {
        return null;
      }
      var node22 = this.graph.getNodeById(link.origin_id);
      if (!node22) {
        return link.type;
      }
      var output_info = node22.outputs[link.origin_slot];
      if (output_info) {
        return output_info.type;
      }
      return null;
    }
    /**
         * Retrieves the input data from one slot using its name instead of slot number
         * @method getInputDataByName
         * @param {String} slot_name
         * @param {boolean} force_update if set to true it will force the connected node of this slot to output data into this link
         * @return {*} data or if it is not connected returns null
         */
    getInputDataByName(slot_name, force_update) {
      var slot = this.findInputSlot(slot_name);
      if (slot == -1) {
        return null;
      }
      return this.getInputData(slot, force_update);
    }
    /**
         * tells you if there is a connection in one input slot
         * @method isInputConnected
         * @param {number} slot
         * @return {boolean}
         */
    isInputConnected(slot) {
      if (!this.inputs) {
        return false;
      }
      return slot < this.inputs.length && this.inputs[slot].link != null;
    }
    /**
         * tells you info about an input connection (which node, type, etc)
         * @method getInputInfo
         * @param {number} slot
         * @return {Object} object or null { link: id, name: string, type: string or 0 }
         */
    getInputInfo(slot) {
      if (!this.inputs) {
        return null;
      }
      if (slot < this.inputs.length) {
        return this.inputs[slot];
      }
      return null;
    }
    /**
         * Returns the link info in the connection of an input slot
         * @method getInputLink
         * @param {number} slot
         * @return {LLink} object or null
         */
    getInputLink(slot) {
      if (!this.inputs) {
        return null;
      }
      if (slot < this.inputs.length) {
        var slot_info = this.inputs[slot];
        return this.graph.links[slot_info.link];
      }
      return null;
    }
    /**
         * returns the node connected in the input slot
         * @method getInputNode
         * @param {number} slot
         * @return {LGraphNode} node or null
         */
    getInputNode(slot) {
      if (!this.inputs) {
        return null;
      }
      if (slot >= this.inputs.length) {
        return null;
      }
      var input = this.inputs[slot];
      if (!input || input.link === null) {
        return null;
      }
      var link_info = this.graph.links[input.link];
      if (!link_info) {
        return null;
      }
      return this.graph.getNodeById(link_info.origin_id);
    }
    /**
         * returns the value of an input with this name, otherwise checks if there is a property with that name
         * @method getInputOrProperty
         * @param {string} name
         * @return {*} value
         */
    getInputOrProperty(name) {
      if (!this.inputs || !this.inputs.length) {
        return this.properties ? this.properties[name] : null;
      }
      for (var i2 = 0, l = this.inputs.length; i2 < l; ++i2) {
        var input_info = this.inputs[i2];
        if (name == input_info.name && input_info.link != null) {
          var link = this.graph.links[input_info.link];
          if (link) {
            return link.data;
          }
        }
      }
      return this.properties[name];
    }
    /**
         * tells you the last output data that went in that slot
         * @method getOutputData
         * @param {number} slot
         * @return {Object}  object or null
         */
    getOutputData(slot) {
      if (!this.outputs) {
        return null;
      }
      if (slot >= this.outputs.length) {
        return null;
      }
      var info = this.outputs[slot];
      return info._data;
    }
    /**
         * tells you info about an output connection (which node, type, etc)
         * @method getOutputInfo
         * @param {number} slot
         * @return {Object}  object or null { name: string, type: string, links: [ ids of links in number ] }
         */
    getOutputInfo(slot) {
      if (!this.outputs) {
        return null;
      }
      if (slot < this.outputs.length) {
        return this.outputs[slot];
      }
      return null;
    }
    /**
         * tells you if there is a connection in one output slot
         * @method isOutputConnected
         * @param {number} slot
         * @return {boolean}
         */
    isOutputConnected(slot) {
      if (!this.outputs) {
        return false;
      }
      return slot < this.outputs.length && this.outputs[slot].links && this.outputs[slot].links.length;
    }
    /**
         * tells you if there is any connection in the output slots
         * @method isAnyOutputConnected
         * @return {boolean}
         */
    isAnyOutputConnected() {
      if (!this.outputs) {
        return false;
      }
      for (var i2 = 0; i2 < this.outputs.length; ++i2) {
        if (this.outputs[i2].links && this.outputs[i2].links.length) {
          return true;
        }
      }
      return false;
    }
    /**
         * retrieves all the nodes connected to this output slot
         * @method getOutputNodes
         * @param {number} slot
         * @return {array}
         */
    getOutputNodes(slot) {
      if (!this.outputs || this.outputs.length == 0) {
        return null;
      }
      if (slot >= this.outputs.length) {
        return null;
      }
      var output = this.outputs[slot];
      if (!output.links || output.links.length == 0) {
        return null;
      }
      var r = [];
      for (var i2 = 0; i2 < output.links.length; i2++) {
        var link_id = output.links[i2];
        var link = this.graph.links[link_id];
        if (link) {
          var target_node = this.graph.getNodeById(link.target_id);
          if (target_node) {
            r.push(target_node);
          }
        }
      }
      return r;
    }
    addOnTriggerInput() {
      var trigS = this.findInputSlot("onTrigger");
      if (trigS == -1) {
        //!trigS || 
        this.addInput("onTrigger", LiteGraph.EVENT, { optional: true, nameLocked: true });
        return this.findInputSlot("onTrigger");
      }
      return trigS;
    }
    addOnExecutedOutput() {
      var trigS = this.findOutputSlot("onExecuted");
      if (trigS == -1) {
        //!trigS || 
        this.addOutput("onExecuted", LiteGraph.ACTION, { optional: true, nameLocked: true });
        return this.findOutputSlot("onExecuted");
      }
      return trigS;
    }
    onAfterExecuteNode(param, options3) {
      var trigS = this.findOutputSlot("onExecuted");
      if (trigS != -1) {
        this.triggerSlot(trigS, param, null, options3);
      }
    }
    changeMode(modeTo) {
      switch (modeTo) {
        case LiteGraph.ON_EVENT:
          break;
        case LiteGraph.ON_TRIGGER:
          this.addOnTriggerInput();
          this.addOnExecutedOutput();
          break;
        case LiteGraph.NEVER:
          break;
        case LiteGraph.ALWAYS:
          break;
        case LiteGraph.ON_REQUEST:
          break;
        default:
          return false;
      }
      this.mode = modeTo;
      return true;
    }
    /**
         * Triggers the node code execution, place a boolean/counter to mark the node as being executed
         * @method execute
         * @param {*} param
         * @param {*} options
         */
    doExecute(param, options3) {
      options3 = options3 || {};
      if (this.onExecute) {
        if (!options3.action_call) options3.action_call = this.id + "_exec_" + Math.floor(Math.random() * 9999);
        this.graph.nodes_executing[this.id] = true;
        this.onExecute(param, options3);
        this.graph.nodes_executing[this.id] = false;
        this.exec_version = this.graph.iteration;
        if (options3 && options3.action_call) {
          this.action_call = options3.action_call;
          this.graph.nodes_executedAction[this.id] = options3.action_call;
        }
      }
      this.execute_triggered = 2;
      if (this.onAfterExecuteNode) this.onAfterExecuteNode(param, options3);
    }
    /**
         * Triggers an action, wrapped by logics to control execution flow
         * @method actionDo
         * @param {String} action name
         * @param {*} param
         */
    actionDo(action, param, options3) {
      options3 = options3 || {};
      if (this.onAction) {
        if (!options3.action_call) options3.action_call = this.id + "_" + (action ? action : "action") + "_" + Math.floor(Math.random() * 9999);
        this.graph.nodes_actioning[this.id] = action ? action : "actioning";
        this.onAction(action, param, options3);
        this.graph.nodes_actioning[this.id] = false;
        if (options3 && options3.action_call) {
          this.action_call = options3.action_call;
          this.graph.nodes_executedAction[this.id] = options3.action_call;
        }
      }
      this.action_triggered = 2;
      if (this.onAfterExecuteNode) this.onAfterExecuteNode(param, options3);
    }
    /**
         * Triggers an event in this node, this will trigger any output with the same name
         * @method trigger
         * @param {String} event name ( "on_play", ... ) if action is equivalent to false then the event is send to all
         * @param {*} param
         */
    trigger(action, param, options3) {
      if (!this.outputs || !this.outputs.length) {
        return;
      }
      if (this.graph)
        this.graph._last_trigger_time = LiteGraph.getTime();
      for (var i2 = 0; i2 < this.outputs.length; ++i2) {
        var output = this.outputs[i2];
        if (!output || output.type !== LiteGraph.EVENT || action && output.name != action)
          continue;
        this.triggerSlot(i2, param, null, options3);
      }
    }
    /**
         * Triggers a slot event in this node: cycle output slots and launch execute/action on connected nodes
         * @method triggerSlot
         * @param {Number} slot the index of the output slot
         * @param {*} param
         * @param {Number} link_id [optional] in case you want to trigger and specific output link in a slot
         */
    triggerSlot(slot, param, link_id, options3) {
      options3 = options3 || {};
      if (!this.outputs) {
        return;
      }
      if (slot == null) {
        console.error("slot must be a number");
        return;
      }
      if (slot.constructor !== Number)
        console.warn("slot must be a number, use node.trigger('name') if you want to use a string");
      var output = this.outputs[slot];
      if (!output) {
        return;
      }
      var links = output.links;
      if (!links || !links.length) {
        return;
      }
      if (this.graph) {
        this.graph._last_trigger_time = LiteGraph.getTime();
      }
      for (var k = 0; k < links.length; ++k) {
        var id2 = links[k];
        if (link_id != null && link_id != id2) {
          continue;
        }
        var link_info = this.graph.links[links[k]];
        if (!link_info) {
          continue;
        }
        link_info._last_time = LiteGraph.getTime();
        var node22 = this.graph.getNodeById(link_info.target_id);
        if (!node22) {
          continue;
        }
        var target_connection = node22.inputs[link_info.target_slot];
        if (node22.mode === LiteGraph.ON_TRIGGER) {
          if (!options3.action_call) options3.action_call = this.id + "_trigg_" + Math.floor(Math.random() * 9999);
          if (node22.onExecute) {
            node22.doExecute(param, options3);
          }
        } else if (node22.onAction) {
          if (!options3.action_call) options3.action_call = this.id + "_act_" + Math.floor(Math.random() * 9999);
          var target_connection = node22.inputs[link_info.target_slot];
          node22.actionDo(target_connection.name, param, options3);
        }
      }
    }
    /**
         * clears the trigger slot animation
         * @method clearTriggeredSlot
         * @param {Number} slot the index of the output slot
         * @param {Number} link_id [optional] in case you want to trigger and specific output link in a slot
         */
    clearTriggeredSlot(slot, link_id) {
      if (!this.outputs) {
        return;
      }
      var output = this.outputs[slot];
      if (!output) {
        return;
      }
      var links = output.links;
      if (!links || !links.length) {
        return;
      }
      for (var k = 0; k < links.length; ++k) {
        var id2 = links[k];
        if (link_id != null && link_id != id2) {
          continue;
        }
        var link_info = this.graph.links[links[k]];
        if (!link_info) {
          continue;
        }
        link_info._last_time = 0;
      }
    }
    /**
         * changes node size and triggers callback
         * @method setSize
         * @param {vec2} size
         */
    setSize(size2) {
      this.size = size2;
      if (this.onResize)
        this.onResize(this.size);
    }
    /**
         * add a new property to this node
         * @method addProperty
         * @param {string} name
         * @param {*} default_value
         * @param {string} type string defining the output type ("vec3","number",...)
         * @param {Object} extra_info this can be used to have special properties of the property (like values, etc)
         */
    addProperty(name, default_value, type, extra_info) {
      var o = { name, type, default_value };
      if (extra_info) {
        for (var i2 in extra_info) {
          o[i2] = extra_info[i2];
        }
      }
      if (!this.properties_info) {
        this.properties_info = [];
      }
      this.properties_info.push(o);
      if (!this.properties) {
        this.properties = {};
      }
      this.properties[name] = default_value;
      return o;
    }
    //connections
    /**
         * add a new output slot to use in this node
         * @method addOutput
         * @param {string} name
         * @param {string} type string defining the output type ("vec3","number",...)
         * @param {Object} extra_info this can be used to have special properties of an output (label, special color, position, etc)
         */
    addOutput(name, type, extra_info) {
      var output = { name, type, links: null };
      if (extra_info) {
        for (var i2 in extra_info) {
          output[i2] = extra_info[i2];
        }
      }
      if (!this.outputs) {
        this.outputs = [];
      }
      this.outputs.push(output);
      if (this.onOutputAdded) {
        this.onOutputAdded(output);
      }
      if (LiteGraph.auto_load_slot_types) LiteGraph.registerNodeAndSlotType(this, type, true);
      this.setSize(this.computeSize());
      this.setDirtyCanvas(true, true);
      return output;
    }
    /**
         * add a new output slot to use in this node
         * @method addOutputs
         * @param {Array} array of triplets like [[name,type,extra_info],[...]]
         */
    addOutputs(array) {
      for (var i2 = 0; i2 < array.length; ++i2) {
        var info = array[i2];
        var o = { name: info[0], type: info[1], link: null };
        if (array[2]) {
          for (var j in info[2]) {
            o[j] = info[2][j];
          }
        }
        if (!this.outputs) {
          this.outputs = [];
        }
        this.outputs.push(o);
        if (this.onOutputAdded) {
          this.onOutputAdded(o);
        }
        if (LiteGraph.auto_load_slot_types) LiteGraph.registerNodeAndSlotType(this, info[1], true);
      }
      this.setSize(this.computeSize());
      this.setDirtyCanvas(true, true);
    }
    /**
         * remove an existing output slot
         * @method removeOutput
         * @param {number} slot
         */
    removeOutput(slot) {
      this.disconnectOutput(slot);
      this.outputs.splice(slot, 1);
      for (var i2 = slot; i2 < this.outputs.length; ++i2) {
        if (!this.outputs[i2] || !this.outputs[i2].links) {
          continue;
        }
        var links = this.outputs[i2].links;
        for (var j = 0; j < links.length; ++j) {
          var link = this.graph.links[links[j]];
          if (!link) {
            continue;
          }
          link.origin_slot -= 1;
        }
      }
      this.setSize(this.computeSize());
      if (this.onOutputRemoved) {
        this.onOutputRemoved(slot);
      }
      this.setDirtyCanvas(true, true);
    }
    /**
         * add a new input slot to use in this node
         * @method addInput
         * @param {string} name
         * @param {string} type string defining the input type ("vec3","number",...), it its a generic one use 0
         * @param {Object} extra_info this can be used to have special properties of an input (label, color, position, etc)
         */
    addInput(name, type, extra_info) {
      type = type || 0;
      var input = { name, type, link: null };
      if (extra_info) {
        for (var i2 in extra_info) {
          input[i2] = extra_info[i2];
        }
      }
      if (!this.inputs) {
        this.inputs = [];
      }
      this.inputs.push(input);
      this.setSize(this.computeSize());
      if (this.onInputAdded) {
        this.onInputAdded(input);
      }
      LiteGraph.registerNodeAndSlotType(this, type);
      this.setDirtyCanvas(true, true);
      return input;
    }
    /**
         * add several new input slots in this node
         * @method addInputs
         * @param {Array} array of triplets like [[name,type,extra_info],[...]]
         */
    addInputs(array) {
      for (var i2 = 0; i2 < array.length; ++i2) {
        var info = array[i2];
        var o = { name: info[0], type: info[1], link: null };
        if (array[2]) {
          for (var j in info[2]) {
            o[j] = info[2][j];
          }
        }
        if (!this.inputs) {
          this.inputs = [];
        }
        this.inputs.push(o);
        if (this.onInputAdded) {
          this.onInputAdded(o);
        }
        LiteGraph.registerNodeAndSlotType(this, info[1]);
      }
      this.setSize(this.computeSize());
      this.setDirtyCanvas(true, true);
    }
    /**
         * remove an existing input slot
         * @method removeInput
         * @param {number} slot
         */
    removeInput(slot) {
      this.disconnectInput(slot);
      var slot_info = this.inputs.splice(slot, 1);
      for (var i2 = slot; i2 < this.inputs.length; ++i2) {
        if (!this.inputs[i2]) {
          continue;
        }
        var link = this.graph.links[this.inputs[i2].link];
        if (!link) {
          continue;
        }
        link.target_slot -= 1;
      }
      this.setSize(this.computeSize());
      if (this.onInputRemoved) {
        this.onInputRemoved(slot, slot_info[0]);
      }
      this.setDirtyCanvas(true, true);
    }
    /**
         * add an special connection to this node (used for special kinds of graphs)
         * @method addConnection
         * @param {string} name
         * @param {string} type string defining the input type ("vec3","number",...)
         * @param {[x,y]} pos position of the connection inside the node
         * @param {string} direction if is input or output
         */
    addConnection(name, type, pos2, direction) {
      var o = {
        name,
        type,
        pos: pos2,
        direction,
        links: null
      };
      this.connections.push(o);
      return o;
    }
    /**
         * computes the minimum size of a node according to its inputs and output slots
         * @method computeSize
         * @param {vec2} minHeight
         * @return {vec2} the total size
         */
    computeSize(out) {
      if (this.constructor.size) {
        return this.constructor.size.concat();
      }
      var rows = Math.max(
        this.inputs ? this.inputs.length : 1,
        this.outputs ? this.outputs.length : 1
      );
      var size2 = out || new Float32Array([0, 0]);
      rows = Math.max(rows, 1);
      var font_size = LiteGraph.NODE_TEXT_SIZE;
      var title_width = compute_text_size(this.title);
      var input_width = 0;
      var output_width = 0;
      if (this.inputs) {
        for (var i2 = 0, l = this.inputs.length; i2 < l; ++i2) {
          var input = this.inputs[i2];
          var text = input.label || input.name || "";
          var text_width = compute_text_size(text);
          if (input_width < text_width) {
            input_width = text_width;
          }
        }
      }
      if (this.outputs) {
        for (var i2 = 0, l = this.outputs.length; i2 < l; ++i2) {
          var output = this.outputs[i2];
          var text = output.label || output.name || "";
          var text_width = compute_text_size(text);
          if (output_width < text_width) {
            output_width = text_width;
          }
        }
      }
      size2[0] = Math.max(input_width + output_width + 10, title_width);
      size2[0] = Math.max(size2[0], LiteGraph.NODE_WIDTH);
      if (this.widgets && this.widgets.length) {
        size2[0] = Math.max(size2[0], LiteGraph.NODE_WIDTH * 1.5);
      }
      size2[1] = (this.constructor.slot_start_y || 0) + rows * LiteGraph.NODE_SLOT_HEIGHT;
      var widgets_height = 0;
      if (this.widgets && this.widgets.length) {
        for (var i2 = 0, l = this.widgets.length; i2 < l; ++i2) {
          if (this.widgets[i2].computeSize)
            widgets_height += this.widgets[i2].computeSize(size2[0])[1] + 4;
          else
            widgets_height += LiteGraph.NODE_WIDGET_HEIGHT + 4;
        }
        widgets_height += 8;
      }
      if (this.widgets_up)
        size2[1] = Math.max(size2[1], widgets_height);
      else if (this.widgets_start_y != null)
        size2[1] = Math.max(size2[1], widgets_height + this.widgets_start_y);
      else
        size2[1] += widgets_height;
      function compute_text_size(text2) {
        if (!text2) {
          return 0;
        }
        return font_size * text2.length * 0.6;
      }
      __name(compute_text_size, "compute_text_size");
      if (this.constructor.min_height && size2[1] < this.constructor.min_height) {
        size2[1] = this.constructor.min_height;
      }
      size2[1] += 6;
      return size2;
    }
    inResizeCorner(canvasX, canvasY) {
      var rows = this.outputs ? this.outputs.length : 1;
      var outputs_offset = (this.constructor.slot_start_y || 0) + rows * LiteGraph.NODE_SLOT_HEIGHT;
      return isInsideRectangle(
        canvasX,
        canvasY,
        this.pos[0] + this.size[0] - 15,
        this.pos[1] + Math.max(this.size[1] - 15, outputs_offset),
        20,
        20
      );
    }
    /**
         * returns all the info available about a property of this node.
         *
         * @method getPropertyInfo
         * @param {String} property name of the property
         * @return {Object} the object with all the available info
        */
    getPropertyInfo(property) {
      var info = null;
      if (this.properties_info) {
        for (var i2 = 0; i2 < this.properties_info.length; ++i2) {
          if (this.properties_info[i2].name == property) {
            info = this.properties_info[i2];
            break;
          }
        }
      }
      if (this.constructor["@" + property])
        info = this.constructor["@" + property];
      if (this.constructor.widgets_info && this.constructor.widgets_info[property])
        info = this.constructor.widgets_info[property];
      if (!info && this.onGetPropertyInfo) {
        info = this.onGetPropertyInfo(property);
      }
      if (!info)
        info = {};
      if (!info.type)
        info.type = typeof this.properties[property];
      if (info.widget == "combo")
        info.type = "enum";
      return info;
    }
    /**
         * Defines a widget inside the node, it will be rendered on top of the node, you can control lots of properties
         *
         * @method addWidget
         * @param {String} type the widget type (could be "number","string","combo"
         * @param {String} name the text to show on the widget
         * @param {String} value the default value
         * @param {Function|String} callback function to call when it changes (optionally, it can be the name of the property to modify)
         * @param {Object} options the object that contains special properties of this widget
         * @return {Object} the created widget object
         */
    addWidget(type, name, value3, callback, options3) {
      if (!this.widgets) {
        this.widgets = [];
      }
      if (!options3 && callback && callback.constructor === Object) {
        options3 = callback;
        callback = null;
      }
      if (options3 && options3.constructor === String)
        options3 = { property: options3 };
      if (callback && callback.constructor === String) {
        if (!options3)
          options3 = {};
        options3.property = callback;
        callback = null;
      }
      if (callback && callback.constructor !== Function) {
        console.warn("addWidget: callback must be a function");
        callback = null;
      }
      var w2 = {
        type: type.toLowerCase(),
        name,
        value: value3,
        callback,
        options: options3 || {}
      };
      if (w2.options.y !== void 0) {
        w2.y = w2.options.y;
      }
      if (!callback && !w2.options.callback && !w2.options.property) {
        console.warn("LiteGraph addWidget(...) without a callback or property assigned");
      }
      if (type == "combo" && !w2.options.values) {
        throw "LiteGraph addWidget('combo',...) requires to pass values in options: { values:['red','blue'] }";
      }
      this.widgets.push(w2);
      this.setSize(this.computeSize());
      return w2;
    }
    addCustomWidget(custom_widget) {
      if (!this.widgets) {
        this.widgets = [];
      }
      this.widgets.push(custom_widget);
      return custom_widget;
    }
    /**
         * returns the bounding of the object, used for rendering purposes
         * @method getBounding
         * @param out {Float32Array[4]?} [optional] a place to store the output, to free garbage
         * @param compute_outer {boolean?} [optional] set to true to include the shadow and connection points in the bounding calculation
         * @return {Float32Array[4]} the bounding box in format of [topleft_cornerx, topleft_cornery, width, height]
         */
    getBounding(out, compute_outer) {
      out = out || new Float32Array(4);
      const nodePos = this.pos;
      const isCollapsed = this.flags.collapsed;
      const nodeSize = this.size;
      let left_offset = 0;
      let right_offset = 1;
      let top_offset = 0;
      let bottom_offset = 0;
      if (compute_outer) {
        left_offset = 4;
        right_offset = 6 + left_offset;
        top_offset = 4;
        bottom_offset = 5 + top_offset;
      }
      out[0] = nodePos[0] - left_offset;
      out[1] = nodePos[1] - LiteGraph.NODE_TITLE_HEIGHT - top_offset;
      out[2] = isCollapsed ? (this._collapsed_width || LiteGraph.NODE_COLLAPSED_WIDTH) + right_offset : nodeSize[0] + right_offset;
      out[3] = isCollapsed ? LiteGraph.NODE_TITLE_HEIGHT + bottom_offset : nodeSize[1] + LiteGraph.NODE_TITLE_HEIGHT + bottom_offset;
      if (this.onBounding) {
        this.onBounding(out);
      }
      return out;
    }
    /**
         * checks if a point is inside the shape of a node
         * @method isPointInside
         * @param {number} x
         * @param {number} y
         * @return {boolean}
         */
    isPointInside(x2, y2, margin, skip_title) {
      margin = margin || 0;
      var margin_top = this.graph && this.graph.isLive() ? 0 : LiteGraph.NODE_TITLE_HEIGHT;
      if (skip_title) {
        margin_top = 0;
      }
      if (this.flags && this.flags.collapsed) {
        if (isInsideRectangle(
          x2,
          y2,
          this.pos[0] - margin,
          this.pos[1] - LiteGraph.NODE_TITLE_HEIGHT - margin,
          (this._collapsed_width || LiteGraph.NODE_COLLAPSED_WIDTH) + 2 * margin,
          LiteGraph.NODE_TITLE_HEIGHT + 2 * margin
        )) {
          return true;
        }
      } else if (this.pos[0] - 4 - margin < x2 && this.pos[0] + this.size[0] + 4 + margin > x2 && this.pos[1] - margin_top - margin < y2 && this.pos[1] + this.size[1] + margin > y2) {
        return true;
      }
      return false;
    }
    /**
         * checks if a point is inside a node slot, and returns info about which slot
         * @method getSlotInPosition
         * @param {number} x
         * @param {number} y
         * @return {Object} if found the object contains { input|output: slot object, slot: number, link_pos: [x,y] }
         */
    getSlotInPosition(x2, y2) {
      var link_pos = new Float32Array(2);
      if (this.inputs) {
        for (var i2 = 0, l = this.inputs.length; i2 < l; ++i2) {
          var input = this.inputs[i2];
          this.getConnectionPos(true, i2, link_pos);
          if (isInsideRectangle(
            x2,
            y2,
            link_pos[0] - 10,
            link_pos[1] - 5,
            20,
            10
          )) {
            return { input, slot: i2, link_pos };
          }
        }
      }
      if (this.outputs) {
        for (var i2 = 0, l = this.outputs.length; i2 < l; ++i2) {
          var output = this.outputs[i2];
          this.getConnectionPos(false, i2, link_pos);
          if (isInsideRectangle(
            x2,
            y2,
            link_pos[0] - 10,
            link_pos[1] - 5,
            20,
            10
          )) {
            return { output, slot: i2, link_pos };
          }
        }
      }
      return null;
    }
    /**
         * returns the input slot with a given name (used for dynamic slots), -1 if not found
         * @method findInputSlot
         * @param {string} name the name of the slot
         * @param {boolean} returnObj if the obj itself wanted
         * @return {number_or_object} the slot (-1 if not found)
         */
    findInputSlot(name, returnObj) {
      if (!this.inputs) {
        return -1;
      }
      for (var i2 = 0, l = this.inputs.length; i2 < l; ++i2) {
        if (name == this.inputs[i2].name) {
          return !returnObj ? i2 : this.inputs[i2];
        }
      }
      return -1;
    }
    /**
         * returns the output slot with a given name (used for dynamic slots), -1 if not found
         * @method findOutputSlot
         * @param {string} name the name of the slot
         * @param {boolean} returnObj if the obj itself wanted
         * @return {number_or_object} the slot (-1 if not found)
         */
    findOutputSlot(name, returnObj) {
      returnObj = returnObj || false;
      if (!this.outputs) {
        return -1;
      }
      for (var i2 = 0, l = this.outputs.length; i2 < l; ++i2) {
        if (name == this.outputs[i2].name) {
          return !returnObj ? i2 : this.outputs[i2];
        }
      }
      return -1;
    }
    // TODO refactor: USE SINGLE findInput/findOutput functions! :: merge options
    /**
         * returns the first free input slot
         * @method findInputSlotFree
         * @param {object} options
         * @return {number_or_object} the slot (-1 if not found)
         */
    findInputSlotFree(optsIn) {
      var optsIn = optsIn || {};
      var optsDef = {
        returnObj: false,
        typesNotAccepted: []
      };
      var opts = Object.assign(optsDef, optsIn);
      if (!this.inputs) {
        return -1;
      }
      for (var i2 = 0, l = this.inputs.length; i2 < l; ++i2) {
        if (this.inputs[i2].link && this.inputs[i2].link != null) {
          continue;
        }
        if (opts.typesNotAccepted && opts.typesNotAccepted.includes && opts.typesNotAccepted.includes(this.inputs[i2].type)) {
          continue;
        }
        return !opts.returnObj ? i2 : this.inputs[i2];
      }
      return -1;
    }
    /**
         * returns the first output slot free
         * @method findOutputSlotFree
         * @param {object} options
         * @return {number_or_object} the slot (-1 if not found)
         */
    findOutputSlotFree(optsIn) {
      var optsIn = optsIn || {};
      var optsDef = {
        returnObj: false,
        typesNotAccepted: []
      };
      var opts = Object.assign(optsDef, optsIn);
      if (!this.outputs) {
        return -1;
      }
      for (var i2 = 0, l = this.outputs.length; i2 < l; ++i2) {
        if (this.outputs[i2].links && this.outputs[i2].links != null) {
          continue;
        }
        if (opts.typesNotAccepted && opts.typesNotAccepted.includes && opts.typesNotAccepted.includes(this.outputs[i2].type)) {
          continue;
        }
        return !opts.returnObj ? i2 : this.outputs[i2];
      }
      return -1;
    }
    /**
         * findSlotByType for INPUTS
         */
    findInputSlotByType(type, returnObj, preferFreeSlot, doNotUseOccupied) {
      return this.findSlotByType(true, type, returnObj, preferFreeSlot, doNotUseOccupied);
    }
    /**
         * findSlotByType for OUTPUTS
         */
    findOutputSlotByType(type, returnObj, preferFreeSlot, doNotUseOccupied) {
      return this.findSlotByType(false, type, returnObj, preferFreeSlot, doNotUseOccupied);
    }
    /**
         * returns the output (or input) slot with a given type, -1 if not found
         * @method findSlotByType
         * @param {boolean} input uise inputs instead of outputs
         * @param {string} type the type of the slot
         * @param {boolean} returnObj if the obj itself wanted
         * @param {boolean} preferFreeSlot if we want a free slot (if not found, will return the first of the type anyway)
         * @return {number_or_object} the slot (-1 if not found)
         */
    findSlotByType(input, type, returnObj, preferFreeSlot, doNotUseOccupied) {
      input = input || false;
      returnObj = returnObj || false;
      preferFreeSlot = preferFreeSlot || false;
      doNotUseOccupied = doNotUseOccupied || false;
      var aSlots = input ? this.inputs : this.outputs;
      if (!aSlots) {
        return -1;
      }
      if (type == "" || type == "*") type = 0;
      for (var i2 = 0, l = aSlots.length; i2 < l; ++i2) {
        var aSource = (type + "").toLowerCase().split(",");
        var aDest = aSlots[i2].type == "0" || aSlots[i2].type == "*" ? "0" : aSlots[i2].type;
        aDest = (aDest + "").toLowerCase().split(",");
        for (var sI = 0; sI < aSource.length; sI++) {
          for (var dI = 0; dI < aDest.length; dI++) {
            if (aSource[sI] == "_event_") aSource[sI] = LiteGraph.EVENT;
            if (aDest[sI] == "_event_") aDest[sI] = LiteGraph.EVENT;
            if (aSource[sI] == "*") aSource[sI] = 0;
            if (aDest[sI] == "*") aDest[sI] = 0;
            if (aSource[sI] == aDest[dI]) {
              if (preferFreeSlot && (aSlots[i2].links && aSlots[i2].links !== null) || aSlots[i2].link && aSlots[i2].link !== null) continue;
              return !returnObj ? i2 : aSlots[i2];
            }
          }
        }
      }
      if (preferFreeSlot && !doNotUseOccupied) {
        for (var i2 = 0, l = aSlots.length; i2 < l; ++i2) {
          var aSource = (type + "").toLowerCase().split(",");
          var aDest = aSlots[i2].type == "0" || aSlots[i2].type == "*" ? "0" : aSlots[i2].type;
          aDest = (aDest + "").toLowerCase().split(",");
          for (var sI = 0; sI < aSource.length; sI++) {
            for (var dI = 0; dI < aDest.length; dI++) {
              if (aSource[sI] == "*") aSource[sI] = 0;
              if (aDest[sI] == "*") aDest[sI] = 0;
              if (aSource[sI] == aDest[dI]) {
                return !returnObj ? i2 : aSlots[i2];
              }
            }
          }
        }
      }
      return -1;
    }
    /**
         * connect this node output to the input of another node BY TYPE
         * @method connectByType
         * @param {number_or_string} slot (could be the number of the slot or the string with the name of the slot)
         * @param {LGraphNode} node the target node
         * @param {string} target_type the input slot type of the target node
         * @return {Object} the link_info is created, otherwise null
         */
    connectByType(slot, target_node, target_slotType, optsIn) {
      var optsIn = optsIn || {};
      var optsDef = {
        createEventInCase: true,
        firstFreeIfOutputGeneralInCase: true,
        generalTypeInCase: true
      };
      var opts = Object.assign(optsDef, optsIn);
      if (target_node && target_node.constructor === Number) {
        target_node = this.graph.getNodeById(target_node);
      }
      var target_slot = target_node.findInputSlotByType(target_slotType, false, true);
      if (target_slot >= 0 && target_slot !== null) {
        return this.connect(slot, target_node, target_slot);
      } else {
        if (opts.createEventInCase && target_slotType == LiteGraph.EVENT) {
          return this.connect(slot, target_node, -1);
        }
        if (opts.generalTypeInCase) {
          var target_slot = target_node.findInputSlotByType(0, false, true, true);
          if (target_slot >= 0) {
            return this.connect(slot, target_node, target_slot);
          }
        }
        if (opts.firstFreeIfOutputGeneralInCase && (target_slotType == 0 || target_slotType == "*" || target_slotType == "")) {
          var target_slot = target_node.findInputSlotFree({ typesNotAccepted: [LiteGraph.EVENT] });
          if (target_slot >= 0) {
            return this.connect(slot, target_node, target_slot);
          }
        }
        console.debug("no way to connect type: ", target_slotType, " to targetNODE ", target_node);
        return null;
      }
    }
    /**
         * connect this node input to the output of another node BY TYPE
         * @method connectByType
         * @param {number_or_string} slot (could be the number of the slot or the string with the name of the slot)
         * @param {LGraphNode} node the target node
         * @param {string} target_type the output slot type of the target node
         * @return {Object} the link_info is created, otherwise null
         */
    connectByTypeOutput(slot, source_node, source_slotType, optsIn) {
      var optsIn = optsIn || {};
      var optsDef = {
        createEventInCase: true,
        firstFreeIfInputGeneralInCase: true,
        generalTypeInCase: true
      };
      var opts = Object.assign(optsDef, optsIn);
      if (source_node && source_node.constructor === Number) {
        source_node = this.graph.getNodeById(source_node);
      }
      var source_slot = source_node.findOutputSlotByType(source_slotType, false, true);
      if (source_slot >= 0 && source_slot !== null) {
        return source_node.connect(source_slot, this, slot);
      } else {
        if (opts.generalTypeInCase) {
          var source_slot = source_node.findOutputSlotByType(0, false, true, true);
          if (source_slot >= 0) {
            return source_node.connect(source_slot, this, slot);
          }
        }
        if (opts.createEventInCase && source_slotType == LiteGraph.EVENT) {
          if (LiteGraph.do_add_triggers_slots) {
            var source_slot = source_node.addOnExecutedOutput();
            return source_node.connect(source_slot, this, slot);
          }
        }
        if (opts.firstFreeIfInputGeneralInCase && (source_slotType == 0 || source_slotType == "*" || source_slotType == "")) {
          var source_slot = source_node.findOutputSlotFree({ typesNotAccepted: [LiteGraph.EVENT] });
          if (source_slot >= 0) {
            return source_node.connect(source_slot, this, slot);
          }
        }
        console.debug("no way to connect byOUT type: ", source_slotType, " to sourceNODE ", source_node);
        return null;
      }
    }
    /**
         * connect this node output to the input of another node
         * @method connect
         * @param {number_or_string} slot (could be the number of the slot or the string with the name of the slot)
         * @param {LGraphNode} node the target node
         * @param {number_or_string} target_slot the input slot of the target node (could be the number of the slot or the string with the name of the slot, or -1 to connect a trigger)
         * @return {Object} the link_info is created, otherwise null
         */
    connect(slot, target_node, target_slot) {
      target_slot = target_slot || 0;
      if (!this.graph) {
        console.log(
          "Connect: Error, node doesn't belong to any graph. Nodes must be added first to a graph before connecting them."
        );
        return null;
      }
      if (slot.constructor === String) {
        slot = this.findOutputSlot(slot);
        if (slot == -1) {
          if (LiteGraph.debug) {
            console.log("Connect: Error, no slot of name " + slot);
          }
          return null;
        }
      } else if (!this.outputs || slot >= this.outputs.length) {
        if (LiteGraph.debug) {
          console.log("Connect: Error, slot number not found");
        }
        return null;
      }
      if (target_node && target_node.constructor === Number) {
        target_node = this.graph.getNodeById(target_node);
      }
      if (!target_node) {
        throw "target node is null";
      }
      if (target_node == this) {
        return null;
      }
      if (target_slot.constructor === String) {
        target_slot = target_node.findInputSlot(target_slot);
        if (target_slot == -1) {
          if (LiteGraph.debug) {
            console.log(
              "Connect: Error, no slot of name " + target_slot
            );
          }
          return null;
        }
      } else if (target_slot === LiteGraph.EVENT) {
        if (LiteGraph.do_add_triggers_slots) {
          target_node.changeMode(LiteGraph.ON_TRIGGER);
          target_slot = target_node.findInputSlot("onTrigger");
        } else {
          return null;
        }
      } else if (!target_node.inputs || target_slot >= target_node.inputs.length) {
        if (LiteGraph.debug) {
          console.log("Connect: Error, slot number not found");
        }
        return null;
      }
      var changed = false;
      var input = target_node.inputs[target_slot];
      var link_info = null;
      var output = this.outputs[slot];
      if (!this.outputs[slot]) {
        return null;
      }
      if (target_node.onBeforeConnectInput) {
        target_slot = target_node.onBeforeConnectInput(target_slot);
      }
      if (target_slot === false || target_slot === null || !LiteGraph.isValidConnection(output.type, input.type)) {
        this.setDirtyCanvas(false, true);
        if (changed)
          this.graph.connectionChange(this, link_info);
        return null;
      }
      if (target_node.onConnectInput) {
        if (target_node.onConnectInput(target_slot, output.type, output, this, slot) === false) {
          return null;
        }
      }
      if (this.onConnectOutput) {
        if (this.onConnectOutput(slot, input.type, input, target_node, target_slot) === false) {
          return null;
        }
      }
      if (target_node.inputs[target_slot] && target_node.inputs[target_slot].link != null) {
        this.graph.beforeChange();
        target_node.disconnectInput(target_slot, { doProcessChange: false });
        changed = true;
      }
      if (output.links !== null && output.links.length) {
        switch (output.type) {
          case LiteGraph.EVENT:
            if (!LiteGraph.allow_multi_output_for_events) {
              this.graph.beforeChange();
              this.disconnectOutput(slot, false, { doProcessChange: false });
              changed = true;
            }
            break;
        }
      }
      var nextId;
      if (LiteGraph.use_uuids)
        nextId = LiteGraph.uuidv4();
      else
        nextId = ++this.graph.last_link_id;
      link_info = new LLink(
        nextId,
        input.type || output.type,
        this.id,
        slot,
        target_node.id,
        target_slot
      );
      this.graph.links[link_info.id] = link_info;
      if (output.links == null) {
        output.links = [];
      }
      output.links.push(link_info.id);
      target_node.inputs[target_slot].link = link_info.id;
      if (this.graph) {
        this.graph._version++;
      }
      if (this.onConnectionsChange) {
        this.onConnectionsChange(
          LiteGraph.OUTPUT,
          slot,
          true,
          link_info,
          output
        );
      }
      if (target_node.onConnectionsChange) {
        target_node.onConnectionsChange(
          LiteGraph.INPUT,
          target_slot,
          true,
          link_info,
          input
        );
      }
      if (this.graph && this.graph.onNodeConnectionChange) {
        this.graph.onNodeConnectionChange(
          LiteGraph.INPUT,
          target_node,
          target_slot,
          this,
          slot
        );
        this.graph.onNodeConnectionChange(
          LiteGraph.OUTPUT,
          this,
          slot,
          target_node,
          target_slot
        );
      }
      this.setDirtyCanvas(false, true);
      this.graph.afterChange();
      this.graph.connectionChange(this, link_info);
      return link_info;
    }
    /**
         * disconnect one output to an specific node
         * @method disconnectOutput
         * @param {number_or_string} slot (could be the number of the slot or the string with the name of the slot)
         * @param {LGraphNode} target_node the target node to which this slot is connected [Optional, if not target_node is specified all nodes will be disconnected]
         * @return {boolean} if it was disconnected successfully
         */
    disconnectOutput(slot, target_node) {
      if (slot.constructor === String) {
        slot = this.findOutputSlot(slot);
        if (slot == -1) {
          if (LiteGraph.debug) {
            console.log("Connect: Error, no slot of name " + slot);
          }
          return false;
        }
      } else if (!this.outputs || slot >= this.outputs.length) {
        if (LiteGraph.debug) {
          console.log("Connect: Error, slot number not found");
        }
        return false;
      }
      var output = this.outputs[slot];
      if (!output || !output.links || output.links.length == 0) {
        return false;
      }
      if (target_node) {
        if (target_node.constructor === Number) {
          target_node = this.graph.getNodeById(target_node);
        }
        if (!target_node) {
          throw "Target Node not found";
        }
        for (var i2 = 0, l = output.links.length; i2 < l; i2++) {
          var link_id = output.links[i2];
          var link_info = this.graph.links[link_id];
          if (link_info.target_id == target_node.id) {
            output.links.splice(i2, 1);
            var input = target_node.inputs[link_info.target_slot];
            input.link = null;
            delete this.graph.links[link_id];
            if (this.graph) {
              this.graph._version++;
            }
            if (target_node.onConnectionsChange) {
              target_node.onConnectionsChange(
                LiteGraph.INPUT,
                link_info.target_slot,
                false,
                link_info,
                input
              );
            }
            if (this.onConnectionsChange) {
              this.onConnectionsChange(
                LiteGraph.OUTPUT,
                slot,
                false,
                link_info,
                output
              );
            }
            if (this.graph && this.graph.onNodeConnectionChange) {
              this.graph.onNodeConnectionChange(
                LiteGraph.OUTPUT,
                this,
                slot
              );
            }
            if (this.graph && this.graph.onNodeConnectionChange) {
              this.graph.onNodeConnectionChange(
                LiteGraph.OUTPUT,
                this,
                slot
              );
              this.graph.onNodeConnectionChange(
                LiteGraph.INPUT,
                target_node,
                link_info.target_slot
              );
            }
            break;
          }
        }
      } else {
        for (var i2 = 0, l = output.links.length; i2 < l; i2++) {
          var link_id = output.links[i2];
          var link_info = this.graph.links[link_id];
          if (!link_info) {
            continue;
          }
          var target_node = this.graph.getNodeById(link_info.target_id);
          var input = null;
          if (this.graph) {
            this.graph._version++;
          }
          if (target_node) {
            input = target_node.inputs[link_info.target_slot];
            input.link = null;
            if (target_node.onConnectionsChange) {
              target_node.onConnectionsChange(
                LiteGraph.INPUT,
                link_info.target_slot,
                false,
                link_info,
                input
              );
            }
            if (this.graph && this.graph.onNodeConnectionChange) {
              this.graph.onNodeConnectionChange(
                LiteGraph.INPUT,
                target_node,
                link_info.target_slot
              );
            }
          }
          delete this.graph.links[link_id];
          if (this.onConnectionsChange) {
            this.onConnectionsChange(
              LiteGraph.OUTPUT,
              slot,
              false,
              link_info,
              output
            );
          }
          if (this.graph && this.graph.onNodeConnectionChange) {
            this.graph.onNodeConnectionChange(
              LiteGraph.OUTPUT,
              this,
              slot
            );
            this.graph.onNodeConnectionChange(
              LiteGraph.INPUT,
              target_node,
              link_info.target_slot
            );
          }
        }
        output.links = null;
      }
      this.setDirtyCanvas(false, true);
      this.graph.connectionChange(this);
      return true;
    }
    /**
         * disconnect one input
         * @method disconnectInput
         * @param {number_or_string} slot (could be the number of the slot or the string with the name of the slot)
         * @return {boolean} if it was disconnected successfully
         */
    disconnectInput(slot) {
      if (slot.constructor === String) {
        slot = this.findInputSlot(slot);
        if (slot == -1) {
          if (LiteGraph.debug) {
            console.log("Connect: Error, no slot of name " + slot);
          }
          return false;
        }
      } else if (!this.inputs || slot >= this.inputs.length) {
        if (LiteGraph.debug) {
          console.log("Connect: Error, slot number not found");
        }
        return false;
      }
      var input = this.inputs[slot];
      if (!input) {
        return false;
      }
      var link_id = this.inputs[slot].link;
      if (link_id != null) {
        this.inputs[slot].link = null;
        var link_info = this.graph.links[link_id];
        if (link_info) {
          var target_node = this.graph.getNodeById(link_info.origin_id);
          if (!target_node) {
            return false;
          }
          var output = target_node.outputs[link_info.origin_slot];
          if (!output || !output.links || output.links.length == 0) {
            return false;
          }
          for (var i2 = 0, l = output.links.length; i2 < l; i2++) {
            if (output.links[i2] == link_id) {
              output.links.splice(i2, 1);
              break;
            }
          }
          delete this.graph.links[link_id];
          if (this.graph) {
            this.graph._version++;
          }
          if (this.onConnectionsChange) {
            this.onConnectionsChange(
              LiteGraph.INPUT,
              slot,
              false,
              link_info,
              input
            );
          }
          if (target_node.onConnectionsChange) {
            target_node.onConnectionsChange(
              LiteGraph.OUTPUT,
              i2,
              false,
              link_info,
              output
            );
          }
          if (this.graph && this.graph.onNodeConnectionChange) {
            this.graph.onNodeConnectionChange(
              LiteGraph.OUTPUT,
              target_node,
              i2
            );
            this.graph.onNodeConnectionChange(LiteGraph.INPUT, this, slot);
          }
        }
      }
      this.setDirtyCanvas(false, true);
      if (this.graph)
        this.graph.connectionChange(this);
      return true;
    }
    /**
         * returns the center of a connection point in canvas coords
         * @method getConnectionPos
         * @param {boolean} is_input true if if a input slot, false if it is an output
         * @param {number_or_string} slot (could be the number of the slot or the string with the name of the slot)
         * @param {vec2} out [optional] a place to store the output, to free garbage
         * @return {[x,y]} the position
         **/
    getConnectionPos(is_input, slot_number, out) {
      out = out || new Float32Array(2);
      var num_slots = 0;
      if (is_input && this.inputs) {
        num_slots = this.inputs.length;
      }
      if (!is_input && this.outputs) {
        num_slots = this.outputs.length;
      }
      var offset = LiteGraph.NODE_SLOT_HEIGHT * 0.5;
      if (this.flags.collapsed) {
        var w2 = this._collapsed_width || LiteGraph.NODE_COLLAPSED_WIDTH;
        if (this.horizontal) {
          out[0] = this.pos[0] + w2 * 0.5;
          if (is_input) {
            out[1] = this.pos[1] - LiteGraph.NODE_TITLE_HEIGHT;
          } else {
            out[1] = this.pos[1];
          }
        } else {
          if (is_input) {
            out[0] = this.pos[0];
          } else {
            out[0] = this.pos[0] + w2;
          }
          out[1] = this.pos[1] - LiteGraph.NODE_TITLE_HEIGHT * 0.5;
        }
        return out;
      }
      if (is_input && slot_number == -1) {
        out[0] = this.pos[0] + LiteGraph.NODE_TITLE_HEIGHT * 0.5;
        out[1] = this.pos[1] + LiteGraph.NODE_TITLE_HEIGHT * 0.5;
        return out;
      }
      if (is_input && num_slots > slot_number && this.inputs[slot_number].pos) {
        out[0] = this.pos[0] + this.inputs[slot_number].pos[0];
        out[1] = this.pos[1] + this.inputs[slot_number].pos[1];
        return out;
      } else if (!is_input && num_slots > slot_number && this.outputs[slot_number].pos) {
        out[0] = this.pos[0] + this.outputs[slot_number].pos[0];
        out[1] = this.pos[1] + this.outputs[slot_number].pos[1];
        return out;
      }
      if (this.horizontal) {
        out[0] = this.pos[0] + (slot_number + 0.5) * (this.size[0] / num_slots);
        if (is_input) {
          out[1] = this.pos[1] - LiteGraph.NODE_TITLE_HEIGHT;
        } else {
          out[1] = this.pos[1] + this.size[1];
        }
        return out;
      }
      if (is_input) {
        out[0] = this.pos[0] + offset;
      } else {
        out[0] = this.pos[0] + this.size[0] + 1 - offset;
      }
      out[1] = this.pos[1] + (slot_number + 0.7) * LiteGraph.NODE_SLOT_HEIGHT + (this.constructor.slot_start_y || 0);
      return out;
    }
    /* Force align to grid */
    alignToGrid() {
      this.pos[0] = LiteGraph.CANVAS_GRID_SIZE * Math.round(this.pos[0] / LiteGraph.CANVAS_GRID_SIZE);
      this.pos[1] = LiteGraph.CANVAS_GRID_SIZE * Math.round(this.pos[1] / LiteGraph.CANVAS_GRID_SIZE);
    }
    /* Console output */
    trace(msg) {
      if (!this.console) {
        this.console = [];
      }
      this.console.push(msg);
      if (this.console.length > LGraphNode.MAX_CONSOLE) {
        this.console.shift();
      }
      if (this.graph.onNodeTrace)
        this.graph.onNodeTrace(this, msg);
    }
    /* Forces to redraw or the main canvas (LGraphNode) or the bg canvas (links) */
    setDirtyCanvas(dirty_foreground, dirty_background) {
      if (!this.graph) {
        return;
      }
      this.graph.sendActionToCanvas("setDirty", [
        dirty_foreground,
        dirty_background
      ]);
    }
    loadImage(url) {
      var img = new Image();
      img.src = LiteGraph.node_images_path + url;
      img.ready = false;
      var that2 = this;
      img.onload = function() {
        this.ready = true;
        that2.setDirtyCanvas(true);
      };
      return img;
    }
    //safe LGraphNode action execution (not sure if safe)
    /*
    LGraphNode.prototype.executeAction = function(action)
    {
        if(action == "") return false;
    
        if( action.indexOf(";") != -1 || action.indexOf("}") != -1)
        {
            this.trace("Error: Action contains unsafe characters");
            return false;
        }
    
        var tokens = action.split("(");
        var func_name = tokens[0];
        if( typeof(this[func_name]) != "function")
        {
            this.trace("Error: Action not found on node: " + func_name);
            return false;
        }
    
        var code = action;
    
        try
        {
            var _foo = eval;
            eval = null;
            (new Function("with(this) { " + code + "}")).call(this);
            eval = _foo;
        }
        catch (err)
        {
            this.trace("Error executing action {" + action + "} :" + err);
            return false;
        }
    
        return true;
    }
    */
    /* Allows to get onMouseMove and onMouseUp events even if the mouse is out of focus */
    captureInput(v2) {
      if (!this.graph || !this.graph.list_of_graphcanvas) {
        return;
      }
      var list = this.graph.list_of_graphcanvas;
      for (var i2 = 0; i2 < list.length; ++i2) {
        var c = list[i2];
        if (!v2 && c.node_capturing_input != this) {
          continue;
        }
        c.node_capturing_input = v2 ? this : null;
      }
    }
    get collapsed() {
      return !!this.flags.collapsed;
    }
    get collapsible() {
      return !this.pinned && this.constructor.collapsable !== false;
    }
    /**
         * Collapse the node to make it smaller on the canvas
         * @method collapse
         **/
    collapse(force) {
      this.graph._version++;
      if (!this.collapsible && !force) {
        return;
      }
      if (!this.flags.collapsed) {
        this.flags.collapsed = true;
      } else {
        this.flags.collapsed = false;
      }
      this.setDirtyCanvas(true, true);
    }
    get pinned() {
      return !!this.flags.pinned;
    }
    /**
         * Forces the node to do not move or realign on Z or resize
         * @method pin
         **/
    pin(v2) {
      this.graph._version++;
      if (v2 === void 0) {
        this.flags.pinned = !this.flags.pinned;
      } else {
        this.flags.pinned = v2;
      }
      this.resizable = !this.pinned;
      if (!this.pinned) {
        delete this.flags.pinned;
      }
    }
    localToScreen(x2, y2, graphcanvas) {
      return [
        (x2 + this.pos[0]) * graphcanvas.scale + graphcanvas.offset[0],
        (y2 + this.pos[1]) * graphcanvas.scale + graphcanvas.offset[1]
      ];
    }
  }
  globalThis.LGraphNode = LiteGraph.LGraphNode = LGraphNode;
  class LGraphGroup {
    static {
      __name(this, "LGraphGroup");
    }
    constructor(title) {
      this._ctor(title);
    }
    _ctor(title) {
      this.title = title || "Group";
      this.font_size = LiteGraph.DEFAULT_GROUP_FONT || 24;
      this.color = LGraphCanvas.node_colors.pale_blue ? LGraphCanvas.node_colors.pale_blue.groupcolor : "#AAA";
      this._bounding = new Float32Array([10, 10, 140, 80]);
      this._pos = this._bounding.subarray(0, 2);
      this._size = this._bounding.subarray(2, 4);
      this._nodes = [];
      this.graph = null;
      this.flags = {};
      Object.defineProperty(this, "pos", {
        set: /* @__PURE__ */ __name(function(v2) {
          if (!v2 || v2.length < 2) {
            return;
          }
          this._pos[0] = v2[0];
          this._pos[1] = v2[1];
        }, "set"),
        get: /* @__PURE__ */ __name(function() {
          return this._pos;
        }, "get"),
        enumerable: true
      });
      Object.defineProperty(this, "size", {
        set: /* @__PURE__ */ __name(function(v2) {
          if (!v2 || v2.length < 2) {
            return;
          }
          this._size[0] = Math.max(140, v2[0]);
          this._size[1] = Math.max(80, v2[1]);
        }, "set"),
        get: /* @__PURE__ */ __name(function() {
          return this._size;
        }, "get"),
        enumerable: true
      });
    }
    get titleHeight() {
      return this.font_size * 1.4;
    }
    get selected() {
      var _a, _b;
      return !!((_b = (_a = this.graph) == null ? void 0 : _a.list_of_graphcanvas) == null ? void 0 : _b.some((c) => c.selected_group === this));
    }
    get pinned() {
      return !!this.flags.pinned;
    }
    pin() {
      this.flags.pinned = true;
    }
    unpin() {
      delete this.flags.pinned;
    }
    configure(o) {
      this.title = o.title;
      this._bounding.set(o.bounding);
      this.color = o.color;
      this.flags = o.flags || this.flags;
      if (o.font_size) {
        this.font_size = o.font_size;
      }
    }
    serialize() {
      var b = this._bounding;
      return {
        title: this.title,
        bounding: [
          Math.round(b[0]),
          Math.round(b[1]),
          Math.round(b[2]),
          Math.round(b[3])
        ],
        color: this.color,
        font_size: this.font_size,
        flags: this.flags
      };
    }
    /**
     * Draws the group on the canvas
     * @param {LGraphCanvas} graphCanvas
     * @param {CanvasRenderingContext2D} ctx
     */
    draw(graphCanvas, ctx) {
      const padding = 4;
      ctx.fillStyle = this.color;
      ctx.strokeStyle = this.color;
      const [x2, y2] = this._pos;
      const [width2, height] = this._size;
      ctx.globalAlpha = 0.25 * graphCanvas.editor_alpha;
      ctx.beginPath();
      ctx.rect(x2 + 0.5, y2 + 0.5, width2, height);
      ctx.fill();
      ctx.globalAlpha = graphCanvas.editor_alpha;
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x2 + width2, y2 + height);
      ctx.lineTo(x2 + width2 - 10, y2 + height);
      ctx.lineTo(x2 + width2, y2 + height - 10);
      ctx.fill();
      const font_size = this.font_size || LiteGraph.DEFAULT_GROUP_FONT_SIZE;
      ctx.font = font_size + "px Arial";
      ctx.textAlign = "left";
      ctx.fillText(this.title + (this.pinned ? "" : ""), x2 + padding, y2 + font_size);
      if (LiteGraph.highlight_selected_group && this.selected) {
        graphCanvas.drawSelectionBounding(ctx, this._bounding, {
          shape: LiteGraph.BOX_SHAPE,
          title_height: this.titleHeight,
          title_mode: LiteGraph.NORMAL_TITLE,
          fgcolor: this.color,
          padding
        });
      }
    }
    resize(width2, height) {
      if (this.pinned) {
        return;
      }
      this._size[0] = width2;
      this._size[1] = height;
    }
    move(deltax, deltay, ignore_nodes) {
      if (this.pinned) {
        return;
      }
      this._pos[0] += deltax;
      this._pos[1] += deltay;
      if (ignore_nodes) {
        return;
      }
      for (var i2 = 0; i2 < this._nodes.length; ++i2) {
        var node22 = this._nodes[i2];
        node22.pos[0] += deltax;
        node22.pos[1] += deltay;
      }
    }
    recomputeInsideNodes() {
      this._nodes.length = 0;
      var nodes = this.graph._nodes;
      var node_bounding = new Float32Array(4);
      for (var i2 = 0; i2 < nodes.length; ++i2) {
        var node22 = nodes[i2];
        node22.getBounding(node_bounding);
        if (!overlapBounding(this._bounding, node_bounding)) {
          continue;
        }
        this._nodes.push(node22);
      }
    }
    /**
     * Add nodes to the group and adjust the group's position and size accordingly
     * @param {LGraphNode[]} nodes - The nodes to add to the group
     * @param {number} [padding=10] - The padding around the group
     * @returns {void}
     */
    addNodes(nodes, padding = 10) {
      if (!this._nodes && nodes.length === 0) return;
      const allNodes = [...this._nodes || [], ...nodes];
      const bounds = allNodes.reduce((acc, node22) => {
        var _a;
        const [x2, y2] = node22.pos;
        const [width2, height] = node22.size;
        const isReroute = node22.type === "Reroute";
        const isCollapsed = (_a = node22.flags) == null ? void 0 : _a.collapsed;
        const top = y2 - (isReroute ? 0 : LiteGraph.NODE_TITLE_HEIGHT);
        const bottom = isCollapsed ? top + LiteGraph.NODE_TITLE_HEIGHT : y2 + height;
        const right = isCollapsed && node22._collapsed_width ? x2 + Math.round(node22._collapsed_width) : x2 + width2;
        return {
          left: Math.min(acc.left, x2),
          top: Math.min(acc.top, top),
          right: Math.max(acc.right, right),
          bottom: Math.max(acc.bottom, bottom)
        };
      }, { left: Infinity, top: Infinity, right: -Infinity, bottom: -Infinity });
      this.pos = [
        bounds.left - padding,
        bounds.top - padding - this.titleHeight
      ];
      this.size = [
        bounds.right - bounds.left + padding * 2,
        bounds.bottom - bounds.top + padding * 2 + this.titleHeight
      ];
    }
    getMenuOptions() {
      return [
        {
          content: this.pinned ? "Unpin" : "Pin",
          callback: /* @__PURE__ */ __name(() => {
            this.pinned ? this.unpin() : this.pin();
            this.setDirtyCanvas(false, true);
          }, "callback")
        },
        null,
        { content: "Title", callback: LGraphCanvas.onShowPropertyEditor },
        {
          content: "Color",
          has_submenu: true,
          callback: LGraphCanvas.onMenuNodeColors
        },
        {
          content: "Font size",
          property: "font_size",
          type: "Number",
          callback: LGraphCanvas.onShowPropertyEditor
        },
        null,
        { content: "Remove", callback: LGraphCanvas.onMenuNodeRemove }
      ];
    }
  }
  LGraphGroup.prototype.isPointInside = LGraphNode.prototype.isPointInside;
  LGraphGroup.prototype.setDirtyCanvas = LGraphNode.prototype.setDirtyCanvas;
  globalThis.LGraphGroup = LiteGraph.LGraphGroup = LGraphGroup;
  class DragAndScale {
    static {
      __name(this, "DragAndScale");
    }
    constructor(element, skip_events) {
      this.offset = new Float32Array([0, 0]);
      this.scale = 1;
      this.max_scale = 10;
      this.min_scale = 0.1;
      this.onredraw = null;
      this.enabled = true;
      this.last_mouse = [0, 0];
      this.element = null;
      this.visible_area = new Float32Array(4);
      if (element) {
        this.element = element;
        if (!skip_events) {
          this.bindEvents(element);
        }
      }
    }
    bindEvents(element) {
      this.last_mouse = new Float32Array(2);
      this._binded_mouse_callback = this.onMouse.bind(this);
      LiteGraph.pointerListenerAdd(element, "down", this._binded_mouse_callback);
      LiteGraph.pointerListenerAdd(element, "move", this._binded_mouse_callback);
      LiteGraph.pointerListenerAdd(element, "up", this._binded_mouse_callback);
      element.addEventListener(
        "mousewheel",
        this._binded_mouse_callback,
        false
      );
      element.addEventListener("wheel", this._binded_mouse_callback, false);
    }
    computeVisibleArea(viewport) {
      if (!this.element) {
        this.visible_area[0] = this.visible_area[1] = this.visible_area[2] = this.visible_area[3] = 0;
        return;
      }
      var width2 = this.element.width;
      var height = this.element.height;
      var startx = -this.offset[0];
      var starty = -this.offset[1];
      if (viewport) {
        startx += viewport[0] / this.scale;
        starty += viewport[1] / this.scale;
        width2 = viewport[2];
        height = viewport[3];
      }
      var endx = startx + width2 / this.scale;
      var endy = starty + height / this.scale;
      this.visible_area[0] = startx;
      this.visible_area[1] = starty;
      this.visible_area[2] = endx - startx;
      this.visible_area[3] = endy - starty;
    }
    onMouse(e) {
      if (!this.enabled) {
        return;
      }
      var canvas = this.element;
      var rect = canvas.getBoundingClientRect();
      var x2 = e.clientX - rect.left;
      var y2 = e.clientY - rect.top;
      e.canvasx = x2;
      e.canvasy = y2;
      e.dragging = this.dragging;
      var is_inside = !this.viewport || this.viewport && x2 >= this.viewport[0] && x2 < this.viewport[0] + this.viewport[2] && y2 >= this.viewport[1] && y2 < this.viewport[1] + this.viewport[3];
      var ignore = false;
      if (this.onmouse) {
        ignore = this.onmouse(e);
      }
      if (e.type == LiteGraph.pointerevents_method + "down" && is_inside) {
        this.dragging = true;
        LiteGraph.pointerListenerRemove(canvas, "move", this._binded_mouse_callback);
        LiteGraph.pointerListenerAdd(document, "move", this._binded_mouse_callback);
        LiteGraph.pointerListenerAdd(document, "up", this._binded_mouse_callback);
      } else if (e.type == LiteGraph.pointerevents_method + "move") {
        if (!ignore) {
          var deltax = x2 - this.last_mouse[0];
          var deltay = y2 - this.last_mouse[1];
          if (this.dragging) {
            this.mouseDrag(deltax, deltay);
          }
        }
      } else if (e.type == LiteGraph.pointerevents_method + "up") {
        this.dragging = false;
        LiteGraph.pointerListenerRemove(document, "move", this._binded_mouse_callback);
        LiteGraph.pointerListenerRemove(document, "up", this._binded_mouse_callback);
        LiteGraph.pointerListenerAdd(canvas, "move", this._binded_mouse_callback);
      } else if (is_inside && (e.type == "mousewheel" || e.type == "wheel" || e.type == "DOMMouseScroll")) {
        e.eventType = "mousewheel";
        if (e.type == "wheel") {
          e.wheel = -e.deltaY;
        } else {
          e.wheel = e.wheelDeltaY != null ? e.wheelDeltaY : e.detail * -60;
        }
        e.delta = e.wheelDelta ? e.wheelDelta / 40 : e.deltaY ? -e.deltaY / 3 : 0;
        this.changeDeltaScale(1 + e.delta * 0.05);
      }
      this.last_mouse[0] = x2;
      this.last_mouse[1] = y2;
      if (is_inside) {
        e.preventDefault();
        e.stopPropagation();
        return false;
      }
    }
    toCanvasContext(ctx) {
      ctx.scale(this.scale, this.scale);
      ctx.translate(this.offset[0], this.offset[1]);
    }
    convertOffsetToCanvas(pos2) {
      return [
        (pos2[0] + this.offset[0]) * this.scale,
        (pos2[1] + this.offset[1]) * this.scale
      ];
    }
    convertCanvasToOffset(pos2, out) {
      out = out || [0, 0];
      out[0] = pos2[0] / this.scale - this.offset[0];
      out[1] = pos2[1] / this.scale - this.offset[1];
      return out;
    }
    mouseDrag(x2, y2) {
      this.offset[0] += x2 / this.scale;
      this.offset[1] += y2 / this.scale;
      if (this.onredraw) {
        this.onredraw(this);
      }
    }
    changeScale(value3, zooming_center) {
      if (value3 < this.min_scale) {
        value3 = this.min_scale;
      } else if (value3 > this.max_scale) {
        value3 = this.max_scale;
      }
      if (value3 == this.scale) {
        return;
      }
      if (!this.element) {
        return;
      }
      var rect = this.element.getBoundingClientRect();
      if (!rect) {
        return;
      }
      zooming_center = zooming_center || [
        rect.width * 0.5,
        rect.height * 0.5
      ];
      var center = this.convertCanvasToOffset(zooming_center);
      this.scale = value3;
      if (Math.abs(this.scale - 1) < 0.01) {
        this.scale = 1;
      }
      var new_center = this.convertCanvasToOffset(zooming_center);
      var delta_offset = [
        new_center[0] - center[0],
        new_center[1] - center[1]
      ];
      this.offset[0] += delta_offset[0];
      this.offset[1] += delta_offset[1];
      if (this.onredraw) {
        this.onredraw(this);
      }
    }
    changeDeltaScale(value3, zooming_center) {
      this.changeScale(this.scale * value3, zooming_center);
    }
    reset() {
      this.scale = 1;
      this.offset[0] = 0;
      this.offset[1] = 0;
    }
  }
  LiteGraph.DragAndScale = DragAndScale;
  const _LGraphCanvas = class __LGraphCanvas {
    static {
      __name(this, "_LGraphCanvas");
    }
    constructor(canvas, graph, options3) {
      this.options = options3 = options3 || {};
      this.background_image = __LGraphCanvas.DEFAULT_BACKGROUND_IMAGE;
      if (canvas && canvas.constructor === String) {
        canvas = document.querySelector(canvas);
      }
      this.ds = new DragAndScale();
      this.zoom_modify_alpha = true;
      this.zoom_speed = 1.1;
      this.title_text_font = "" + LiteGraph.NODE_TEXT_SIZE + "px Arial";
      this.inner_text_font = "normal " + LiteGraph.NODE_SUBTEXT_SIZE + "px Arial";
      this.node_title_color = LiteGraph.NODE_TITLE_COLOR;
      this.default_link_color = LiteGraph.LINK_COLOR;
      this.default_connection_color = {
        input_off: "#778",
        input_on: "#7F7",
        //"#BBD"
        output_off: "#778",
        output_on: "#7F7"
        //"#BBD"
      };
      this.default_connection_color_byType = {
        /*number: "#7F7",
        string: "#77F",
        boolean: "#F77",*/
      };
      this.default_connection_color_byTypeOff = {
        /*number: "#474",
        string: "#447",
        boolean: "#744",*/
      };
      this.highquality_render = true;
      this.use_gradients = false;
      this.editor_alpha = 1;
      this.pause_rendering = false;
      this.clear_background = true;
      this.clear_background_color = "#222";
      this.read_only = false;
      this.render_only_selected = true;
      this.live_mode = false;
      this.show_info = true;
      this.allow_dragcanvas = true;
      this.allow_dragnodes = true;
      this.allow_interaction = true;
      this.multi_select = false;
      this.allow_searchbox = true;
      this.allow_reconnect_links = true;
      this.align_to_grid = false;
      this.drag_mode = false;
      this.dragging_rectangle = null;
      this.filter = null;
      this.set_canvas_dirty_on_mouse_event = true;
      this.always_render_background = false;
      this.render_shadows = true;
      this.render_canvas_border = true;
      this.render_connections_shadows = false;
      this.render_connections_border = true;
      this.render_curved_connections = false;
      this.render_connection_arrows = false;
      this.render_collapsed_slots = true;
      this.render_execution_order = false;
      this.render_title_colored = true;
      this.render_link_tooltip = true;
      this.links_render_mode = LiteGraph.SPLINE_LINK;
      this.mouse = [0, 0];
      this.graph_mouse = [0, 0];
      this.canvas_mouse = this.graph_mouse;
      this.onSearchBox = null;
      this.onSearchBoxSelection = null;
      this.onMouse = null;
      this.onDrawBackground = null;
      this.onDrawForeground = null;
      this.onDrawOverlay = null;
      this.onDrawLinkTooltip = null;
      this.onNodeMoved = null;
      this.onSelectionChange = null;
      this.onConnectingChange = null;
      this.onBeforeChange = null;
      this.onAfterChange = null;
      this.connections_width = 3;
      this.round_radius = 8;
      this.current_node = null;
      this.node_widget = null;
      this.over_link_center = null;
      this.last_mouse_position = [0, 0];
      this.visible_area = this.ds.visible_area;
      this.visible_links = [];
      this.connecting_links = null;
      this.viewport = options3.viewport || null;
      if (graph) {
        graph.attachCanvas(this);
      }
      this.setCanvas(canvas, options3.skip_events);
      this.clear();
      if (!options3.skip_render) {
        this.startRendering();
      }
      this.autoresize = options3.autoresize;
    }
    static getFileExtension(url) {
      var question = url.indexOf("?");
      if (question != -1) {
        url = url.substr(0, question);
      }
      var point = url.lastIndexOf(".");
      if (point == -1) {
        return "";
      }
      return url.substr(point + 1).toLowerCase();
    }
    /* this is an implementation for touch not in production and not ready
         */
    /*LGraphCanvas.prototype.touchHandler = function(event) {
            //alert("foo");
            var touches = event.changedTouches,
                first = touches[0],
                type = "";
    
            switch (event.type) {
                case "touchstart":
                    type = "mousedown";
                    break;
                case "touchmove":
                    type = "mousemove";
                    break;
                case "touchend":
                    type = "mouseup";
                    break;
                default:
                    return;
            }
    
            //initMouseEvent(type, canBubble, cancelable, view, clickCount,
            //           screenX, screenY, clientX, clientY, ctrlKey,
            //           altKey, shiftKey, metaKey, button, relatedTarget);
    
            // this is eventually a Dom object, get the LGraphCanvas back
            if(typeof this.getCanvasWindow == "undefined"){
                var window = this.lgraphcanvas.getCanvasWindow();
            }else{
                var window = this.getCanvasWindow();
            }
            
            var document = window.document;
    
            var simulatedEvent = document.createEvent("MouseEvent");
            simulatedEvent.initMouseEvent(
                type,
                true,
                true,
                window,
                1,
                first.screenX,
                first.screenY,
                first.clientX,
                first.clientY,
                false,
                false,
                false,
                false,
                0, //left
                null
            );
            first.target.dispatchEvent(simulatedEvent);
            event.preventDefault();
        };*/
    /* CONTEXT MENU ********************/
    static onGroupAdd(info, entry, mouse_event) {
      var canvas = __LGraphCanvas.active_canvas;
      canvas.getCanvasWindow();
      var group = new LiteGraph.LGraphGroup();
      group.pos = canvas.convertEventToCanvasOffset(mouse_event);
      canvas.graph.add(group);
    }
    /**
         * Determines the furthest nodes in each direction
         * @param nodes {LGraphNode[]} the nodes to from which boundary nodes will be extracted
         * @return {{left: LGraphNode, top: LGraphNode, right: LGraphNode, bottom: LGraphNode}}
         */
    static getBoundaryNodes(nodes) {
      let top = null;
      let right = null;
      let bottom = null;
      let left = null;
      for (const nID in nodes) {
        const node22 = nodes[nID];
        const [x2, y2] = node22.pos;
        const [width2, height] = node22.size;
        if (top === null || y2 < top.pos[1]) {
          top = node22;
        }
        if (right === null || x2 + width2 > right.pos[0] + right.size[0]) {
          right = node22;
        }
        if (bottom === null || y2 + height > bottom.pos[1] + bottom.size[1]) {
          bottom = node22;
        }
        if (left === null || x2 < left.pos[0]) {
          left = node22;
        }
      }
      return {
        "top": top,
        "right": right,
        "bottom": bottom,
        "left": left
      };
    }
    /**
         *
         * @param {LGraphNode[]} nodes a list of nodes
         * @param {"top"|"bottom"|"left"|"right"} direction Direction to align the nodes
         * @param {LGraphNode?} align_to Node to align to (if null, align to the furthest node in the given direction)
         */
    static alignNodes(nodes, direction, align_to) {
      if (!nodes) {
        return;
      }
      const canvas = __LGraphCanvas.active_canvas;
      let boundaryNodes = [];
      if (align_to === void 0) {
        boundaryNodes = __LGraphCanvas.getBoundaryNodes(nodes);
      } else {
        boundaryNodes = {
          "top": align_to,
          "right": align_to,
          "bottom": align_to,
          "left": align_to
        };
      }
      for (const [_2, node22] of Object.entries(canvas.selected_nodes)) {
        switch (direction) {
          case "right":
            node22.pos[0] = boundaryNodes["right"].pos[0] + boundaryNodes["right"].size[0] - node22.size[0];
            break;
          case "left":
            node22.pos[0] = boundaryNodes["left"].pos[0];
            break;
          case "top":
            node22.pos[1] = boundaryNodes["top"].pos[1];
            break;
          case "bottom":
            node22.pos[1] = boundaryNodes["bottom"].pos[1] + boundaryNodes["bottom"].size[1] - node22.size[1];
            break;
        }
      }
      canvas.dirty_canvas = true;
      canvas.dirty_bgcanvas = true;
    }
    static onNodeAlign(value3, options3, event2, prev_menu, node22) {
      new LiteGraph.ContextMenu(["Top", "Bottom", "Left", "Right"], {
        event: event2,
        callback: inner_clicked,
        parentMenu: prev_menu
      });
      function inner_clicked(value22) {
        __LGraphCanvas.alignNodes(__LGraphCanvas.active_canvas.selected_nodes, value22.toLowerCase(), node22);
      }
      __name(inner_clicked, "inner_clicked");
    }
    static onGroupAlign(value3, options3, event2, prev_menu) {
      new LiteGraph.ContextMenu(["Top", "Bottom", "Left", "Right"], {
        event: event2,
        callback: inner_clicked,
        parentMenu: prev_menu
      });
      function inner_clicked(value22) {
        __LGraphCanvas.alignNodes(__LGraphCanvas.active_canvas.selected_nodes, value22.toLowerCase());
      }
      __name(inner_clicked, "inner_clicked");
    }
    static onMenuAdd(node22, options3, e, prev_menu, callback) {
      var canvas = __LGraphCanvas.active_canvas;
      var ref_window2 = canvas.getCanvasWindow();
      var graph = canvas.graph;
      if (!graph)
        return;
      function inner_onMenuAdded(base_category, prev_menu2) {
        var categories = LiteGraph.getNodeTypesCategories(canvas.filter || graph.filter).filter(function(category) {
          return category.startsWith(base_category);
        });
        var entries = [];
        categories.map(function(category) {
          if (!category)
            return;
          var base_category_regex = new RegExp("^(" + base_category + ")");
          var category_name = category.replace(base_category_regex, "").split("/")[0];
          var category_path = base_category === "" ? category_name + "/" : base_category + category_name + "/";
          var name = category_name;
          if (name.indexOf("::") != -1)
            name = name.split("::")[1];
          var index2 = entries.findIndex(function(entry) {
            return entry.value === category_path;
          });
          if (index2 === -1) {
            entries.push({
              value: category_path,
              content: name,
              has_submenu: true,
              callback: /* @__PURE__ */ __name(function(value3, event2, mouseEvent, contextMenu) {
                inner_onMenuAdded(value3.value, contextMenu);
              }, "callback")
            });
          }
        });
        var nodes = LiteGraph.getNodeTypesInCategory(base_category.slice(0, -1), canvas.filter || graph.filter);
        nodes.map(function(node3) {
          if (node3.skip_list)
            return;
          var entry = {
            value: node3.type,
            content: node3.title,
            has_submenu: false,
            callback: /* @__PURE__ */ __name(function(value3, event2, mouseEvent, contextMenu) {
              var first_event = contextMenu.getFirstEvent();
              canvas.graph.beforeChange();
              var node4 = LiteGraph.createNode(value3.value);
              if (node4) {
                node4.pos = canvas.convertEventToCanvasOffset(first_event);
                canvas.graph.add(node4);
              }
              if (callback)
                callback(node4);
              canvas.graph.afterChange();
            }, "callback")
          };
          entries.push(entry);
        });
        new LiteGraph.ContextMenu(entries, { event: e, parentMenu: prev_menu2 }, ref_window2);
      }
      __name(inner_onMenuAdded, "inner_onMenuAdded");
      inner_onMenuAdded("", prev_menu);
      return false;
    }
    static onMenuCollapseAll() {
    }
    static onMenuNodeEdit() {
    }
    static showMenuNodeOptionalInputs(v2, options3, e, prev_menu, node22) {
      if (!node22) {
        return;
      }
      var that2 = this;
      var canvas = __LGraphCanvas.active_canvas;
      var ref_window2 = canvas.getCanvasWindow();
      var options3 = node22.optional_inputs;
      if (node22.onGetInputs) {
        options3 = node22.onGetInputs();
      }
      var entries = [];
      if (options3) {
        for (var i2 = 0; i2 < options3.length; i2++) {
          var entry = options3[i2];
          if (!entry) {
            entries.push(null);
            continue;
          }
          var label5 = entry[0];
          if (!entry[2])
            entry[2] = {};
          if (entry[2].label) {
            label5 = entry[2].label;
          }
          entry[2].removable = true;
          var data24 = { content: label5, value: entry };
          if (entry[1] == LiteGraph.ACTION) {
            data24.className = "event";
          }
          entries.push(data24);
        }
      }
      if (node22.onMenuNodeInputs) {
        var retEntries = node22.onMenuNodeInputs(entries);
        if (retEntries) entries = retEntries;
      }
      if (!entries.length) {
        console.log("no input entries");
        return;
      }
      new LiteGraph.ContextMenu(
        entries,
        {
          event: e,
          callback: inner_clicked,
          parentMenu: prev_menu,
          node: node22
        },
        ref_window2
      );
      function inner_clicked(v3, e2, prev2) {
        if (!node22) {
          return;
        }
        if (v3.callback) {
          v3.callback.call(that2, node22, v3, e2, prev2);
        }
        if (v3.value) {
          node22.graph.beforeChange();
          node22.addInput(v3.value[0], v3.value[1], v3.value[2]);
          if (node22.onNodeInputAdd) {
            node22.onNodeInputAdd(v3.value);
          }
          node22.setDirtyCanvas(true, true);
          node22.graph.afterChange();
        }
      }
      __name(inner_clicked, "inner_clicked");
      return false;
    }
    static showMenuNodeOptionalOutputs(v2, options3, e, prev_menu, node22) {
      if (!node22) {
        return;
      }
      var that2 = this;
      var canvas = __LGraphCanvas.active_canvas;
      var ref_window2 = canvas.getCanvasWindow();
      var options3 = node22.optional_outputs;
      if (node22.onGetOutputs) {
        options3 = node22.onGetOutputs();
      }
      var entries = [];
      if (options3) {
        for (var i2 = 0; i2 < options3.length; i2++) {
          var entry = options3[i2];
          if (!entry) {
            entries.push(null);
            continue;
          }
          if (node22.flags && node22.flags.skip_repeated_outputs && node22.findOutputSlot(entry[0]) != -1) {
            continue;
          }
          var label5 = entry[0];
          if (!entry[2])
            entry[2] = {};
          if (entry[2].label) {
            label5 = entry[2].label;
          }
          entry[2].removable = true;
          var data24 = { content: label5, value: entry };
          if (entry[1] == LiteGraph.EVENT) {
            data24.className = "event";
          }
          entries.push(data24);
        }
      }
      if (this.onMenuNodeOutputs) {
        entries = this.onMenuNodeOutputs(entries);
      }
      if (LiteGraph.do_add_triggers_slots) {
        if (node22.findOutputSlot("onExecuted") == -1) {
          entries.push({ content: "On Executed", value: ["onExecuted", LiteGraph.EVENT, { nameLocked: true }], className: "event" });
        }
      }
      if (node22.onMenuNodeOutputs) {
        var retEntries = node22.onMenuNodeOutputs(entries);
        if (retEntries) entries = retEntries;
      }
      if (!entries.length) {
        return;
      }
      new LiteGraph.ContextMenu(
        entries,
        {
          event: e,
          callback: inner_clicked,
          parentMenu: prev_menu,
          node: node22
        },
        ref_window2
      );
      function inner_clicked(v3, e2, prev2) {
        if (!node22) {
          return;
        }
        if (v3.callback) {
          v3.callback.call(that2, node22, v3, e2, prev2);
        }
        if (!v3.value) {
          return;
        }
        var value3 = v3.value[1];
        if (value3 && (value3.constructor === Object || value3.constructor === Array)) {
          var entries2 = [];
          for (var i3 in value3) {
            entries2.push({ content: i3, value: value3[i3] });
          }
          new LiteGraph.ContextMenu(entries2, {
            event: e2,
            callback: inner_clicked,
            parentMenu: prev_menu,
            node: node22
          });
          return false;
        } else {
          node22.graph.beforeChange();
          node22.addOutput(v3.value[0], v3.value[1], v3.value[2]);
          if (node22.onNodeOutputAdd) {
            node22.onNodeOutputAdd(v3.value);
          }
          node22.setDirtyCanvas(true, true);
          node22.graph.afterChange();
        }
      }
      __name(inner_clicked, "inner_clicked");
      return false;
    }
    static onShowMenuNodeProperties(value3, options3, e, prev_menu, node22) {
      if (!node22 || !node22.properties) {
        return;
      }
      var canvas = __LGraphCanvas.active_canvas;
      var ref_window2 = canvas.getCanvasWindow();
      var entries = [];
      for (var i2 in node22.properties) {
        var value3 = node22.properties[i2] !== void 0 ? node22.properties[i2] : " ";
        if (typeof value3 == "object")
          value3 = JSON.stringify(value3);
        var info = node22.getPropertyInfo(i2);
        if (info.type == "enum" || info.type == "combo")
          value3 = __LGraphCanvas.getPropertyPrintableValue(value3, info.values);
        value3 = __LGraphCanvas.decodeHTML(value3);
        entries.push({
          content: "<span class='property_name'>" + (info.label ? info.label : i2) + "</span><span class='property_value'>" + value3 + "</span>",
          value: i2
        });
      }
      if (!entries.length) {
        return;
      }
      new LiteGraph.ContextMenu(
        entries,
        {
          event: e,
          callback: inner_clicked,
          parentMenu: prev_menu,
          allow_html: true,
          node: node22
        },
        ref_window2
      );
      function inner_clicked(v2, options22, e2, prev2) {
        if (!node22) {
          return;
        }
        var rect = this.getBoundingClientRect();
        canvas.showEditPropertyValue(node22, v2.value, {
          position: [rect.left, rect.top]
        });
      }
      __name(inner_clicked, "inner_clicked");
      return false;
    }
    static decodeHTML(str) {
      var e = document.createElement("div");
      e.innerText = str;
      return e.innerHTML;
    }
    static onMenuResizeNode(value3, options3, e, menu, node22) {
      if (!node22) {
        return;
      }
      var fApplyMultiNode = /* @__PURE__ */ __name(function(node3) {
        node3.size = node3.computeSize();
        if (node3.onResize)
          node3.onResize(node3.size);
      }, "fApplyMultiNode");
      var graphcanvas = __LGraphCanvas.active_canvas;
      if (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1) {
        fApplyMultiNode(node22);
      } else {
        for (var i2 in graphcanvas.selected_nodes) {
          fApplyMultiNode(graphcanvas.selected_nodes[i2]);
        }
      }
      node22.setDirtyCanvas(true, true);
    }
    // TODO refactor :: this is used fot title but not for properties!
    static onShowPropertyEditor(item2, options3, e, menu, node22) {
      var property = item2.property || "title";
      var value3 = node22[property];
      var dialog = document.createElement("div");
      dialog.is_modified = false;
      dialog.className = "graphdialog";
      dialog.innerHTML = "<span class='name'></span><input autofocus type='text' class='value'/><button>OK</button>";
      dialog.close = function() {
        if (dialog.parentNode) {
          dialog.parentNode.removeChild(dialog);
        }
      };
      var title = dialog.querySelector(".name");
      title.innerText = property;
      var input = dialog.querySelector(".value");
      if (input) {
        input.value = value3;
        input.addEventListener("blur", function(e2) {
          this.focus();
        });
        input.addEventListener("keydown", function(e2) {
          dialog.is_modified = true;
          if (e2.keyCode == 27) {
            dialog.close();
          } else if (e2.keyCode == 13) {
            inner();
          } else if (e2.keyCode != 13 && e2.target.localName != "textarea") {
            return;
          }
          e2.preventDefault();
          e2.stopPropagation();
        });
      }
      var graphcanvas = __LGraphCanvas.active_canvas;
      var canvas = graphcanvas.canvas;
      var rect = canvas.getBoundingClientRect();
      var offsetx = -20;
      var offsety = -20;
      if (rect) {
        offsetx -= rect.left;
        offsety -= rect.top;
      }
      if (event) {
        dialog.style.left = event.clientX + offsetx + "px";
        dialog.style.top = event.clientY + offsety + "px";
      } else {
        dialog.style.left = canvas.width * 0.5 + offsetx + "px";
        dialog.style.top = canvas.height * 0.5 + offsety + "px";
      }
      var button = dialog.querySelector("button");
      button.addEventListener("click", inner);
      canvas.parentNode.appendChild(dialog);
      if (input) input.focus();
      var dialogCloseTimer = null;
      dialog.addEventListener("mouseleave", function(e2) {
        if (LiteGraph.dialog_close_on_mouse_leave) {
          if (!dialog.is_modified && LiteGraph.dialog_close_on_mouse_leave)
            dialogCloseTimer = setTimeout(dialog.close, LiteGraph.dialog_close_on_mouse_leave_delay);
        }
      });
      dialog.addEventListener("mouseenter", function(e2) {
        if (LiteGraph.dialog_close_on_mouse_leave) {
          if (dialogCloseTimer) clearTimeout(dialogCloseTimer);
        }
      });
      function inner() {
        if (input) setValue2(input.value);
      }
      __name(inner, "inner");
      function setValue2(value22) {
        if (item2.type == "Number") {
          value22 = Number(value22);
        } else if (item2.type == "Boolean") {
          value22 = Boolean(value22);
        }
        node22[property] = value22;
        if (dialog.parentNode) {
          dialog.parentNode.removeChild(dialog);
        }
        node22.setDirtyCanvas(true, true);
      }
      __name(setValue2, "setValue");
    }
    static getPropertyPrintableValue(value3, values2) {
      if (!values2)
        return String(value3);
      if (values2.constructor === Array) {
        return String(value3);
      }
      if (values2.constructor === Object) {
        var desc_value = "";
        for (var k in values2) {
          if (values2[k] != value3)
            continue;
          desc_value = k;
          break;
        }
        return String(value3) + " (" + desc_value + ")";
      }
    }
    static onMenuNodeCollapse(value3, options3, e, menu, node22) {
      node22.graph.beforeChange(
        /*?*/
      );
      var fApplyMultiNode = /* @__PURE__ */ __name(function(node3) {
        node3.collapse();
      }, "fApplyMultiNode");
      var graphcanvas = __LGraphCanvas.active_canvas;
      if (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1) {
        fApplyMultiNode(node22);
      } else {
        for (var i2 in graphcanvas.selected_nodes) {
          fApplyMultiNode(graphcanvas.selected_nodes[i2]);
        }
      }
      node22.graph.afterChange(
        /*?*/
      );
    }
    static onMenuNodePin(value3, options3, e, menu, node22) {
      node22.pin();
    }
    static onMenuNodeMode(value3, options3, e, menu, node22) {
      new LiteGraph.ContextMenu(
        LiteGraph.NODE_MODES,
        { event: e, callback: inner_clicked, parentMenu: menu, node: node22 }
      );
      function inner_clicked(v2) {
        if (!node22) {
          return;
        }
        var kV = Object.values(LiteGraph.NODE_MODES).indexOf(v2);
        var fApplyMultiNode = /* @__PURE__ */ __name(function(node3) {
          if (kV >= 0 && LiteGraph.NODE_MODES[kV])
            node3.changeMode(kV);
          else {
            console.warn("unexpected mode: " + v2);
            node3.changeMode(LiteGraph.ALWAYS);
          }
        }, "fApplyMultiNode");
        var graphcanvas = __LGraphCanvas.active_canvas;
        if (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1) {
          fApplyMultiNode(node22);
        } else {
          for (var i2 in graphcanvas.selected_nodes) {
            fApplyMultiNode(graphcanvas.selected_nodes[i2]);
          }
        }
      }
      __name(inner_clicked, "inner_clicked");
      return false;
    }
    static onMenuNodeColors(value3, options3, e, menu, node22) {
      if (!node22) {
        throw "no node for color";
      }
      var values2 = [];
      values2.push({
        value: null,
        content: "<span style='display: block; padding-left: 4px;'>No color</span>"
      });
      for (var i2 in __LGraphCanvas.node_colors) {
        var color = __LGraphCanvas.node_colors[i2];
        var value3 = {
          value: i2,
          content: "<span style='display: block; color: #999; padding-left: 4px; border-left: 8px solid " + color.color + "; background-color:" + color.bgcolor + "'>" + i2 + "</span>"
        };
        values2.push(value3);
      }
      new LiteGraph.ContextMenu(values2, {
        event: e,
        callback: inner_clicked,
        parentMenu: menu,
        node: node22
      });
      function inner_clicked(v2) {
        if (!node22) {
          return;
        }
        var color2 = v2.value ? __LGraphCanvas.node_colors[v2.value] : null;
        var fApplyColor = /* @__PURE__ */ __name(function(node3) {
          if (color2) {
            if (node3.constructor === LiteGraph.LGraphGroup) {
              node3.color = color2.groupcolor;
            } else {
              node3.color = color2.color;
              node3.bgcolor = color2.bgcolor;
            }
          } else {
            delete node3.color;
            delete node3.bgcolor;
          }
        }, "fApplyColor");
        var graphcanvas = __LGraphCanvas.active_canvas;
        if (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1) {
          fApplyColor(node22);
        } else {
          for (var i3 in graphcanvas.selected_nodes) {
            fApplyColor(graphcanvas.selected_nodes[i3]);
          }
        }
        node22.setDirtyCanvas(true, true);
      }
      __name(inner_clicked, "inner_clicked");
      return false;
    }
    static onMenuNodeShapes(value3, options3, e, menu, node22) {
      if (!node22) {
        throw "no node passed";
      }
      new LiteGraph.ContextMenu(LiteGraph.VALID_SHAPES, {
        event: e,
        callback: inner_clicked,
        parentMenu: menu,
        node: node22
      });
      function inner_clicked(v2) {
        if (!node22) {
          return;
        }
        node22.graph.beforeChange(
          /*?*/
        );
        var fApplyMultiNode = /* @__PURE__ */ __name(function(node3) {
          node3.shape = v2;
        }, "fApplyMultiNode");
        var graphcanvas = __LGraphCanvas.active_canvas;
        if (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1) {
          fApplyMultiNode(node22);
        } else {
          for (var i2 in graphcanvas.selected_nodes) {
            fApplyMultiNode(graphcanvas.selected_nodes[i2]);
          }
        }
        node22.graph.afterChange(
          /*?*/
        );
        node22.setDirtyCanvas(true);
      }
      __name(inner_clicked, "inner_clicked");
      return false;
    }
    static onMenuNodeRemove(value3, options3, e, menu, node22) {
      if (!node22) {
        throw "no node passed";
      }
      var graph = node22.graph;
      graph.beforeChange();
      var fApplyMultiNode = /* @__PURE__ */ __name(function(node3) {
        if (node3.removable === false) {
          return;
        }
        graph.remove(node3);
      }, "fApplyMultiNode");
      var graphcanvas = __LGraphCanvas.active_canvas;
      if (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1) {
        fApplyMultiNode(node22);
      } else {
        for (var i2 in graphcanvas.selected_nodes) {
          fApplyMultiNode(graphcanvas.selected_nodes[i2]);
        }
      }
      graph.afterChange();
      node22.setDirtyCanvas(true, true);
    }
    static onMenuNodeToSubgraph(value3, options3, e, menu, node22) {
      var graph = node22.graph;
      var graphcanvas = __LGraphCanvas.active_canvas;
      if (!graphcanvas)
        return;
      var nodes_list = Object.values(graphcanvas.selected_nodes || {});
      if (!nodes_list.length)
        nodes_list = [node22];
      var subgraph_node = LiteGraph.createNode("graph/subgraph");
      subgraph_node.pos = node22.pos.concat();
      graph.add(subgraph_node);
      subgraph_node.buildFromNodes(nodes_list);
      graphcanvas.deselectAllNodes();
      node22.setDirtyCanvas(true, true);
    }
    static onMenuNodeClone(value3, options3, e, menu, node22) {
      node22.graph.beforeChange();
      var newSelected = {};
      var fApplyMultiNode = /* @__PURE__ */ __name(function(node3) {
        if (node3.clonable === false) {
          return;
        }
        var newnode = node3.clone();
        if (!newnode) {
          return;
        }
        newnode.pos = [node3.pos[0] + 5, node3.pos[1] + 5];
        node3.graph.add(newnode);
        newSelected[newnode.id] = newnode;
      }, "fApplyMultiNode");
      var graphcanvas = __LGraphCanvas.active_canvas;
      if (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1) {
        fApplyMultiNode(node22);
      } else {
        for (var i2 in graphcanvas.selected_nodes) {
          fApplyMultiNode(graphcanvas.selected_nodes[i2]);
        }
      }
      if (Object.keys(newSelected).length) {
        graphcanvas.selectNodes(newSelected);
      }
      node22.graph.afterChange();
      node22.setDirtyCanvas(true, true);
    }
    /**
         * clears all the data inside
         *
         * @method clear
         */
    clear() {
      this.frame = 0;
      this.last_draw_time = 0;
      this.render_time = 0;
      this.fps = 0;
      this.dragging_rectangle = null;
      this.selected_nodes = {};
      this.selected_group = null;
      this.visible_nodes = [];
      this.node_dragged = null;
      this.node_over = null;
      this.node_capturing_input = null;
      this.connecting_links = null;
      this.highlighted_links = {};
      this.dragging_canvas = false;
      this.dirty_canvas = true;
      this.dirty_bgcanvas = true;
      this.dirty_area = null;
      this.node_in_panel = null;
      this.node_widget = null;
      this.last_mouse = [0, 0];
      this.last_mouseclick = 0;
      this.pointer_is_down = false;
      this.pointer_is_double = false;
      this.visible_area.set([0, 0, 0, 0]);
      if (this.onClear) {
        this.onClear();
      }
    }
    /**
         * assigns a graph, you can reassign graphs to the same canvas
         *
         * @method setGraph
         * @param {LGraph} graph
         */
    setGraph(graph, skip_clear) {
      if (this.graph == graph) {
        return;
      }
      if (!skip_clear) {
        this.clear();
      }
      if (!graph && this.graph) {
        this.graph.detachCanvas(this);
        return;
      }
      graph.attachCanvas(this);
      if (this._graph_stack)
        this._graph_stack = null;
      this.setDirty(true, true);
    }
    /**
         * returns the top level graph (in case there are subgraphs open on the canvas)
         *
         * @method getTopGraph
         * @return {LGraph} graph
         */
    getTopGraph() {
      if (this._graph_stack.length)
        return this._graph_stack[0];
      return this.graph;
    }
    /**
         * opens a graph contained inside a node in the current graph
         *
         * @method openSubgraph
         * @param {LGraph} graph
         */
    openSubgraph(graph) {
      if (!graph) {
        throw "graph cannot be null";
      }
      if (this.graph == graph) {
        throw "graph cannot be the same";
      }
      this.clear();
      if (this.graph) {
        if (!this._graph_stack) {
          this._graph_stack = [];
        }
        this._graph_stack.push(this.graph);
      }
      graph.attachCanvas(this);
      this.checkPanels();
      this.setDirty(true, true);
    }
    /**
         * closes a subgraph contained inside a node
         *
         * @method closeSubgraph
         * @param {LGraph} assigns a graph
         */
    closeSubgraph() {
      if (!this._graph_stack || this._graph_stack.length == 0) {
        return;
      }
      var subgraph_node = this.graph._subgraph_node;
      var graph = this._graph_stack.pop();
      this.selected_nodes = {};
      this.highlighted_links = {};
      graph.attachCanvas(this);
      this.setDirty(true, true);
      if (subgraph_node) {
        this.centerOnNode(subgraph_node);
        this.selectNodes([subgraph_node]);
      }
      this.ds.offset = [0, 0];
      this.ds.scale = 1;
    }
    /**
         * returns the visually active graph (in case there are more in the stack)
         * @method getCurrentGraph
         * @return {LGraph} the active graph
         */
    getCurrentGraph() {
      return this.graph;
    }
    /**
         * assigns a canvas
         *
         * @method setCanvas
         * @param {Canvas} assigns a canvas (also accepts the ID of the element (not a selector)
         */
    setCanvas(canvas, skip_events) {
      if (canvas) {
        if (canvas.constructor === String) {
          canvas = document.getElementById(canvas);
          if (!canvas) {
            throw "Error creating LiteGraph canvas: Canvas not found";
          }
        }
      }
      if (canvas === this.canvas) {
        return;
      }
      if (!canvas && this.canvas) {
        if (!skip_events) {
          this.unbindEvents();
        }
      }
      this.canvas = canvas;
      this.ds.element = canvas;
      if (!canvas) {
        return;
      }
      canvas.className += " lgraphcanvas";
      canvas.data = this;
      canvas.tabindex = "1";
      this.bgcanvas = null;
      if (!this.bgcanvas) {
        this.bgcanvas = document.createElement("canvas");
        this.bgcanvas.width = this.canvas.width;
        this.bgcanvas.height = this.canvas.height;
      }
      if (canvas.getContext == null) {
        if (canvas.localName != "canvas") {
          throw "Element supplied for LGraphCanvas must be a <canvas> element, you passed a " + canvas.localName;
        }
        throw "This browser doesn't support Canvas";
      }
      var ctx = this.ctx = canvas.getContext("2d");
      if (ctx == null) {
        if (!canvas.webgl_enabled) {
          console.warn(
            "This canvas seems to be WebGL, enabling WebGL renderer"
          );
        }
        this.enableWebGL();
      }
      if (!skip_events) {
        this.bindEvents();
      }
    }
    //used in some events to capture them
    _doNothing(e) {
      e.preventDefault();
      return false;
    }
    _doReturnTrue(e) {
      e.preventDefault();
      return true;
    }
    /**
         * binds mouse, keyboard, touch and drag events to the canvas
         * @method bindEvents
         **/
    bindEvents() {
      if (this._events_binded) {
        console.warn("LGraphCanvas: events already binded");
        return;
      }
      var canvas = this.canvas;
      var ref_window2 = this.getCanvasWindow();
      var document2 = ref_window2.document;
      this._mousedown_callback = this.processMouseDown.bind(this);
      this._mousewheel_callback = this.processMouseWheel.bind(this);
      this._mousemove_callback = this.processMouseMove.bind(this);
      this._mouseup_callback = this.processMouseUp.bind(this);
      LiteGraph.pointerListenerAdd(canvas, "down", this._mousedown_callback, true);
      canvas.addEventListener("mousewheel", this._mousewheel_callback, false);
      LiteGraph.pointerListenerAdd(canvas, "up", this._mouseup_callback, true);
      LiteGraph.pointerListenerAdd(canvas, "move", this._mousemove_callback);
      canvas.addEventListener("contextmenu", this._doNothing);
      canvas.addEventListener(
        "DOMMouseScroll",
        this._mousewheel_callback,
        false
      );
      this._key_callback = this.processKey.bind(this);
      canvas.addEventListener("keydown", this._key_callback, true);
      document2.addEventListener("keyup", this._key_callback, true);
      this._ondrop_callback = this.processDrop.bind(this);
      canvas.addEventListener("dragover", this._doNothing, false);
      canvas.addEventListener("dragend", this._doNothing, false);
      canvas.addEventListener("drop", this._ondrop_callback, false);
      canvas.addEventListener("dragenter", this._doReturnTrue, false);
      this._events_binded = true;
    }
    /**
         * unbinds mouse events from the canvas
         * @method unbindEvents
         **/
    unbindEvents() {
      if (!this._events_binded) {
        console.warn("LGraphCanvas: no events binded");
        return;
      }
      var ref_window2 = this.getCanvasWindow();
      var document2 = ref_window2.document;
      LiteGraph.pointerListenerRemove(this.canvas, "move", this._mousemove_callback);
      LiteGraph.pointerListenerRemove(this.canvas, "up", this._mouseup_callback);
      LiteGraph.pointerListenerRemove(this.canvas, "down", this._mousedown_callback);
      this.canvas.removeEventListener(
        "mousewheel",
        this._mousewheel_callback
      );
      this.canvas.removeEventListener(
        "DOMMouseScroll",
        this._mousewheel_callback
      );
      this.canvas.removeEventListener("keydown", this._key_callback);
      document2.removeEventListener("keyup", this._key_callback);
      this.canvas.removeEventListener("contextmenu", this._doNothing);
      this.canvas.removeEventListener("drop", this._ondrop_callback);
      this.canvas.removeEventListener("dragenter", this._doReturnTrue);
      this._mousedown_callback = null;
      this._mousewheel_callback = null;
      this._key_callback = null;
      this._ondrop_callback = null;
      this._events_binded = false;
    }
    /**
         * this function allows to render the canvas using WebGL instead of Canvas2D
         * this is useful if you plant to render 3D objects inside your nodes, it uses litegl.js for webgl and canvas2DtoWebGL to emulate the Canvas2D calls in webGL
         * @method enableWebGL
         **/
    enableWebGL() {
      if (typeof GL === "undefined") {
        throw "litegl.js must be included to use a WebGL canvas";
      }
      if (typeof enableWebGLCanvas === "undefined") {
        throw "webglCanvas.js must be included to use this feature";
      }
      this.gl = this.ctx = enableWebGLCanvas(this.canvas);
      this.ctx.webgl = true;
      this.bgcanvas = this.canvas;
      this.bgctx = this.gl;
      this.canvas.webgl_enabled = true;
    }
    /**
         * marks as dirty the canvas, this way it will be rendered again
         *
         * @class LGraphCanvas
         * @method setDirty
         * @param {bool} fgcanvas if the foreground canvas is dirty (the one containing the nodes)
         * @param {bool} bgcanvas if the background canvas is dirty (the one containing the wires)
         */
    setDirty(fgcanvas, bgcanvas) {
      if (fgcanvas) {
        this.dirty_canvas = true;
      }
      if (bgcanvas) {
        this.dirty_bgcanvas = true;
      }
    }
    /**
         * Used to attach the canvas in a popup
         *
         * @method getCanvasWindow
         * @return {window} returns the window where the canvas is attached (the DOM root node)
         */
    getCanvasWindow() {
      if (!this.canvas) {
        return window;
      }
      var doc2 = this.canvas.ownerDocument;
      return doc2.defaultView || doc2.parentWindow;
    }
    /**
         * starts rendering the content of the canvas when needed
         *
         * @method startRendering
         */
    startRendering() {
      if (this.is_rendering) {
        return;
      }
      this.is_rendering = true;
      renderFrame.call(this);
      function renderFrame() {
        if (!this.pause_rendering) {
          this.draw();
        }
        var window2 = this.getCanvasWindow();
        if (this.is_rendering) {
          window2.requestAnimationFrame(renderFrame.bind(this));
        }
      }
      __name(renderFrame, "renderFrame");
    }
    /**
         * stops rendering the content of the canvas (to save resources)
         *
         * @method stopRendering
         */
    stopRendering() {
      this.is_rendering = false;
    }
    /* LiteGraphCanvas input */
    //used to block future mouse events (because of im gui)
    blockClick() {
      this.block_click = true;
      this.last_mouseclick = 0;
    }
    processMouseDown(e) {
      var _a;
      if (this.set_canvas_dirty_on_mouse_event)
        this.dirty_canvas = true;
      if (!this.graph) {
        return;
      }
      this.adjustMouseEvent(e);
      var ref_window2 = this.getCanvasWindow();
      ref_window2.document;
      __LGraphCanvas.active_canvas = this;
      var that2 = this;
      var x2 = e.clientX;
      var y2 = e.clientY;
      this.ds.viewport = this.viewport;
      var is_inside = !this.viewport || this.viewport && x2 >= this.viewport[0] && x2 < this.viewport[0] + this.viewport[2] && y2 >= this.viewport[1] && y2 < this.viewport[1] + this.viewport[3];
      if (!this.options.skip_events) {
        LiteGraph.pointerListenerRemove(this.canvas, "move", this._mousemove_callback);
        LiteGraph.pointerListenerAdd(ref_window2.document, "move", this._mousemove_callback, true);
        LiteGraph.pointerListenerAdd(ref_window2.document, "up", this._mouseup_callback, true);
      }
      if (!is_inside) {
        return;
      }
      var node22 = this.graph.getNodeOnPos(e.canvasX, e.canvasY, this.visible_nodes, 5);
      var skip_action = false;
      var now2 = LiteGraph.getTime();
      var is_primary = e.isPrimary === void 0 || !e.isPrimary;
      var is_double_click = now2 - this.last_mouseclick < 300;
      this.mouse[0] = e.clientX;
      this.mouse[1] = e.clientY;
      this.graph_mouse[0] = e.canvasX;
      this.graph_mouse[1] = e.canvasY;
      this.last_click_position = [this.mouse[0], this.mouse[1]];
      if (this.pointer_is_down && is_primary) {
        this.pointer_is_double = true;
      } else {
        this.pointer_is_double = false;
      }
      this.pointer_is_down = true;
      this.canvas.focus();
      LiteGraph.closeAllContextMenus(ref_window2);
      if (this.onMouse) {
        if (this.onMouse(e) == true)
          return;
      }
      if (e.which == 1 && !this.pointer_is_double) {
        if (e.ctrlKey && !e.altKey) {
          this.dragging_rectangle = new Float32Array(4);
          this.dragging_rectangle[0] = e.canvasX;
          this.dragging_rectangle[1] = e.canvasY;
          this.dragging_rectangle[2] = 1;
          this.dragging_rectangle[3] = 1;
          skip_action = true;
        }
        if (LiteGraph.alt_drag_do_clone_nodes && e.altKey && !e.ctrlKey && node22 && this.allow_interaction && !skip_action && !this.read_only) {
          const cloned = node22.clone();
          if (cloned) {
            cloned.pos[0] += 5;
            cloned.pos[1] += 5;
            this.graph.add(cloned, false, { doCalcSize: false });
            node22 = cloned;
            skip_action = true;
            if (!block_drag_node) {
              if (this.allow_dragnodes) {
                this.graph.beforeChange();
                this.node_dragged = node22;
              }
              if (!this.selected_nodes[node22.id]) {
                this.processNodeSelected(node22, e);
              }
            }
          }
        }
        var clicking_canvas_bg = false;
        if (node22 && (this.allow_interaction || node22.flags.allow_interaction) && !skip_action && !this.read_only) {
          if (!this.live_mode && !node22.flags.pinned) {
            this.bringToFront(node22);
          }
          if (this.allow_interaction && !this.connecting_links && !node22.flags.collapsed && !this.live_mode) {
            if (!skip_action && node22.resizable !== false && node22.inResizeCorner(e.canvasX, e.canvasY)) {
              this.graph.beforeChange();
              this.resizing_node = node22;
              this.canvas.style.cursor = "se-resize";
              skip_action = true;
            } else {
              if (node22.outputs) {
                for (var i2 = 0, l = node22.outputs.length; i2 < l; ++i2) {
                  var output = node22.outputs[i2];
                  var link_pos = node22.getConnectionPos(false, i2);
                  if (isInsideRectangle(
                    e.canvasX,
                    e.canvasY,
                    link_pos[0] - 15,
                    link_pos[1] - 10,
                    30,
                    20
                  )) {
                    if (e.shiftKey) {
                      if (((_a = output.links) == null ? void 0 : _a.length) > 0) {
                        this.connecting_links = [];
                        for (const linkId of output.links) {
                          const link2 = this.graph.links[linkId];
                          const slot = link2.target_slot;
                          const linked_node = this.graph._nodes_by_id[link2.target_id];
                          const input2 = linked_node.inputs[slot];
                          const pos3 = linked_node.getConnectionPos(true, slot);
                          this.connecting_links.push({
                            node: linked_node,
                            slot,
                            input: input2,
                            output: null,
                            pos: pos3
                          });
                        }
                        skip_action = true;
                        break;
                      }
                    }
                    output.slot_index = i2;
                    this.connecting_links = [
                      {
                        node: node22,
                        slot: i2,
                        input: null,
                        output,
                        pos: link_pos
                      }
                    ];
                    if (LiteGraph.shift_click_do_break_link_from) {
                      if (e.shiftKey) {
                        node22.disconnectOutput(i2);
                      }
                    } else if (LiteGraph.ctrl_alt_click_do_break_link) {
                      if (e.ctrlKey && e.altKey && !e.shiftKey) {
                        node22.disconnectOutput(i2);
                      }
                    }
                    if (is_double_click) {
                      if (node22.onOutputDblClick) {
                        node22.onOutputDblClick(i2, e);
                      }
                    } else {
                      if (node22.onOutputClick) {
                        node22.onOutputClick(i2, e);
                      }
                    }
                    skip_action = true;
                    break;
                  }
                }
              }
              if (node22.inputs) {
                for (var i2 = 0, l = node22.inputs.length; i2 < l; ++i2) {
                  var input = node22.inputs[i2];
                  var link_pos = node22.getConnectionPos(true, i2);
                  if (isInsideRectangle(
                    e.canvasX,
                    e.canvasY,
                    link_pos[0] - 15,
                    link_pos[1] - 10,
                    30,
                    20
                  )) {
                    if (is_double_click) {
                      if (node22.onInputDblClick) {
                        node22.onInputDblClick(i2, e);
                      }
                    } else {
                      if (node22.onInputClick) {
                        node22.onInputClick(i2, e);
                      }
                    }
                    if (input.link !== null) {
                      var link_info = this.graph.links[input.link];
                      if (LiteGraph.click_do_break_link_to || LiteGraph.ctrl_alt_click_do_break_link && e.ctrlKey && e.altKey && !e.shiftKey) {
                        node22.disconnectInput(i2);
                      } else if (this.allow_reconnect_links || //this.move_destination_link_without_shift ||
                      e.shiftKey) {
                        if (!LiteGraph.click_do_break_link_to) {
                          node22.disconnectInput(i2);
                        }
                        const linked_node = this.graph._nodes_by_id[link_info.origin_id];
                        const slot = link_info.origin_slot;
                        this.connecting_links = [
                          {
                            node: linked_node,
                            slot,
                            input: null,
                            output: linked_node.outputs[slot],
                            pos: linked_node.getConnectionPos(false, slot)
                          }
                        ];
                        this.dirty_bgcanvas = true;
                        skip_action = true;
                      } else ;
                    }
                    if (!skip_action) {
                      this.connecting_links = [
                        {
                          node: node22,
                          slot: i2,
                          input,
                          output: null,
                          pos: link_pos
                        }
                      ];
                      this.dirty_bgcanvas = true;
                      skip_action = true;
                    }
                    break;
                  }
                }
              }
            }
          }
          if (!skip_action) {
            var block_drag_node = false;
            if (node22 == null ? void 0 : node22.pinned) {
              block_drag_node = true;
            }
            var pos2 = [e.canvasX - node22.pos[0], e.canvasY - node22.pos[1]];
            var widget = this.processNodeWidgets(node22, this.graph_mouse, e);
            if (widget) {
              block_drag_node = true;
              this.node_widget = [node22, widget];
            }
            if (this.allow_interaction && is_double_click && this.selected_nodes[node22.id]) {
              if (pos2[1] < 0) {
                if (node22.onNodeTitleDblClick) {
                  node22.onNodeTitleDblClick(e, pos2, this);
                }
              }
              if (node22.onDblClick) {
                node22.onDblClick(e, pos2, this);
              }
              this.processNodeDblClicked(node22);
              block_drag_node = true;
            }
            if (node22.onMouseDown && node22.onMouseDown(e, pos2, this)) {
              block_drag_node = true;
            } else {
              if (node22.subgraph && !node22.skip_subgraph_button) {
                if (!node22.flags.collapsed && pos2[0] > node22.size[0] - LiteGraph.NODE_TITLE_HEIGHT && pos2[1] < 0) {
                  var that2 = this;
                  setTimeout(function() {
                    that2.openSubgraph(node22.subgraph);
                  }, 10);
                }
              }
              if (this.live_mode) {
                clicking_canvas_bg = true;
                block_drag_node = true;
              }
            }
            if (!block_drag_node) {
              if (this.allow_dragnodes) {
                this.graph.beforeChange();
                this.node_dragged = node22;
              }
              if (!(e.shiftKey && !e.ctrlKey && !e.altKey) || !node22.is_selected) {
                this.processNodeSelected(node22, e);
              }
            } else {
              if (!node22.is_selected) this.processNodeSelected(node22, e);
            }
            this.dirty_canvas = true;
          }
        } else {
          if (!skip_action) {
            if (!this.read_only) {
              for (var i2 = 0; i2 < this.visible_links.length; ++i2) {
                var link = this.visible_links[i2];
                var center = link._pos;
                if (!center || e.canvasX < center[0] - 4 || e.canvasX > center[0] + 4 || e.canvasY < center[1] - 4 || e.canvasY > center[1] + 4) {
                  continue;
                }
                this.showLinkMenu(link, e);
                this.over_link_center = null;
                break;
              }
            }
            this.selected_group = this.graph.getGroupOnPos(e.canvasX, e.canvasY);
            this.selected_group_resizing = false;
            if (this.selected_group && !this.read_only) {
              if (e.ctrlKey) {
                this.dragging_rectangle = null;
              }
              var dist2 = distance([e.canvasX, e.canvasY], [this.selected_group.pos[0] + this.selected_group.size[0], this.selected_group.pos[1] + this.selected_group.size[1]]);
              if (dist2 * this.ds.scale < 10) {
                this.selected_group_resizing = true;
              } else {
                this.selected_group.recomputeInsideNodes();
              }
              if (is_double_click) {
                this.canvas.dispatchEvent(new CustomEvent(
                  "litegraph:canvas",
                  {
                    bubbles: true,
                    detail: {
                      subType: "group-double-click",
                      originalEvent: e,
                      group: this.selected_group
                    }
                  }
                ));
              }
            } else if (is_double_click && !this.read_only) {
              if (this.allow_searchbox) {
                this.showSearchBox(e);
                e.preventDefault();
                e.stopPropagation();
              }
              this.canvas.dispatchEvent(new CustomEvent(
                "litegraph:canvas",
                {
                  bubbles: true,
                  detail: {
                    subType: "empty-double-click",
                    originalEvent: e
                  }
                }
              ));
            }
            clicking_canvas_bg = true;
          }
        }
        if (!skip_action && clicking_canvas_bg && this.allow_dragcanvas) {
          this.dragging_canvas = true;
        }
      } else if (e.which == 2) {
        if (LiteGraph.middle_click_slot_add_default_node) {
          if (node22 && this.allow_interaction && !skip_action && !this.read_only) {
            if (!this.connecting_links && !node22.flags.collapsed && !this.live_mode) {
              var mClikSlot = false;
              var mClikSlot_index = false;
              var mClikSlot_isOut = false;
              if (node22.outputs) {
                for (var i2 = 0, l = node22.outputs.length; i2 < l; ++i2) {
                  var output = node22.outputs[i2];
                  var link_pos = node22.getConnectionPos(false, i2);
                  if (isInsideRectangle(e.canvasX, e.canvasY, link_pos[0] - 15, link_pos[1] - 10, 30, 20)) {
                    mClikSlot = output;
                    mClikSlot_index = i2;
                    mClikSlot_isOut = true;
                    break;
                  }
                }
              }
              if (node22.inputs) {
                for (var i2 = 0, l = node22.inputs.length; i2 < l; ++i2) {
                  var input = node22.inputs[i2];
                  var link_pos = node22.getConnectionPos(true, i2);
                  if (isInsideRectangle(e.canvasX, e.canvasY, link_pos[0] - 15, link_pos[1] - 10, 30, 20)) {
                    mClikSlot = input;
                    mClikSlot_index = i2;
                    mClikSlot_isOut = false;
                    break;
                  }
                }
              }
              if (mClikSlot && mClikSlot_index !== false) {
                var alphaPosY = 0.5 - (mClikSlot_index + 1) / (mClikSlot_isOut ? node22.outputs.length : node22.inputs.length);
                var node_bounding = node22.getBounding();
                var posRef = [
                  !mClikSlot_isOut ? node_bounding[0] : node_bounding[0] + node_bounding[2],
                  e.canvasY - 80
                  // + node_bounding[0]/this.canvas.width*66 // vertical "derive"
                ];
                this.createDefaultNodeForSlot({
                  nodeFrom: !mClikSlot_isOut ? null : node22,
                  slotFrom: !mClikSlot_isOut ? null : mClikSlot_index,
                  nodeTo: !mClikSlot_isOut ? node22 : null,
                  slotTo: !mClikSlot_isOut ? mClikSlot_index : null,
                  position: posRef,
                  nodeType: "AUTO",
                  posAdd: [!mClikSlot_isOut ? -30 : 30, -alphaPosY * 130],
                  posSizeFix: [!mClikSlot_isOut ? -1 : 0, 0]
                  //-alphaPosY*2*/
                });
                skip_action = true;
              }
            }
          }
        }
        if (!skip_action && this.allow_dragcanvas) {
          this.dragging_canvas = true;
        }
      } else if (e.which == 3 || this.pointer_is_double) {
        if (this.allow_interaction && !skip_action && !this.read_only) {
          if (node22) {
            if (Object.keys(this.selected_nodes).length && (this.selected_nodes[node22.id] || e.shiftKey || e.ctrlKey || e.metaKey)) {
              if (!this.selected_nodes[node22.id]) this.selectNodes([node22], true);
            } else {
              this.selectNodes([node22]);
            }
          }
          this.processContextMenu(node22, e);
        }
      }
      this.last_mouse[0] = e.clientX;
      this.last_mouse[1] = e.clientY;
      this.last_mouseclick = LiteGraph.getTime();
      this.last_mouse_dragging = true;
      this.graph.change();
      if (!ref_window2.document.activeElement || ref_window2.document.activeElement.nodeName.toLowerCase() != "input" && ref_window2.document.activeElement.nodeName.toLowerCase() != "textarea") {
        e.preventDefault();
      }
      e.stopPropagation();
      if (this.onMouseDown) {
        this.onMouseDown(e);
      }
      return false;
    }
    /**
         * Called when a mouse move event has to be processed
         * @method processMouseMove
         **/
    processMouseMove(e) {
      if (this.autoresize) {
        this.resize();
      }
      if (this.set_canvas_dirty_on_mouse_event)
        this.dirty_canvas = true;
      if (!this.graph) {
        return;
      }
      __LGraphCanvas.active_canvas = this;
      this.adjustMouseEvent(e);
      var mouse = [e.clientX, e.clientY];
      this.mouse[0] = mouse[0];
      this.mouse[1] = mouse[1];
      var delta2 = [
        mouse[0] - this.last_mouse[0],
        mouse[1] - this.last_mouse[1]
      ];
      this.last_mouse = mouse;
      this.graph_mouse[0] = e.canvasX;
      this.graph_mouse[1] = e.canvasY;
      if (this.block_click) {
        e.preventDefault();
        return false;
      }
      e.dragging = this.last_mouse_dragging;
      if (this.node_widget) {
        this.processNodeWidgets(
          this.node_widget[0],
          this.graph_mouse,
          e,
          this.node_widget[1]
        );
        this.dirty_canvas = true;
      }
      var node22 = this.graph.getNodeOnPos(e.canvasX, e.canvasY, this.visible_nodes);
      if (this.dragging_rectangle) {
        this.dragging_rectangle[2] = e.canvasX - this.dragging_rectangle[0];
        this.dragging_rectangle[3] = e.canvasY - this.dragging_rectangle[1];
        this.dirty_canvas = true;
      } else if (this.selected_group && !this.read_only) {
        if (this.selected_group_resizing) {
          this.selected_group.resize(
            e.canvasX - this.selected_group.pos[0],
            e.canvasY - this.selected_group.pos[1]
          );
        } else {
          var deltax = delta2[0] / this.ds.scale;
          var deltay = delta2[1] / this.ds.scale;
          this.selected_group.move(deltax, deltay, e.ctrlKey);
          if (this.selected_group._nodes.length) {
            this.dirty_canvas = true;
          }
        }
        this.dirty_bgcanvas = true;
      } else if (this.dragging_canvas) {
        this.ds.offset[0] += delta2[0] / this.ds.scale;
        this.ds.offset[1] += delta2[1] / this.ds.scale;
        this.dirty_canvas = true;
        this.dirty_bgcanvas = true;
      } else if ((this.allow_interaction || node22 && node22.flags.allow_interaction) && !this.read_only) {
        if (this.connecting_links) {
          this.dirty_canvas = true;
        }
        for (var i2 = 0, l = this.graph._nodes.length; i2 < l; ++i2) {
          if (this.graph._nodes[i2].mouseOver && node22 != this.graph._nodes[i2]) {
            this.graph._nodes[i2].mouseOver = false;
            if (this.node_over && this.node_over.onMouseLeave) {
              this.node_over.onMouseLeave(e);
            }
            this.node_over = null;
            this.dirty_canvas = true;
          }
        }
        if (node22) {
          if (node22.redraw_on_mouse)
            this.dirty_canvas = true;
          if (!node22.mouseOver) {
            node22.mouseOver = true;
            this.node_over = node22;
            this.dirty_canvas = true;
            if (node22.onMouseEnter) {
              node22.onMouseEnter(e);
            }
          }
          if (node22.onMouseMove) {
            node22.onMouseMove(e, [e.canvasX - node22.pos[0], e.canvasY - node22.pos[1]], this);
          }
          if (this.connecting_links) {
            const firstLink = this.connecting_links[0];
            if (firstLink.output) {
              var pos2 = this._highlight_input || [0, 0];
              if (this.isOverNodeBox(node22, e.canvasX, e.canvasY)) ;
              else {
                var slot = this.isOverNodeInput(node22, e.canvasX, e.canvasY, pos2);
                if (slot != -1 && node22.inputs[slot] && LiteGraph.isValidConnection(firstLink.output.type, node22.inputs[slot].type)) {
                  this._highlight_input = pos2;
                  this._highlight_input_slot = node22.inputs[slot];
                } else {
                  this._highlight_input = null;
                  this._highlight_input_slot = null;
                }
              }
            } else if (firstLink.input) {
              var pos2 = this._highlight_output || [0, 0];
              if (this.isOverNodeBox(node22, e.canvasX, e.canvasY)) ;
              else {
                var slot = this.isOverNodeOutput(node22, e.canvasX, e.canvasY, pos2);
                if (slot != -1 && node22.outputs[slot] && LiteGraph.isValidConnection(firstLink.input.type, node22.outputs[slot].type)) {
                  this._highlight_output = pos2;
                } else {
                  this._highlight_output = null;
                }
              }
            }
          }
          if (this.canvas) {
            if (node22.inResizeCorner(e.canvasX, e.canvasY)) {
              this.canvas.style.cursor = "se-resize";
            } else {
              this.canvas.style.cursor = "crosshair";
            }
          }
        } else {
          var over_link = null;
          for (var i2 = 0; i2 < this.visible_links.length; ++i2) {
            var link = this.visible_links[i2];
            var center = link._pos;
            if (!center || e.canvasX < center[0] - 4 || e.canvasX > center[0] + 4 || e.canvasY < center[1] - 4 || e.canvasY > center[1] + 4) {
              continue;
            }
            over_link = link;
            break;
          }
          if (over_link != this.over_link_center) {
            this.over_link_center = over_link;
            this.dirty_canvas = true;
          }
          if (this.canvas) {
            this.canvas.style.cursor = "";
          }
        }
        if (this.node_capturing_input && this.node_capturing_input != node22 && this.node_capturing_input.onMouseMove) {
          this.node_capturing_input.onMouseMove(e, [e.canvasX - this.node_capturing_input.pos[0], e.canvasY - this.node_capturing_input.pos[1]], this);
        }
        if (this.node_dragged && !this.live_mode) {
          for (var i2 in this.selected_nodes) {
            var n = this.selected_nodes[i2];
            n.pos[0] += delta2[0] / this.ds.scale;
            n.pos[1] += delta2[1] / this.ds.scale;
            if (!n.is_selected) this.processNodeSelected(n, e);
          }
          this.dirty_canvas = true;
          this.dirty_bgcanvas = true;
        }
        if (this.resizing_node && !this.live_mode) {
          var desired_size = [e.canvasX - this.resizing_node.pos[0], e.canvasY - this.resizing_node.pos[1]];
          var min_size = this.resizing_node.computeSize();
          desired_size[0] = Math.max(min_size[0], desired_size[0]);
          desired_size[1] = Math.max(min_size[1], desired_size[1]);
          this.resizing_node.setSize(desired_size);
          this.canvas.style.cursor = "se-resize";
          this.dirty_canvas = true;
          this.dirty_bgcanvas = true;
        }
      }
      e.preventDefault();
      return false;
    }
    /**
         * Called when a mouse up event has to be processed
         * @method processMouseUp
         **/
    processMouseUp(e) {
      var is_primary = e.isPrimary === void 0 || e.isPrimary;
      if (!is_primary) {
        return false;
      }
      if (!this.graph)
        return;
      var window2 = this.getCanvasWindow();
      var document2 = window2.document;
      __LGraphCanvas.active_canvas = this;
      if (!this.options.skip_events) {
        LiteGraph.pointerListenerRemove(document2, "move", this._mousemove_callback, true);
        LiteGraph.pointerListenerAdd(this.canvas, "move", this._mousemove_callback, true);
        LiteGraph.pointerListenerRemove(document2, "up", this._mouseup_callback, true);
      }
      this.adjustMouseEvent(e);
      var now2 = LiteGraph.getTime();
      e.click_time = now2 - this.last_mouseclick;
      this.last_mouse_dragging = false;
      this.last_click_position = null;
      if (this.block_click) {
        this.block_click = false;
      }
      if (e.which == 1) {
        if (this.node_widget) {
          this.processNodeWidgets(this.node_widget[0], this.graph_mouse, e);
        }
        this.node_widget = null;
        if (this.selected_group) {
          var diffx = this.selected_group.pos[0] - Math.round(this.selected_group.pos[0]);
          var diffy = this.selected_group.pos[1] - Math.round(this.selected_group.pos[1]);
          this.selected_group.move(diffx, diffy, e.ctrlKey);
          this.selected_group.pos[0] = Math.round(
            this.selected_group.pos[0]
          );
          this.selected_group.pos[1] = Math.round(
            this.selected_group.pos[1]
          );
          if (this.selected_group._nodes.length) {
            this.dirty_canvas = true;
          }
          this.selected_group = null;
        }
        this.selected_group_resizing = false;
        var node22 = this.graph.getNodeOnPos(
          e.canvasX,
          e.canvasY,
          this.visible_nodes
        );
        if (this.dragging_rectangle) {
          if (this.graph) {
            var nodes = this.graph._nodes;
            var node_bounding = new Float32Array(4);
            var w2 = Math.abs(this.dragging_rectangle[2]);
            var h2 = Math.abs(this.dragging_rectangle[3]);
            var startx = this.dragging_rectangle[2] < 0 ? this.dragging_rectangle[0] - w2 : this.dragging_rectangle[0];
            var starty = this.dragging_rectangle[3] < 0 ? this.dragging_rectangle[1] - h2 : this.dragging_rectangle[1];
            this.dragging_rectangle[0] = startx;
            this.dragging_rectangle[1] = starty;
            this.dragging_rectangle[2] = w2;
            this.dragging_rectangle[3] = h2;
            if (!node22 || w2 > 10 && h2 > 10) {
              var to_select = [];
              for (var i2 = 0; i2 < nodes.length; ++i2) {
                var nodeX = nodes[i2];
                nodeX.getBounding(node_bounding);
                if (!overlapBounding(
                  this.dragging_rectangle,
                  node_bounding
                )) {
                  continue;
                }
                to_select.push(nodeX);
              }
              if (to_select.length) {
                this.selectNodes(to_select, e.shiftKey);
              }
            } else {
              this.selectNodes([node22], e.shiftKey || e.ctrlKey);
            }
          }
          this.dragging_rectangle = null;
        } else if (this.connecting_links) {
          if (node22) {
            for (const link of this.connecting_links) {
              this.dirty_canvas = true;
              this.dirty_bgcanvas = true;
              if (link.output) {
                var slot = this.isOverNodeInput(
                  node22,
                  e.canvasX,
                  e.canvasY
                );
                if (slot != -1) {
                  link.node.connect(link.slot, node22, slot);
                } else {
                  link.node.connectByType(link.slot, node22, link.output.type);
                }
              } else if (link.input) {
                var slot = this.isOverNodeOutput(
                  node22,
                  e.canvasX,
                  e.canvasY
                );
                if (slot != -1) {
                  node22.connect(slot, link.node, link.slot);
                } else {
                  link.node.connectByTypeOutput(link.slot, node22, link.input.type);
                }
              }
            }
          } else {
            const firstLink = this.connecting_links[0];
            const linkReleaseContext = firstLink.output ? {
              node_from: firstLink.node,
              slot_from: firstLink.output,
              type_filter_in: firstLink.output.type
            } : {
              node_to: firstLink.node,
              slot_from: firstLink.input,
              type_filter_out: firstLink.input.type
            };
            const linkReleaseContextExtended = {
              links: this.connecting_links
            };
            this.canvas.dispatchEvent(new CustomEvent(
              "litegraph:canvas",
              {
                bubbles: true,
                detail: {
                  subType: "empty-release",
                  originalEvent: e,
                  linkReleaseContext: linkReleaseContextExtended
                }
              }
            ));
            if (LiteGraph.release_link_on_empty_shows_menu) {
              if (e.shiftKey) {
                if (this.allow_searchbox) {
                  this.showSearchBox(e, linkReleaseContext);
                }
              } else {
                if (firstLink.output) {
                  this.showConnectionMenu({ nodeFrom: firstLink.node, slotFrom: firstLink.output, e });
                } else if (firstLink.input) {
                  this.showConnectionMenu({ nodeTo: firstLink.node, slotTo: firstLink.input, e });
                }
              }
            }
          }
          this.connecting_links = null;
        } else if (this.resizing_node) {
          this.dirty_canvas = true;
          this.dirty_bgcanvas = true;
          this.graph.afterChange(this.resizing_node);
          this.resizing_node = null;
        } else if (this.node_dragged) {
          var node22 = this.node_dragged;
          if (node22 && e.click_time < 300 && isInsideRectangle(e.canvasX, e.canvasY, node22.pos[0], node22.pos[1] - LiteGraph.NODE_TITLE_HEIGHT, LiteGraph.NODE_TITLE_HEIGHT, LiteGraph.NODE_TITLE_HEIGHT)) {
            node22.collapse();
          }
          this.dirty_canvas = true;
          this.dirty_bgcanvas = true;
          this.node_dragged.pos[0] = Math.round(this.node_dragged.pos[0]);
          this.node_dragged.pos[1] = Math.round(this.node_dragged.pos[1]);
          if (this.graph.config.align_to_grid || this.align_to_grid) {
            this.node_dragged.alignToGrid();
          }
          if (this.onNodeMoved)
            this.onNodeMoved(this.node_dragged);
          this.graph.afterChange(this.node_dragged);
          this.node_dragged = null;
        } else {
          var node22 = this.graph.getNodeOnPos(
            e.canvasX,
            e.canvasY,
            this.visible_nodes
          );
          if (!node22 && e.click_time < 300) {
            this.deselectAllNodes();
          }
          this.dirty_canvas = true;
          this.dragging_canvas = false;
          if (this.node_over && this.node_over.onMouseUp) {
            this.node_over.onMouseUp(e, [e.canvasX - this.node_over.pos[0], e.canvasY - this.node_over.pos[1]], this);
          }
          if (this.node_capturing_input && this.node_capturing_input.onMouseUp) {
            this.node_capturing_input.onMouseUp(e, [
              e.canvasX - this.node_capturing_input.pos[0],
              e.canvasY - this.node_capturing_input.pos[1]
            ]);
          }
        }
      } else if (e.which == 2) {
        this.dirty_canvas = true;
        this.dragging_canvas = false;
      } else if (e.which == 3) {
        this.dirty_canvas = true;
        this.dragging_canvas = false;
      }
      if (is_primary) {
        this.pointer_is_down = false;
        this.pointer_is_double = false;
      }
      this.graph.change();
      e.stopPropagation();
      e.preventDefault();
      return false;
    }
    /**
         * Called when a mouse wheel event has to be processed
         * @method processMouseWheel
         **/
    processMouseWheel(e) {
      if (!this.graph || !this.allow_dragcanvas) {
        return;
      }
      var delta2 = e.wheelDeltaY != null ? e.wheelDeltaY : e.detail * -60;
      this.adjustMouseEvent(e);
      var x2 = e.clientX;
      var y2 = e.clientY;
      var is_inside = !this.viewport || this.viewport && x2 >= this.viewport[0] && x2 < this.viewport[0] + this.viewport[2] && y2 >= this.viewport[1] && y2 < this.viewport[1] + this.viewport[3];
      if (!is_inside)
        return;
      var scale = this.ds.scale;
      if (delta2 > 0) {
        scale *= this.zoom_speed;
      } else if (delta2 < 0) {
        scale *= 1 / this.zoom_speed;
      }
      this.ds.changeScale(scale, [e.clientX, e.clientY]);
      this.graph.change();
      e.preventDefault();
      return false;
    }
    /**
         * returns true if a position (in graph space) is on top of a node little corner box
         * @method isOverNodeBox
         **/
    isOverNodeBox(node22, canvasx, canvasy) {
      var title_height = LiteGraph.NODE_TITLE_HEIGHT;
      if (isInsideRectangle(
        canvasx,
        canvasy,
        node22.pos[0] + 2,
        node22.pos[1] + 2 - title_height,
        title_height - 4,
        title_height - 4
      )) {
        return true;
      }
      return false;
    }
    /**
         * returns the INDEX if a position (in graph space) is on top of a node input slot
         * @method isOverNodeInput
         **/
    isOverNodeInput(node22, canvasx, canvasy, slot_pos) {
      var _a, _b;
      if (node22.inputs) {
        for (var i2 = 0, l = node22.inputs.length; i2 < l; ++i2) {
          var input = node22.inputs[i2];
          var link_pos = node22.getConnectionPos(true, i2);
          var is_inside = false;
          if (node22.horizontal) {
            is_inside = isInsideRectangle(
              canvasx,
              canvasy,
              link_pos[0] - 5,
              link_pos[1] - 10,
              10,
              20
            );
          } else {
            const width2 = 20 + ((((_a = input.label) == null ? void 0 : _a.length) ?? ((_b = input.name) == null ? void 0 : _b.length)) || 3) * 7;
            is_inside = isInsideRectangle(
              canvasx,
              canvasy,
              link_pos[0] - 10,
              link_pos[1] - 10,
              width2,
              20
            );
          }
          if (is_inside) {
            if (slot_pos) {
              slot_pos[0] = link_pos[0];
              slot_pos[1] = link_pos[1];
            }
            return i2;
          }
        }
      }
      return -1;
    }
    /**
         * returns the INDEX if a position (in graph space) is on top of a node output slot
         * @method isOverNodeOuput
         **/
    isOverNodeOutput(node22, canvasx, canvasy, slot_pos) {
      if (node22.outputs) {
        for (var i2 = 0, l = node22.outputs.length; i2 < l; ++i2) {
          node22.outputs[i2];
          var link_pos = node22.getConnectionPos(false, i2);
          var is_inside = false;
          if (node22.horizontal) {
            is_inside = isInsideRectangle(
              canvasx,
              canvasy,
              link_pos[0] - 5,
              link_pos[1] - 10,
              10,
              20
            );
          } else {
            is_inside = isInsideRectangle(
              canvasx,
              canvasy,
              link_pos[0] - 10,
              link_pos[1] - 10,
              40,
              20
            );
          }
          if (is_inside) {
            if (slot_pos) {
              slot_pos[0] = link_pos[0];
              slot_pos[1] = link_pos[1];
            }
            return i2;
          }
        }
      }
      return -1;
    }
    /**
         * process a key event
         * @method processKey
         **/
    processKey(e) {
      if (!this.graph) {
        return;
      }
      var block_default = false;
      if (e.target.localName == "input") {
        return;
      }
      if (e.type == "keydown") {
        if (e.keyCode == 32) {
          this.dragging_canvas = true;
          block_default = true;
        }
        if (e.keyCode == 27) {
          if (this.node_panel) this.node_panel.close();
          if (this.options_panel) this.options_panel.close();
          block_default = true;
        }
        if (e.keyCode == 65 && e.ctrlKey) {
          this.selectNodes();
          block_default = true;
        }
        if (e.keyCode === 67 && (e.metaKey || e.ctrlKey) && !e.shiftKey) {
          if (this.selected_nodes) {
            this.copyToClipboard();
            block_default = true;
          }
        }
        if (e.keyCode === 86 && (e.metaKey || e.ctrlKey)) {
          this.pasteFromClipboard(e.shiftKey);
        }
        if (e.keyCode == 46 || e.keyCode == 8) {
          if (e.target.localName != "input" && e.target.localName != "textarea") {
            this.deleteSelectedNodes();
            block_default = true;
          }
        }
        if (this.selected_nodes) {
          for (var i2 in this.selected_nodes) {
            if (this.selected_nodes[i2].onKeyDown) {
              this.selected_nodes[i2].onKeyDown(e);
            }
          }
        }
      } else if (e.type == "keyup") {
        if (e.keyCode == 32) {
          this.dragging_canvas = false;
        }
        if (this.selected_nodes) {
          for (var i2 in this.selected_nodes) {
            if (this.selected_nodes[i2].onKeyUp) {
              this.selected_nodes[i2].onKeyUp(e);
            }
          }
        }
      }
      this.graph.change();
      if (block_default) {
        e.preventDefault();
        e.stopImmediatePropagation();
        return false;
      }
    }
    copyToClipboard(nodes) {
      var clipboard_info = {
        nodes: [],
        links: []
      };
      var index2 = 0;
      var selected_nodes_array = [];
      if (!nodes) nodes = this.selected_nodes;
      for (var i2 in nodes) {
        var node22 = nodes[i2];
        if (node22.clonable === false)
          continue;
        node22._relative_id = index2;
        selected_nodes_array.push(node22);
        index2 += 1;
      }
      for (var i2 = 0; i2 < selected_nodes_array.length; ++i2) {
        var node22 = selected_nodes_array[i2];
        var cloned = node22.clone();
        if (!cloned) {
          console.warn("node type not found: " + node22.type);
          continue;
        }
        clipboard_info.nodes.push(cloned.serialize());
        if (node22.inputs && node22.inputs.length) {
          for (var j = 0; j < node22.inputs.length; ++j) {
            var input = node22.inputs[j];
            if (!input || input.link == null) {
              continue;
            }
            var link_info = this.graph.links[input.link];
            if (!link_info) {
              continue;
            }
            var target_node = this.graph.getNodeById(
              link_info.origin_id
            );
            if (!target_node) {
              continue;
            }
            clipboard_info.links.push([
              target_node._relative_id,
              link_info.origin_slot,
              //j,
              node22._relative_id,
              link_info.target_slot,
              target_node.id
            ]);
          }
        }
      }
      localStorage.setItem(
        "litegrapheditor_clipboard",
        JSON.stringify(clipboard_info)
      );
    }
    pasteFromClipboard(isConnectUnselected = false) {
      if (!LiteGraph.ctrl_shift_v_paste_connect_unselected_outputs && isConnectUnselected) {
        return;
      }
      var data24 = localStorage.getItem("litegrapheditor_clipboard");
      if (!data24) {
        return;
      }
      this.graph.beforeChange();
      var clipboard_info = JSON.parse(data24);
      var posMin = false;
      var posMinIndexes = false;
      for (var i2 = 0; i2 < clipboard_info.nodes.length; ++i2) {
        if (posMin) {
          if (posMin[0] > clipboard_info.nodes[i2].pos[0]) {
            posMin[0] = clipboard_info.nodes[i2].pos[0];
            posMinIndexes[0] = i2;
          }
          if (posMin[1] > clipboard_info.nodes[i2].pos[1]) {
            posMin[1] = clipboard_info.nodes[i2].pos[1];
            posMinIndexes[1] = i2;
          }
        } else {
          posMin = [clipboard_info.nodes[i2].pos[0], clipboard_info.nodes[i2].pos[1]];
          posMinIndexes = [i2, i2];
        }
      }
      var nodes = [];
      for (var i2 = 0; i2 < clipboard_info.nodes.length; ++i2) {
        var node_data = clipboard_info.nodes[i2];
        var node22 = LiteGraph.createNode(node_data.type);
        if (node22) {
          node22.configure(node_data);
          node22.pos[0] += this.graph_mouse[0] - posMin[0];
          node22.pos[1] += this.graph_mouse[1] - posMin[1];
          this.graph.add(node22, { doProcessChange: false });
          nodes.push(node22);
        }
      }
      for (var i2 = 0; i2 < clipboard_info.links.length; ++i2) {
        var link_info = clipboard_info.links[i2];
        var origin_node = void 0;
        var origin_node_relative_id = link_info[0];
        if (origin_node_relative_id != null) {
          origin_node = nodes[origin_node_relative_id];
        } else if (LiteGraph.ctrl_shift_v_paste_connect_unselected_outputs && isConnectUnselected) {
          var origin_node_id = link_info[4];
          if (origin_node_id) {
            origin_node = this.graph.getNodeById(origin_node_id);
          }
        }
        var target_node = nodes[link_info[2]];
        if (origin_node && target_node)
          origin_node.connect(link_info[1], target_node, link_info[3]);
        else
          console.warn("Warning, nodes missing on pasting");
      }
      this.selectNodes(nodes);
      this.graph.afterChange();
    }
    /**
         * process a item drop event on top the canvas
         * @method processDrop
         **/
    processDrop(e) {
      e.preventDefault();
      this.adjustMouseEvent(e);
      var x2 = e.clientX;
      var y2 = e.clientY;
      var is_inside = !this.viewport || this.viewport && x2 >= this.viewport[0] && x2 < this.viewport[0] + this.viewport[2] && y2 >= this.viewport[1] && y2 < this.viewport[1] + this.viewport[3];
      if (!is_inside) {
        return;
      }
      var pos2 = [e.canvasX, e.canvasY];
      var node22 = this.graph ? this.graph.getNodeOnPos(pos2[0], pos2[1]) : null;
      if (!node22) {
        var r = null;
        if (this.onDropItem) {
          r = this.onDropItem(event);
        }
        if (!r) {
          this.checkDropItem(e);
        }
        return;
      }
      if (node22.onDropFile || node22.onDropData) {
        var files = e.dataTransfer.files;
        if (files && files.length) {
          for (var i2 = 0; i2 < files.length; i2++) {
            var file = e.dataTransfer.files[0];
            var filename = file.name;
            __LGraphCanvas.getFileExtension(filename);
            if (node22.onDropFile) {
              node22.onDropFile(file);
            }
            if (node22.onDropData) {
              var reader = new FileReader();
              reader.onload = function(event2) {
                var data24 = event2.target.result;
                node22.onDropData(data24, filename, file);
              };
              var type = file.type.split("/")[0];
              if (type == "text" || type == "") {
                reader.readAsText(file);
              } else if (type == "image") {
                reader.readAsDataURL(file);
              } else {
                reader.readAsArrayBuffer(file);
              }
            }
          }
        }
      }
      if (node22.onDropItem) {
        if (node22.onDropItem(event)) {
          return true;
        }
      }
      if (this.onDropItem) {
        return this.onDropItem(event);
      }
      return false;
    }
    //called if the graph doesn't have a default drop item behaviour
    checkDropItem(e) {
      if (e.dataTransfer.files.length) {
        var file = e.dataTransfer.files[0];
        var ext = __LGraphCanvas.getFileExtension(file.name).toLowerCase();
        var nodetype = LiteGraph.node_types_by_file_extension[ext];
        if (nodetype) {
          this.graph.beforeChange();
          var node22 = LiteGraph.createNode(nodetype.type);
          node22.pos = [e.canvasX, e.canvasY];
          this.graph.add(node22);
          if (node22.onDropFile) {
            node22.onDropFile(file);
          }
          this.graph.afterChange();
        }
      }
    }
    processNodeDblClicked(n) {
      if (this.onShowNodePanel) {
        this.onShowNodePanel(n);
      }
      if (this.onNodeDblClicked) {
        this.onNodeDblClicked(n);
      }
      this.setDirty(true);
    }
    processNodeSelected(node22, e) {
      this.selectNode(node22, e && (e.shiftKey || e.ctrlKey || this.multi_select));
      if (this.onNodeSelected) {
        this.onNodeSelected(node22);
      }
    }
    /**
         * selects a given node (or adds it to the current selection)
         * @method selectNode
         **/
    selectNode(node22, add_to_current_selection) {
      if (node22 == null) {
        this.deselectAllNodes();
      } else {
        this.selectNodes([node22], add_to_current_selection);
      }
    }
    /**
         * selects several nodes (or adds them to the current selection)
         * @method selectNodes
         **/
    selectNodes(nodes, add_to_current_selection) {
      if (!add_to_current_selection) {
        this.deselectAllNodes();
      }
      nodes = nodes || this.graph._nodes;
      if (typeof nodes == "string") nodes = [nodes];
      for (var i2 in nodes) {
        var node22 = nodes[i2];
        if (node22.is_selected) {
          this.deselectNode(node22);
          continue;
        }
        if (!node22.is_selected && node22.onSelected) {
          node22.onSelected();
        }
        node22.is_selected = true;
        this.selected_nodes[node22.id] = node22;
        if (node22.inputs) {
          for (var j = 0; j < node22.inputs.length; ++j) {
            this.highlighted_links[node22.inputs[j].link] = true;
          }
        }
        if (node22.outputs) {
          for (var j = 0; j < node22.outputs.length; ++j) {
            var out = node22.outputs[j];
            if (out.links) {
              for (var k = 0; k < out.links.length; ++k) {
                this.highlighted_links[out.links[k]] = true;
              }
            }
          }
        }
      }
      if (this.onSelectionChange)
        this.onSelectionChange(this.selected_nodes);
      this.setDirty(true);
    }
    /**
         * removes a node from the current selection
         * @method deselectNode
         **/
    deselectNode(node22) {
      if (!node22.is_selected) {
        return;
      }
      if (node22.onDeselected) {
        node22.onDeselected();
      }
      node22.is_selected = false;
      delete this.selected_nodes[node22.id];
      if (this.onNodeDeselected) {
        this.onNodeDeselected(node22);
      }
      if (node22.inputs) {
        for (var i2 = 0; i2 < node22.inputs.length; ++i2) {
          delete this.highlighted_links[node22.inputs[i2].link];
        }
      }
      if (node22.outputs) {
        for (var i2 = 0; i2 < node22.outputs.length; ++i2) {
          var out = node22.outputs[i2];
          if (out.links) {
            for (var j = 0; j < out.links.length; ++j) {
              delete this.highlighted_links[out.links[j]];
            }
          }
        }
      }
    }
    /**
         * removes all nodes from the current selection
         * @method deselectAllNodes
         **/
    deselectAllNodes() {
      if (!this.graph) {
        return;
      }
      var nodes = this.graph._nodes;
      for (var i2 = 0, l = nodes.length; i2 < l; ++i2) {
        var node22 = nodes[i2];
        if (!node22.is_selected) {
          continue;
        }
        if (node22.onDeselected) {
          node22.onDeselected();
        }
        node22.is_selected = false;
        if (this.onNodeDeselected) {
          this.onNodeDeselected(node22);
        }
      }
      this.selected_nodes = {};
      this.current_node = null;
      this.highlighted_links = {};
      if (this.onSelectionChange)
        this.onSelectionChange(this.selected_nodes);
      this.setDirty(true);
    }
    /**
         * deletes all nodes in the current selection from the graph
         * @method deleteSelectedNodes
         **/
    deleteSelectedNodes() {
      this.graph.beforeChange();
      for (var i2 in this.selected_nodes) {
        var node22 = this.selected_nodes[i2];
        if (node22.block_delete)
          continue;
        if (node22.inputs && node22.inputs.length && node22.outputs && node22.outputs.length && LiteGraph.isValidConnection(node22.inputs[0].type, node22.outputs[0].type) && node22.inputs[0].link && node22.outputs[0].links && node22.outputs[0].links.length) {
          var input_link = node22.graph.links[node22.inputs[0].link];
          var output_link = node22.graph.links[node22.outputs[0].links[0]];
          var input_node = node22.getInputNode(0);
          var output_node = node22.getOutputNodes(0)[0];
          if (input_node && output_node)
            input_node.connect(input_link.origin_slot, output_node, output_link.target_slot);
        }
        this.graph.remove(node22);
        if (this.onNodeDeselected) {
          this.onNodeDeselected(node22);
        }
      }
      this.selected_nodes = {};
      this.current_node = null;
      this.highlighted_links = {};
      this.setDirty(true);
      this.graph.afterChange();
    }
    /**
         * centers the camera on a given node
         * @method centerOnNode
         **/
    centerOnNode(node22) {
      const dpi = (window == null ? void 0 : window.devicePixelRatio) || 1;
      this.ds.offset[0] = -node22.pos[0] - node22.size[0] * 0.5 + this.canvas.width * 0.5 / (this.ds.scale * dpi);
      this.ds.offset[1] = -node22.pos[1] - node22.size[1] * 0.5 + this.canvas.height * 0.5 / (this.ds.scale * dpi);
      this.setDirty(true, true);
    }
    /**
         * adds some useful properties to a mouse event, like the position in graph coordinates
         * @method adjustMouseEvent
         **/
    adjustMouseEvent(e) {
      var clientX_rel = 0;
      var clientY_rel = 0;
      if (this.canvas) {
        var b = this.canvas.getBoundingClientRect();
        clientX_rel = e.clientX - b.left;
        clientY_rel = e.clientY - b.top;
      } else {
        clientX_rel = e.clientX;
        clientY_rel = e.clientY;
      }
      if (e.deltaX === void 0)
        e.deltaX = clientX_rel - this.last_mouse_position[0];
      if (e.deltaY === void 0)
        e.deltaY = clientY_rel - this.last_mouse_position[1];
      this.last_mouse_position[0] = clientX_rel;
      this.last_mouse_position[1] = clientY_rel;
      e.canvasX = clientX_rel / this.ds.scale - this.ds.offset[0];
      e.canvasY = clientY_rel / this.ds.scale - this.ds.offset[1];
    }
    /**
         * changes the zoom level of the graph (default is 1), you can pass also a place used to pivot the zoom
         * @method setZoom
         **/
    setZoom(value3, zooming_center) {
      this.ds.changeScale(value3, zooming_center);
      this.dirty_canvas = true;
      this.dirty_bgcanvas = true;
    }
    /**
         * converts a coordinate from graph coordinates to canvas2D coordinates
         * @method convertOffsetToCanvas
         **/
    convertOffsetToCanvas(pos2, out) {
      return this.ds.convertOffsetToCanvas(pos2, out);
    }
    /**
         * converts a coordinate from Canvas2D coordinates to graph space
         * @method convertCanvasToOffset
         **/
    convertCanvasToOffset(pos2, out) {
      return this.ds.convertCanvasToOffset(pos2, out);
    }
    //converts event coordinates from canvas2D to graph coordinates
    convertEventToCanvasOffset(e) {
      var rect = this.canvas.getBoundingClientRect();
      return this.convertCanvasToOffset([
        e.clientX - rect.left,
        e.clientY - rect.top
      ]);
    }
    /**
         * brings a node to front (above all other nodes)
         * @method bringToFront
         **/
    bringToFront(node22) {
      var i2 = this.graph._nodes.indexOf(node22);
      if (i2 == -1) {
        return;
      }
      this.graph._nodes.splice(i2, 1);
      this.graph._nodes.push(node22);
    }
    /**
         * sends a node to the back (below all other nodes)
         * @method sendToBack
         **/
    sendToBack(node22) {
      var i2 = this.graph._nodes.indexOf(node22);
      if (i2 == -1) {
        return;
      }
      this.graph._nodes.splice(i2, 1);
      this.graph._nodes.unshift(node22);
    }
    /* LGraphCanvas render */
    /**
     * checks which nodes are visible (inside the camera area)
     * @method computeVisibleNodes
     **/
    computeVisibleNodes(nodes, out) {
      var visible_nodes = out || [];
      visible_nodes.length = 0;
      nodes = nodes || this.graph._nodes;
      for (var i2 = 0, l = nodes.length; i2 < l; ++i2) {
        var n = nodes[i2];
        if (this.live_mode && !n.onDrawBackground && !n.onDrawForeground) {
          continue;
        }
        if (!overlapBounding(this.visible_area, n.getBounding(__privateGet(__LGraphCanvas, _temp), true))) {
          continue;
        }
        visible_nodes.push(n);
      }
      return visible_nodes;
    }
    /**
         * renders the whole canvas content, by rendering in two separated canvas, one containing the background grid and the connections, and one containing the nodes)
         * @method draw
         **/
    draw(force_canvas, force_bgcanvas) {
      if (!this.canvas || this.canvas.width == 0 || this.canvas.height == 0) {
        return;
      }
      var now2 = LiteGraph.getTime();
      this.render_time = (now2 - this.last_draw_time) * 1e-3;
      this.last_draw_time = now2;
      if (this.graph) {
        this.ds.computeVisibleArea(this.viewport);
      }
      if (this.dirty_bgcanvas || force_bgcanvas || this.always_render_background || this.graph && this.graph._last_trigger_time && now2 - this.graph._last_trigger_time < 1e3) {
        this.drawBackCanvas();
      }
      if (this.dirty_canvas || force_canvas) {
        this.drawFrontCanvas();
      }
      this.fps = this.render_time ? 1 / this.render_time : 0;
      this.frame += 1;
    }
    /**
         * draws the front canvas (the one containing all the nodes)
         * @method drawFrontCanvas
         **/
    drawFrontCanvas() {
      this.dirty_canvas = false;
      if (!this.ctx) {
        this.ctx = this.bgcanvas.getContext("2d");
      }
      var ctx = this.ctx;
      if (!ctx) {
        return;
      }
      var canvas = this.canvas;
      if (ctx.start2D && !this.viewport) {
        ctx.start2D();
        ctx.restore();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
      }
      var area = this.viewport || this.dirty_area;
      if (area) {
        ctx.save();
        ctx.beginPath();
        ctx.rect(area[0], area[1], area[2], area[3]);
        ctx.clip();
      }
      if (this.clear_background) {
        if (area)
          ctx.clearRect(area[0], area[1], area[2], area[3]);
        else
          ctx.clearRect(0, 0, canvas.width, canvas.height);
      }
      if (this.bgcanvas == this.canvas) {
        this.drawBackCanvas();
      } else {
        ctx.drawImage(this.bgcanvas, 0, 0);
      }
      if (this.onRender) {
        this.onRender(canvas, ctx);
      }
      if (this.show_info) {
        this.renderInfo(ctx, area ? area[0] : 0, area ? area[1] : 0);
      }
      if (this.graph) {
        ctx.save();
        this.ds.toCanvasContext(ctx);
        var visible_nodes = this.computeVisibleNodes(
          null,
          this.visible_nodes
        );
        for (var i2 = 0; i2 < visible_nodes.length; ++i2) {
          var node22 = visible_nodes[i2];
          ctx.save();
          ctx.translate(node22.pos[0], node22.pos[1]);
          this.drawNode(node22, ctx);
          ctx.restore();
        }
        if (this.render_execution_order) {
          this.drawExecutionOrder(ctx);
        }
        if (this.graph.config.links_ontop) {
          if (!this.live_mode) {
            this.drawConnections(ctx);
          }
        }
        if (this.connecting_links) {
          for (const link of this.connecting_links) {
            ctx.lineWidth = this.connections_width;
            var link_color = null;
            var connInOrOut = link.output || link.input;
            var connType = connInOrOut.type;
            var connDir = connInOrOut.dir;
            if (connDir == null) {
              if (link.output)
                connDir = link.node.horizontal ? LiteGraph.DOWN : LiteGraph.RIGHT;
              else
                connDir = link.node.horizontal ? LiteGraph.UP : LiteGraph.LEFT;
            }
            var connShape = connInOrOut.shape;
            switch (connType) {
              case LiteGraph.EVENT:
                link_color = LiteGraph.EVENT_LINK_COLOR;
                break;
              default:
                link_color = LiteGraph.CONNECTING_LINK_COLOR;
            }
            this.renderLink(
              ctx,
              link.pos,
              [this.graph_mouse[0], this.graph_mouse[1]],
              null,
              false,
              null,
              link_color,
              connDir,
              LiteGraph.CENTER
            );
            ctx.beginPath();
            if (connType === LiteGraph.EVENT || connShape === LiteGraph.BOX_SHAPE) {
              ctx.rect(
                link.pos[0] - 6 + 0.5,
                link.pos[1] - 5 + 0.5,
                14,
                10
              );
              ctx.fill();
              ctx.beginPath();
              ctx.rect(
                this.graph_mouse[0] - 6 + 0.5,
                this.graph_mouse[1] - 5 + 0.5,
                14,
                10
              );
            } else if (connShape === LiteGraph.ARROW_SHAPE) {
              ctx.moveTo(link.pos[0] + 8, link.pos[1] + 0.5);
              ctx.lineTo(link.pos[0] - 4, link.pos[1] + 6 + 0.5);
              ctx.lineTo(link.pos[0] - 4, link.pos[1] - 6 + 0.5);
              ctx.closePath();
            } else {
              ctx.arc(
                link.pos[0],
                link.pos[1],
                4,
                0,
                Math.PI * 2
              );
              ctx.fill();
              ctx.beginPath();
              ctx.arc(
                this.graph_mouse[0],
                this.graph_mouse[1],
                4,
                0,
                Math.PI * 2
              );
            }
            ctx.fill();
            ctx.fillStyle = "#ffcc00";
            if (this._highlight_input) {
              ctx.beginPath();
              var shape = this._highlight_input_slot.shape;
              if (shape === LiteGraph.ARROW_SHAPE) {
                ctx.moveTo(this._highlight_input[0] + 8, this._highlight_input[1] + 0.5);
                ctx.lineTo(this._highlight_input[0] - 4, this._highlight_input[1] + 6 + 0.5);
                ctx.lineTo(this._highlight_input[0] - 4, this._highlight_input[1] - 6 + 0.5);
                ctx.closePath();
              } else {
                ctx.arc(
                  this._highlight_input[0],
                  this._highlight_input[1],
                  6,
                  0,
                  Math.PI * 2
                );
              }
              ctx.fill();
            }
            if (this._highlight_output) {
              ctx.beginPath();
              if (shape === LiteGraph.ARROW_SHAPE) {
                ctx.moveTo(this._highlight_output[0] + 8, this._highlight_output[1] + 0.5);
                ctx.lineTo(this._highlight_output[0] - 4, this._highlight_output[1] + 6 + 0.5);
                ctx.lineTo(this._highlight_output[0] - 4, this._highlight_output[1] - 6 + 0.5);
                ctx.closePath();
              } else {
                ctx.arc(
                  this._highlight_output[0],
                  this._highlight_output[1],
                  6,
                  0,
                  Math.PI * 2
                );
              }
              ctx.fill();
            }
          }
        }
        if (this.dragging_rectangle) {
          ctx.strokeStyle = "#FFF";
          ctx.strokeRect(
            this.dragging_rectangle[0],
            this.dragging_rectangle[1],
            this.dragging_rectangle[2],
            this.dragging_rectangle[3]
          );
        }
        if (this.over_link_center && this.render_link_tooltip)
          this.drawLinkTooltip(ctx, this.over_link_center);
        else if (this.onDrawLinkTooltip)
          this.onDrawLinkTooltip(ctx, null);
        if (this.onDrawForeground) {
          this.onDrawForeground(ctx, this.visible_rect);
        }
        ctx.restore();
      }
      if (this._graph_stack && this._graph_stack.length) {
        this.drawSubgraphPanel(ctx);
      }
      if (this.onDrawOverlay) {
        this.onDrawOverlay(ctx);
      }
      if (area) {
        ctx.restore();
      }
      if (ctx.finish2D) {
        ctx.finish2D();
      }
    }
    /**
         * draws the panel in the corner that shows subgraph properties
         * @method drawSubgraphPanel
         **/
    drawSubgraphPanel(ctx) {
      var subgraph = this.graph;
      var subnode = subgraph._subgraph_node;
      if (!subnode) {
        console.warn("subgraph without subnode");
        return;
      }
      this.drawSubgraphPanelLeft(subgraph, subnode, ctx);
      this.drawSubgraphPanelRight(subgraph, subnode, ctx);
    }
    drawSubgraphPanelLeft(subgraph, subnode, ctx) {
      var num = subnode.inputs ? subnode.inputs.length : 0;
      var w2 = 200;
      var h2 = Math.floor(LiteGraph.NODE_SLOT_HEIGHT * 1.6);
      ctx.fillStyle = "#111";
      ctx.globalAlpha = 0.8;
      ctx.beginPath();
      ctx.roundRect(10, 10, w2, (num + 1) * h2 + 50, [8]);
      ctx.fill();
      ctx.globalAlpha = 1;
      ctx.fillStyle = "#888";
      ctx.font = "14px Arial";
      ctx.textAlign = "left";
      ctx.fillText("Graph Inputs", 20, 34);
      if (this.drawButton(w2 - 20, 20, 20, 20, "X", "#151515")) {
        this.closeSubgraph();
        return;
      }
      var y2 = 50;
      ctx.font = "14px Arial";
      if (subnode.inputs)
        for (var i2 = 0; i2 < subnode.inputs.length; ++i2) {
          var input = subnode.inputs[i2];
          if (input.not_subgraph_input)
            continue;
          if (this.drawButton(20, y2 + 2, w2 - 20, h2 - 2)) {
            var type = subnode.constructor.input_node_type || "graph/input";
            this.graph.beforeChange();
            var newnode = LiteGraph.createNode(type);
            if (newnode) {
              subgraph.add(newnode);
              this.block_click = false;
              this.last_click_position = null;
              this.selectNodes([newnode]);
              this.node_dragged = newnode;
              this.dragging_canvas = false;
              newnode.setProperty("name", input.name);
              newnode.setProperty("type", input.type);
              this.node_dragged.pos[0] = this.graph_mouse[0] - 5;
              this.node_dragged.pos[1] = this.graph_mouse[1] - 5;
              this.graph.afterChange();
            } else
              console.error("graph input node not found:", type);
          }
          ctx.fillStyle = "#9C9";
          ctx.beginPath();
          ctx.arc(w2 - 16, y2 + h2 * 0.5, 5, 0, 2 * Math.PI);
          ctx.fill();
          ctx.fillStyle = "#AAA";
          ctx.fillText(input.name, 30, y2 + h2 * 0.75);
          ctx.fillStyle = "#777";
          ctx.fillText(input.type, 130, y2 + h2 * 0.75);
          y2 += h2;
        }
      if (this.drawButton(20, y2 + 2, w2 - 20, h2 - 2, "+", "#151515", "#222")) {
        this.showSubgraphPropertiesDialog(subnode);
      }
    }
    drawSubgraphPanelRight(subgraph, subnode, ctx) {
      var num = subnode.outputs ? subnode.outputs.length : 0;
      var canvas_w = this.bgcanvas.width;
      var w2 = 200;
      var h2 = Math.floor(LiteGraph.NODE_SLOT_HEIGHT * 1.6);
      ctx.fillStyle = "#111";
      ctx.globalAlpha = 0.8;
      ctx.beginPath();
      ctx.roundRect(canvas_w - w2 - 10, 10, w2, (num + 1) * h2 + 50, [8]);
      ctx.fill();
      ctx.globalAlpha = 1;
      ctx.fillStyle = "#888";
      ctx.font = "14px Arial";
      ctx.textAlign = "left";
      var title_text = "Graph Outputs";
      var tw = ctx.measureText(title_text).width;
      ctx.fillText(title_text, canvas_w - tw - 20, 34);
      if (this.drawButton(canvas_w - w2, 20, 20, 20, "X", "#151515")) {
        this.closeSubgraph();
        return;
      }
      var y2 = 50;
      ctx.font = "14px Arial";
      if (subnode.outputs)
        for (var i2 = 0; i2 < subnode.outputs.length; ++i2) {
          var output = subnode.outputs[i2];
          if (output.not_subgraph_input)
            continue;
          if (this.drawButton(canvas_w - w2, y2 + 2, w2 - 20, h2 - 2)) {
            var type = subnode.constructor.output_node_type || "graph/output";
            this.graph.beforeChange();
            var newnode = LiteGraph.createNode(type);
            if (newnode) {
              subgraph.add(newnode);
              this.block_click = false;
              this.last_click_position = null;
              this.selectNodes([newnode]);
              this.node_dragged = newnode;
              this.dragging_canvas = false;
              newnode.setProperty("name", output.name);
              newnode.setProperty("type", output.type);
              this.node_dragged.pos[0] = this.graph_mouse[0] - 5;
              this.node_dragged.pos[1] = this.graph_mouse[1] - 5;
              this.graph.afterChange();
            } else
              console.error("graph input node not found:", type);
          }
          ctx.fillStyle = "#9C9";
          ctx.beginPath();
          ctx.arc(canvas_w - w2 + 16, y2 + h2 * 0.5, 5, 0, 2 * Math.PI);
          ctx.fill();
          ctx.fillStyle = "#AAA";
          ctx.fillText(output.name, canvas_w - w2 + 30, y2 + h2 * 0.75);
          ctx.fillStyle = "#777";
          ctx.fillText(output.type, canvas_w - w2 + 130, y2 + h2 * 0.75);
          y2 += h2;
        }
      if (this.drawButton(canvas_w - w2, y2 + 2, w2 - 20, h2 - 2, "+", "#151515", "#222")) {
        this.showSubgraphPropertiesDialogRight(subnode);
      }
    }
    //Draws a button into the canvas overlay and computes if it was clicked using the immediate gui paradigm
    drawButton(x2, y2, w2, h2, text, bgcolor, hovercolor, textcolor) {
      var ctx = this.ctx;
      bgcolor = bgcolor || LiteGraph.NODE_DEFAULT_COLOR;
      hovercolor = hovercolor || "#555";
      textcolor = textcolor || LiteGraph.NODE_TEXT_COLOR;
      var pos2 = this.ds.convertOffsetToCanvas(this.graph_mouse);
      var hover = LiteGraph.isInsideRectangle(pos2[0], pos2[1], x2, y2, w2, h2);
      pos2 = this.last_click_position ? [this.last_click_position[0], this.last_click_position[1]] : null;
      if (pos2) {
        var rect = this.canvas.getBoundingClientRect();
        pos2[0] -= rect.left;
        pos2[1] -= rect.top;
      }
      var clicked = pos2 && LiteGraph.isInsideRectangle(pos2[0], pos2[1], x2, y2, w2, h2);
      ctx.fillStyle = hover ? hovercolor : bgcolor;
      if (clicked)
        ctx.fillStyle = "#AAA";
      ctx.beginPath();
      ctx.roundRect(x2, y2, w2, h2, [4]);
      ctx.fill();
      if (text != null) {
        if (text.constructor == String) {
          ctx.fillStyle = textcolor;
          ctx.textAlign = "center";
          ctx.font = (h2 * 0.65 | 0) + "px Arial";
          ctx.fillText(text, x2 + w2 * 0.5, y2 + h2 * 0.75);
          ctx.textAlign = "left";
        }
      }
      var was_clicked = clicked && !this.block_click;
      if (clicked)
        this.blockClick();
      return was_clicked;
    }
    isAreaClicked(x2, y2, w2, h2, hold_click) {
      var pos2 = this.mouse;
      LiteGraph.isInsideRectangle(pos2[0], pos2[1], x2, y2, w2, h2);
      pos2 = this.last_click_position;
      var clicked = pos2 && LiteGraph.isInsideRectangle(pos2[0], pos2[1], x2, y2, w2, h2);
      var was_clicked = clicked && !this.block_click;
      if (clicked && hold_click)
        this.blockClick();
      return was_clicked;
    }
    /**
         * draws some useful stats in the corner of the canvas
         * @method renderInfo
         **/
    renderInfo(ctx, x2, y2) {
      x2 = x2 || 10;
      y2 = y2 || this.canvas.offsetHeight - 80;
      ctx.save();
      ctx.translate(x2, y2);
      ctx.font = "10px Arial";
      ctx.fillStyle = "#888";
      ctx.textAlign = "left";
      if (this.graph) {
        ctx.fillText("T: " + this.graph.globaltime.toFixed(2) + "s", 5, 13 * 1);
        ctx.fillText("I: " + this.graph.iteration, 5, 13 * 2);
        ctx.fillText("N: " + this.graph._nodes.length + " [" + this.visible_nodes.length + "]", 5, 13 * 3);
        ctx.fillText("V: " + this.graph._version, 5, 13 * 4);
        ctx.fillText("FPS:" + this.fps.toFixed(2), 5, 13 * 5);
      } else {
        ctx.fillText("No graph selected", 5, 13 * 1);
      }
      ctx.restore();
    }
    /**
         * draws the back canvas (the one containing the background and the connections)
         * @method drawBackCanvas
         **/
    drawBackCanvas() {
      var canvas = this.bgcanvas;
      if (canvas.width != this.canvas.width || canvas.height != this.canvas.height) {
        canvas.width = this.canvas.width;
        canvas.height = this.canvas.height;
      }
      if (!this.bgctx) {
        this.bgctx = this.bgcanvas.getContext("2d");
      }
      var ctx = this.bgctx;
      if (ctx.start) {
        ctx.start();
      }
      var viewport = this.viewport || [0, 0, ctx.canvas.width, ctx.canvas.height];
      if (this.clear_background) {
        ctx.clearRect(viewport[0], viewport[1], viewport[2], viewport[3]);
      }
      if (this._graph_stack && this._graph_stack.length) {
        ctx.save();
        this._graph_stack[this._graph_stack.length - 1];
        var subgraph_node = this.graph._subgraph_node;
        ctx.strokeStyle = subgraph_node.bgcolor;
        ctx.lineWidth = 10;
        ctx.strokeRect(1, 1, canvas.width - 2, canvas.height - 2);
        ctx.lineWidth = 1;
        ctx.font = "40px Arial";
        ctx.textAlign = "center";
        ctx.fillStyle = subgraph_node.bgcolor || "#AAA";
        var title = "";
        for (var i2 = 1; i2 < this._graph_stack.length; ++i2) {
          title += this._graph_stack[i2]._subgraph_node.getTitle() + " >> ";
        }
        ctx.fillText(
          title + subgraph_node.getTitle(),
          canvas.width * 0.5,
          40
        );
        ctx.restore();
      }
      var bg_already_painted = false;
      if (this.onRenderBackground) {
        bg_already_painted = this.onRenderBackground(canvas, ctx);
      }
      if (!this.viewport) {
        ctx.restore();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
      }
      this.visible_links.length = 0;
      if (this.graph) {
        ctx.save();
        this.ds.toCanvasContext(ctx);
        if (this.ds.scale < 1.5 && !bg_already_painted && this.clear_background_color) {
          ctx.fillStyle = this.clear_background_color;
          ctx.fillRect(
            this.visible_area[0],
            this.visible_area[1],
            this.visible_area[2],
            this.visible_area[3]
          );
        }
        if (this.background_image && this.ds.scale > 0.5 && !bg_already_painted) {
          if (this.zoom_modify_alpha) {
            ctx.globalAlpha = (1 - 0.5 / this.ds.scale) * this.editor_alpha;
          } else {
            ctx.globalAlpha = this.editor_alpha;
          }
          ctx.imageSmoothingEnabled = ctx.imageSmoothingEnabled = false;
          if (!this._bg_img || this._bg_img.name != this.background_image) {
            this._bg_img = new Image();
            this._bg_img.name = this.background_image;
            this._bg_img.src = this.background_image;
            var that2 = this;
            this._bg_img.onload = function() {
              that2.draw(true, true);
            };
          }
          var pattern = null;
          if (this._pattern == null && this._bg_img.width > 0) {
            pattern = ctx.createPattern(this._bg_img, "repeat");
            this._pattern_img = this._bg_img;
            this._pattern = pattern;
          } else {
            pattern = this._pattern;
          }
          if (pattern) {
            ctx.fillStyle = pattern;
            ctx.fillRect(
              this.visible_area[0],
              this.visible_area[1],
              this.visible_area[2],
              this.visible_area[3]
            );
            ctx.fillStyle = "transparent";
          }
          ctx.globalAlpha = 1;
          ctx.imageSmoothingEnabled = ctx.imageSmoothingEnabled = true;
        }
        if (this.graph._groups.length && !this.live_mode) {
          this.drawGroups(canvas, ctx);
        }
        if (this.onDrawBackground) {
          this.onDrawBackground(ctx, this.visible_area);
        }
        if (this.onBackgroundRender) {
          console.error(
            "WARNING! onBackgroundRender deprecated, now is named onDrawBackground "
          );
          this.onBackgroundRender = null;
        }
        if (this.render_canvas_border) {
          ctx.strokeStyle = "#235";
          ctx.strokeRect(0, 0, canvas.width, canvas.height);
        }
        if (this.render_connections_shadows) {
          ctx.shadowColor = "#000";
          ctx.shadowOffsetX = 0;
          ctx.shadowOffsetY = 0;
          ctx.shadowBlur = 6;
        } else {
          ctx.shadowColor = "rgba(0,0,0,0)";
        }
        if (!this.live_mode) {
          this.drawConnections(ctx);
        }
        ctx.shadowColor = "rgba(0,0,0,0)";
        ctx.restore();
      }
      if (ctx.finish) {
        ctx.finish();
      }
      this.dirty_bgcanvas = false;
      this.dirty_canvas = true;
    }
    /**
         * draws the given node inside the canvas
         * @method drawNode
         **/
    drawNode(node22, ctx) {
      this.current_node = node22;
      var color = node22.color || node22.constructor.color || LiteGraph.NODE_DEFAULT_COLOR;
      var bgcolor = node22.bgcolor || node22.constructor.bgcolor || LiteGraph.NODE_DEFAULT_BGCOLOR;
      if (node22.mouseOver) ;
      var low_quality = this.ds.scale < 0.6;
      if (this.live_mode) {
        if (!node22.flags.collapsed) {
          ctx.shadowColor = "transparent";
          if (node22.onDrawForeground) {
            node22.onDrawForeground(ctx, this, this.canvas);
          }
        }
        return;
      }
      var editor_alpha = this.editor_alpha;
      ctx.globalAlpha = editor_alpha;
      if (this.render_shadows && !low_quality) {
        ctx.shadowColor = LiteGraph.DEFAULT_SHADOW_COLOR;
        ctx.shadowOffsetX = 2 * this.ds.scale;
        ctx.shadowOffsetY = 2 * this.ds.scale;
        ctx.shadowBlur = 3 * this.ds.scale;
      } else {
        ctx.shadowColor = "transparent";
      }
      if (node22.flags.collapsed && node22.onDrawCollapsed && node22.onDrawCollapsed(ctx, this) == true) {
        return;
      }
      var shape = node22._shape || LiteGraph.BOX_SHAPE;
      var size2 = __privateGet(__LGraphCanvas, _temp_vec2);
      __privateGet(__LGraphCanvas, _temp_vec2).set(node22.size);
      var horizontal3 = node22.horizontal;
      if (node22.flags.collapsed) {
        ctx.font = this.inner_text_font;
        var title = node22.getTitle ? node22.getTitle() : node22.title;
        if (title != null) {
          node22._collapsed_width = Math.min(
            node22.size[0],
            ctx.measureText(title).width + LiteGraph.NODE_TITLE_HEIGHT * 2
          );
          size2[0] = node22._collapsed_width;
          size2[1] = 0;
        }
      }
      if (node22.clip_area) {
        ctx.save();
        ctx.beginPath();
        if (shape == LiteGraph.BOX_SHAPE) {
          ctx.rect(0, 0, size2[0], size2[1]);
        } else if (shape == LiteGraph.ROUND_SHAPE) {
          ctx.roundRect(0, 0, size2[0], size2[1], [10]);
        } else if (shape == LiteGraph.CIRCLE_SHAPE) {
          ctx.arc(
            size2[0] * 0.5,
            size2[1] * 0.5,
            size2[0] * 0.5,
            0,
            Math.PI * 2
          );
        }
        ctx.clip();
      }
      if (node22.has_errors) {
        bgcolor = "red";
      }
      this.drawNodeShape(
        node22,
        ctx,
        size2,
        color,
        bgcolor,
        node22.is_selected,
        node22.mouseOver
      );
      ctx.shadowColor = "transparent";
      if (node22.onDrawForeground) {
        node22.onDrawForeground(ctx, this, this.canvas);
      }
      ctx.textAlign = horizontal3 ? "center" : "left";
      ctx.font = this.inner_text_font;
      var render_text = !low_quality;
      var out_slot = this.connecting_links ? this.connecting_links[0].output : null;
      var in_slot = this.connecting_links ? this.connecting_links[0].input : null;
      ctx.lineWidth = 1;
      var max_y = 0;
      var slot_pos = new Float32Array(2);
      if (!node22.flags.collapsed) {
        if (node22.inputs) {
          for (var i2 = 0; i2 < node22.inputs.length; i2++) {
            var slot = node22.inputs[i2];
            var slot_type = slot.type;
            var slot_shape = slot.shape;
            ctx.globalAlpha = editor_alpha;
            if (out_slot && !LiteGraph.isValidConnection(slot.type, out_slot.type)) {
              ctx.globalAlpha = 0.4 * editor_alpha;
            }
            ctx.fillStyle = slot.link != null ? slot.color_on || this.default_connection_color_byType[slot_type] || this.default_connection_color.input_on : slot.color_off || this.default_connection_color_byTypeOff[slot_type] || this.default_connection_color_byType[slot_type] || this.default_connection_color.input_off;
            var pos2 = node22.getConnectionPos(true, i2, slot_pos);
            pos2[0] -= node22.pos[0];
            pos2[1] -= node22.pos[1];
            if (max_y < pos2[1] + LiteGraph.NODE_SLOT_HEIGHT * 0.5) {
              max_y = pos2[1] + LiteGraph.NODE_SLOT_HEIGHT * 0.5;
            }
            ctx.beginPath();
            if (slot_type == "array") {
              slot_shape = LiteGraph.GRID_SHAPE;
            }
            var doStroke = true;
            if (slot.type === LiteGraph.EVENT || slot.shape === LiteGraph.BOX_SHAPE) {
              if (horizontal3) {
                ctx.rect(
                  pos2[0] - 5 + 0.5,
                  pos2[1] - 8 + 0.5,
                  10,
                  14
                );
              } else {
                ctx.rect(
                  pos2[0] - 6 + 0.5,
                  pos2[1] - 5 + 0.5,
                  14,
                  10
                );
              }
            } else if (slot_shape === LiteGraph.ARROW_SHAPE) {
              ctx.moveTo(pos2[0] + 8, pos2[1] + 0.5);
              ctx.lineTo(pos2[0] - 4, pos2[1] + 6 + 0.5);
              ctx.lineTo(pos2[0] - 4, pos2[1] - 6 + 0.5);
              ctx.closePath();
            } else if (slot_shape === LiteGraph.GRID_SHAPE) {
              ctx.rect(pos2[0] - 4, pos2[1] - 4, 2, 2);
              ctx.rect(pos2[0] - 1, pos2[1] - 4, 2, 2);
              ctx.rect(pos2[0] + 2, pos2[1] - 4, 2, 2);
              ctx.rect(pos2[0] - 4, pos2[1] - 1, 2, 2);
              ctx.rect(pos2[0] - 1, pos2[1] - 1, 2, 2);
              ctx.rect(pos2[0] + 2, pos2[1] - 1, 2, 2);
              ctx.rect(pos2[0] - 4, pos2[1] + 2, 2, 2);
              ctx.rect(pos2[0] - 1, pos2[1] + 2, 2, 2);
              ctx.rect(pos2[0] + 2, pos2[1] + 2, 2, 2);
              doStroke = false;
            } else {
              if (low_quality)
                ctx.rect(pos2[0] - 4, pos2[1] - 4, 8, 8);
              else
                ctx.arc(pos2[0], pos2[1], 4, 0, Math.PI * 2);
            }
            ctx.fill();
            if (render_text) {
              var text = slot.label != null ? slot.label : slot.name;
              if (text) {
                ctx.fillStyle = LiteGraph.NODE_TEXT_COLOR;
                if (horizontal3 || slot.dir == LiteGraph.UP) {
                  ctx.fillText(text, pos2[0], pos2[1] - 10);
                } else {
                  ctx.fillText(text, pos2[0] + 10, pos2[1] + 5);
                }
              }
            }
          }
        }
        ctx.textAlign = horizontal3 ? "center" : "right";
        ctx.strokeStyle = "black";
        if (node22.outputs) {
          for (var i2 = 0; i2 < node22.outputs.length; i2++) {
            var slot = node22.outputs[i2];
            var slot_type = slot.type;
            var slot_shape = slot.shape;
            if (in_slot && !LiteGraph.isValidConnection(slot_type, in_slot.type)) {
              ctx.globalAlpha = 0.4 * editor_alpha;
            }
            var pos2 = node22.getConnectionPos(false, i2, slot_pos);
            pos2[0] -= node22.pos[0];
            pos2[1] -= node22.pos[1];
            if (max_y < pos2[1] + LiteGraph.NODE_SLOT_HEIGHT * 0.5) {
              max_y = pos2[1] + LiteGraph.NODE_SLOT_HEIGHT * 0.5;
            }
            ctx.fillStyle = slot.links && slot.links.length ? slot.color_on || this.default_connection_color_byType[slot_type] || this.default_connection_color.output_on : slot.color_off || this.default_connection_color_byTypeOff[slot_type] || this.default_connection_color_byType[slot_type] || this.default_connection_color.output_off;
            ctx.beginPath();
            if (slot_type == "array") {
              slot_shape = LiteGraph.GRID_SHAPE;
            }
            var doStroke = true;
            if (slot_type === LiteGraph.EVENT || slot_shape === LiteGraph.BOX_SHAPE) {
              if (horizontal3) {
                ctx.rect(
                  pos2[0] - 5 + 0.5,
                  pos2[1] - 8 + 0.5,
                  10,
                  14
                );
              } else {
                ctx.rect(
                  pos2[0] - 6 + 0.5,
                  pos2[1] - 5 + 0.5,
                  14,
                  10
                );
              }
            } else if (slot_shape === LiteGraph.ARROW_SHAPE) {
              ctx.moveTo(pos2[0] + 8, pos2[1] + 0.5);
              ctx.lineTo(pos2[0] - 4, pos2[1] + 6 + 0.5);
              ctx.lineTo(pos2[0] - 4, pos2[1] - 6 + 0.5);
              ctx.closePath();
            } else if (slot_shape === LiteGraph.GRID_SHAPE) {
              ctx.rect(pos2[0] - 4, pos2[1] - 4, 2, 2);
              ctx.rect(pos2[0] - 1, pos2[1] - 4, 2, 2);
              ctx.rect(pos2[0] + 2, pos2[1] - 4, 2, 2);
              ctx.rect(pos2[0] - 4, pos2[1] - 1, 2, 2);
              ctx.rect(pos2[0] - 1, pos2[1] - 1, 2, 2);
              ctx.rect(pos2[0] + 2, pos2[1] - 1, 2, 2);
              ctx.rect(pos2[0] - 4, pos2[1] + 2, 2, 2);
              ctx.rect(pos2[0] - 1, pos2[1] + 2, 2, 2);
              ctx.rect(pos2[0] + 2, pos2[1] + 2, 2, 2);
              doStroke = false;
            } else {
              if (low_quality)
                ctx.rect(pos2[0] - 4, pos2[1] - 4, 8, 8);
              else
                ctx.arc(pos2[0], pos2[1], 4, 0, Math.PI * 2);
            }
            ctx.fill();
            if (!low_quality && doStroke)
              ctx.stroke();
            if (render_text) {
              var text = slot.label != null ? slot.label : slot.name;
              if (text) {
                ctx.fillStyle = LiteGraph.NODE_TEXT_COLOR;
                if (horizontal3 || slot.dir == LiteGraph.DOWN) {
                  ctx.fillText(text, pos2[0], pos2[1] - 8);
                } else {
                  ctx.fillText(text, pos2[0] - 10, pos2[1] + 5);
                }
              }
            }
          }
        }
        ctx.textAlign = "left";
        ctx.globalAlpha = 1;
        if (node22.widgets) {
          var widgets_y = max_y;
          if (horizontal3 || node22.widgets_up) {
            widgets_y = 2;
          }
          if (node22.widgets_start_y != null)
            widgets_y = node22.widgets_start_y;
          this.drawNodeWidgets(
            node22,
            widgets_y,
            ctx,
            this.node_widget && this.node_widget[0] == node22 ? this.node_widget[1] : null
          );
        }
      } else if (this.render_collapsed_slots) {
        var input_slot = null;
        var output_slot = null;
        if (node22.inputs) {
          for (var i2 = 0; i2 < node22.inputs.length; i2++) {
            var slot = node22.inputs[i2];
            if (slot.link == null) {
              continue;
            }
            input_slot = slot;
            break;
          }
        }
        if (node22.outputs) {
          for (var i2 = 0; i2 < node22.outputs.length; i2++) {
            var slot = node22.outputs[i2];
            if (!slot.links || !slot.links.length) {
              continue;
            }
            output_slot = slot;
          }
        }
        if (input_slot) {
          var x2 = 0;
          var y2 = LiteGraph.NODE_TITLE_HEIGHT * -0.5;
          if (horizontal3) {
            x2 = node22._collapsed_width * 0.5;
            y2 = -LiteGraph.NODE_TITLE_HEIGHT;
          }
          ctx.fillStyle = "#686";
          ctx.beginPath();
          if (slot.type === LiteGraph.EVENT || slot.shape === LiteGraph.BOX_SHAPE) {
            ctx.rect(x2 - 7 + 0.5, y2 - 4, 14, 8);
          } else if (slot.shape === LiteGraph.ARROW_SHAPE) {
            ctx.moveTo(x2 + 8, y2);
            ctx.lineTo(x2 + -4, y2 - 4);
            ctx.lineTo(x2 + -4, y2 + 4);
            ctx.closePath();
          } else {
            ctx.arc(x2, y2, 4, 0, Math.PI * 2);
          }
          ctx.fill();
        }
        if (output_slot) {
          var x2 = node22._collapsed_width;
          var y2 = LiteGraph.NODE_TITLE_HEIGHT * -0.5;
          if (horizontal3) {
            x2 = node22._collapsed_width * 0.5;
            y2 = 0;
          }
          ctx.fillStyle = "#686";
          ctx.strokeStyle = "black";
          ctx.beginPath();
          if (slot.type === LiteGraph.EVENT || slot.shape === LiteGraph.BOX_SHAPE) {
            ctx.rect(x2 - 7 + 0.5, y2 - 4, 14, 8);
          } else if (slot.shape === LiteGraph.ARROW_SHAPE) {
            ctx.moveTo(x2 + 6, y2);
            ctx.lineTo(x2 - 6, y2 - 4);
            ctx.lineTo(x2 - 6, y2 + 4);
            ctx.closePath();
          } else {
            ctx.arc(x2, y2, 4, 0, Math.PI * 2);
          }
          ctx.fill();
        }
      }
      if (node22.clip_area) {
        ctx.restore();
      }
      ctx.globalAlpha = 1;
    }
    //used by this.over_link_center
    drawLinkTooltip(ctx, link) {
      var pos2 = link._pos;
      ctx.fillStyle = "black";
      ctx.beginPath();
      ctx.arc(pos2[0], pos2[1], 3, 0, Math.PI * 2);
      ctx.fill();
      if (link.data == null)
        return;
      if (this.onDrawLinkTooltip) {
        if (this.onDrawLinkTooltip(ctx, link, this) == true)
          return;
      }
      var data24 = link.data;
      var text = null;
      if (data24.constructor === Number)
        text = data24.toFixed(2);
      else if (data24.constructor === String)
        text = '"' + data24 + '"';
      else if (data24.constructor === Boolean)
        text = String(data24);
      else if (data24.toToolTip)
        text = data24.toToolTip();
      else
        text = "[" + data24.constructor.name + "]";
      if (text == null)
        return;
      text = text.substr(0, 30);
      ctx.font = "14px Courier New";
      var info = ctx.measureText(text);
      var w2 = info.width + 20;
      var h2 = 24;
      ctx.shadowColor = "black";
      ctx.shadowOffsetX = 2;
      ctx.shadowOffsetY = 2;
      ctx.shadowBlur = 3;
      ctx.fillStyle = "#454";
      ctx.beginPath();
      ctx.roundRect(pos2[0] - w2 * 0.5, pos2[1] - 15 - h2, w2, h2, [3]);
      ctx.moveTo(pos2[0] - 10, pos2[1] - 15);
      ctx.lineTo(pos2[0] + 10, pos2[1] - 15);
      ctx.lineTo(pos2[0], pos2[1] - 5);
      ctx.fill();
      ctx.shadowColor = "transparent";
      ctx.textAlign = "center";
      ctx.fillStyle = "#CEC";
      ctx.fillText(text, pos2[0], pos2[1] - 15 - h2 * 0.3);
    }
    /**
     * draws the shape of the given node in the canvas
     * @method drawNodeShape
     **/
    drawNodeShape(node22, ctx, size2, fgcolor, bgcolor, selected2, mouse_over) {
      ctx.strokeStyle = fgcolor;
      ctx.fillStyle = bgcolor;
      var title_height = LiteGraph.NODE_TITLE_HEIGHT;
      var low_quality = this.ds.scale < 0.5;
      var shape = node22._shape || node22.constructor.shape || LiteGraph.ROUND_SHAPE;
      var title_mode = node22.constructor.title_mode;
      var render_title = true;
      if (title_mode == LiteGraph.TRANSPARENT_TITLE || title_mode == LiteGraph.NO_TITLE) {
        render_title = false;
      } else if (title_mode == LiteGraph.AUTOHIDE_TITLE && mouse_over) {
        render_title = true;
      }
      var area = __privateGet(__LGraphCanvas, _tmp_area);
      area[0] = 0;
      area[1] = render_title ? -title_height : 0;
      area[2] = size2[0] + 1;
      area[3] = render_title ? size2[1] + title_height : size2[1];
      var old_alpha = ctx.globalAlpha;
      {
        ctx.beginPath();
        if (shape == LiteGraph.BOX_SHAPE || low_quality) {
          ctx.fillRect(area[0], area[1], area[2], area[3]);
        } else if (shape == LiteGraph.ROUND_SHAPE || shape == LiteGraph.CARD_SHAPE) {
          ctx.roundRect(
            area[0],
            area[1],
            area[2],
            area[3],
            shape == LiteGraph.CARD_SHAPE ? [this.round_radius, this.round_radius, 0, 0] : [this.round_radius]
          );
        } else if (shape == LiteGraph.CIRCLE_SHAPE) {
          ctx.arc(
            size2[0] * 0.5,
            size2[1] * 0.5,
            size2[0] * 0.5,
            0,
            Math.PI * 2
          );
        }
        ctx.fill();
        if (!node22.flags.collapsed && render_title) {
          ctx.shadowColor = "transparent";
          ctx.fillStyle = "rgba(0,0,0,0.2)";
          ctx.fillRect(0, -1, area[2], 2);
        }
      }
      ctx.shadowColor = "transparent";
      if (node22.onDrawBackground) {
        node22.onDrawBackground(ctx, this, this.canvas, this.graph_mouse);
      }
      if (render_title || title_mode == LiteGraph.TRANSPARENT_TITLE) {
        if (node22.onDrawTitleBar) {
          node22.onDrawTitleBar(ctx, title_height, size2, this.ds.scale, fgcolor);
        } else if (title_mode != LiteGraph.TRANSPARENT_TITLE && (node22.constructor.title_color || this.render_title_colored)) {
          var title_color = node22.constructor.title_color || fgcolor;
          if (node22.flags.collapsed) {
            ctx.shadowColor = LiteGraph.DEFAULT_SHADOW_COLOR;
          }
          if (this.use_gradients) {
            var grad = __LGraphCanvas.gradients[title_color];
            if (!grad) {
              grad = __LGraphCanvas.gradients[title_color] = ctx.createLinearGradient(0, 0, 400, 0);
              grad.addColorStop(0, title_color);
              grad.addColorStop(1, "#000");
            }
            ctx.fillStyle = grad;
          } else {
            ctx.fillStyle = title_color;
          }
          ctx.beginPath();
          if (shape == LiteGraph.BOX_SHAPE || low_quality) {
            ctx.rect(0, -title_height, size2[0] + 1, title_height);
          } else if (shape == LiteGraph.ROUND_SHAPE || shape == LiteGraph.CARD_SHAPE) {
            ctx.roundRect(
              0,
              -title_height,
              size2[0] + 1,
              title_height,
              node22.flags.collapsed ? [this.round_radius] : [this.round_radius, this.round_radius, 0, 0]
            );
          }
          ctx.fill();
          ctx.shadowColor = "transparent";
        }
        var colState = false;
        if (LiteGraph.node_box_coloured_by_mode) {
          if (LiteGraph.NODE_MODES_COLORS[node22.mode]) {
            colState = LiteGraph.NODE_MODES_COLORS[node22.mode];
          }
        }
        if (LiteGraph.node_box_coloured_when_on) {
          colState = node22.action_triggered ? "#FFF" : node22.execute_triggered ? "#AAA" : colState;
        }
        var box_size = 10;
        if (node22.onDrawTitleBox) {
          node22.onDrawTitleBox(ctx, title_height, size2, this.ds.scale);
        } else if (shape == LiteGraph.ROUND_SHAPE || shape == LiteGraph.CIRCLE_SHAPE || shape == LiteGraph.CARD_SHAPE) {
          if (low_quality) {
            ctx.fillStyle = "black";
            ctx.beginPath();
            ctx.arc(
              title_height * 0.5,
              title_height * -0.5,
              box_size * 0.5 + 1,
              0,
              Math.PI * 2
            );
            ctx.fill();
          }
          ctx.fillStyle = node22.boxcolor || colState || LiteGraph.NODE_DEFAULT_BOXCOLOR;
          if (low_quality)
            ctx.fillRect(title_height * 0.5 - box_size * 0.5, title_height * -0.5 - box_size * 0.5, box_size, box_size);
          else {
            ctx.beginPath();
            ctx.arc(
              title_height * 0.5,
              title_height * -0.5,
              box_size * 0.5,
              0,
              Math.PI * 2
            );
            ctx.fill();
          }
        } else {
          if (low_quality) {
            ctx.fillStyle = "black";
            ctx.fillRect(
              (title_height - box_size) * 0.5 - 1,
              (title_height + box_size) * -0.5 - 1,
              box_size + 2,
              box_size + 2
            );
          }
          ctx.fillStyle = node22.boxcolor || colState || LiteGraph.NODE_DEFAULT_BOXCOLOR;
          ctx.fillRect(
            (title_height - box_size) * 0.5,
            (title_height + box_size) * -0.5,
            box_size,
            box_size
          );
        }
        ctx.globalAlpha = old_alpha;
        if (node22.onDrawTitleText) {
          node22.onDrawTitleText(
            ctx,
            title_height,
            size2,
            this.ds.scale,
            this.title_text_font,
            selected2
          );
        }
        if (!low_quality) {
          ctx.font = this.title_text_font;
          var title = String(node22.getTitle()) + (node22.pinned ? "" : "");
          if (title) {
            if (selected2) {
              ctx.fillStyle = LiteGraph.NODE_SELECTED_TITLE_COLOR;
            } else {
              ctx.fillStyle = node22.constructor.title_text_color || this.node_title_color;
            }
            if (node22.flags.collapsed) {
              ctx.textAlign = "left";
              ctx.measureText(title);
              ctx.fillText(
                title.substr(0, 20),
                //avoid urls too long
                title_height,
                // + measure.width * 0.5,
                LiteGraph.NODE_TITLE_TEXT_Y - title_height
              );
              ctx.textAlign = "left";
            } else {
              ctx.textAlign = "left";
              ctx.fillText(
                title,
                title_height,
                LiteGraph.NODE_TITLE_TEXT_Y - title_height
              );
            }
          }
        }
        if (!node22.flags.collapsed && node22.subgraph && !node22.skip_subgraph_button) {
          var w2 = LiteGraph.NODE_TITLE_HEIGHT;
          var x2 = node22.size[0] - w2;
          var over = LiteGraph.isInsideRectangle(this.graph_mouse[0] - node22.pos[0], this.graph_mouse[1] - node22.pos[1], x2 + 2, -w2 + 2, w2 - 4, w2 - 4);
          ctx.fillStyle = over ? "#888" : "#555";
          if (shape == LiteGraph.BOX_SHAPE || low_quality)
            ctx.fillRect(x2 + 2, -w2 + 2, w2 - 4, w2 - 4);
          else {
            ctx.beginPath();
            ctx.roundRect(x2 + 2, -w2 + 2, w2 - 4, w2 - 4, [4]);
            ctx.fill();
          }
          ctx.fillStyle = "#333";
          ctx.beginPath();
          ctx.moveTo(x2 + w2 * 0.2, -w2 * 0.6);
          ctx.lineTo(x2 + w2 * 0.8, -w2 * 0.6);
          ctx.lineTo(x2 + w2 * 0.5, -w2 * 0.3);
          ctx.fill();
        }
        if (node22.onDrawTitle) {
          node22.onDrawTitle(ctx);
        }
      }
      if (selected2) {
        if (node22.onBounding) {
          node22.onBounding(area);
        }
        this.drawSelectionBounding(
          ctx,
          area,
          {
            shape,
            title_height,
            title_mode,
            fgcolor
          }
        );
      }
      if (node22.execute_triggered > 0) node22.execute_triggered--;
      if (node22.action_triggered > 0) node22.action_triggered--;
    }
    /**
     * Draws the selection bounding of an area.
     * @param {CanvasRenderingContext2D} ctx
     * @param {Vector4} area
     * @param {{
     *   shape: LiteGraph.Shape,
     *   title_height: number,
     *   title_mode: LiteGraph.TitleMode,
     *   fgcolor: string,
     *   padding: number,
     * }} options
     */
    drawSelectionBounding(ctx, area, {
      shape = LiteGraph.BOX_SHAPE,
      title_height = LiteGraph.NODE_TITLE_HEIGHT,
      title_mode = LiteGraph.NORMAL_TITLE,
      fgcolor = LiteGraph.NODE_BOX_OUTLINE_COLOR,
      padding = 6
    } = {}) {
      if (title_mode === LiteGraph.TRANSPARENT_TITLE) {
        area[1] -= title_height;
        area[3] += title_height;
      }
      ctx.lineWidth = 1;
      ctx.globalAlpha = 0.8;
      ctx.beginPath();
      const [x2, y2, width2, height] = area;
      switch (shape) {
        case LiteGraph.BOX_SHAPE: {
          ctx.rect(x2 - padding, y2 - padding, width2 + 2 * padding, height + 2 * padding);
          break;
        }
        case LiteGraph.ROUND_SHAPE:
        case LiteGraph.CARD_SHAPE: {
          const radius = this.round_radius * 2;
          const isCollapsed = shape === LiteGraph.CARD_SHAPE && node.flags.collapsed;
          const cornerRadii = isCollapsed || shape === LiteGraph.ROUND_SHAPE ? [radius] : [radius, 2, radius, 2];
          ctx.roundRect(x2 - padding, y2 - padding, width2 + 2 * padding, height + 2 * padding, cornerRadii);
          break;
        }
        case LiteGraph.CIRCLE_SHAPE: {
          const centerX = x2 + width2 / 2;
          const centerY = y2 + height / 2;
          const radius = Math.max(width2, height) / 2 + padding;
          ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
          break;
        }
      }
      ctx.strokeStyle = LiteGraph.NODE_BOX_OUTLINE_COLOR;
      ctx.stroke();
      ctx.strokeStyle = fgcolor;
      ctx.globalAlpha = 1;
    }
    drawConnections(ctx) {
      var now2 = LiteGraph.getTime();
      var visible_area = this.visible_area;
      __privateGet(__LGraphCanvas, _margin_area)[0] = visible_area[0] - 20;
      __privateGet(__LGraphCanvas, _margin_area)[1] = visible_area[1] - 20;
      __privateGet(__LGraphCanvas, _margin_area)[2] = visible_area[2] + 40;
      __privateGet(__LGraphCanvas, _margin_area)[3] = visible_area[3] + 40;
      ctx.lineWidth = this.connections_width;
      ctx.fillStyle = "#AAA";
      ctx.strokeStyle = "#AAA";
      ctx.globalAlpha = this.editor_alpha;
      var nodes = this.graph._nodes;
      for (var n = 0, l = nodes.length; n < l; ++n) {
        var node22 = nodes[n];
        if (!node22.inputs || !node22.inputs.length) {
          continue;
        }
        for (var i2 = 0; i2 < node22.inputs.length; ++i2) {
          var input = node22.inputs[i2];
          if (!input || input.link == null) {
            continue;
          }
          var link_id = input.link;
          var link = this.graph.links[link_id];
          if (!link) {
            continue;
          }
          var start_node = this.graph.getNodeById(link.origin_id);
          if (start_node == null) {
            continue;
          }
          var start_node_slot = link.origin_slot;
          var start_node_slotpos = null;
          if (start_node_slot == -1) {
            start_node_slotpos = [
              start_node.pos[0] + 10,
              start_node.pos[1] + 10
            ];
          } else {
            start_node_slotpos = start_node.getConnectionPos(
              false,
              start_node_slot,
              __privateGet(__LGraphCanvas, _tempA)
            );
          }
          var end_node_slotpos = node22.getConnectionPos(true, i2, __privateGet(__LGraphCanvas, _tempB));
          __privateGet(__LGraphCanvas, _link_bounding)[0] = start_node_slotpos[0];
          __privateGet(__LGraphCanvas, _link_bounding)[1] = start_node_slotpos[1];
          __privateGet(__LGraphCanvas, _link_bounding)[2] = end_node_slotpos[0] - start_node_slotpos[0];
          __privateGet(__LGraphCanvas, _link_bounding)[3] = end_node_slotpos[1] - start_node_slotpos[1];
          if (__privateGet(__LGraphCanvas, _link_bounding)[2] < 0) {
            __privateGet(__LGraphCanvas, _link_bounding)[0] += __privateGet(__LGraphCanvas, _link_bounding)[2];
            __privateGet(__LGraphCanvas, _link_bounding)[2] = Math.abs(__privateGet(__LGraphCanvas, _link_bounding)[2]);
          }
          if (__privateGet(__LGraphCanvas, _link_bounding)[3] < 0) {
            __privateGet(__LGraphCanvas, _link_bounding)[1] += __privateGet(__LGraphCanvas, _link_bounding)[3];
            __privateGet(__LGraphCanvas, _link_bounding)[3] = Math.abs(__privateGet(__LGraphCanvas, _link_bounding)[3]);
          }
          if (!overlapBounding(__privateGet(__LGraphCanvas, _link_bounding), __privateGet(__LGraphCanvas, _margin_area))) {
            continue;
          }
          var start_slot = start_node.outputs[start_node_slot];
          var end_slot = node22.inputs[i2];
          if (!start_slot || !end_slot) {
            continue;
          }
          var start_dir = start_slot.dir || (start_node.horizontal ? LiteGraph.DOWN : LiteGraph.RIGHT);
          var end_dir = end_slot.dir || (node22.horizontal ? LiteGraph.UP : LiteGraph.LEFT);
          this.renderLink(
            ctx,
            start_node_slotpos,
            end_node_slotpos,
            link,
            false,
            0,
            null,
            start_dir,
            end_dir
          );
          if (link && link._last_time && now2 - link._last_time < 1e3) {
            var f = 2 - (now2 - link._last_time) * 2e-3;
            var tmp = ctx.globalAlpha;
            ctx.globalAlpha = tmp * f;
            this.renderLink(
              ctx,
              start_node_slotpos,
              end_node_slotpos,
              link,
              true,
              f,
              "white",
              start_dir,
              end_dir
            );
            ctx.globalAlpha = tmp;
          }
        }
      }
      ctx.globalAlpha = 1;
    }
    /**
         * draws a link between two points
         * @method renderLink
         * @param {vec2} a start pos
         * @param {vec2} b end pos
         * @param {Object} link the link object with all the link info
         * @param {boolean} skip_border ignore the shadow of the link
         * @param {boolean} flow show flow animation (for events)
         * @param {string} color the color for the link
         * @param {number} start_dir the direction enum
         * @param {number} end_dir the direction enum
         * @param {number} num_sublines number of sublines (useful to represent vec3 or rgb)
         **/
    renderLink(ctx, a, b, link, skip_border, flow, color, start_dir, end_dir, num_sublines) {
      if (link) {
        this.visible_links.push(link);
      }
      if (!color && link) {
        color = link.color || __LGraphCanvas.link_type_colors[link.type];
      }
      if (!color) {
        color = this.default_link_color;
      }
      if (link != null && this.highlighted_links[link.id]) {
        color = "#FFF";
      }
      start_dir = start_dir || LiteGraph.RIGHT;
      end_dir = end_dir || LiteGraph.LEFT;
      var dist2 = distance(a, b);
      if (this.render_connections_border && this.ds.scale > 0.6) {
        ctx.lineWidth = this.connections_width + 4;
      }
      ctx.lineJoin = "round";
      num_sublines = num_sublines || 1;
      if (num_sublines > 1) {
        ctx.lineWidth = 0.5;
      }
      ctx.beginPath();
      for (var i2 = 0; i2 < num_sublines; i2 += 1) {
        var offsety = (i2 - (num_sublines - 1) * 0.5) * 5;
        if (this.links_render_mode == LiteGraph.SPLINE_LINK) {
          ctx.moveTo(a[0], a[1] + offsety);
          var start_offset_x = 0;
          var start_offset_y = 0;
          var end_offset_x = 0;
          var end_offset_y = 0;
          switch (start_dir) {
            case LiteGraph.LEFT:
              start_offset_x = dist2 * -0.25;
              break;
            case LiteGraph.RIGHT:
              start_offset_x = dist2 * 0.25;
              break;
            case LiteGraph.UP:
              start_offset_y = dist2 * -0.25;
              break;
            case LiteGraph.DOWN:
              start_offset_y = dist2 * 0.25;
              break;
          }
          switch (end_dir) {
            case LiteGraph.LEFT:
              end_offset_x = dist2 * -0.25;
              break;
            case LiteGraph.RIGHT:
              end_offset_x = dist2 * 0.25;
              break;
            case LiteGraph.UP:
              end_offset_y = dist2 * -0.25;
              break;
            case LiteGraph.DOWN:
              end_offset_y = dist2 * 0.25;
              break;
          }
          ctx.bezierCurveTo(
            a[0] + start_offset_x,
            a[1] + start_offset_y + offsety,
            b[0] + end_offset_x,
            b[1] + end_offset_y + offsety,
            b[0],
            b[1] + offsety
          );
        } else if (this.links_render_mode == LiteGraph.LINEAR_LINK) {
          ctx.moveTo(a[0], a[1] + offsety);
          var start_offset_x = 0;
          var start_offset_y = 0;
          var end_offset_x = 0;
          var end_offset_y = 0;
          switch (start_dir) {
            case LiteGraph.LEFT:
              start_offset_x = -1;
              break;
            case LiteGraph.RIGHT:
              start_offset_x = 1;
              break;
            case LiteGraph.UP:
              start_offset_y = -1;
              break;
            case LiteGraph.DOWN:
              start_offset_y = 1;
              break;
          }
          switch (end_dir) {
            case LiteGraph.LEFT:
              end_offset_x = -1;
              break;
            case LiteGraph.RIGHT:
              end_offset_x = 1;
              break;
            case LiteGraph.UP:
              end_offset_y = -1;
              break;
            case LiteGraph.DOWN:
              end_offset_y = 1;
              break;
          }
          var l = 15;
          ctx.lineTo(
            a[0] + start_offset_x * l,
            a[1] + start_offset_y * l + offsety
          );
          ctx.lineTo(
            b[0] + end_offset_x * l,
            b[1] + end_offset_y * l + offsety
          );
          ctx.lineTo(b[0], b[1] + offsety);
        } else if (this.links_render_mode == LiteGraph.STRAIGHT_LINK) {
          ctx.moveTo(a[0], a[1]);
          var start_x = a[0];
          var start_y = a[1];
          var end_x = b[0];
          var end_y = b[1];
          if (start_dir == LiteGraph.RIGHT) {
            start_x += 10;
          } else {
            start_y += 10;
          }
          if (end_dir == LiteGraph.LEFT) {
            end_x -= 10;
          } else {
            end_y -= 10;
          }
          ctx.lineTo(start_x, start_y);
          ctx.lineTo((start_x + end_x) * 0.5, start_y);
          ctx.lineTo((start_x + end_x) * 0.5, end_y);
          ctx.lineTo(end_x, end_y);
          ctx.lineTo(b[0], b[1]);
        } else {
          return;
        }
      }
      if (this.render_connections_border && this.ds.scale > 0.6 && !skip_border) {
        ctx.strokeStyle = "rgba(0,0,0,0.5)";
        ctx.stroke();
      }
      ctx.lineWidth = this.connections_width;
      ctx.fillStyle = ctx.strokeStyle = color;
      ctx.stroke();
      var pos2 = this.computeConnectionPoint(a, b, 0.5, start_dir, end_dir);
      if (link && link._pos) {
        link._pos[0] = pos2[0];
        link._pos[1] = pos2[1];
      }
      if (this.ds.scale >= 0.6 && this.highquality_render && end_dir != LiteGraph.CENTER) {
        if (this.render_connection_arrows) {
          var posA = this.computeConnectionPoint(
            a,
            b,
            0.25,
            start_dir,
            end_dir
          );
          var posB = this.computeConnectionPoint(
            a,
            b,
            0.26,
            start_dir,
            end_dir
          );
          var posC = this.computeConnectionPoint(
            a,
            b,
            0.75,
            start_dir,
            end_dir
          );
          var posD = this.computeConnectionPoint(
            a,
            b,
            0.76,
            start_dir,
            end_dir
          );
          var angleA = 0;
          var angleB = 0;
          if (this.render_curved_connections) {
            angleA = -Math.atan2(posB[0] - posA[0], posB[1] - posA[1]);
            angleB = -Math.atan2(posD[0] - posC[0], posD[1] - posC[1]);
          } else {
            angleB = angleA = b[1] > a[1] ? 0 : Math.PI;
          }
          ctx.save();
          ctx.translate(posA[0], posA[1]);
          ctx.rotate(angleA);
          ctx.beginPath();
          ctx.moveTo(-5, -3);
          ctx.lineTo(0, 7);
          ctx.lineTo(5, -3);
          ctx.fill();
          ctx.restore();
          ctx.save();
          ctx.translate(posC[0], posC[1]);
          ctx.rotate(angleB);
          ctx.beginPath();
          ctx.moveTo(-5, -3);
          ctx.lineTo(0, 7);
          ctx.lineTo(5, -3);
          ctx.fill();
          ctx.restore();
        }
        ctx.beginPath();
        ctx.arc(pos2[0], pos2[1], 5, 0, Math.PI * 2);
        ctx.fill();
      }
      if (flow) {
        ctx.fillStyle = color;
        for (var i2 = 0; i2 < 5; ++i2) {
          var f = (LiteGraph.getTime() * 1e-3 + i2 * 0.2) % 1;
          var pos2 = this.computeConnectionPoint(
            a,
            b,
            f,
            start_dir,
            end_dir
          );
          ctx.beginPath();
          ctx.arc(pos2[0], pos2[1], 5, 0, 2 * Math.PI);
          ctx.fill();
        }
      }
    }
    //returns the link center point based on curvature
    computeConnectionPoint(a, b, t, start_dir, end_dir) {
      start_dir = start_dir || LiteGraph.RIGHT;
      end_dir = end_dir || LiteGraph.LEFT;
      var dist2 = distance(a, b);
      var p0 = a;
      var p1 = [a[0], a[1]];
      var p2 = [b[0], b[1]];
      var p3 = b;
      switch (start_dir) {
        case LiteGraph.LEFT:
          p1[0] += dist2 * -0.25;
          break;
        case LiteGraph.RIGHT:
          p1[0] += dist2 * 0.25;
          break;
        case LiteGraph.UP:
          p1[1] += dist2 * -0.25;
          break;
        case LiteGraph.DOWN:
          p1[1] += dist2 * 0.25;
          break;
      }
      switch (end_dir) {
        case LiteGraph.LEFT:
          p2[0] += dist2 * -0.25;
          break;
        case LiteGraph.RIGHT:
          p2[0] += dist2 * 0.25;
          break;
        case LiteGraph.UP:
          p2[1] += dist2 * -0.25;
          break;
        case LiteGraph.DOWN:
          p2[1] += dist2 * 0.25;
          break;
      }
      var c1 = (1 - t) * (1 - t) * (1 - t);
      var c2 = 3 * ((1 - t) * (1 - t)) * t;
      var c3 = 3 * (1 - t) * (t * t);
      var c4 = t * t * t;
      var x2 = c1 * p0[0] + c2 * p1[0] + c3 * p2[0] + c4 * p3[0];
      var y2 = c1 * p0[1] + c2 * p1[1] + c3 * p2[1] + c4 * p3[1];
      return [x2, y2];
    }
    drawExecutionOrder(ctx) {
      ctx.shadowColor = "transparent";
      ctx.globalAlpha = 0.25;
      ctx.textAlign = "center";
      ctx.strokeStyle = "white";
      ctx.globalAlpha = 0.75;
      var visible_nodes = this.visible_nodes;
      for (var i2 = 0; i2 < visible_nodes.length; ++i2) {
        var node22 = visible_nodes[i2];
        ctx.fillStyle = "black";
        ctx.fillRect(
          node22.pos[0] - LiteGraph.NODE_TITLE_HEIGHT,
          node22.pos[1] - LiteGraph.NODE_TITLE_HEIGHT,
          LiteGraph.NODE_TITLE_HEIGHT,
          LiteGraph.NODE_TITLE_HEIGHT
        );
        if (node22.order == 0) {
          ctx.strokeRect(
            node22.pos[0] - LiteGraph.NODE_TITLE_HEIGHT + 0.5,
            node22.pos[1] - LiteGraph.NODE_TITLE_HEIGHT + 0.5,
            LiteGraph.NODE_TITLE_HEIGHT,
            LiteGraph.NODE_TITLE_HEIGHT
          );
        }
        ctx.fillStyle = "#FFF";
        ctx.fillText(
          node22.order,
          node22.pos[0] + LiteGraph.NODE_TITLE_HEIGHT * -0.5,
          node22.pos[1] - 6
        );
      }
      ctx.globalAlpha = 1;
    }
    /**
         * draws the widgets stored inside a node
         * @method drawNodeWidgets
         **/
    drawNodeWidgets(node22, posY, ctx, active_widget2) {
      if (!node22.widgets || !node22.widgets.length) {
        return 0;
      }
      var width2 = node22.size[0];
      var widgets = node22.widgets;
      posY += 2;
      var H = LiteGraph.NODE_WIDGET_HEIGHT;
      var show_text = this.ds.scale > 0.5;
      ctx.save();
      ctx.globalAlpha = this.editor_alpha;
      var outline_color = LiteGraph.WIDGET_OUTLINE_COLOR;
      var background_color = LiteGraph.WIDGET_BGCOLOR;
      var text_color = LiteGraph.WIDGET_TEXT_COLOR;
      var secondary_text_color = LiteGraph.WIDGET_SECONDARY_TEXT_COLOR;
      var margin = 15;
      for (var i2 = 0; i2 < widgets.length; ++i2) {
        var w2 = widgets[i2];
        var y2 = posY;
        if (w2.y) {
          y2 = w2.y;
        }
        w2.last_y = y2;
        ctx.strokeStyle = outline_color;
        ctx.fillStyle = "#222";
        ctx.textAlign = "left";
        if (w2.disabled)
          ctx.globalAlpha *= 0.5;
        var widget_width2 = w2.width || width2;
        switch (w2.type) {
          case "button":
            ctx.fillStyle = background_color;
            if (w2.clicked) {
              ctx.fillStyle = "#AAA";
              w2.clicked = false;
              this.dirty_canvas = true;
            }
            ctx.fillRect(margin, y2, widget_width2 - margin * 2, H);
            if (show_text && !w2.disabled)
              ctx.strokeRect(margin, y2, widget_width2 - margin * 2, H);
            if (show_text) {
              ctx.textAlign = "center";
              ctx.fillStyle = text_color;
              ctx.fillText(w2.label || w2.name, widget_width2 * 0.5, y2 + H * 0.7);
            }
            break;
          case "toggle":
            ctx.textAlign = "left";
            ctx.strokeStyle = outline_color;
            ctx.fillStyle = background_color;
            ctx.beginPath();
            if (show_text)
              ctx.roundRect(margin, y2, widget_width2 - margin * 2, H, [H * 0.5]);
            else
              ctx.rect(margin, y2, widget_width2 - margin * 2, H);
            ctx.fill();
            if (show_text && !w2.disabled)
              ctx.stroke();
            ctx.fillStyle = w2.value ? "#89A" : "#333";
            ctx.beginPath();
            ctx.arc(widget_width2 - margin * 2, y2 + H * 0.5, H * 0.36, 0, Math.PI * 2);
            ctx.fill();
            if (show_text) {
              ctx.fillStyle = secondary_text_color;
              const label5 = w2.label || w2.name;
              if (label5 != null) {
                ctx.fillText(label5, margin * 2, y2 + H * 0.7);
              }
              ctx.fillStyle = w2.value ? text_color : secondary_text_color;
              ctx.textAlign = "right";
              ctx.fillText(
                w2.value ? w2.options.on || "true" : w2.options.off || "false",
                widget_width2 - 40,
                y2 + H * 0.7
              );
            }
            break;
          case "slider":
            ctx.fillStyle = background_color;
            ctx.fillRect(margin, y2, widget_width2 - margin * 2, H);
            var range2 = w2.options.max - w2.options.min;
            var nvalue2 = (w2.value - w2.options.min) / range2;
            if (nvalue2 < 0) nvalue2 = 0;
            if (nvalue2 > 1) nvalue2 = 1;
            ctx.fillStyle = w2.options.hasOwnProperty("slider_color") ? w2.options.slider_color : active_widget2 == w2 ? "#89A" : "#678";
            ctx.fillRect(margin, y2, nvalue2 * (widget_width2 - margin * 2), H);
            if (show_text && !w2.disabled)
              ctx.strokeRect(margin, y2, widget_width2 - margin * 2, H);
            if (w2.marker) {
              var marker_nvalue = (w2.marker - w2.options.min) / range2;
              if (marker_nvalue < 0) marker_nvalue = 0;
              if (marker_nvalue > 1) marker_nvalue = 1;
              ctx.fillStyle = w2.options.hasOwnProperty("marker_color") ? w2.options.marker_color : "#AA9";
              ctx.fillRect(margin + marker_nvalue * (widget_width2 - margin * 2), y2, 2, H);
            }
            if (show_text) {
              ctx.textAlign = "center";
              ctx.fillStyle = text_color;
              ctx.fillText(
                w2.label || w2.name + "  " + Number(w2.value).toFixed(
                  w2.options.precision != null ? w2.options.precision : 3
                ),
                widget_width2 * 0.5,
                y2 + H * 0.7
              );
            }
            break;
          case "number":
          case "combo":
            ctx.textAlign = "left";
            ctx.strokeStyle = outline_color;
            ctx.fillStyle = background_color;
            ctx.beginPath();
            if (show_text)
              ctx.roundRect(margin, y2, widget_width2 - margin * 2, H, [H * 0.5]);
            else
              ctx.rect(margin, y2, widget_width2 - margin * 2, H);
            ctx.fill();
            if (show_text) {
              if (!w2.disabled)
                ctx.stroke();
              ctx.fillStyle = text_color;
              if (!w2.disabled) {
                ctx.beginPath();
                ctx.moveTo(margin + 16, y2 + 5);
                ctx.lineTo(margin + 6, y2 + H * 0.5);
                ctx.lineTo(margin + 16, y2 + H - 5);
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(widget_width2 - margin - 16, y2 + 5);
                ctx.lineTo(widget_width2 - margin - 6, y2 + H * 0.5);
                ctx.lineTo(widget_width2 - margin - 16, y2 + H - 5);
                ctx.fill();
              }
              ctx.fillStyle = secondary_text_color;
              ctx.fillText(w2.label || w2.name, margin * 2 + 5, y2 + H * 0.7);
              ctx.fillStyle = text_color;
              ctx.textAlign = "right";
              if (w2.type == "number") {
                ctx.fillText(
                  Number(w2.value).toFixed(
                    w2.options.precision !== void 0 ? w2.options.precision : 3
                  ),
                  widget_width2 - margin * 2 - 20,
                  y2 + H * 0.7
                );
              } else {
                var v2 = w2.value;
                if (w2.options.values) {
                  var values2 = w2.options.values;
                  if (values2.constructor === Function)
                    values2 = values2();
                  if (values2 && values2.constructor !== Array)
                    v2 = values2[w2.value];
                }
                const labelWidth = ctx.measureText(w2.label || w2.name).width + margin * 2;
                const inputWidth = widget_width2 - margin * 4;
                const availableWidth = inputWidth - labelWidth;
                const textWidth = ctx.measureText(v2).width;
                if (textWidth > availableWidth) {
                  const ELLIPSIS = "";
                  const ellipsisWidth = ctx.measureText(ELLIPSIS).width;
                  const charWidthAvg = ctx.measureText("a").width;
                  if (availableWidth <= ellipsisWidth) {
                    v2 = "";
                  } else {
                    v2 = `${v2}`;
                    const overflowWidth = textWidth + ellipsisWidth - availableWidth;
                    if (overflowWidth + charWidthAvg * 3 > availableWidth) {
                      const preciseRange = availableWidth + charWidthAvg * 3;
                      const preTruncateCt = Math.floor((preciseRange - ellipsisWidth) / charWidthAvg);
                      v2 = v2.substr(0, preTruncateCt);
                    }
                    while (ctx.measureText(v2).width + ellipsisWidth > availableWidth) {
                      v2 = v2.substr(0, v2.length - 1);
                    }
                    v2 += ELLIPSIS;
                  }
                }
                ctx.fillText(
                  v2,
                  widget_width2 - margin * 2 - 20,
                  y2 + H * 0.7
                );
              }
            }
            break;
          case "string":
          case "text":
            ctx.textAlign = "left";
            ctx.strokeStyle = outline_color;
            ctx.fillStyle = background_color;
            ctx.beginPath();
            if (show_text)
              ctx.roundRect(margin, y2, widget_width2 - margin * 2, H, [H * 0.5]);
            else
              ctx.rect(margin, y2, widget_width2 - margin * 2, H);
            ctx.fill();
            if (show_text) {
              if (!w2.disabled)
                ctx.stroke();
              ctx.save();
              ctx.beginPath();
              ctx.rect(margin, y2, widget_width2 - margin * 2, H);
              ctx.clip();
              ctx.fillStyle = secondary_text_color;
              const label5 = w2.label || w2.name;
              if (label5 != null) {
                ctx.fillText(label5, margin * 2, y2 + H * 0.7);
              }
              ctx.fillStyle = text_color;
              ctx.textAlign = "right";
              ctx.fillText(String(w2.value).substr(0, 30), widget_width2 - margin * 2, y2 + H * 0.7);
              ctx.restore();
            }
            break;
          default:
            if (w2.draw) {
              w2.draw(ctx, node22, widget_width2, y2, H);
            }
            break;
        }
        posY += (w2.computeSize ? w2.computeSize(widget_width2)[1] : H) + 4;
        ctx.globalAlpha = this.editor_alpha;
      }
      ctx.restore();
      ctx.textAlign = "left";
    }
    /**
         * process an event on widgets
         * @method processNodeWidgets
         **/
    processNodeWidgets(node, pos, event, active_widget) {
      if (!node.widgets || !node.widgets.length || !this.allow_interaction && !node.flags.allow_interaction) {
        return null;
      }
      var x = pos[0] - node.pos[0];
      var y = pos[1] - node.pos[1];
      var width = node.size[0];
      var that = this;
      var ref_window = this.getCanvasWindow();
      for (var i = 0; i < node.widgets.length; ++i) {
        var w = node.widgets[i];
        if (!w || w.disabled)
          continue;
        var widget_height = w.computeSize ? w.computeSize(width)[1] : LiteGraph.NODE_WIDGET_HEIGHT;
        var widget_width = w.width || width;
        if (w != active_widget && (x < 6 || x > widget_width - 12 || y < w.last_y || y > w.last_y + widget_height || w.last_y === void 0))
          continue;
        var old_value = w.value;
        switch (w.type) {
          case "button":
            if (event.type === LiteGraph.pointerevents_method + "down") {
              if (w.callback) {
                setTimeout(function() {
                  w.callback(w, that, node, pos, event);
                }, 20);
              }
              w.clicked = true;
              this.dirty_canvas = true;
            }
            break;
          case "slider":
            var old_value = w.value;
            var nvalue = clamp((x - 15) / (widget_width - 30), 0, 1);
            if (w.options.read_only) break;
            w.value = w.options.min + (w.options.max - w.options.min) * nvalue;
            if (old_value != w.value) {
              setTimeout(function() {
                inner_value_change(w, w.value);
              }, 20);
            }
            this.dirty_canvas = true;
            break;
          case "number":
          case "combo":
            var old_value = w.value;
            var delta = x < 40 ? -1 : x > widget_width - 40 ? 1 : 0;
            var allow_scroll = true;
            if (delta) {
              if (x > -3 && x < widget_width + 3) {
                allow_scroll = false;
              }
            }
            if (allow_scroll && event.type == LiteGraph.pointerevents_method + "move" && w.type == "number") {
              if (event.deltaX)
                w.value += event.deltaX * 0.1 * (w.options.step || 1);
              if (w.options.min != null && w.value < w.options.min) {
                w.value = w.options.min;
              }
              if (w.options.max != null && w.value > w.options.max) {
                w.value = w.options.max;
              }
            } else if (event.type == LiteGraph.pointerevents_method + "down") {
              var values = w.options.values;
              if (values && values.constructor === Function) {
                values = w.options.values(w, node);
              }
              var values_list = null;
              if (w.type != "number")
                values_list = values.constructor === Array ? values : Object.keys(values);
              var delta = x < 40 ? -1 : x > widget_width - 40 ? 1 : 0;
              if (w.type == "number") {
                w.value += delta * 0.1 * (w.options.step || 1);
                if (w.options.min != null && w.value < w.options.min) {
                  w.value = w.options.min;
                }
                if (w.options.max != null && w.value > w.options.max) {
                  w.value = w.options.max;
                }
              } else if (delta) {
                var index = -1;
                this.last_mouseclick = 0;
                if (values.constructor === Object)
                  index = values_list.indexOf(String(w.value)) + delta;
                else
                  index = values_list.indexOf(w.value) + delta;
                if (index >= values_list.length) {
                  index = values_list.length - 1;
                }
                if (index < 0) {
                  index = 0;
                }
                if (values.constructor === Array)
                  w.value = values[index];
                else
                  w.value = index;
              } else {
                let inner_clicked = /* @__PURE__ */ __name(function(v2, option4, event2) {
                  if (values != values_list)
                    v2 = text_values.indexOf(v2);
                  this.value = v2;
                  inner_value_change(this, v2);
                  that.dirty_canvas = true;
                  return false;
                }, "inner_clicked");
                var text_values = values != values_list ? Object.values(values) : values;
                new LiteGraph.ContextMenu(
                  text_values,
                  {
                    scale: Math.max(1, this.ds.scale),
                    event,
                    className: "dark",
                    callback: inner_clicked.bind(w)
                  },
                  ref_window
                );
              }
            } else if (event.type == LiteGraph.pointerevents_method + "up" && w.type == "number") {
              var delta = x < 40 ? -1 : x > widget_width - 40 ? 1 : 0;
              if (event.click_time < 200 && delta == 0) {
                this.prompt(
                  "Value",
                  w.value,
                  function(v) {
                    if (/^[0-9+\-*/()\s]+|\d+\.\d+$/.test(v)) {
                      try {
                        v = eval(v);
                      } catch (e) {
                      }
                    }
                    this.value = Number(v);
                    inner_value_change(this, this.value);
                  }.bind(w),
                  event
                );
              }
            }
            if (old_value != w.value)
              setTimeout(
                function() {
                  inner_value_change(this, this.value);
                }.bind(w),
                20
              );
            this.dirty_canvas = true;
            break;
          case "toggle":
            if (event.type == LiteGraph.pointerevents_method + "down") {
              w.value = !w.value;
              setTimeout(function() {
                inner_value_change(w, w.value);
              }, 20);
            }
            break;
          case "string":
          case "text":
            if (event.type == LiteGraph.pointerevents_method + "down") {
              this.prompt(
                "Value",
                w.value,
                function(v2) {
                  inner_value_change(this, v2);
                }.bind(w),
                event,
                w.options ? w.options.multiline : false
              );
            }
            break;
          default:
            if (w.mouse) {
              this.dirty_canvas = w.mouse(event, [x, y], node);
            }
            break;
        }
        if (old_value != w.value) {
          if (node.onWidgetChanged)
            node.onWidgetChanged(w.name, w.value, old_value, w);
          node.graph._version++;
        }
        return w;
      }
      function inner_value_change(widget, value3) {
        if (widget.type == "number") {
          value3 = Number(value3);
        }
        widget.value = value3;
        if (widget.options && widget.options.property && node.properties[widget.options.property] !== void 0) {
          node.setProperty(widget.options.property, value3);
        }
        if (widget.callback) {
          widget.callback(widget.value, that, node, pos, event);
        }
      }
      __name(inner_value_change, "inner_value_change");
      return null;
    }
    /**
     * draws every group area in the background
     * @method drawGroups
     **/
    drawGroups(canvas, ctx) {
      if (!this.graph) {
        return;
      }
      var groups = this.graph._groups;
      ctx.save();
      ctx.globalAlpha = 0.5 * this.editor_alpha;
      for (var i2 = 0; i2 < groups.length; ++i2) {
        var group = groups[i2];
        if (!overlapBounding(this.visible_area, group._bounding)) {
          continue;
        }
        group.draw(this, ctx);
      }
      ctx.restore();
    }
    adjustNodesSize() {
      var nodes = this.graph._nodes;
      for (var i2 = 0; i2 < nodes.length; ++i2) {
        nodes[i2].size = nodes[i2].computeSize();
      }
      this.setDirty(true, true);
    }
    /**
         * resizes the canvas to a given size, if no size is passed, then it tries to fill the parentNode
         * @method resize
         **/
    resize(width2, height) {
      if (!width2 && !height) {
        var parent = this.canvas.parentNode;
        width2 = parent.offsetWidth;
        height = parent.offsetHeight;
      }
      if (this.canvas.width == width2 && this.canvas.height == height) {
        return;
      }
      this.canvas.width = width2;
      this.canvas.height = height;
      this.bgcanvas.width = this.canvas.width;
      this.bgcanvas.height = this.canvas.height;
      this.setDirty(true, true);
    }
    /**
         * switches to live mode (node shapes are not rendered, only the content)
         * this feature was designed when graphs where meant to create user interfaces
         * @method switchLiveMode
         **/
    switchLiveMode(transition) {
      if (!transition) {
        this.live_mode = !this.live_mode;
        this.dirty_canvas = true;
        this.dirty_bgcanvas = true;
        return;
      }
      var self2 = this;
      var delta2 = this.live_mode ? 1.1 : 0.9;
      if (this.live_mode) {
        this.live_mode = false;
        this.editor_alpha = 0.1;
      }
      var t = setInterval(function() {
        self2.editor_alpha *= delta2;
        self2.dirty_canvas = true;
        self2.dirty_bgcanvas = true;
        if (delta2 < 1 && self2.editor_alpha < 0.01) {
          clearInterval(t);
          if (delta2 < 1) {
            self2.live_mode = true;
          }
        }
        if (delta2 > 1 && self2.editor_alpha > 0.99) {
          clearInterval(t);
          self2.editor_alpha = 1;
        }
      }, 1);
    }
    onNodeSelectionChange(node22) {
      return;
    }
    /**
         * Determines the furthest nodes in each direction for the currently selected nodes
         * @return {{left: LGraphNode, top: LGraphNode, right: LGraphNode, bottom: LGraphNode}}
         */
    boundaryNodesForSelection() {
      return __LGraphCanvas.getBoundaryNodes(Object.values(this.selected_nodes));
    }
    showLinkMenu(link, e) {
      var that2 = this;
      var node_left = that2.graph.getNodeById(link.origin_id);
      var node_right = that2.graph.getNodeById(link.target_id);
      var fromType = false;
      if (node_left && node_left.outputs && node_left.outputs[link.origin_slot]) fromType = node_left.outputs[link.origin_slot].type;
      var destType = false;
      if (node_right && node_right.outputs && node_right.outputs[link.target_slot]) destType = node_right.inputs[link.target_slot].type;
      var options3 = ["Add Node", null, "Delete", null];
      var menu = new LiteGraph.ContextMenu(options3, {
        event: e,
        title: link.data != null ? link.data.constructor.name : null,
        callback: inner_clicked
      });
      function inner_clicked(v2, options22, e2) {
        switch (v2) {
          case "Add Node":
            __LGraphCanvas.onMenuAdd(null, null, e2, menu, function(node22) {
              if (!node22.inputs || !node22.inputs.length || !node22.outputs || !node22.outputs.length) {
                return;
              }
              if (node_left.connectByType(link.origin_slot, node22, fromType)) {
                node22.connectByType(link.target_slot, node_right, destType);
                node22.pos[0] -= node22.size[0] * 0.5;
              }
            });
            break;
          case "Delete":
            that2.graph.removeLink(link.id);
            break;
        }
      }
      __name(inner_clicked, "inner_clicked");
      return false;
    }
    createDefaultNodeForSlot(optPass) {
      var optPass = optPass || {};
      var opts = Object.assign(
        {
          nodeFrom: null,
          slotFrom: null,
          nodeTo: null,
          slotTo: null,
          position: [],
          nodeType: null,
          posAdd: [0, 0],
          posSizeFix: [0, 0]
          // alpha, adjust the position x,y based on the new node size w,h
        },
        optPass
      );
      var that2 = this;
      var isFrom = opts.nodeFrom && opts.slotFrom !== null;
      var isTo = !isFrom && opts.nodeTo && opts.slotTo !== null;
      if (!isFrom && !isTo) {
        console.warn("No data passed to createDefaultNodeForSlot " + opts.nodeFrom + " " + opts.slotFrom + " " + opts.nodeTo + " " + opts.slotTo);
        return false;
      }
      if (!opts.nodeType) {
        console.warn("No type to createDefaultNodeForSlot");
        return false;
      }
      var nodeX = isFrom ? opts.nodeFrom : opts.nodeTo;
      var slotX = isFrom ? opts.slotFrom : opts.slotTo;
      var iSlotConn = false;
      switch (typeof slotX) {
        case "string":
          iSlotConn = isFrom ? nodeX.findOutputSlot(slotX, false) : nodeX.findInputSlot(slotX, false);
          slotX = isFrom ? nodeX.outputs[slotX] : nodeX.inputs[slotX];
          break;
        case "object":
          iSlotConn = isFrom ? nodeX.findOutputSlot(slotX.name) : nodeX.findInputSlot(slotX.name);
          break;
        case "number":
          iSlotConn = slotX;
          slotX = isFrom ? nodeX.outputs[slotX] : nodeX.inputs[slotX];
          break;
        case "undefined":
        default:
          console.warn("Cant get slot information " + slotX);
          return false;
      }
      if (slotX === false || iSlotConn === false) {
        console.warn("createDefaultNodeForSlot bad slotX " + slotX + " " + iSlotConn);
      }
      var fromSlotType = slotX.type == LiteGraph.EVENT ? "_event_" : slotX.type;
      var slotTypesDefault = isFrom ? LiteGraph.slot_types_default_out : LiteGraph.slot_types_default_in;
      if (slotTypesDefault && slotTypesDefault[fromSlotType]) {
        if (slotX.link !== null) ;
        let nodeNewType = false;
        if (typeof slotTypesDefault[fromSlotType] == "object" || typeof slotTypesDefault[fromSlotType] == "array") {
          for (var typeX in slotTypesDefault[fromSlotType]) {
            if (opts.nodeType == slotTypesDefault[fromSlotType][typeX] || opts.nodeType == "AUTO") {
              nodeNewType = slotTypesDefault[fromSlotType][typeX];
              break;
            }
          }
        } else {
          if (opts.nodeType == slotTypesDefault[fromSlotType] || opts.nodeType == "AUTO") nodeNewType = slotTypesDefault[fromSlotType];
        }
        if (nodeNewType) {
          var nodeNewOpts = false;
          if (typeof nodeNewType == "object" && nodeNewType.node) {
            nodeNewOpts = nodeNewType;
            nodeNewType = nodeNewType.node;
          }
          var newNode = LiteGraph.createNode(nodeNewType);
          if (newNode) {
            if (nodeNewOpts) {
              if (nodeNewOpts.properties) {
                for (var i2 in nodeNewOpts.properties) {
                  newNode.addProperty(i2, nodeNewOpts.properties[i2]);
                }
              }
              if (nodeNewOpts.inputs) {
                newNode.inputs = [];
                for (var i2 in nodeNewOpts.inputs) {
                  newNode.addOutput(
                    nodeNewOpts.inputs[i2][0],
                    nodeNewOpts.inputs[i2][1]
                  );
                }
              }
              if (nodeNewOpts.outputs) {
                newNode.outputs = [];
                for (var i2 in nodeNewOpts.outputs) {
                  newNode.addOutput(
                    nodeNewOpts.outputs[i2][0],
                    nodeNewOpts.outputs[i2][1]
                  );
                }
              }
              if (nodeNewOpts.title) {
                newNode.title = nodeNewOpts.title;
              }
              if (nodeNewOpts.json) {
                newNode.configure(nodeNewOpts.json);
              }
            }
            that2.graph.add(newNode);
            newNode.pos = [
              opts.position[0] + opts.posAdd[0] + (opts.posSizeFix[0] ? opts.posSizeFix[0] * newNode.size[0] : 0),
              opts.position[1] + opts.posAdd[1] + (opts.posSizeFix[1] ? opts.posSizeFix[1] * newNode.size[1] : 0)
            ];
            if (isFrom) {
              opts.nodeFrom.connectByType(iSlotConn, newNode, fromSlotType);
            } else {
              opts.nodeTo.connectByTypeOutput(iSlotConn, newNode, fromSlotType);
            }
            return true;
          } else {
            console.log("failed creating " + nodeNewType);
          }
        }
      }
      return false;
    }
    showConnectionMenu(optPass) {
      var optPass = optPass || {};
      var opts = Object.assign(
        {
          nodeFrom: null,
          slotFrom: null,
          nodeTo: null,
          slotTo: null,
          e: null,
          allow_searchbox: this.allow_searchbox,
          showSearchBox: this.showSearchBox
        },
        optPass
      );
      var that2 = this;
      var isFrom = opts.nodeFrom && opts.slotFrom;
      var isTo = !isFrom && opts.nodeTo && opts.slotTo;
      if (!isFrom && !isTo) {
        console.warn("No data passed to showConnectionMenu");
        return;
      }
      var nodeX = isFrom ? opts.nodeFrom : opts.nodeTo;
      var slotX = isFrom ? opts.slotFrom : opts.slotTo;
      var iSlotConn = false;
      switch (typeof slotX) {
        case "string":
          iSlotConn = isFrom ? nodeX.findOutputSlot(slotX, false) : nodeX.findInputSlot(slotX, false);
          slotX = isFrom ? nodeX.outputs[slotX] : nodeX.inputs[slotX];
          break;
        case "object":
          iSlotConn = isFrom ? nodeX.findOutputSlot(slotX.name) : nodeX.findInputSlot(slotX.name);
          break;
        case "number":
          iSlotConn = slotX;
          slotX = isFrom ? nodeX.outputs[slotX] : nodeX.inputs[slotX];
          break;
        default:
          console.warn("Cant get slot information " + slotX);
          return;
      }
      var options3 = ["Add Node", null];
      if (opts.allow_searchbox) {
        options3.push("Search");
        options3.push(null);
      }
      var fromSlotType = slotX.type == LiteGraph.EVENT ? "_event_" : slotX.type;
      var slotTypesDefault = isFrom ? LiteGraph.slot_types_default_out : LiteGraph.slot_types_default_in;
      if (slotTypesDefault && slotTypesDefault[fromSlotType]) {
        if (typeof slotTypesDefault[fromSlotType] == "object" || typeof slotTypesDefault[fromSlotType] == "array") {
          for (var typeX in slotTypesDefault[fromSlotType]) {
            options3.push(slotTypesDefault[fromSlotType][typeX]);
          }
        } else {
          options3.push(slotTypesDefault[fromSlotType]);
        }
      }
      var menu = new LiteGraph.ContextMenu(options3, {
        event: opts.e,
        title: (slotX && slotX.name != "" ? slotX.name + (fromSlotType ? " | " : "") : "") + (slotX && fromSlotType ? fromSlotType : ""),
        callback: inner_clicked
      });
      function inner_clicked(v2, options22, e) {
        switch (v2) {
          case "Add Node":
            __LGraphCanvas.onMenuAdd(null, null, e, menu, function(node22) {
              if (isFrom) {
                opts.nodeFrom.connectByType(iSlotConn, node22, fromSlotType);
              } else {
                opts.nodeTo.connectByTypeOutput(iSlotConn, node22, fromSlotType);
              }
            });
            break;
          case "Search":
            if (isFrom) {
              opts.showSearchBox(e, { node_from: opts.nodeFrom, slot_from: slotX, type_filter_in: fromSlotType });
            } else {
              opts.showSearchBox(e, { node_to: opts.nodeTo, slot_from: slotX, type_filter_out: fromSlotType });
            }
            break;
          default:
            that2.createDefaultNodeForSlot(Object.assign(opts, {
              position: [opts.e.canvasX, opts.e.canvasY],
              nodeType: v2
            }));
            break;
        }
      }
      __name(inner_clicked, "inner_clicked");
    }
    // refactor: there are different dialogs, some uses createDialog some dont
    prompt(title, value3, callback, event2, multiline) {
      var that2 = this;
      title = title || "";
      var dialog = document.createElement("div");
      dialog.is_modified = false;
      dialog.className = "graphdialog rounded";
      if (multiline)
        dialog.innerHTML = "<span class='name'></span> <textarea autofocus class='value'></textarea><button class='rounded'>OK</button>";
      else
        dialog.innerHTML = "<span class='name'></span> <input autofocus type='text' class='value'/><button class='rounded'>OK</button>";
      dialog.close = function() {
        that2.prompt_box = null;
        if (dialog.parentNode) {
          dialog.parentNode.removeChild(dialog);
        }
      };
      var graphcanvas = __LGraphCanvas.active_canvas;
      var canvas = graphcanvas.canvas;
      canvas.parentNode.appendChild(dialog);
      if (this.ds.scale > 1) {
        dialog.style.transform = "scale(" + this.ds.scale + ")";
      }
      var dialogCloseTimer = null;
      var prevent_timeout = false;
      LiteGraph.pointerListenerAdd(dialog, "leave", function(e) {
        if (prevent_timeout)
          return;
        if (LiteGraph.dialog_close_on_mouse_leave) {
          if (!dialog.is_modified && LiteGraph.dialog_close_on_mouse_leave)
            dialogCloseTimer = setTimeout(dialog.close, LiteGraph.dialog_close_on_mouse_leave_delay);
        }
      });
      LiteGraph.pointerListenerAdd(dialog, "enter", function(e) {
        if (LiteGraph.dialog_close_on_mouse_leave) {
          if (dialogCloseTimer) clearTimeout(dialogCloseTimer);
        }
      });
      var selInDia = dialog.querySelectorAll("select");
      if (selInDia) {
        selInDia.forEach(function(selIn) {
          selIn.addEventListener("click", function(e) {
            prevent_timeout++;
          });
          selIn.addEventListener("blur", function(e) {
            prevent_timeout = 0;
          });
          selIn.addEventListener("change", function(e) {
            prevent_timeout = -1;
          });
        });
      }
      if (that2.prompt_box) {
        that2.prompt_box.close();
      }
      that2.prompt_box = dialog;
      var name_element = dialog.querySelector(".name");
      name_element.innerText = title;
      var value_element = dialog.querySelector(".value");
      value_element.value = value3;
      value_element.select();
      var input = value_element;
      input.addEventListener("keydown", function(e) {
        dialog.is_modified = true;
        if (e.keyCode == 27) {
          dialog.close();
        } else if (e.keyCode == 13 && e.target.localName != "textarea") {
          if (callback) {
            callback(this.value);
          }
          dialog.close();
        } else {
          return;
        }
        e.preventDefault();
        e.stopPropagation();
      });
      var button = dialog.querySelector("button");
      button.addEventListener("click", function(e) {
        if (callback) {
          callback(input.value);
        }
        that2.setDirty(true);
        dialog.close();
      });
      var rect = canvas.getBoundingClientRect();
      var offsetx = -20;
      var offsety = -20;
      if (rect) {
        offsetx -= rect.left;
        offsety -= rect.top;
      }
      if (event2) {
        dialog.style.left = event2.clientX + offsetx + "px";
        dialog.style.top = event2.clientY + offsety + "px";
      } else {
        dialog.style.left = canvas.width * 0.5 + offsetx + "px";
        dialog.style.top = canvas.height * 0.5 + offsety + "px";
      }
      setTimeout(function() {
        input.focus();
        const clickTime = Date.now();
        function handleOutsideClick(e) {
          if (e.target === canvas && Date.now() - clickTime > 256) {
            dialog.close();
            canvas.parentNode.removeEventListener("click", handleOutsideClick);
            canvas.parentNode.removeEventListener("touchend", handleOutsideClick);
          }
        }
        __name(handleOutsideClick, "handleOutsideClick");
        canvas.parentNode.addEventListener("click", handleOutsideClick);
        canvas.parentNode.addEventListener("touchend", handleOutsideClick);
      }, 10);
      return dialog;
    }
    showSearchBox(event2, options3) {
      var def_options = {
        slot_from: null,
        node_from: null,
        node_to: null,
        do_type_filter: LiteGraph.search_filter_enabled,
        type_filter_in: false,
        type_filter_out: false,
        show_general_if_none_on_typefilter: true,
        show_general_after_typefiltered: true,
        hide_on_mouse_leave: LiteGraph.search_hide_on_mouse_leave,
        show_all_if_empty: true,
        show_all_on_open: LiteGraph.search_show_all_on_open
      };
      options3 = Object.assign(def_options, options3 || {});
      var that2 = this;
      var graphcanvas = __LGraphCanvas.active_canvas;
      var canvas = graphcanvas.canvas;
      var root_document = canvas.ownerDocument || document;
      var dialog = document.createElement("div");
      dialog.className = "litegraph litesearchbox graphdialog rounded";
      dialog.innerHTML = "<span class='name'>Search</span> <input autofocus type='text' class='value rounded'/>";
      if (options3.do_type_filter) {
        dialog.innerHTML += "<select class='slot_in_type_filter'><option value=''></option></select>";
        dialog.innerHTML += "<select class='slot_out_type_filter'><option value=''></option></select>";
      }
      dialog.innerHTML += "<div class='helper'></div>";
      if (root_document.fullscreenElement)
        root_document.fullscreenElement.appendChild(dialog);
      else {
        root_document.body.appendChild(dialog);
        root_document.body.style.overflow = "hidden";
      }
      if (options3.do_type_filter) {
        var selIn = dialog.querySelector(".slot_in_type_filter");
        var selOut = dialog.querySelector(".slot_out_type_filter");
      }
      dialog.close = function() {
        that2.search_box = null;
        this.blur();
        canvas.focus();
        root_document.body.style.overflow = "";
        setTimeout(function() {
          that2.canvas.focus();
        }, 20);
        if (dialog.parentNode) {
          dialog.parentNode.removeChild(dialog);
        }
      };
      if (this.ds.scale > 1) {
        dialog.style.transform = "scale(" + this.ds.scale + ")";
      }
      if (options3.hide_on_mouse_leave) {
        var prevent_timeout = false;
        var timeout_close = null;
        LiteGraph.pointerListenerAdd(dialog, "enter", function(e) {
          if (timeout_close) {
            clearTimeout(timeout_close);
            timeout_close = null;
          }
        });
        LiteGraph.pointerListenerAdd(dialog, "leave", function(e) {
          if (prevent_timeout) {
            return;
          }
          timeout_close = setTimeout(function() {
            dialog.close();
          }, typeof options3.hide_on_mouse_leave === "number" ? options3.hide_on_mouse_leave : 500);
        });
        if (options3.do_type_filter) {
          selIn.addEventListener("click", function(e) {
            prevent_timeout++;
          });
          selIn.addEventListener("blur", function(e) {
            prevent_timeout = 0;
          });
          selIn.addEventListener("change", function(e) {
            prevent_timeout = -1;
          });
          selOut.addEventListener("click", function(e) {
            prevent_timeout++;
          });
          selOut.addEventListener("blur", function(e) {
            prevent_timeout = 0;
          });
          selOut.addEventListener("change", function(e) {
            prevent_timeout = -1;
          });
        }
      }
      if (that2.search_box) {
        that2.search_box.close();
      }
      that2.search_box = dialog;
      var helper = dialog.querySelector(".helper");
      var first = null;
      var timeout = null;
      var selected2 = null;
      var input = dialog.querySelector("input");
      if (input) {
        input.addEventListener("blur", function(e) {
          this.focus();
        });
        input.addEventListener("keydown", function(e) {
          if (e.keyCode == 38) {
            changeSelection(false);
          } else if (e.keyCode == 40) {
            changeSelection(true);
          } else if (e.keyCode == 27) {
            dialog.close();
          } else if (e.keyCode == 13) {
            if (selected2) {
              select(unescape(selected2.dataset["type"]));
            } else if (first) {
              select(first);
            } else {
              dialog.close();
            }
          } else {
            if (timeout) {
              clearInterval(timeout);
            }
            timeout = setTimeout(refreshHelper, 10);
            return;
          }
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
          return true;
        });
      }
      if (options3.do_type_filter) {
        if (selIn) {
          var aSlots = LiteGraph.slot_types_in;
          var nSlots = aSlots.length;
          if (options3.type_filter_in == LiteGraph.EVENT || options3.type_filter_in == LiteGraph.ACTION)
            options3.type_filter_in = "_event_";
          for (var iK = 0; iK < nSlots; iK++) {
            var opt = document.createElement("option");
            opt.value = aSlots[iK];
            opt.innerHTML = aSlots[iK];
            selIn.appendChild(opt);
            if (options3.type_filter_in !== false && (options3.type_filter_in + "").toLowerCase() == (aSlots[iK] + "").toLowerCase()) {
              opt.selected = true;
            }
          }
          selIn.addEventListener("change", function() {
            refreshHelper();
          });
        }
        if (selOut) {
          var aSlots = LiteGraph.slot_types_out;
          var nSlots = aSlots.length;
          if (options3.type_filter_out == LiteGraph.EVENT || options3.type_filter_out == LiteGraph.ACTION)
            options3.type_filter_out = "_event_";
          for (var iK = 0; iK < nSlots; iK++) {
            var opt = document.createElement("option");
            opt.value = aSlots[iK];
            opt.innerHTML = aSlots[iK];
            selOut.appendChild(opt);
            if (options3.type_filter_out !== false && (options3.type_filter_out + "").toLowerCase() == (aSlots[iK] + "").toLowerCase()) {
              opt.selected = true;
            }
          }
          selOut.addEventListener("change", function() {
            refreshHelper();
          });
        }
      }
      var rect = canvas.getBoundingClientRect();
      var left = (event2 ? event2.clientX : rect.left + rect.width * 0.5) - 80;
      var top = (event2 ? event2.clientY : rect.top + rect.height * 0.5) - 20;
      dialog.style.left = left + "px";
      dialog.style.top = top + "px";
      if (event2.layerY > rect.height - 200)
        helper.style.maxHeight = rect.height - event2.layerY - 20 + "px";
      input.focus();
      if (options3.show_all_on_open) refreshHelper();
      function select(name) {
        if (name) {
          if (that2.onSearchBoxSelection) {
            that2.onSearchBoxSelection(name, event2, graphcanvas);
          } else {
            var extra = LiteGraph.searchbox_extras[name.toLowerCase()];
            if (extra) {
              name = extra.type;
            }
            graphcanvas.graph.beforeChange();
            var node22 = LiteGraph.createNode(name);
            if (node22) {
              node22.pos = graphcanvas.convertEventToCanvasOffset(
                event2
              );
              graphcanvas.graph.add(node22, false);
            }
            if (extra && extra.data) {
              if (extra.data.properties) {
                for (var i2 in extra.data.properties) {
                  node22.addProperty(i2, extra.data.properties[i2]);
                }
              }
              if (extra.data.inputs) {
                node22.inputs = [];
                for (var i2 in extra.data.inputs) {
                  node22.addOutput(
                    extra.data.inputs[i2][0],
                    extra.data.inputs[i2][1]
                  );
                }
              }
              if (extra.data.outputs) {
                node22.outputs = [];
                for (var i2 in extra.data.outputs) {
                  node22.addOutput(
                    extra.data.outputs[i2][0],
                    extra.data.outputs[i2][1]
                  );
                }
              }
              if (extra.data.title) {
                node22.title = extra.data.title;
              }
              if (extra.data.json) {
                node22.configure(extra.data.json);
              }
            }
            if (options3.node_from) {
              var iS = false;
              switch (typeof options3.slot_from) {
                case "string":
                  iS = options3.node_from.findOutputSlot(options3.slot_from);
                  break;
                case "object":
                  if (options3.slot_from.name) {
                    iS = options3.node_from.findOutputSlot(options3.slot_from.name);
                  } else {
                    iS = -1;
                  }
                  if (iS == -1 && typeof options3.slot_from.slot_index !== "undefined") iS = options3.slot_from.slot_index;
                  break;
                case "number":
                  iS = options3.slot_from;
                  break;
                default:
                  iS = 0;
              }
              if (typeof options3.node_from.outputs[iS] !== "undefined") {
                if (iS !== false && iS > -1) {
                  options3.node_from.connectByType(iS, node22, options3.node_from.outputs[iS].type);
                }
              }
            }
            if (options3.node_to) {
              var iS = false;
              switch (typeof options3.slot_from) {
                case "string":
                  iS = options3.node_to.findInputSlot(options3.slot_from);
                  break;
                case "object":
                  if (options3.slot_from.name) {
                    iS = options3.node_to.findInputSlot(options3.slot_from.name);
                  } else {
                    iS = -1;
                  }
                  if (iS == -1 && typeof options3.slot_from.slot_index !== "undefined") iS = options3.slot_from.slot_index;
                  break;
                case "number":
                  iS = options3.slot_from;
                  break;
                default:
                  iS = 0;
              }
              if (typeof options3.node_to.inputs[iS] !== "undefined") {
                if (iS !== false && iS > -1) {
                  options3.node_to.connectByTypeOutput(iS, node22, options3.node_to.inputs[iS].type);
                }
              }
            }
            graphcanvas.graph.afterChange();
          }
        }
        dialog.close();
      }
      __name(select, "select");
      function changeSelection(forward) {
        var prev2 = selected2;
        if (selected2) {
          selected2.classList.remove("selected");
        }
        if (!selected2) {
          selected2 = forward ? helper.childNodes[0] : helper.childNodes[helper.childNodes.length];
        } else {
          selected2 = forward ? selected2.nextSibling : selected2.previousSibling;
          if (!selected2) {
            selected2 = prev2;
          }
        }
        if (!selected2) {
          return;
        }
        selected2.classList.add("selected");
        selected2.scrollIntoView({ block: "end", behavior: "smooth" });
      }
      __name(changeSelection, "changeSelection");
      function refreshHelper() {
        timeout = null;
        var str = input.value;
        first = null;
        helper.innerHTML = "";
        if (!str && !options3.show_all_if_empty) {
          return;
        }
        if (that2.onSearchBox) {
          var list = that2.onSearchBox(helper, str, graphcanvas);
          if (list) {
            for (var i2 = 0; i2 < list.length; ++i2) {
              addResult(list[i2]);
            }
          }
        } else {
          let inner_test_filter = /* @__PURE__ */ __name(function(type, optsIn) {
            var optsIn = optsIn || {};
            var optsDef = {
              skipFilter: false,
              inTypeOverride: false,
              outTypeOverride: false
            };
            var opts = Object.assign(optsDef, optsIn);
            var ctor2 = LiteGraph.registered_node_types[type];
            if (filter4 && ctor2.filter != filter4)
              return false;
            if ((!options3.show_all_if_empty || str) && type.toLowerCase().indexOf(str) === -1 && (!ctor2.title || ctor2.title.toLowerCase().indexOf(str) === -1))
              return false;
            if (options3.do_type_filter && !opts.skipFilter) {
              var sType = type;
              var sV = sIn.value;
              if (opts.inTypeOverride !== false) sV = opts.inTypeOverride;
              if (sIn && sV) {
                if (LiteGraph.registered_slot_in_types[sV] && LiteGraph.registered_slot_in_types[sV].nodes) {
                  var doesInc = LiteGraph.registered_slot_in_types[sV].nodes.includes(sType);
                  if (doesInc !== false) ;
                  else {
                    return false;
                  }
                }
              }
              var sV = sOut.value;
              if (opts.outTypeOverride !== false) sV = opts.outTypeOverride;
              if (sOut && sV) {
                if (LiteGraph.registered_slot_out_types[sV] && LiteGraph.registered_slot_out_types[sV].nodes) {
                  var doesInc = LiteGraph.registered_slot_out_types[sV].nodes.includes(sType);
                  if (doesInc !== false) ;
                  else {
                    return false;
                  }
                }
              }
            }
            return true;
          }, "inner_test_filter");
          var c = 0;
          str = str.toLowerCase();
          var filter4 = graphcanvas.filter || graphcanvas.graph.filter;
          if (options3.do_type_filter && that2.search_box) {
            var sIn = that2.search_box.querySelector(".slot_in_type_filter");
            var sOut = that2.search_box.querySelector(".slot_out_type_filter");
          } else {
            var sIn = false;
            var sOut = false;
          }
          for (var i2 in LiteGraph.searchbox_extras) {
            var extra = LiteGraph.searchbox_extras[i2];
            if ((!options3.show_all_if_empty || str) && extra.desc.toLowerCase().indexOf(str) === -1) {
              continue;
            }
            var ctor = LiteGraph.registered_node_types[extra.type];
            if (ctor && ctor.filter != filter4)
              continue;
            if (!inner_test_filter(extra.type))
              continue;
            addResult(extra.desc, "searchbox_extra");
            if (__LGraphCanvas.search_limit !== -1 && c++ > __LGraphCanvas.search_limit) {
              break;
            }
          }
          var filtered = null;
          if (Array.prototype.filter) {
            var keys2 = Object.keys(LiteGraph.registered_node_types);
            var filtered = keys2.filter(inner_test_filter);
          } else {
            filtered = [];
            for (var i2 in LiteGraph.registered_node_types) {
              if (inner_test_filter(i2))
                filtered.push(i2);
            }
          }
          for (var i2 = 0; i2 < filtered.length; i2++) {
            addResult(filtered[i2]);
            if (__LGraphCanvas.search_limit !== -1 && c++ > __LGraphCanvas.search_limit) {
              break;
            }
          }
          if (options3.show_general_after_typefiltered && (sIn.value || sOut.value)) {
            filtered_extra = [];
            for (var i2 in LiteGraph.registered_node_types) {
              if (inner_test_filter(i2, { inTypeOverride: sIn && sIn.value ? "*" : false, outTypeOverride: sOut && sOut.value ? "*" : false }))
                filtered_extra.push(i2);
            }
            for (var i2 = 0; i2 < filtered_extra.length; i2++) {
              addResult(filtered_extra[i2], "generic_type");
              if (__LGraphCanvas.search_limit !== -1 && c++ > __LGraphCanvas.search_limit) {
                break;
              }
            }
          }
          if ((sIn.value || sOut.value) && (helper.childNodes.length == 0 && options3.show_general_if_none_on_typefilter)) {
            filtered_extra = [];
            for (var i2 in LiteGraph.registered_node_types) {
              if (inner_test_filter(i2, { skipFilter: true }))
                filtered_extra.push(i2);
            }
            for (var i2 = 0; i2 < filtered_extra.length; i2++) {
              addResult(filtered_extra[i2], "not_in_filter");
              if (__LGraphCanvas.search_limit !== -1 && c++ > __LGraphCanvas.search_limit) {
                break;
              }
            }
          }
        }
        function addResult(type, className) {
          var help = document.createElement("div");
          if (!first) {
            first = type;
          }
          const nodeType = LiteGraph.registered_node_types[type];
          if (nodeType == null ? void 0 : nodeType.title) {
            help.innerText = nodeType == null ? void 0 : nodeType.title;
            const typeEl = document.createElement("span");
            typeEl.className = "litegraph lite-search-item-type";
            typeEl.textContent = type;
            help.append(typeEl);
          } else {
            help.innerText = type;
          }
          help.dataset["type"] = escape(type);
          help.className = "litegraph lite-search-item";
          if (className) {
            help.className += " " + className;
          }
          help.addEventListener("click", function(e) {
            select(unescape(this.dataset["type"]));
          });
          helper.appendChild(help);
        }
        __name(addResult, "addResult");
      }
      __name(refreshHelper, "refreshHelper");
      return dialog;
    }
    showEditPropertyValue(node22, property, options3) {
      if (!node22 || node22.properties[property] === void 0) {
        return;
      }
      options3 = options3 || {};
      var info = node22.getPropertyInfo(property);
      var type = info.type;
      var input_html = "";
      if (type == "string" || type == "number" || type == "array" || type == "object") {
        input_html = "<input autofocus type='text' class='value'/>";
      } else if ((type == "enum" || type == "combo") && info.values) {
        input_html = "<select autofocus type='text' class='value'>";
        for (var i2 in info.values) {
          var v2 = i2;
          if (info.values.constructor === Array)
            v2 = info.values[i2];
          input_html += "<option value='" + v2 + "' " + (v2 == node22.properties[property] ? "selected" : "") + ">" + info.values[i2] + "</option>";
        }
        input_html += "</select>";
      } else if (type == "boolean" || type == "toggle") {
        input_html = "<input autofocus type='checkbox' class='value' " + (node22.properties[property] ? "checked" : "") + "/>";
      } else {
        console.warn("unknown type: " + type);
        return;
      }
      var dialog = this.createDialog(
        "<span class='name'>" + (info.label ? info.label : property) + "</span>" + input_html + "<button>OK</button>",
        options3
      );
      var input = false;
      if ((type == "enum" || type == "combo") && info.values) {
        input = dialog.querySelector("select");
        input.addEventListener("change", function(e) {
          dialog.modified();
          setValue2(e.target.value);
        });
      } else if (type == "boolean" || type == "toggle") {
        input = dialog.querySelector("input");
        if (input) {
          input.addEventListener("click", function(e) {
            dialog.modified();
            setValue2(!!input.checked);
          });
        }
      } else {
        input = dialog.querySelector("input");
        if (input) {
          input.addEventListener("blur", function(e) {
            this.focus();
          });
          var v2 = node22.properties[property] !== void 0 ? node22.properties[property] : "";
          if (type !== "string") {
            v2 = JSON.stringify(v2);
          }
          input.value = v2;
          input.addEventListener("keydown", function(e) {
            if (e.keyCode == 27) {
              dialog.close();
            } else if (e.keyCode == 13) {
              inner();
            } else if (e.keyCode != 13) {
              dialog.modified();
              return;
            }
            e.preventDefault();
            e.stopPropagation();
          });
        }
      }
      if (input) input.focus();
      var button = dialog.querySelector("button");
      button.addEventListener("click", inner);
      function inner() {
        setValue2(input.value);
      }
      __name(inner, "inner");
      function setValue2(value3) {
        if (info && info.values && info.values.constructor === Object && info.values[value3] != void 0)
          value3 = info.values[value3];
        if (typeof node22.properties[property] == "number") {
          value3 = Number(value3);
        }
        if (type == "array" || type == "object") {
          value3 = JSON.parse(value3);
        }
        node22.properties[property] = value3;
        if (node22.graph) {
          node22.graph._version++;
        }
        if (node22.onPropertyChanged) {
          node22.onPropertyChanged(property, value3);
        }
        if (options3.onclose)
          options3.onclose();
        dialog.close();
        node22.setDirtyCanvas(true, true);
      }
      __name(setValue2, "setValue");
      return dialog;
    }
    // TODO refactor, theer are different dialog, some uses createDialog, some dont
    createDialog(html, options3) {
      var def_options = { checkForInput: false, closeOnLeave: true, closeOnLeave_checkModified: true };
      options3 = Object.assign(def_options, options3 || {});
      var dialog = document.createElement("div");
      dialog.className = "graphdialog";
      dialog.innerHTML = html;
      dialog.is_modified = false;
      var rect = this.canvas.getBoundingClientRect();
      var offsetx = -20;
      var offsety = -20;
      if (rect) {
        offsetx -= rect.left;
        offsety -= rect.top;
      }
      if (options3.position) {
        offsetx += options3.position[0];
        offsety += options3.position[1];
      } else if (options3.event) {
        offsetx += options3.event.clientX;
        offsety += options3.event.clientY;
      } else {
        offsetx += this.canvas.width * 0.5;
        offsety += this.canvas.height * 0.5;
      }
      dialog.style.left = offsetx + "px";
      dialog.style.top = offsety + "px";
      this.canvas.parentNode.appendChild(dialog);
      if (options3.checkForInput) {
        var aI = [];
        var focused = false;
        if (aI = dialog.querySelectorAll("input")) {
          aI.forEach(function(iX) {
            iX.addEventListener("keydown", function(e) {
              dialog.modified();
              if (e.keyCode == 27) {
                dialog.close();
              } else if (e.keyCode != 13) {
                return;
              }
              e.preventDefault();
              e.stopPropagation();
            });
            if (!focused) iX.focus();
          });
        }
      }
      dialog.modified = function() {
        dialog.is_modified = true;
      };
      dialog.close = function() {
        if (dialog.parentNode) {
          dialog.parentNode.removeChild(dialog);
        }
      };
      var dialogCloseTimer = null;
      var prevent_timeout = false;
      dialog.addEventListener("mouseleave", function(e) {
        if (prevent_timeout)
          return;
        if (options3.closeOnLeave || LiteGraph.dialog_close_on_mouse_leave) {
          if (!dialog.is_modified && LiteGraph.dialog_close_on_mouse_leave)
            dialogCloseTimer = setTimeout(dialog.close, LiteGraph.dialog_close_on_mouse_leave_delay);
        }
      });
      dialog.addEventListener("mouseenter", function(e) {
        if (options3.closeOnLeave || LiteGraph.dialog_close_on_mouse_leave) {
          if (dialogCloseTimer) clearTimeout(dialogCloseTimer);
        }
      });
      var selInDia = dialog.querySelectorAll("select");
      if (selInDia) {
        selInDia.forEach(function(selIn) {
          selIn.addEventListener("click", function(e) {
            prevent_timeout++;
          });
          selIn.addEventListener("blur", function(e) {
            prevent_timeout = 0;
          });
          selIn.addEventListener("change", function(e) {
            prevent_timeout = -1;
          });
        });
      }
      return dialog;
    }
    createPanel(title, options3) {
      options3 = options3 || {};
      var ref_window2 = options3.window || window;
      var root26 = document.createElement("div");
      root26.className = "litegraph dialog";
      root26.innerHTML = "<div class='dialog-header'><span class='dialog-title'></span></div><div class='dialog-content'></div><div style='display:none;' class='dialog-alt-content'></div><div class='dialog-footer'></div>";
      root26.header = root26.querySelector(".dialog-header");
      if (options3.width)
        root26.style.width = options3.width + (options3.width.constructor === Number ? "px" : "");
      if (options3.height)
        root26.style.height = options3.height + (options3.height.constructor === Number ? "px" : "");
      if (options3.closable) {
        var close4 = document.createElement("span");
        close4.innerHTML = "&#10005;";
        close4.classList.add("close");
        close4.addEventListener("click", function() {
          root26.close();
        });
        root26.header.appendChild(close4);
      }
      root26.title_element = root26.querySelector(".dialog-title");
      root26.title_element.innerText = title;
      root26.content = root26.querySelector(".dialog-content");
      root26.alt_content = root26.querySelector(".dialog-alt-content");
      root26.footer = root26.querySelector(".dialog-footer");
      root26.close = function() {
        if (root26.onClose && typeof root26.onClose == "function") {
          root26.onClose();
        }
        if (root26.parentNode)
          root26.parentNode.removeChild(root26);
        if (this.parentNode) {
          this.parentNode.removeChild(this);
        }
      };
      root26.toggleAltContent = function(force) {
        if (typeof force != "undefined") {
          var vTo = force ? "block" : "none";
          var vAlt = force ? "none" : "block";
        } else {
          var vTo = root26.alt_content.style.display != "block" ? "block" : "none";
          var vAlt = root26.alt_content.style.display != "block" ? "none" : "block";
        }
        root26.alt_content.style.display = vTo;
        root26.content.style.display = vAlt;
      };
      root26.toggleFooterVisibility = function(force) {
        if (typeof force != "undefined") {
          var vTo = force ? "block" : "none";
        } else {
          var vTo = root26.footer.style.display != "block" ? "block" : "none";
        }
        root26.footer.style.display = vTo;
      };
      root26.clear = function() {
        this.content.innerHTML = "";
      };
      root26.addHTML = function(code2, classname, on_footer) {
        var elem = document.createElement("div");
        if (classname)
          elem.className = classname;
        elem.innerHTML = code2;
        if (on_footer)
          root26.footer.appendChild(elem);
        else
          root26.content.appendChild(elem);
        return elem;
      };
      root26.addButton = function(name, callback, options22) {
        var elem = document.createElement("button");
        elem.innerText = name;
        elem.options = options22;
        elem.classList.add("btn");
        elem.addEventListener("click", callback);
        root26.footer.appendChild(elem);
        return elem;
      };
      root26.addSeparator = function() {
        var elem = document.createElement("div");
        elem.className = "separator";
        root26.content.appendChild(elem);
      };
      root26.addWidget = function(type, name, value3, options22, callback) {
        options22 = options22 || {};
        var str_value = String(value3);
        type = type.toLowerCase();
        if (type == "number")
          str_value = value3.toFixed(3);
        var elem = document.createElement("div");
        elem.className = "property";
        elem.innerHTML = "<span class='property_name'></span><span class='property_value'></span>";
        elem.querySelector(".property_name").innerText = options22.label || name;
        var value_element = elem.querySelector(".property_value");
        value_element.innerText = str_value;
        elem.dataset["property"] = name;
        elem.dataset["type"] = options22.type || type;
        elem.options = options22;
        elem.value = value3;
        if (type == "code")
          elem.addEventListener("click", function(e) {
            root26.inner_showCodePad(this.dataset["property"]);
          });
        else if (type == "boolean") {
          elem.classList.add("boolean");
          if (value3)
            elem.classList.add("bool-on");
          elem.addEventListener("click", function() {
            var propname = this.dataset["property"];
            this.value = !this.value;
            this.classList.toggle("bool-on");
            this.querySelector(".property_value").innerText = this.value ? "true" : "false";
            innerChange(propname, this.value);
          });
        } else if (type == "string" || type == "number") {
          value_element.setAttribute("contenteditable", true);
          value_element.addEventListener("keydown", function(e) {
            if (e.code == "Enter" && (type != "string" || !e.shiftKey)) {
              e.preventDefault();
              this.blur();
            }
          });
          value_element.addEventListener("blur", function() {
            var v2 = this.innerText;
            var propname = this.parentNode.dataset["property"];
            var proptype = this.parentNode.dataset["type"];
            if (proptype == "number")
              v2 = Number(v2);
            innerChange(propname, v2);
          });
        } else if (type == "enum" || type == "combo") {
          var str_value = __LGraphCanvas.getPropertyPrintableValue(value3, options22.values);
          value_element.innerText = str_value;
          value_element.addEventListener("click", function(event2) {
            var values2 = options22.values || [];
            var propname = this.parentNode.dataset["property"];
            var elem_that = this;
            new LiteGraph.ContextMenu(
              values2,
              {
                event: event2,
                className: "dark",
                callback: inner_clicked
              },
              ref_window2
            );
            function inner_clicked(v2, option4, event3) {
              elem_that.innerText = v2;
              innerChange(propname, v2);
              return false;
            }
            __name(inner_clicked, "inner_clicked");
          });
        }
        root26.content.appendChild(elem);
        function innerChange(name2, value22) {
          if (options22.callback)
            options22.callback(name2, value22, options22);
          if (callback)
            callback(name2, value22, options22);
        }
        __name(innerChange, "innerChange");
        return elem;
      };
      if (root26.onOpen && typeof root26.onOpen == "function") root26.onOpen();
      return root26;
    }
    closePanels() {
      var panel22 = document.querySelector("#node-panel");
      if (panel22)
        panel22.close();
      var panel22 = document.querySelector("#option-panel");
      if (panel22)
        panel22.close();
    }
    showShowGraphOptionsPanel(refOpts, obEv, refMenu, refMenu2) {
      if (this.constructor && this.constructor.name == "HTMLDivElement") {
        if (!obEv || !obEv.event || !obEv.event.target || !obEv.event.target.lgraphcanvas) {
          console.warn("Canvas not found");
          return;
        }
        var graphcanvas = obEv.event.target.lgraphcanvas;
      } else {
        var graphcanvas = this;
      }
      graphcanvas.closePanels();
      var ref_window2 = graphcanvas.getCanvasWindow();
      panel = graphcanvas.createPanel("Options", {
        closable: true,
        window: ref_window2,
        onOpen: /* @__PURE__ */ __name(function() {
          graphcanvas.OPTIONPANEL_IS_OPEN = true;
        }, "onOpen"),
        onClose: /* @__PURE__ */ __name(function() {
          graphcanvas.OPTIONPANEL_IS_OPEN = false;
          graphcanvas.options_panel = null;
        }, "onClose")
      });
      graphcanvas.options_panel = panel;
      panel.id = "option-panel";
      panel.classList.add("settings");
      function inner_refresh() {
        panel.content.innerHTML = "";
        var fUpdate = /* @__PURE__ */ __name(function(name, value3, options3) {
          switch (name) {
            default:
              if (options3 && options3.key) {
                name = options3.key;
              }
              if (options3.values) {
                value3 = Object.values(options3.values).indexOf(value3);
              }
              graphcanvas[name] = value3;
              break;
          }
        }, "fUpdate");
        var aProps = LiteGraph.availableCanvasOptions;
        aProps.sort();
        for (var pI in aProps) {
          var pX = aProps[pI];
          panel.addWidget("boolean", pX, graphcanvas[pX], { key: pX, on: "True", off: "False" }, fUpdate);
        }
        [graphcanvas.links_render_mode];
        panel.addWidget("combo", "Render mode", LiteGraph.LINK_RENDER_MODES[graphcanvas.links_render_mode], { key: "links_render_mode", values: LiteGraph.LINK_RENDER_MODES }, fUpdate);
        panel.addSeparator();
        panel.footer.innerHTML = "";
      }
      __name(inner_refresh, "inner_refresh");
      inner_refresh();
      graphcanvas.canvas.parentNode.appendChild(panel);
    }
    showShowNodePanel(node22) {
      this.SELECTED_NODE = node22;
      this.closePanels();
      var ref_window2 = this.getCanvasWindow();
      var graphcanvas = this;
      var panel22 = this.createPanel(node22.title || "", {
        closable: true,
        window: ref_window2,
        onOpen: /* @__PURE__ */ __name(function() {
          graphcanvas.NODEPANEL_IS_OPEN = true;
        }, "onOpen"),
        onClose: /* @__PURE__ */ __name(function() {
          graphcanvas.NODEPANEL_IS_OPEN = false;
          graphcanvas.node_panel = null;
        }, "onClose")
      });
      graphcanvas.node_panel = panel22;
      panel22.id = "node-panel";
      panel22.node = node22;
      panel22.classList.add("settings");
      function inner_refresh() {
        panel22.content.innerHTML = "";
        panel22.addHTML("<span class='node_type'>" + node22.type + "</span><span class='node_desc'>" + (node22.constructor.desc || "") + "</span><span class='separator'></span>");
        panel22.addHTML("<h3>Properties</h3>");
        var fUpdate = /* @__PURE__ */ __name(function(name, value22) {
          graphcanvas.graph.beforeChange(node22);
          switch (name) {
            case "Title":
              node22.title = value22;
              break;
            case "Mode":
              var kV = Object.values(LiteGraph.NODE_MODES).indexOf(value22);
              if (kV >= 0 && LiteGraph.NODE_MODES[kV]) {
                node22.changeMode(kV);
              } else {
                console.warn("unexpected mode: " + value22);
              }
              break;
            case "Color":
              if (__LGraphCanvas.node_colors[value22]) {
                node22.color = __LGraphCanvas.node_colors[value22].color;
                node22.bgcolor = __LGraphCanvas.node_colors[value22].bgcolor;
              } else {
                console.warn("unexpected color: " + value22);
              }
              break;
            default:
              node22.setProperty(name, value22);
              break;
          }
          graphcanvas.graph.afterChange();
          graphcanvas.dirty_canvas = true;
        }, "fUpdate");
        panel22.addWidget("string", "Title", node22.title, {}, fUpdate);
        panel22.addWidget("combo", "Mode", LiteGraph.NODE_MODES[node22.mode], { values: LiteGraph.NODE_MODES }, fUpdate);
        var nodeCol = "";
        if (node22.color !== void 0) {
          nodeCol = Object.keys(__LGraphCanvas.node_colors).filter(function(nK) {
            return __LGraphCanvas.node_colors[nK].color == node22.color;
          });
        }
        panel22.addWidget("combo", "Color", nodeCol, { values: Object.keys(__LGraphCanvas.node_colors) }, fUpdate);
        for (var pName in node22.properties) {
          var value3 = node22.properties[pName];
          var info = node22.getPropertyInfo(pName);
          info.type || "string";
          if (node22.onAddPropertyToPanel && node22.onAddPropertyToPanel(pName, panel22))
            continue;
          panel22.addWidget(info.widget || info.type, pName, value3, info, fUpdate);
        }
        panel22.addSeparator();
        if (node22.onShowCustomPanelInfo)
          node22.onShowCustomPanelInfo(panel22);
        panel22.footer.innerHTML = "";
        panel22.addButton("Delete", function() {
          if (node22.block_delete)
            return;
          node22.graph.remove(node22);
          panel22.close();
        }).classList.add("delete");
      }
      __name(inner_refresh, "inner_refresh");
      panel22.inner_showCodePad = function(propname) {
        panel22.classList.remove("settings");
        panel22.classList.add("centered");
        panel22.alt_content.innerHTML = "<textarea class='code'></textarea>";
        var textarea = panel22.alt_content.querySelector("textarea");
        var fDoneWith = /* @__PURE__ */ __name(function() {
          panel22.toggleAltContent(false);
          panel22.toggleFooterVisibility(true);
          textarea.parentNode.removeChild(textarea);
          panel22.classList.add("settings");
          panel22.classList.remove("centered");
          inner_refresh();
        }, "fDoneWith");
        textarea.value = node22.properties[propname];
        textarea.addEventListener("keydown", function(e) {
          if (e.code == "Enter" && e.ctrlKey) {
            node22.setProperty(propname, textarea.value);
            fDoneWith();
          }
        });
        panel22.toggleAltContent(true);
        panel22.toggleFooterVisibility(false);
        textarea.style.height = "calc(100% - 40px)";
        var assign2 = panel22.addButton("Assign", function() {
          node22.setProperty(propname, textarea.value);
          fDoneWith();
        });
        panel22.alt_content.appendChild(assign2);
        var button = panel22.addButton("Close", fDoneWith);
        button.style.float = "right";
        panel22.alt_content.appendChild(button);
      };
      inner_refresh();
      this.canvas.parentNode.appendChild(panel22);
    }
    showSubgraphPropertiesDialog(node22) {
      console.log("showing subgraph properties dialog");
      var old_panel = this.canvas.parentNode.querySelector(".subgraph_dialog");
      if (old_panel)
        old_panel.close();
      var panel22 = this.createPanel("Subgraph Inputs", { closable: true, width: 500 });
      panel22.node = node22;
      panel22.classList.add("subgraph_dialog");
      function inner_refresh() {
        panel22.clear();
        if (node22.inputs)
          for (var i2 = 0; i2 < node22.inputs.length; ++i2) {
            var input = node22.inputs[i2];
            if (input.not_subgraph_input)
              continue;
            var html2 = "<button>&#10005;</button> <span class='bullet_icon'></span><span class='name'></span><span class='type'></span>";
            var elem2 = panel22.addHTML(html2, "subgraph_property");
            elem2.dataset["name"] = input.name;
            elem2.dataset["slot"] = i2;
            elem2.querySelector(".name").innerText = input.name;
            elem2.querySelector(".type").innerText = input.type;
            elem2.querySelector("button").addEventListener("click", function(e) {
              node22.removeInput(Number(this.parentNode.dataset["slot"]));
              inner_refresh();
            });
          }
      }
      __name(inner_refresh, "inner_refresh");
      var html = " + <span class='label'>Name</span><input class='name'/><span class='label'>Type</span><input class='type'></input><button>+</button>";
      var elem = panel22.addHTML(html, "subgraph_property extra", true);
      elem.querySelector("button").addEventListener("click", function(e) {
        var elem2 = this.parentNode;
        var name = elem2.querySelector(".name").value;
        var type = elem2.querySelector(".type").value;
        if (!name || node22.findInputSlot(name) != -1)
          return;
        node22.addInput(name, type);
        elem2.querySelector(".name").value = "";
        elem2.querySelector(".type").value = "";
        inner_refresh();
      });
      inner_refresh();
      this.canvas.parentNode.appendChild(panel22);
      return panel22;
    }
    showSubgraphPropertiesDialogRight(node22) {
      var old_panel = this.canvas.parentNode.querySelector(".subgraph_dialog");
      if (old_panel)
        old_panel.close();
      var panel22 = this.createPanel("Subgraph Outputs", { closable: true, width: 500 });
      panel22.node = node22;
      panel22.classList.add("subgraph_dialog");
      function inner_refresh() {
        panel22.clear();
        if (node22.outputs)
          for (var i2 = 0; i2 < node22.outputs.length; ++i2) {
            var input = node22.outputs[i2];
            if (input.not_subgraph_output)
              continue;
            var html2 = "<button>&#10005;</button> <span class='bullet_icon'></span><span class='name'></span><span class='type'></span>";
            var elem2 = panel22.addHTML(html2, "subgraph_property");
            elem2.dataset["name"] = input.name;
            elem2.dataset["slot"] = i2;
            elem2.querySelector(".name").innerText = input.name;
            elem2.querySelector(".type").innerText = input.type;
            elem2.querySelector("button").addEventListener("click", function(e) {
              node22.removeOutput(Number(this.parentNode.dataset["slot"]));
              inner_refresh();
            });
          }
      }
      __name(inner_refresh, "inner_refresh");
      var html = " + <span class='label'>Name</span><input class='name'/><span class='label'>Type</span><input class='type'></input><button>+</button>";
      var elem = panel22.addHTML(html, "subgraph_property extra", true);
      elem.querySelector(".name").addEventListener("keydown", function(e) {
        if (e.keyCode == 13) {
          addOutput.apply(this);
        }
      });
      elem.querySelector("button").addEventListener("click", function(e) {
        addOutput.apply(this);
      });
      function addOutput() {
        var elem2 = this.parentNode;
        var name = elem2.querySelector(".name").value;
        var type = elem2.querySelector(".type").value;
        if (!name || node22.findOutputSlot(name) != -1)
          return;
        node22.addOutput(name, type);
        elem2.querySelector(".name").value = "";
        elem2.querySelector(".type").value = "";
        inner_refresh();
      }
      __name(addOutput, "addOutput");
      inner_refresh();
      this.canvas.parentNode.appendChild(panel22);
      return panel22;
    }
    checkPanels() {
      if (!this.canvas)
        return;
      var panels2 = this.canvas.parentNode.querySelectorAll(".litegraph.dialog");
      for (var i2 = 0; i2 < panels2.length; ++i2) {
        var panel22 = panels2[i2];
        if (!panel22.node)
          continue;
        if (!panel22.node.graph || panel22.graph != this.graph)
          panel22.close();
      }
    }
    getCanvasMenuOptions() {
      var options3 = null;
      if (this.getMenuOptions) {
        options3 = this.getMenuOptions();
      } else {
        options3 = [
          {
            content: "Add Node",
            has_submenu: true,
            callback: __LGraphCanvas.onMenuAdd
          },
          { content: "Add Group", callback: __LGraphCanvas.onGroupAdd }
          //{ content: "Arrange", callback: that.graph.arrange },
          //{content:"Collapse All", callback: LGraphCanvas.onMenuCollapseAll }
        ];
        if (Object.keys(this.selected_nodes).length > 1) {
          options3.push({
            content: "Align",
            has_submenu: true,
            callback: __LGraphCanvas.onGroupAlign
          });
        }
        if (this._graph_stack && this._graph_stack.length > 0) {
          options3.push(null, {
            content: "Close subgraph",
            callback: this.closeSubgraph.bind(this)
          });
        }
      }
      if (this.getExtraMenuOptions) {
        var extra = this.getExtraMenuOptions(this, options3);
        if (extra) {
          options3 = options3.concat(extra);
        }
      }
      return options3;
    }
    //called by processContextMenu to extract the menu list
    getNodeMenuOptions(node22) {
      var options3 = null;
      if (node22.getMenuOptions) {
        options3 = node22.getMenuOptions(this);
      } else {
        options3 = [
          {
            content: "Inputs",
            has_submenu: true,
            disabled: true,
            callback: __LGraphCanvas.showMenuNodeOptionalInputs
          },
          {
            content: "Outputs",
            has_submenu: true,
            disabled: true,
            callback: __LGraphCanvas.showMenuNodeOptionalOutputs
          },
          null,
          {
            content: "Properties",
            has_submenu: true,
            callback: __LGraphCanvas.onShowMenuNodeProperties
          },
          {
            content: "Properties Panel",
            callback: /* @__PURE__ */ __name(function(item2, options22, e, menu, node3) {
              __LGraphCanvas.active_canvas.showShowNodePanel(node3);
            }, "callback")
          },
          null,
          {
            content: "Title",
            callback: __LGraphCanvas.onShowPropertyEditor
          },
          {
            content: "Mode",
            has_submenu: true,
            callback: __LGraphCanvas.onMenuNodeMode
          }
        ];
        if (node22.resizable !== false) {
          options3.push({
            content: "Resize",
            callback: __LGraphCanvas.onMenuResizeNode
          });
        }
        if (node22.collapsible) {
          options3.push({
            content: node22.collapsed ? "Expand" : "Collapse",
            callback: __LGraphCanvas.onMenuNodeCollapse
          });
        }
        options3.push(
          {
            content: node22.pinned ? "Unpin" : "Pin",
            callback: __LGraphCanvas.onMenuNodePin
          },
          {
            content: "Colors",
            has_submenu: true,
            callback: __LGraphCanvas.onMenuNodeColors
          },
          {
            content: "Shapes",
            has_submenu: true,
            callback: __LGraphCanvas.onMenuNodeShapes
          },
          null
        );
      }
      if (node22.onGetInputs) {
        var inputs = node22.onGetInputs();
        if (inputs && inputs.length) {
          options3[0].disabled = false;
        }
      }
      if (node22.onGetOutputs) {
        var outputs = node22.onGetOutputs();
        if (outputs && outputs.length) {
          options3[1].disabled = false;
        }
      }
      if (node22.getExtraMenuOptions) {
        var extra = node22.getExtraMenuOptions(this, options3);
        if (extra) {
          extra.push(null);
          options3 = extra.concat(options3);
        }
      }
      if (node22.clonable !== false) {
        options3.push({
          content: "Clone",
          callback: __LGraphCanvas.onMenuNodeClone
        });
      }
      if (Object.keys(this.selected_nodes).length > 1) {
        options3.push({
          content: "Align Selected To",
          has_submenu: true,
          callback: __LGraphCanvas.onNodeAlign
        });
      }
      options3.push(null, {
        content: "Remove",
        disabled: !(node22.removable !== false && !node22.block_delete),
        callback: __LGraphCanvas.onMenuNodeRemove
      });
      if (node22.graph && node22.graph.onGetNodeMenuOptions) {
        node22.graph.onGetNodeMenuOptions(options3, node22);
      }
      return options3;
    }
    getGroupMenuOptions(node22) {
      console.warn("LGraphCanvas.getGroupMenuOptions is deprecated, use LGraphGroup.getMenuOptions instead");
      return node22.getMenuOptions();
    }
    processContextMenu(node22, event2) {
      var that2 = this;
      var canvas = __LGraphCanvas.active_canvas;
      var ref_window2 = canvas.getCanvasWindow();
      var menu_info = null;
      var options3 = {
        event: event2,
        callback: inner_option_clicked,
        extra: node22
      };
      if (node22)
        options3.title = node22.type;
      var slot = null;
      if (node22) {
        slot = node22.getSlotInPosition(event2.canvasX, event2.canvasY);
        __LGraphCanvas.active_node = node22;
      }
      if (slot) {
        menu_info = [];
        if (node22.getSlotMenuOptions) {
          menu_info = node22.getSlotMenuOptions(slot);
        } else {
          if (slot && slot.output && slot.output.links && slot.output.links.length) {
            menu_info.push({ content: "Disconnect Links", slot });
          }
          var _slot = slot.input || slot.output;
          if (_slot.removable) {
            menu_info.push(
              _slot.locked ? "Cannot remove" : { content: "Remove Slot", slot }
            );
          }
          if (!_slot.nameLocked) {
            menu_info.push({ content: "Rename Slot", slot });
          }
        }
        options3.title = (slot.input ? slot.input.type : slot.output.type) || "*";
        if (slot.input && slot.input.type == LiteGraph.ACTION) {
          options3.title = "Action";
        }
        if (slot.output && slot.output.type == LiteGraph.EVENT) {
          options3.title = "Event";
        }
      } else {
        if (node22) {
          menu_info = this.getNodeMenuOptions(node22);
        } else {
          menu_info = this.getCanvasMenuOptions();
          var group = this.graph.getGroupOnPos(
            event2.canvasX,
            event2.canvasY
          );
          if (group) {
            menu_info.push(null, {
              content: "Edit Group",
              has_submenu: true,
              submenu: {
                title: "Group",
                extra: group,
                options: group.getMenuOptions()
              }
            });
          }
        }
      }
      if (!menu_info) {
        return;
      }
      new LiteGraph.ContextMenu(menu_info, options3, ref_window2);
      function inner_option_clicked(v2, options22, e) {
        if (!v2) {
          return;
        }
        if (v2.content == "Remove Slot") {
          var info = v2.slot;
          node22.graph.beforeChange();
          if (info.input) {
            node22.removeInput(info.slot);
          } else if (info.output) {
            node22.removeOutput(info.slot);
          }
          node22.graph.afterChange();
          return;
        } else if (v2.content == "Disconnect Links") {
          var info = v2.slot;
          node22.graph.beforeChange();
          if (info.output) {
            node22.disconnectOutput(info.slot);
          } else if (info.input) {
            node22.disconnectInput(info.slot);
          }
          node22.graph.afterChange();
          return;
        } else if (v2.content == "Rename Slot") {
          var info = v2.slot;
          var slot_info = info.input ? node22.getInputInfo(info.slot) : node22.getOutputInfo(info.slot);
          var dialog = that2.createDialog(
            "<span class='name'>Name</span><input autofocus type='text'/><button>OK</button>",
            options22
          );
          var input = dialog.querySelector("input");
          if (input && slot_info) {
            input.value = slot_info.label || "";
          }
          var inner = /* @__PURE__ */ __name(function() {
            node22.graph.beforeChange();
            if (input.value) {
              if (slot_info) {
                slot_info.label = input.value;
              }
              that2.setDirty(true);
            }
            dialog.close();
            node22.graph.afterChange();
          }, "inner");
          dialog.querySelector("button").addEventListener("click", inner);
          input.addEventListener("keydown", function(e2) {
            dialog.is_modified = true;
            if (e2.keyCode == 27) {
              dialog.close();
            } else if (e2.keyCode == 13) {
              inner();
            } else if (e2.keyCode != 13 && e2.target.localName != "textarea") {
              return;
            }
            e2.preventDefault();
            e2.stopPropagation();
          });
          input.focus();
        }
      }
      __name(inner_option_clicked, "inner_option_clicked");
    }
  };
  _temp = /* @__PURE__ */ new WeakMap();
  _temp_vec2 = /* @__PURE__ */ new WeakMap();
  _tmp_area = /* @__PURE__ */ new WeakMap();
  _margin_area = /* @__PURE__ */ new WeakMap();
  _link_bounding = /* @__PURE__ */ new WeakMap();
  _tempA = /* @__PURE__ */ new WeakMap();
  _tempB = /* @__PURE__ */ new WeakMap();
  __privateAdd(_LGraphCanvas, _temp, new Float32Array(4));
  __privateAdd(_LGraphCanvas, _temp_vec2, new Float32Array(2));
  __privateAdd(_LGraphCanvas, _tmp_area, new Float32Array(4));
  __privateAdd(_LGraphCanvas, _margin_area, new Float32Array(4));
  __privateAdd(_LGraphCanvas, _link_bounding, new Float32Array(4));
  __privateAdd(_LGraphCanvas, _tempA, new Float32Array(2));
  __privateAdd(_LGraphCanvas, _tempB, new Float32Array(2));
  __publicField(_LGraphCanvas, "DEFAULT_BACKGROUND_IMAGE", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAIAAAD/gAIDAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQBJREFUeNrs1rEKwjAUhlETUkj3vP9rdmr1Ysammk2w5wdxuLgcMHyptfawuZX4pJSWZTnfnu/lnIe/jNNxHHGNn//HNbbv+4dr6V+11uF527arU7+u63qfa/bnmh8sWLBgwYJlqRf8MEptXPBXJXa37BSl3ixYsGDBMliwFLyCV/DeLIMFCxYsWLBMwSt4Be/NggXLYMGCBUvBK3iNruC9WbBgwYJlsGApeAWv4L1ZBgsWLFiwYJmCV/AK3psFC5bBggULloJX8BpdwXuzYMGCBctgwVLwCl7Be7MMFixYsGDBsu8FH1FaSmExVfAxBa/gvVmwYMGCZbBg/W4vAQYA5tRF9QYlv/QAAAAASUVORK5CYII=");
  __publicField(_LGraphCanvas, "link_type_colors", {
    "-1": LiteGraph.EVENT_LINK_COLOR,
    number: "#AAA",
    node: "#DCA"
  });
  __publicField(_LGraphCanvas, "gradients", {});
  __publicField(_LGraphCanvas, "search_limit", -1);
  __publicField(_LGraphCanvas, "node_colors", {
    red: { color: "#322", bgcolor: "#533", groupcolor: "#A88" },
    brown: { color: "#332922", bgcolor: "#593930", groupcolor: "#b06634" },
    green: { color: "#232", bgcolor: "#353", groupcolor: "#8A8" },
    blue: { color: "#223", bgcolor: "#335", groupcolor: "#88A" },
    pale_blue: {
      color: "#2a363b",
      bgcolor: "#3f5159",
      groupcolor: "#3f789e"
    },
    cyan: { color: "#233", bgcolor: "#355", groupcolor: "#8AA" },
    purple: { color: "#323", bgcolor: "#535", groupcolor: "#a1309b" },
    yellow: { color: "#432", bgcolor: "#653", groupcolor: "#b58b2a" },
    black: { color: "#222", bgcolor: "#000", groupcolor: "#444" }
  });
  let LGraphCanvas = _LGraphCanvas;
  globalThis.LGraphCanvas = LiteGraph.LGraphCanvas = LGraphCanvas;
  if (typeof window != "undefined" && window.CanvasRenderingContext2D && !window.CanvasRenderingContext2D.prototype.roundRect) {
    window.CanvasRenderingContext2D.prototype.roundRect = function(x2, y2, w2, h2, radius, radius_low) {
      var top_left_radius = 0;
      var top_right_radius = 0;
      var bottom_left_radius = 0;
      var bottom_right_radius = 0;
      if (radius === 0) {
        this.rect(x2, y2, w2, h2);
        return;
      }
      if (radius_low === void 0)
        radius_low = radius;
      if (radius != null && radius.constructor === Array) {
        if (radius.length == 1)
          top_left_radius = top_right_radius = bottom_left_radius = bottom_right_radius = radius[0];
        else if (radius.length == 2) {
          top_left_radius = bottom_right_radius = radius[0];
          top_right_radius = bottom_left_radius = radius[1];
        } else if (radius.length == 4) {
          top_left_radius = radius[0];
          top_right_radius = radius[1];
          bottom_left_radius = radius[2];
          bottom_right_radius = radius[3];
        } else
          return;
      } else {
        top_left_radius = radius || 0;
        top_right_radius = radius || 0;
        bottom_left_radius = radius_low || 0;
        bottom_right_radius = radius_low || 0;
      }
      this.moveTo(x2 + top_left_radius, y2);
      this.lineTo(x2 + w2 - top_right_radius, y2);
      this.quadraticCurveTo(x2 + w2, y2, x2 + w2, y2 + top_right_radius);
      this.lineTo(x2 + w2, y2 + h2 - bottom_right_radius);
      this.quadraticCurveTo(
        x2 + w2,
        y2 + h2,
        x2 + w2 - bottom_right_radius,
        y2 + h2
      );
      this.lineTo(x2 + bottom_right_radius, y2 + h2);
      this.quadraticCurveTo(x2, y2 + h2, x2, y2 + h2 - bottom_left_radius);
      this.lineTo(x2, y2 + bottom_left_radius);
      this.quadraticCurveTo(x2, y2, x2 + top_left_radius, y2);
    };
  }
  function compareObjects(a, b) {
    for (var i2 in a) {
      if (a[i2] != b[i2]) {
        return false;
      }
    }
    return true;
  }
  __name(compareObjects, "compareObjects");
  LiteGraph.compareObjects = compareObjects;
  function distance(a, b) {
    return Math.sqrt(
      (b[0] - a[0]) * (b[0] - a[0]) + (b[1] - a[1]) * (b[1] - a[1])
    );
  }
  __name(distance, "distance");
  LiteGraph.distance = distance;
  function colorToString(c) {
    return "rgba(" + Math.round(c[0] * 255).toFixed() + "," + Math.round(c[1] * 255).toFixed() + "," + Math.round(c[2] * 255).toFixed() + "," + (c.length == 4 ? c[3].toFixed(2) : "1.0") + ")";
  }
  __name(colorToString, "colorToString");
  LiteGraph.colorToString = colorToString;
  function isInsideRectangle(x2, y2, left, top, width2, height) {
    if (left < x2 && left + width2 > x2 && top < y2 && top + height > y2) {
      return true;
    }
    return false;
  }
  __name(isInsideRectangle, "isInsideRectangle");
  LiteGraph.isInsideRectangle = isInsideRectangle;
  function growBounding(bounding, x2, y2) {
    if (x2 < bounding[0]) {
      bounding[0] = x2;
    } else if (x2 > bounding[2]) {
      bounding[2] = x2;
    }
    if (y2 < bounding[1]) {
      bounding[1] = y2;
    } else if (y2 > bounding[3]) {
      bounding[3] = y2;
    }
  }
  __name(growBounding, "growBounding");
  LiteGraph.growBounding = growBounding;
  function isInsideBounding(p2, bb) {
    if (p2[0] < bb[0][0] || p2[1] < bb[0][1] || p2[0] > bb[1][0] || p2[1] > bb[1][1]) {
      return false;
    }
    return true;
  }
  __name(isInsideBounding, "isInsideBounding");
  LiteGraph.isInsideBounding = isInsideBounding;
  function overlapBounding(a, b) {
    var A_end_x = a[0] + a[2];
    var A_end_y = a[1] + a[3];
    var B_end_x = b[0] + b[2];
    var B_end_y = b[1] + b[3];
    if (a[0] > B_end_x || a[1] > B_end_y || A_end_x < b[0] || A_end_y < b[1]) {
      return false;
    }
    return true;
  }
  __name(overlapBounding, "overlapBounding");
  LiteGraph.overlapBounding = overlapBounding;
  function hex2num(hex) {
    if (hex.charAt(0) == "#") {
      hex = hex.slice(1);
    }
    hex = hex.toUpperCase();
    var hex_alphabets = "0123456789ABCDEF";
    var value3 = new Array(3);
    var k = 0;
    var int1, int2;
    for (var i2 = 0; i2 < 6; i2 += 2) {
      int1 = hex_alphabets.indexOf(hex.charAt(i2));
      int2 = hex_alphabets.indexOf(hex.charAt(i2 + 1));
      value3[k] = int1 * 16 + int2;
      k++;
    }
    return value3;
  }
  __name(hex2num, "hex2num");
  LiteGraph.hex2num = hex2num;
  function num2hex(triplet) {
    var hex_alphabets = "0123456789ABCDEF";
    var hex = "#";
    var int1, int2;
    for (var i2 = 0; i2 < 3; i2++) {
      int1 = triplet[i2] / 16;
      int2 = triplet[i2] % 16;
      hex += hex_alphabets.charAt(int1) + hex_alphabets.charAt(int2);
    }
    return hex;
  }
  __name(num2hex, "num2hex");
  LiteGraph.num2hex = num2hex;
  function ContextMenu(values2, options3) {
    options3 = options3 || {};
    this.options = options3;
    var that2 = this;
    if (options3.parentMenu) {
      if (options3.parentMenu.constructor !== this.constructor) {
        console.error(
          "parentMenu must be of class ContextMenu, ignoring it"
        );
        options3.parentMenu = null;
      } else {
        this.parentMenu = options3.parentMenu;
        this.parentMenu.lock = true;
        this.parentMenu.current_submenu = this;
      }
    }
    var eventClass = null;
    if (options3.event)
      eventClass = options3.event.constructor.name;
    if (eventClass !== "MouseEvent" && eventClass !== "CustomEvent" && eventClass !== "PointerEvent") {
      console.error(
        "Event passed to ContextMenu is not of type MouseEvent or CustomEvent. Ignoring it. (" + eventClass + ")"
      );
      options3.event = null;
    }
    var root26 = document.createElement("div");
    root26.className = "litegraph litecontextmenu litemenubar-panel";
    if (options3.className) {
      root26.className += " " + options3.className;
    }
    root26.style.minWidth = 100;
    root26.style.minHeight = 100;
    root26.style.pointerEvents = "none";
    setTimeout(function() {
      root26.style.pointerEvents = "auto";
    }, 100);
    LiteGraph.pointerListenerAdd(
      root26,
      "up",
      function(e) {
        e.preventDefault();
        return true;
      },
      true
    );
    root26.addEventListener(
      "contextmenu",
      function(e) {
        if (e.button != 2) {
          return false;
        }
        e.preventDefault();
        return false;
      },
      true
    );
    LiteGraph.pointerListenerAdd(
      root26,
      "down",
      function(e) {
        if (e.button == 2) {
          that2.close();
          e.preventDefault();
          return true;
        }
      },
      true
    );
    function on_mouse_wheel(e) {
      var pos2 = parseInt(root26.style.top);
      root26.style.top = (pos2 + e.deltaY * options3.scroll_speed).toFixed() + "px";
      e.preventDefault();
      return true;
    }
    __name(on_mouse_wheel, "on_mouse_wheel");
    if (!options3.scroll_speed) {
      options3.scroll_speed = 0.1;
    }
    root26.addEventListener("wheel", on_mouse_wheel, true);
    root26.addEventListener("mousewheel", on_mouse_wheel, true);
    this.root = root26;
    if (options3.title) {
      var element = document.createElement("div");
      element.className = "litemenu-title";
      element.innerHTML = options3.title;
      root26.appendChild(element);
    }
    for (var i2 = 0; i2 < values2.length; i2++) {
      var name = values2.constructor == Array ? values2[i2] : i2;
      if (name != null && name.constructor !== String) {
        name = name.content === void 0 ? String(name) : name.content;
      }
      var value3 = values2[i2];
      this.addItem(name, value3, options3);
    }
    LiteGraph.pointerListenerAdd(root26, "enter", function(e) {
      if (root26.closing_timer) {
        clearTimeout(root26.closing_timer);
      }
    });
    var root_document = document;
    if (options3.event) {
      root_document = options3.event.target.ownerDocument;
    }
    if (!root_document) {
      root_document = document;
    }
    if (root_document.fullscreenElement)
      root_document.fullscreenElement.appendChild(root26);
    else
      root_document.body.appendChild(root26);
    var left = options3.left || 0;
    var top = options3.top || 0;
    if (options3.event) {
      left = options3.event.clientX - 10;
      top = options3.event.clientY - 10;
      if (options3.title) {
        top -= 20;
      }
      if (options3.parentMenu) {
        var rect = options3.parentMenu.root.getBoundingClientRect();
        left = rect.left + rect.width;
      }
      var body_rect = document.body.getBoundingClientRect();
      var root_rect = root26.getBoundingClientRect();
      if (body_rect.height == 0)
        console.error("document.body height is 0. That is dangerous, set html,body { height: 100%; }");
      if (body_rect.width && left > body_rect.width - root_rect.width - 10) {
        left = body_rect.width - root_rect.width - 10;
      }
      if (body_rect.height && top > body_rect.height - root_rect.height - 10) {
        top = body_rect.height - root_rect.height - 10;
      }
    }
    root26.style.left = left + "px";
    root26.style.top = top + "px";
    if (options3.scale) {
      root26.style.transform = "scale(" + options3.scale + ")";
    }
  }
  __name(ContextMenu, "ContextMenu");
  ContextMenu.prototype.addItem = function(name, value3, options3) {
    var that2 = this;
    options3 = options3 || {};
    var element = document.createElement("div");
    element.className = "litemenu-entry submenu";
    var disabled2 = false;
    if (value3 === null) {
      element.classList.add("separator");
    } else {
      element.innerHTML = value3 && value3.title ? value3.title : name;
      element.value = value3;
      element.setAttribute("role", "menuitem");
      if (value3) {
        if (value3.disabled) {
          disabled2 = true;
          element.classList.add("disabled");
          element.setAttribute("aria-disabled", "true");
        }
        if (value3.submenu || value3.has_submenu) {
          element.classList.add("has_submenu");
          element.setAttribute("aria-haspopup", "true");
          element.setAttribute("aria-expanded", "false");
        }
      }
      if (typeof value3 == "function") {
        element.dataset["value"] = name;
        element.onclick_callback = value3;
      } else {
        element.dataset["value"] = value3;
      }
      if (value3.className) {
        element.className += " " + value3.className;
      }
    }
    this.root.appendChild(element);
    if (!disabled2) {
      element.addEventListener("click", inner_onclick);
    }
    if (!disabled2 && options3.autoopen) {
      LiteGraph.pointerListenerAdd(element, "enter", inner_over);
    }
    function setAriaExpanded() {
      const entries = that2.root.querySelectorAll("div.litemenu-entry.has_submenu");
      if (entries) {
        for (let i2 = 0; i2 < entries.length; i2++) {
          entries[i2].setAttribute("aria-expanded", "false");
        }
      }
      element.setAttribute("aria-expanded", "true");
    }
    __name(setAriaExpanded, "setAriaExpanded");
    function inner_over(e) {
      var value22 = this.value;
      if (!value22 || !value22.has_submenu) {
        return;
      }
      inner_onclick.call(this, e);
      setAriaExpanded();
    }
    __name(inner_over, "inner_over");
    function inner_onclick(e) {
      var value22 = this.value;
      var close_parent = true;
      if (that2.current_submenu) {
        that2.current_submenu.close(e);
      }
      if ((value22 == null ? void 0 : value22.has_submenu) || (value22 == null ? void 0 : value22.submenu)) {
        setAriaExpanded();
      }
      if (options3.callback) {
        var r = options3.callback.call(
          this,
          value22,
          options3,
          e,
          that2,
          options3.node
        );
        if (r === true) {
          close_parent = false;
        }
      }
      if (value22) {
        if (value22.callback && !options3.ignore_item_callbacks && value22.disabled !== true) {
          var r = value22.callback.call(
            this,
            value22,
            options3,
            e,
            that2,
            options3.extra
          );
          if (r === true) {
            close_parent = false;
          }
        }
        if (value22.submenu) {
          if (!value22.submenu.options) {
            throw "ContextMenu submenu needs options";
          }
          new that2.constructor(value22.submenu.options, {
            callback: value22.submenu.callback,
            event: e,
            parentMenu: that2,
            ignore_item_callbacks: value22.submenu.ignore_item_callbacks,
            title: value22.submenu.title,
            extra: value22.submenu.extra,
            autoopen: options3.autoopen
          });
          close_parent = false;
        }
      }
      if (close_parent && !that2.lock) {
        that2.close();
      }
    }
    __name(inner_onclick, "inner_onclick");
    return element;
  };
  ContextMenu.prototype.close = function(e, ignore_parent_menu) {
    if (this.root.parentNode) {
      this.root.parentNode.removeChild(this.root);
    }
    if (this.parentMenu && !ignore_parent_menu) {
      this.parentMenu.lock = false;
      this.parentMenu.current_submenu = null;
      if (e === void 0) {
        this.parentMenu.close();
      } else if (e && !ContextMenu.isCursorOverElement(e, this.parentMenu.root)) {
        ContextMenu.trigger(this.parentMenu.root, LiteGraph.pointerevents_method + "leave", e);
      }
    }
    if (this.current_submenu) {
      this.current_submenu.close(e, true);
    }
    if (this.root.closing_timer) {
      clearTimeout(this.root.closing_timer);
    }
  };
  ContextMenu.trigger = function(element, event_name, params, origin2) {
    var evt = document.createEvent("CustomEvent");
    evt.initCustomEvent(event_name, true, true, params);
    evt.srcElement = origin2;
    if (element.dispatchEvent) {
      element.dispatchEvent(evt);
    } else if (element.__events) {
      element.__events.dispatchEvent(evt);
    }
    return evt;
  };
  ContextMenu.prototype.getTopMenu = function() {
    if (this.options.parentMenu) {
      return this.options.parentMenu.getTopMenu();
    }
    return this;
  };
  ContextMenu.prototype.getFirstEvent = function() {
    if (this.options.parentMenu) {
      return this.options.parentMenu.getFirstEvent();
    }
    return this.options.event;
  };
  ContextMenu.isCursorOverElement = function(event2, element) {
    var left = event2.clientX;
    var top = event2.clientY;
    var rect = element.getBoundingClientRect();
    if (!rect) {
      return false;
    }
    if (top > rect.top && top < rect.top + rect.height && left > rect.left && left < rect.left + rect.width) {
      return true;
    }
    return false;
  };
  LiteGraph.ContextMenu = ContextMenu;
  LiteGraph.closeAllContextMenus = function(ref_window2) {
    ref_window2 = ref_window2 || window;
    var elements = ref_window2.document.querySelectorAll(".litecontextmenu");
    if (!elements.length) {
      return;
    }
    var result = [];
    for (var i2 = 0; i2 < elements.length; i2++) {
      result.push(elements[i2]);
    }
    for (var i2 = 0; i2 < result.length; i2++) {
      if (result[i2].close) {
        result[i2].close();
      } else if (result[i2].parentNode) {
        result[i2].parentNode.removeChild(result[i2]);
      }
    }
  };
  LiteGraph.extendClass = function(target, origin2) {
    for (var i2 in origin2) {
      if (target.hasOwnProperty(i2)) {
        continue;
      }
      target[i2] = origin2[i2];
    }
    if (origin2.prototype) {
      for (var i2 in origin2.prototype) {
        if (!origin2.prototype.hasOwnProperty(i2)) {
          continue;
        }
        if (target.prototype.hasOwnProperty(i2)) {
          continue;
        }
        if (origin2.prototype.__lookupGetter__(i2)) {
          target.prototype.__defineGetter__(
            i2,
            origin2.prototype.__lookupGetter__(i2)
          );
        } else {
          target.prototype[i2] = origin2.prototype[i2];
        }
        if (origin2.prototype.__lookupSetter__(i2)) {
          target.prototype.__defineSetter__(
            i2,
            origin2.prototype.__lookupSetter__(i2)
          );
        }
      }
    }
  };
  function CurveEditor(points) {
    this.points = points;
    this.selected = -1;
    this.nearest = -1;
    this.size = null;
    this.must_update = true;
    this.margin = 5;
  }
  __name(CurveEditor, "CurveEditor");
  CurveEditor.sampleCurve = function(f, points) {
    if (!points)
      return;
    for (var i2 = 0; i2 < points.length - 1; ++i2) {
      var p2 = points[i2];
      var pn = points[i2 + 1];
      if (pn[0] < f)
        continue;
      var r = pn[0] - p2[0];
      if (Math.abs(r) < 1e-5)
        return p2[1];
      var local_f = (f - p2[0]) / r;
      return p2[1] * (1 - local_f) + pn[1] * local_f;
    }
    return 0;
  };
  CurveEditor.prototype.draw = function(ctx, size2, graphcanvas, background_color, line_color, inactive) {
    var points = this.points;
    if (!points)
      return;
    this.size = size2;
    var w2 = size2[0] - this.margin * 2;
    var h2 = size2[1] - this.margin * 2;
    line_color = line_color || "#666";
    ctx.save();
    ctx.translate(this.margin, this.margin);
    if (background_color) {
      ctx.fillStyle = "#111";
      ctx.fillRect(0, 0, w2, h2);
      ctx.fillStyle = "#222";
      ctx.fillRect(w2 * 0.5, 0, 1, h2);
      ctx.strokeStyle = "#333";
      ctx.strokeRect(0, 0, w2, h2);
    }
    ctx.strokeStyle = line_color;
    if (inactive)
      ctx.globalAlpha = 0.5;
    ctx.beginPath();
    for (var i2 = 0; i2 < points.length; ++i2) {
      var p2 = points[i2];
      ctx.lineTo(p2[0] * w2, (1 - p2[1]) * h2);
    }
    ctx.stroke();
    ctx.globalAlpha = 1;
    if (!inactive)
      for (var i2 = 0; i2 < points.length; ++i2) {
        var p2 = points[i2];
        ctx.fillStyle = this.selected == i2 ? "#FFF" : this.nearest == i2 ? "#DDD" : "#AAA";
        ctx.beginPath();
        ctx.arc(p2[0] * w2, (1 - p2[1]) * h2, 2, 0, Math.PI * 2);
        ctx.fill();
      }
    ctx.restore();
  };
  CurveEditor.prototype.onMouseDown = function(localpos, graphcanvas) {
    var points = this.points;
    if (!points)
      return;
    if (localpos[1] < 0)
      return;
    var w2 = this.size[0] - this.margin * 2;
    var h2 = this.size[1] - this.margin * 2;
    var x2 = localpos[0] - this.margin;
    var y2 = localpos[1] - this.margin;
    var pos2 = [x2, y2];
    var max_dist = 30 / graphcanvas.ds.scale;
    this.selected = this.getCloserPoint(pos2, max_dist);
    if (this.selected == -1) {
      var point = [x2 / w2, 1 - y2 / h2];
      points.push(point);
      points.sort(function(a, b) {
        return a[0] - b[0];
      });
      this.selected = points.indexOf(point);
      this.must_update = true;
    }
    if (this.selected != -1)
      return true;
  };
  CurveEditor.prototype.onMouseMove = function(localpos, graphcanvas) {
    var points = this.points;
    if (!points)
      return;
    var s = this.selected;
    if (s < 0)
      return;
    var x2 = (localpos[0] - this.margin) / (this.size[0] - this.margin * 2);
    var y2 = (localpos[1] - this.margin) / (this.size[1] - this.margin * 2);
    var curvepos = [localpos[0] - this.margin, localpos[1] - this.margin];
    var max_dist = 30 / graphcanvas.ds.scale;
    this._nearest = this.getCloserPoint(curvepos, max_dist);
    var point = points[s];
    if (point) {
      var is_edge_point = s == 0 || s == points.length - 1;
      if (!is_edge_point && (localpos[0] < -10 || localpos[0] > this.size[0] + 10 || localpos[1] < -10 || localpos[1] > this.size[1] + 10)) {
        points.splice(s, 1);
        this.selected = -1;
        return;
      }
      if (!is_edge_point)
        point[0] = clamp(x2, 0, 1);
      else
        point[0] = s == 0 ? 0 : 1;
      point[1] = 1 - clamp(y2, 0, 1);
      points.sort(function(a, b) {
        return a[0] - b[0];
      });
      this.selected = points.indexOf(point);
      this.must_update = true;
    }
  };
  CurveEditor.prototype.onMouseUp = function(localpos, graphcanvas) {
    this.selected = -1;
    return false;
  };
  CurveEditor.prototype.getCloserPoint = function(pos2, max_dist) {
    var points = this.points;
    if (!points)
      return -1;
    max_dist = max_dist || 30;
    var w2 = this.size[0] - this.margin * 2;
    var h2 = this.size[1] - this.margin * 2;
    var num = points.length;
    var p2 = [0, 0];
    var min_dist = 1e6;
    var closest = -1;
    for (var i2 = 0; i2 < num; ++i2) {
      var p3 = points[i2];
      p2[0] = p3[0] * w2;
      p2[1] = (1 - p3[1]) * h2;
      if (p2[0] < pos2[0])
        ;
      var dist2 = vec2.distance(pos2, p2);
      if (dist2 > min_dist || dist2 > max_dist)
        continue;
      closest = i2;
      min_dist = dist2;
    }
    return closest;
  };
  LiteGraph.CurveEditor = CurveEditor;
  LiteGraph.getParameterNames = function(func) {
    return (func + "").replace(/[/][/].*$/gm, "").replace(/\s+/g, "").replace(/[/][*][^/*]*[*][/]/g, "").split("){", 1)[0].replace(/^[^(]*[(]/, "").replace(/=[^,]+/g, "").split(",").filter(Boolean);
  };
  LiteGraph.pointerListenerAdd = function(oDOM, sEvIn, fCall, capture = false) {
    if (!oDOM || !oDOM.addEventListener || !sEvIn || typeof fCall !== "function") {
      return;
    }
    var sMethod = LiteGraph.pointerevents_method;
    var sEvent = sEvIn;
    if (sMethod == "pointer" && !window.PointerEvent) {
      console.warn("sMethod=='pointer' && !window.PointerEvent");
      console.log("Converting pointer[" + sEvent + "] : down move up cancel enter TO touchstart touchmove touchend, etc ..");
      switch (sEvent) {
        case "down": {
          sMethod = "touch";
          sEvent = "start";
          break;
        }
        case "move": {
          sMethod = "touch";
          break;
        }
        case "up": {
          sMethod = "touch";
          sEvent = "end";
          break;
        }
        case "cancel": {
          sMethod = "touch";
          break;
        }
        case "enter": {
          console.log("debug: Should I send a move event?");
          break;
        }
        default: {
          console.warn("PointerEvent not available in this browser ? The event " + sEvent + " would not be called");
        }
      }
    }
    switch (sEvent) {
      case "down":
      case "up":
      case "move":
      case "over":
      case "out":
      case "enter": {
        oDOM.addEventListener(sMethod + sEvent, fCall, capture);
      }
      case "leave":
      case "cancel":
      case "gotpointercapture":
      case "lostpointercapture": {
        if (sMethod != "mouse") {
          return oDOM.addEventListener(sMethod + sEvent, fCall, capture);
        }
      }
      default:
        return oDOM.addEventListener(sEvent, fCall, capture);
    }
  };
  LiteGraph.pointerListenerRemove = function(oDOM, sEvent, fCall, capture = false) {
    if (!oDOM || !oDOM.removeEventListener || !sEvent || typeof fCall !== "function") {
      return;
    }
    switch (sEvent) {
      case "down":
      case "up":
      case "move":
      case "over":
      case "out":
      case "enter": {
        if (LiteGraph.pointerevents_method == "pointer" || LiteGraph.pointerevents_method == "mouse") {
          oDOM.removeEventListener(LiteGraph.pointerevents_method + sEvent, fCall, capture);
        }
      }
      case "leave":
      case "cancel":
      case "gotpointercapture":
      case "lostpointercapture": {
        if (LiteGraph.pointerevents_method == "pointer") {
          return oDOM.removeEventListener(LiteGraph.pointerevents_method + sEvent, fCall, capture);
        }
      }
      default:
        return oDOM.removeEventListener(sEvent, fCall, capture);
    }
  };
  function clamp(v2, a, b) {
    return a > v2 ? a : b < v2 ? b : v2;
  }
  __name(clamp, "clamp");
  globalThis.clamp = clamp;
  if (typeof window != "undefined" && !window["requestAnimationFrame"]) {
    window.requestAnimationFrame = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback) {
      window.setTimeout(callback, 1e3 / 60);
    };
  }
})(globalExport);
const LiteGraph = globalExport.LiteGraph;
const LGraph = globalExport.LGraph;
const LLink = globalExport.LLink;
const LGraphNode = globalExport.LGraphNode;
const LGraphGroup = globalExport.LGraphGroup;
const DragAndScale = globalExport.DragAndScale;
const LGraphCanvas = globalExport.LGraphCanvas;
const ContextMenu = globalExport.ContextMenu;
const useTitleEditorStore = defineStore("titleEditor", () => {
  const titleEditorTarget = shallowRef(null);
  return {
    titleEditorTarget
  };
});
const useCanvasStore = defineStore("canvas", () => {
  const canvas = shallowRef(null);
  return {
    canvas
  };
});
const ComfyDialog = ComfyDialog$1;
function $el(tag, propsOrChildren, children) {
  const split = tag.split(".");
  const element = document.createElement(split.shift());
  if (split.length > 0) {
    element.classList.add(...split);
  }
  if (propsOrChildren) {
    if (typeof propsOrChildren === "string") {
      propsOrChildren = { textContent: propsOrChildren };
    } else if (propsOrChildren instanceof Element) {
      propsOrChildren = [propsOrChildren];
    }
    if (Array.isArray(propsOrChildren)) {
      element.append(...propsOrChildren);
    } else {
      const {
        parent,
        $: cb,
        dataset,
        style,
        ...rest
      } = propsOrChildren;
      if (rest.for) {
        element.setAttribute("for", rest.for);
      }
      if (style) {
        Object.assign(element.style, style);
      }
      if (dataset) {
        Object.assign(element.dataset, dataset);
      }
      Object.assign(element, rest);
      if (children) {
        element.append(...Array.isArray(children) ? children : [children]);
      }
      if (parent) {
        parent.append(element);
      }
      if (cb) {
        cb(element);
      }
    }
  }
  return element;
}
__name($el, "$el");
function dragElement(dragEl, settings) {
  var posDiffX = 0, posDiffY = 0, posStartX = 0, posStartY = 0, newPosX = 0, newPosY = 0;
  if (dragEl.getElementsByClassName("drag-handle")[0]) {
    dragEl.getElementsByClassName("drag-handle")[0].onmousedown = dragMouseDown;
  } else {
    dragEl.onmousedown = dragMouseDown;
  }
  const resizeObserver = new ResizeObserver(() => {
    ensureInBounds();
  }).observe(dragEl);
  function ensureInBounds() {
    try {
      newPosX = Math.min(
        document.body.clientWidth - dragEl.clientWidth,
        Math.max(0, dragEl.offsetLeft)
      );
      newPosY = Math.min(
        document.body.clientHeight - dragEl.clientHeight,
        Math.max(0, dragEl.offsetTop)
      );
      positionElement();
    } catch (exception) {
    }
  }
  __name(ensureInBounds, "ensureInBounds");
  function positionElement() {
    if (dragEl.style.display === "none") return;
    const halfWidth = document.body.clientWidth / 2;
    const anchorRight = newPosX + dragEl.clientWidth / 2 > halfWidth;
    if (anchorRight) {
      dragEl.style.left = "unset";
      dragEl.style.right = document.body.clientWidth - newPosX - dragEl.clientWidth + "px";
    } else {
      dragEl.style.left = newPosX + "px";
      dragEl.style.right = "unset";
    }
    dragEl.style.top = newPosY + "px";
    dragEl.style.bottom = "unset";
    if (savePos) {
      localStorage.setItem(
        "Comfy.MenuPosition",
        JSON.stringify({
          x: dragEl.offsetLeft,
          y: dragEl.offsetTop
        })
      );
    }
  }
  __name(positionElement, "positionElement");
  function restorePos() {
    let posString = localStorage.getItem("Comfy.MenuPosition");
    if (posString) {
      const pos2 = JSON.parse(posString);
      newPosX = pos2.x;
      newPosY = pos2.y;
      positionElement();
      ensureInBounds();
    }
  }
  __name(restorePos, "restorePos");
  let savePos = void 0;
  settings.addSetting({
    id: "Comfy.MenuPosition",
    category: ["Comfy", "Menu", "MenuPosition"],
    name: "Save legacy menu's position",
    type: "boolean",
    defaultValue: savePos,
    onChange(value3) {
      if (savePos === void 0 && value3) {
        restorePos();
      }
      savePos = value3;
    }
  });
  function dragMouseDown(e) {
    e = e || window.event;
    e.preventDefault();
    posStartX = e.clientX;
    posStartY = e.clientY;
    document.onmouseup = closeDragElement;
    document.onmousemove = elementDrag;
  }
  __name(dragMouseDown, "dragMouseDown");
  function elementDrag(e) {
    e = e || window.event;
    e.preventDefault();
    dragEl.classList.add("comfy-menu-manual-pos");
    posDiffX = e.clientX - posStartX;
    posDiffY = e.clientY - posStartY;
    posStartX = e.clientX;
    posStartY = e.clientY;
    newPosX = Math.min(
      document.body.clientWidth - dragEl.clientWidth,
      Math.max(0, dragEl.offsetLeft + posDiffX)
    );
    newPosY = Math.min(
      document.body.clientHeight - dragEl.clientHeight,
      Math.max(0, dragEl.offsetTop + posDiffY)
    );
    positionElement();
  }
  __name(elementDrag, "elementDrag");
  window.addEventListener("resize", () => {
    ensureInBounds();
  });
  function closeDragElement() {
    document.onmouseup = null;
    document.onmousemove = null;
  }
  __name(closeDragElement, "closeDragElement");
  return restorePos;
}
__name(dragElement, "dragElement");
class ComfyList {
  static {
    __name(this, "ComfyList");
  }
  #type;
  #text;
  #reverse;
  element;
  button;
  constructor(text, type, reverse) {
    this.#text = text;
    this.#type = type || text.toLowerCase();
    this.#reverse = reverse || false;
    this.element = $el("div.comfy-list");
    this.element.style.display = "none";
  }
  get visible() {
    return this.element.style.display !== "none";
  }
  async load() {
    const items2 = await api.getItems(this.#type);
    this.element.replaceChildren(
      ...Object.keys(items2).flatMap((section) => [
        $el("h4", {
          textContent: section
        }),
        $el("div.comfy-list-items", [
          ...(this.#reverse ? items2[section].reverse() : items2[section]).map(
            (item2) => {
              const removeAction = "remove" in item2 ? item2.remove : {
                name: "Delete",
                cb: /* @__PURE__ */ __name(() => api.deleteItem(this.#type, item2.prompt[1]), "cb")
              };
              return $el("div", { textContent: item2.prompt[0] + ": " }, [
                $el("button", {
                  textContent: "Load",
                  onclick: /* @__PURE__ */ __name(async () => {
                    await app$1.loadGraphData(
                      item2.prompt[3].extra_pnginfo.workflow,
                      true,
                      false
                    );
                    if ("outputs" in item2) {
                      app$1.nodeOutputs = {};
                      for (const [key, value3] of Object.entries(item2.outputs)) {
                        const realKey = item2["meta"]?.[key]?.display_node ?? key;
                        app$1.nodeOutputs[realKey] = value3;
                      }
                    }
                  }, "onclick")
                }),
                $el("button", {
                  textContent: removeAction.name,
                  onclick: /* @__PURE__ */ __name(async () => {
                    await removeAction.cb();
                    await this.update();
                  }, "onclick")
                })
              ]);
            }
          )
        ])
      ]),
      $el("div.comfy-list-actions", [
        $el("button", {
          textContent: "Clear " + this.#text,
          onclick: /* @__PURE__ */ __name(async () => {
            await api.clearItems(this.#type);
            await this.load();
          }, "onclick")
        }),
        $el("button", { textContent: "Refresh", onclick: /* @__PURE__ */ __name(() => this.load(), "onclick") })
      ])
    );
  }
  async update() {
    if (this.visible) {
      await this.load();
    }
  }
  async show() {
    this.element.style.display = "block";
    this.button.textContent = "Close";
    await this.load();
  }
  hide() {
    this.element.style.display = "none";
    this.button.textContent = "View " + this.#text;
  }
  toggle() {
    if (this.visible) {
      this.hide();
      return false;
    } else {
      this.show();
      return true;
    }
  }
}
class ComfyUI {
  static {
    __name(this, "ComfyUI");
  }
  app;
  dialog;
  settings;
  batchCount;
  lastQueueSize;
  queue;
  history;
  autoQueueMode;
  graphHasChanged;
  autoQueueEnabled;
  menuHamburger;
  menuContainer;
  queueSize;
  restoreMenuPosition;
  loadFile;
  constructor(app2) {
    this.app = app2;
    this.dialog = new ComfyDialog();
    this.settings = new ComfySettingsDialog(app2);
    this.batchCount = 1;
    this.lastQueueSize = 0;
    this.queue = new ComfyList("Queue");
    this.history = new ComfyList("History", "history", true);
    api.addEventListener("status", () => {
      this.queue.update();
      this.history.update();
    });
    const confirmClear = this.settings.addSetting({
      id: "Comfy.ConfirmClear",
      category: ["Comfy", "Workflow", "ConfirmClear"],
      name: "Require confirmation when clearing workflow",
      type: "boolean",
      defaultValue: true
    });
    const promptFilename = this.settings.addSetting({
      id: "Comfy.PromptFilename",
      category: ["Comfy", "Workflow", "PromptFilename"],
      name: "Prompt for filename when saving workflow",
      type: "boolean",
      defaultValue: true
    });
    const previewImage = this.settings.addSetting({
      id: "Comfy.PreviewFormat",
      category: ["Comfy", "Node Widget", "PreviewFormat"],
      name: "Preview image format",
      tooltip: "When displaying a preview in the image widget, convert it to a lightweight image, e.g. webp, jpeg, webp;50, etc.",
      type: "text",
      defaultValue: ""
    });
    this.settings.addSetting({
      id: "Comfy.DisableSliders",
      category: ["Comfy", "Node Widget", "DisableSliders"],
      name: "Disable node widget sliders",
      type: "boolean",
      defaultValue: false
    });
    this.settings.addSetting({
      id: "Comfy.DisableFloatRounding",
      category: ["Comfy", "Node Widget", "DisableFloatRounding"],
      name: "Disable default float widget rounding.",
      tooltip: "(requires page reload) Cannot disable round when round is set by the node in the backend.",
      type: "boolean",
      defaultValue: false
    });
    this.settings.addSetting({
      id: "Comfy.FloatRoundingPrecision",
      category: ["Comfy", "Node Widget", "FloatRoundingPrecision"],
      name: "Float widget rounding decimal places [0 = auto].",
      tooltip: "(requires page reload)",
      type: "slider",
      attrs: {
        min: 0,
        max: 6,
        step: 1
      },
      defaultValue: 0
    });
    this.settings.addSetting({
      id: "Comfy.EnableTooltips",
      category: ["Comfy", "Node", "EnableTooltips"],
      name: "Enable Tooltips",
      type: "boolean",
      defaultValue: true
    });
    const fileInput2 = $el("input", {
      id: "comfy-file-input",
      type: "file",
      accept: ".json,image/png,.latent,.safetensors,image/webp,audio/flac",
      style: { display: "none" },
      parent: document.body,
      onchange: /* @__PURE__ */ __name(() => {
        app2.handleFile(fileInput2.files[0]);
      }, "onchange")
    });
    this.loadFile = () => fileInput2.click();
    const autoQueueModeEl = toggleSwitch(
      "autoQueueMode",
      [
        {
          text: "instant",
          tooltip: "A new prompt will be queued as soon as the queue reaches 0"
        },
        {
          text: "change",
          tooltip: "A new prompt will be queued when the queue is at 0 and the graph is/has changed"
        }
      ],
      {
        onChange: /* @__PURE__ */ __name((value3) => {
          this.autoQueueMode = value3.item.value;
        }, "onChange")
      }
    );
    autoQueueModeEl.style.display = "none";
    api.addEventListener("graphChanged", () => {
      if (this.autoQueueMode === "change" && this.autoQueueEnabled === true) {
        if (this.lastQueueSize === 0) {
          this.graphHasChanged = false;
          app2.queuePrompt(0, this.batchCount);
        } else {
          this.graphHasChanged = true;
        }
      }
    });
    this.menuHamburger = $el(
      "div.comfy-menu-hamburger",
      {
        parent: document.body,
        onclick: /* @__PURE__ */ __name(() => {
          this.menuContainer.style.display = "block";
          this.menuHamburger.style.display = "none";
        }, "onclick")
      },
      [$el("div"), $el("div"), $el("div")]
    );
    this.menuContainer = $el("div.comfy-menu", { parent: document.body }, [
      $el(
        "div.drag-handle.comfy-menu-header",
        {
          style: {
            overflow: "hidden",
            position: "relative",
            width: "100%",
            cursor: "default"
          }
        },
        [
          $el("span.drag-handle"),
          $el("span.comfy-menu-queue-size", { $: /* @__PURE__ */ __name((q) => this.queueSize = q, "$") }),
          $el("div.comfy-menu-actions", [
            $el("button.comfy-settings-btn", {
              textContent: "",
              onclick: showSettingsDialog
            }),
            $el("button.comfy-close-menu-btn", {
              textContent: "",
              onclick: /* @__PURE__ */ __name(() => {
                this.menuContainer.style.display = "none";
                this.menuHamburger.style.display = "flex";
              }, "onclick")
            })
          ])
        ]
      ),
      $el("button.comfy-queue-btn", {
        id: "queue-button",
        textContent: "Queue Prompt",
        onclick: /* @__PURE__ */ __name(() => app2.queuePrompt(0, this.batchCount), "onclick")
      }),
      $el("div", {}, [
        $el("label", { innerHTML: "Extra options" }, [
          $el("input", {
            type: "checkbox",
            onchange: /* @__PURE__ */ __name((i2) => {
              document.getElementById("extraOptions").style.display = i2.srcElement.checked ? "block" : "none";
              this.batchCount = i2.srcElement.checked ? Number.parseInt(
                document.getElementById(
                  "batchCountInputRange"
                ).value
              ) : 1;
              document.getElementById("autoQueueCheckbox").checked = false;
              this.autoQueueEnabled = false;
            }, "onchange")
          })
        ])
      ]),
      $el(
        "div",
        { id: "extraOptions", style: { width: "100%", display: "none" } },
        [
          $el("div", [
            $el("label", { innerHTML: "Batch count" }),
            $el("input", {
              id: "batchCountInputNumber",
              type: "number",
              value: this.batchCount,
              min: "1",
              style: { width: "35%", marginLeft: "0.4em" },
              oninput: /* @__PURE__ */ __name((i2) => {
                this.batchCount = i2.target.value;
                document.getElementById(
                  "batchCountInputRange"
                ).value = this.batchCount.toString();
              }, "oninput")
            }),
            $el("input", {
              id: "batchCountInputRange",
              type: "range",
              min: "1",
              max: "100",
              value: this.batchCount,
              oninput: /* @__PURE__ */ __name((i2) => {
                this.batchCount = i2.srcElement.value;
                document.getElementById(
                  "batchCountInputNumber"
                ).value = i2.srcElement.value;
              }, "oninput")
            })
          ]),
          $el("div", [
            $el("label", {
              for: "autoQueueCheckbox",
              innerHTML: "Auto Queue"
            }),
            $el("input", {
              id: "autoQueueCheckbox",
              type: "checkbox",
              checked: false,
              title: "Automatically queue prompt when the queue size hits 0",
              onchange: /* @__PURE__ */ __name((e) => {
                this.autoQueueEnabled = e.target.checked;
                autoQueueModeEl.style.display = this.autoQueueEnabled ? "" : "none";
              }, "onchange")
            }),
            autoQueueModeEl
          ])
        ]
      ),
      $el("div.comfy-menu-btns", [
        $el("button", {
          id: "queue-front-button",
          textContent: "Queue Front",
          onclick: /* @__PURE__ */ __name(() => app2.queuePrompt(-1, this.batchCount), "onclick")
        }),
        $el("button", {
          $: /* @__PURE__ */ __name((b) => this.queue.button = b, "$"),
          id: "comfy-view-queue-button",
          textContent: "View Queue",
          onclick: /* @__PURE__ */ __name(() => {
            this.history.hide();
            this.queue.toggle();
          }, "onclick")
        }),
        $el("button", {
          $: /* @__PURE__ */ __name((b) => this.history.button = b, "$"),
          id: "comfy-view-history-button",
          textContent: "View History",
          onclick: /* @__PURE__ */ __name(() => {
            this.queue.hide();
            this.history.toggle();
          }, "onclick")
        })
      ]),
      this.queue.element,
      this.history.element,
      $el("button", {
        id: "comfy-save-button",
        textContent: "Save",
        onclick: /* @__PURE__ */ __name(() => {
          let filename = "workflow.json";
          if (promptFilename.value) {
            filename = prompt("Save workflow as:", filename);
            if (!filename) return;
            if (!filename.toLowerCase().endsWith(".json")) {
              filename += ".json";
            }
          }
          app2.graphToPrompt().then((p2) => {
            const json = JSON.stringify(p2.workflow, null, 2);
            const blob = new Blob([json], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = $el("a", {
              href: url,
              download: filename,
              style: { display: "none" },
              parent: document.body
            });
            a.click();
            setTimeout(function() {
              a.remove();
              window.URL.revokeObjectURL(url);
            }, 0);
          });
        }, "onclick")
      }),
      $el("button", {
        id: "comfy-dev-save-api-button",
        textContent: "Save (API Format)",
        style: { width: "100%", display: "none" },
        onclick: /* @__PURE__ */ __name(() => {
          let filename = "workflow_api.json";
          if (promptFilename.value) {
            filename = prompt("Save workflow (API) as:", filename);
            if (!filename) return;
            if (!filename.toLowerCase().endsWith(".json")) {
              filename += ".json";
            }
          }
          app2.graphToPrompt().then((p2) => {
            const json = JSON.stringify(p2.output, null, 2);
            const blob = new Blob([json], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = $el("a", {
              href: url,
              download: filename,
              style: { display: "none" },
              parent: document.body
            });
            a.click();
            setTimeout(function() {
              a.remove();
              window.URL.revokeObjectURL(url);
            }, 0);
          });
        }, "onclick")
      }),
      $el("button", {
        id: "comfy-load-button",
        textContent: "Load",
        onclick: /* @__PURE__ */ __name(() => fileInput2.click(), "onclick")
      }),
      $el("button", {
        id: "comfy-refresh-button",
        textContent: "Refresh",
        onclick: /* @__PURE__ */ __name(() => app2.refreshComboInNodes(), "onclick")
      }),
      $el("button", {
        id: "comfy-clipspace-button",
        textContent: "Clipspace",
        onclick: /* @__PURE__ */ __name(() => app2.openClipspace(), "onclick")
      }),
      $el("button", {
        id: "comfy-clear-button",
        textContent: "Clear",
        onclick: /* @__PURE__ */ __name(() => {
          if (!confirmClear.value || confirm("Clear workflow?")) {
            app2.clean();
            app2.graph.clear();
            app2.resetView();
            api.dispatchEvent(new CustomEvent("graphCleared"));
          }
        }, "onclick")
      }),
      $el("button", {
        id: "comfy-load-default-button",
        textContent: "Load Default",
        onclick: /* @__PURE__ */ __name(async () => {
          if (!confirmClear.value || confirm("Load default workflow?")) {
            app2.resetView();
            await app2.loadGraphData();
          }
        }, "onclick")
      }),
      $el("button", {
        id: "comfy-reset-view-button",
        textContent: "Reset View",
        onclick: /* @__PURE__ */ __name(async () => {
          app2.resetView();
        }, "onclick")
      }),
      $el("button", {
        id: "comfy-group-selected-nodes-button",
        textContent: "Group",
        hidden: true,
        onclick: /* @__PURE__ */ __name(() => {
          if (!app2.canvas.selected_nodes || Object.keys(app2.canvas.selected_nodes).length === 0) {
            useToastStore().add({
              severity: "error",
              summary: "No nodes selected",
              detail: "Please select nodes to group",
              life: 3e3
            });
            return;
          }
          const group = new LGraphGroup();
          const padding = useSettingStore().get(
            "Comfy.GroupSelectedNodes.Padding"
          );
          group.addNodes(Object.values(app2.canvas.selected_nodes), padding);
          app2.canvas.graph.add(group);
          useTitleEditorStore().titleEditorTarget = group;
        }, "onclick")
      })
    ]);
    this.settings.addSetting({
      id: "Comfy.DevMode",
      name: "Enable dev mode options (API save, etc.)",
      type: "boolean",
      defaultValue: false,
      onChange: /* @__PURE__ */ __name(function(value3) {
        document.getElementById("comfy-dev-save-api-button").style.display = value3 ? "flex" : "none";
      }, "onChange")
    });
    this.restoreMenuPosition = dragElement(this.menuContainer, this.settings);
    this.setStatus({ exec_info: { queue_remaining: "X" } });
  }
  setStatus(status) {
    this.queueSize.textContent = "Queue size: " + (status ? status.exec_info.queue_remaining : "ERR");
    if (status) {
      if (this.lastQueueSize != 0 && status.exec_info.queue_remaining == 0 && this.autoQueueEnabled && (this.autoQueueMode === "instant" || this.graphHasChanged) && !app$1.lastExecutionError) {
        app$1.queuePrompt(0, this.batchCount);
        status.exec_info.queue_remaining += this.batchCount;
        this.graphHasChanged = false;
      }
      this.lastQueueSize = status.exec_info.queue_remaining;
    }
  }
}
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.ui = window.comfyAPI.ui || {};
window.comfyAPI.ui.ComfyDialog = ComfyDialog;
window.comfyAPI.ui.$el = $el;
window.comfyAPI.ui.ComfyUI = ComfyUI;
$el("style", {
  textContent: `
        .comfy-logging-logs {
            display: grid;
            color: var(--fg-color);
            white-space: pre-wrap;
        }
        .comfy-logging-log {
            display: contents;
        }
        .comfy-logging-title {
            background: var(--tr-even-bg-color);
            font-weight: bold;
            margin-bottom: 5px;
            text-align: center;
        }
        .comfy-logging-log div {
            background: var(--row-bg);
            padding: 5px;
        }
    `,
  parent: document.body
});
function stringify(val, depth, replacer2, space, onGetObjID) {
  depth = isNaN(+depth) ? 1 : depth;
  var recursMap = /* @__PURE__ */ new WeakMap();
  function _build(val2, depth2, o, a, r) {
    return !val2 || typeof val2 != "object" ? val2 : (r = recursMap.has(val2), recursMap.set(val2, true), a = Array.isArray(val2), r ? o = onGetObjID && onGetObjID(val2) || null : JSON.stringify(val2, function(k, v2) {
      if (a || depth2 > 0) {
        if (replacer2) v2 = replacer2(k, v2);
        if (!k) return a = Array.isArray(v2), val2 = v2;
        !o && (o = a ? [] : {});
        o[k] = _build(v2, a ? depth2 : depth2 - 1);
      }
    }), o === void 0 ? a ? [] : {} : o);
  }
  __name(_build, "_build");
  return JSON.stringify(_build(val, depth), null, space);
}
__name(stringify, "stringify");
const jsonReplacer = /* @__PURE__ */ __name((k, v2, ui) => {
  if (v2 instanceof Array && v2.length === 1) {
    v2 = v2[0];
  }
  if (v2 instanceof Date) {
    v2 = v2.toISOString();
    if (ui) {
      v2 = v2.split("T")[1];
    }
  }
  if (v2 instanceof Error) {
    let err = "";
    if (v2.name) err += v2.name + "\n";
    if (v2.message) err += v2.message + "\n";
    if (v2.stack) err += v2.stack + "\n";
    if (!err) {
      err = v2.toString();
    }
    v2 = err;
  }
  return v2;
}, "jsonReplacer");
const fileInput = $el("input", {
  type: "file",
  accept: ".json",
  style: { display: "none" },
  parent: document.body
});
class ComfyLoggingDialog extends ComfyDialog {
  static {
    __name(this, "ComfyLoggingDialog");
  }
  logging;
  constructor(logging) {
    super();
    this.logging = logging;
  }
  clear() {
    this.logging.clear();
    this.show();
  }
  export() {
    const blob = new Blob(
      [stringify([...this.logging.entries], 20, jsonReplacer, "	")],
      {
        type: "application/json"
      }
    );
    const url = URL.createObjectURL(blob);
    const a = $el("a", {
      href: url,
      download: `comfyui-logs-${Date.now()}.json`,
      style: { display: "none" },
      parent: document.body
    });
    a.click();
    setTimeout(function() {
      a.remove();
      window.URL.revokeObjectURL(url);
    }, 0);
  }
  import() {
    fileInput.onchange = () => {
      const reader = new FileReader();
      reader.onload = () => {
        fileInput.remove();
        try {
          const obj = JSON.parse(reader.result);
          if (obj instanceof Array) {
            this.show(obj);
          } else {
            throw new Error("Invalid file selected.");
          }
        } catch (error) {
          alert("Unable to load logs: " + error.message);
        }
      };
      reader.readAsText(fileInput.files[0]);
    };
    fileInput.click();
  }
  createButtons() {
    return [
      $el("button", {
        type: "button",
        textContent: "Clear",
        onclick: /* @__PURE__ */ __name(() => this.clear(), "onclick")
      }),
      $el("button", {
        type: "button",
        textContent: "Export logs...",
        onclick: /* @__PURE__ */ __name(() => this.export(), "onclick")
      }),
      $el("button", {
        type: "button",
        textContent: "View exported logs...",
        onclick: /* @__PURE__ */ __name(() => this.import(), "onclick")
      }),
      ...super.createButtons()
    ];
  }
  getTypeColor(type) {
    switch (type) {
      case "error":
        return "red";
      case "warn":
        return "orange";
      case "debug":
        return "dodgerblue";
    }
  }
  show(entries) {
    if (!entries) entries = this.logging.entries;
    this.element.style.width = "100%";
    const cols = {
      source: "Source",
      type: "Type",
      timestamp: "Timestamp",
      message: "Message"
    };
    const keys2 = Object.keys(cols);
    const headers = Object.values(cols).map(
      (title) => $el("div.comfy-logging-title", {
        textContent: title
      })
    );
    const rows = entries.map((entry, i2) => {
      return $el(
        "div.comfy-logging-log",
        {
          $: /* @__PURE__ */ __name((el) => el.style.setProperty(
            "--row-bg",
            `var(--tr-${i2 % 2 ? "even" : "odd"}-bg-color)`
          ), "$")
        },
        keys2.map((key) => {
          let v2 = entry[key];
          let color;
          if (key === "type") {
            color = this.getTypeColor(v2);
          } else {
            v2 = jsonReplacer(key, v2, true);
            if (typeof v2 === "object") {
              v2 = stringify(v2, 5, jsonReplacer, "  ");
            }
          }
          return $el("div", {
            style: {
              color
            },
            textContent: v2
          });
        })
      );
    });
    const grid = $el(
      "div.comfy-logging-logs",
      {
        style: {
          gridTemplateColumns: `repeat(${headers.length}, 1fr)`
        }
      },
      [...headers, ...rows]
    );
    const els = [grid];
    if (!this.logging.enabled) {
      els.unshift(
        $el("h3", {
          style: { textAlign: "center" },
          textContent: "Logging is disabled"
        })
      );
    }
    super.show($el("div", els));
  }
}
class ComfyLogging {
  static {
    __name(this, "ComfyLogging");
  }
  /**
   * @type Array<{ source: string, type: string, timestamp: Date, message: any }>
   */
  entries = [];
  #enabled;
  #console = {};
  app;
  dialog;
  get enabled() {
    return this.#enabled;
  }
  set enabled(value3) {
    if (value3 === this.#enabled) return;
    if (value3) {
      this.patchConsole();
    } else {
      this.unpatchConsole();
    }
    this.#enabled = value3;
  }
  constructor(app2) {
    this.app = app2;
    this.dialog = new ComfyLoggingDialog(this);
    this.addSetting();
    this.catchUnhandled();
    this.addInitData();
  }
  addSetting() {
    const settingId = "Comfy.Logging.Enabled";
    const htmlSettingId = settingId.replaceAll(".", "-");
    const setting = this.app.ui.settings.addSetting({
      id: settingId,
      name: "Enable logging",
      defaultValue: true,
      onChange: /* @__PURE__ */ __name((value3) => {
        this.enabled = value3;
      }, "onChange"),
      type: /* @__PURE__ */ __name((name, setter, value3) => {
        return $el("tr", [
          $el("td", [
            $el("label", {
              textContent: "Logging",
              for: htmlSettingId
            })
          ]),
          $el("td", [
            $el("input", {
              id: htmlSettingId,
              type: "checkbox",
              checked: value3,
              onchange: /* @__PURE__ */ __name((event2) => {
                setter(event2.target.checked);
              }, "onchange")
            }),
            $el("button", {
              textContent: "View Logs",
              onclick: /* @__PURE__ */ __name(() => {
                this.app.ui.settings.element.close();
                this.dialog.show();
              }, "onclick"),
              style: {
                fontSize: "14px",
                display: "block",
                marginTop: "5px"
              }
            })
          ])
        ]);
      }, "type")
    });
    this.enabled = setting.value;
  }
  patchConsole() {
    const self2 = this;
    for (const type of ["log", "warn", "error", "debug"]) {
      const orig = console[type];
      this.#console[type] = orig;
      console[type] = function() {
        orig.apply(console, arguments);
        self2.addEntry("console", type, ...arguments);
      };
    }
  }
  unpatchConsole() {
    for (const type of Object.keys(this.#console)) {
      console[type] = this.#console[type];
    }
    this.#console = {};
  }
  catchUnhandled() {
    window.addEventListener("error", (e) => {
      this.addEntry("window", "error", e.error ?? "Unknown error");
      return false;
    });
    window.addEventListener("unhandledrejection", (e) => {
      this.addEntry("unhandledrejection", "error", e.reason ?? "Unknown error");
    });
  }
  clear() {
    this.entries = [];
  }
  addEntry(source, type, ...args) {
    if (this.enabled) {
      this.entries.push({
        source,
        type,
        timestamp: /* @__PURE__ */ new Date(),
        message: args
      });
    }
  }
  log(source, ...args) {
    this.addEntry(source, "log", ...args);
  }
  async addInitData() {
    if (!this.enabled) return;
    const source = "ComfyUI.Logging";
    this.addEntry(source, "debug", { UserAgent: navigator.userAgent });
    const systemStats = await api.getSystemStats();
    this.addEntry(source, "debug", systemStats);
  }
}
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.logging = window.comfyAPI.logging || {};
window.comfyAPI.logging.ComfyLogging = ComfyLogging;
const SIZE = Symbol();
function intersect(a, b) {
  const x2 = Math.max(a.x, b.x);
  const num1 = Math.min(a.x + a.width, b.x + b.width);
  const y2 = Math.max(a.y, b.y);
  const num2 = Math.min(a.y + a.height, b.y + b.height);
  if (num1 >= x2 && num2 >= y2) return [x2, y2, num1 - x2, num2 - y2];
  else return null;
}
__name(intersect, "intersect");
function getClipPath(node3, element, canvasRect) {
  const selectedNode = Object.values(
    app$1.canvas.selected_nodes
  )[0];
  if (selectedNode && selectedNode !== node3) {
    const elRect = element.getBoundingClientRect();
    const MARGIN = 7;
    const scale = app$1.canvas.ds.scale;
    const bounding = selectedNode.getBounding();
    const intersection = intersect(
      {
        x: elRect.x / scale - canvasRect.left,
        y: elRect.y / scale - canvasRect.top,
        width: elRect.width / scale,
        height: elRect.height / scale
      },
      {
        x: selectedNode.pos[0] + app$1.canvas.ds.offset[0] - MARGIN,
        y: selectedNode.pos[1] + app$1.canvas.ds.offset[1] - LiteGraph.NODE_TITLE_HEIGHT - MARGIN,
        width: bounding[2] + MARGIN + MARGIN,
        height: bounding[3] + MARGIN + MARGIN
      }
    );
    if (!intersection) {
      return "";
    }
    const clipX = canvasRect.left + intersection[0] - elRect.x / scale + "px";
    const clipY = canvasRect.top + intersection[1] - elRect.y / scale + "px";
    const clipWidth = intersection[2] + "px";
    const clipHeight = intersection[3] + "px";
    const path = `polygon(0% 0%, 0% 100%, ${clipX} 100%, ${clipX} ${clipY}, calc(${clipX} + ${clipWidth}) ${clipY}, calc(${clipX} + ${clipWidth}) calc(${clipY} + ${clipHeight}), ${clipX} calc(${clipY} + ${clipHeight}), ${clipX} 100%, 100% 100%, 100% 0%)`;
    return path;
  }
  return "";
}
__name(getClipPath, "getClipPath");
function computeSize(size2) {
  if (this.widgets?.[0]?.last_y == null) return;
  let y2 = this.widgets[0].last_y;
  let freeSpace = size2[1] - y2;
  let widgetHeight = 0;
  let dom = [];
  for (const w2 of this.widgets) {
    if (w2.type === "converted-widget") {
      delete w2.computedHeight;
    } else if (w2.computeSize) {
      widgetHeight += w2.computeSize()[1] + 4;
    } else if (w2.element) {
      const styles = getComputedStyle(w2.element);
      let minHeight = w2.options.getMinHeight?.() ?? parseInt(styles.getPropertyValue("--comfy-widget-min-height"));
      let maxHeight = w2.options.getMaxHeight?.() ?? parseInt(styles.getPropertyValue("--comfy-widget-max-height"));
      let prefHeight = w2.options.getHeight?.() ?? styles.getPropertyValue("--comfy-widget-height");
      if (prefHeight.endsWith?.("%")) {
        prefHeight = size2[1] * (parseFloat(prefHeight.substring(0, prefHeight.length - 1)) / 100);
      } else {
        prefHeight = parseInt(prefHeight);
        if (isNaN(minHeight)) {
          minHeight = prefHeight;
        }
      }
      if (isNaN(minHeight)) {
        minHeight = 50;
      }
      if (!isNaN(maxHeight)) {
        if (!isNaN(prefHeight)) {
          prefHeight = Math.min(prefHeight, maxHeight);
        } else {
          prefHeight = maxHeight;
        }
      }
      dom.push({
        minHeight,
        prefHeight,
        w: w2
      });
    } else {
      widgetHeight += LiteGraph.NODE_WIDGET_HEIGHT + 4;
    }
  }
  freeSpace -= widgetHeight;
  const prefGrow = [];
  const canGrow = [];
  let growBy = 0;
  for (const d of dom) {
    freeSpace -= d.minHeight;
    if (isNaN(d.prefHeight)) {
      canGrow.push(d);
      d.w.computedHeight = d.minHeight;
    } else {
      const diff = d.prefHeight - d.minHeight;
      if (diff > 0) {
        prefGrow.push(d);
        growBy += diff;
        d.diff = diff;
      } else {
        d.w.computedHeight = d.minHeight;
      }
    }
  }
  if (this.imgs && !this.widgets.find((w2) => w2.name === ANIM_PREVIEW_WIDGET)) {
    freeSpace -= 220;
  }
  this.freeWidgetSpace = freeSpace;
  if (freeSpace < 0) {
    size2[1] -= freeSpace;
    this.graph.setDirtyCanvas(true);
  } else {
    const growDiff = freeSpace - growBy;
    if (growDiff > 0) {
      freeSpace = growDiff;
      for (const d of prefGrow) {
        d.w.computedHeight = d.prefHeight;
      }
    } else {
      const shared = -growDiff / prefGrow.length;
      for (const d of prefGrow) {
        d.w.computedHeight = d.prefHeight - shared;
      }
      freeSpace = 0;
    }
    if (freeSpace > 0 && canGrow.length) {
      const shared = freeSpace / canGrow.length;
      for (const d of canGrow) {
        d.w.computedHeight += shared;
      }
    }
  }
  for (const w2 of this.widgets) {
    w2.y = y2;
    if (w2.computedHeight) {
      y2 += w2.computedHeight;
    } else if (w2.computeSize) {
      y2 += w2.computeSize()[1] + 4;
    } else {
      y2 += LiteGraph.NODE_WIDGET_HEIGHT + 4;
    }
  }
}
__name(computeSize, "computeSize");
const elementWidgets = /* @__PURE__ */ new Set();
const computeVisibleNodes = LGraphCanvas.prototype.computeVisibleNodes;
LGraphCanvas.prototype.computeVisibleNodes = function() {
  const visibleNodes = computeVisibleNodes.apply(this, arguments);
  for (const node3 of app$1.graph._nodes) {
    if (elementWidgets.has(node3)) {
      const hidden = visibleNodes.indexOf(node3) === -1;
      for (const w2 of node3.widgets) {
        if (w2.element) {
          w2.element.dataset.isInVisibleNodes = hidden ? "false" : "true";
          const shouldOtherwiseHide = w2.element.dataset.shouldHide === "true";
          const isCollapsed = w2.element.dataset.collapsed === "true";
          const wasHidden = w2.element.hidden;
          const actualHidden = hidden || shouldOtherwiseHide || isCollapsed;
          w2.element.hidden = actualHidden;
          w2.element.style.display = actualHidden ? "none" : null;
          if (actualHidden && !wasHidden) {
            w2.options.onHide?.(w2);
          }
        }
      }
    }
  }
  return visibleNodes;
};
let enableDomClipping = true;
function addDomClippingSetting() {
  app$1.ui.settings.addSetting({
    id: "Comfy.DOMClippingEnabled",
    category: ["Comfy", "Node", "DOMClippingEnabled"],
    name: "Enable DOM element clipping (enabling may reduce performance)",
    type: "boolean",
    defaultValue: enableDomClipping,
    onChange(value3) {
      enableDomClipping = !!value3;
    }
  });
}
__name(addDomClippingSetting, "addDomClippingSetting");
LGraphNode.prototype.addDOMWidget = function(name, type, element, options3) {
  options3 = { hideOnZoom: true, selectOn: ["focus", "click"], ...options3 };
  if (!element.parentElement) {
    app$1.canvasContainer.append(element);
  }
  element.hidden = true;
  element.style.display = "none";
  let mouseDownHandler;
  if (element.blur) {
    mouseDownHandler = /* @__PURE__ */ __name((event2) => {
      if (!element.contains(event2.target)) {
        element.blur();
      }
    }, "mouseDownHandler");
    document.addEventListener("mousedown", mouseDownHandler);
  }
  const { nodeData } = this.constructor;
  const tooltip = (nodeData?.input.required?.[name] ?? nodeData?.input.optional?.[name])?.[1]?.tooltip;
  if (tooltip && !element.title) {
    element.title = tooltip;
  }
  const widget = {
    type,
    name,
    get value() {
      return options3.getValue?.() ?? void 0;
    },
    set value(v2) {
      options3.setValue?.(v2);
      widget.callback?.(widget.value);
    },
    draw: /* @__PURE__ */ __name(function(ctx, node3, widgetWidth, y2, widgetHeight) {
      if (widget.computedHeight == null) {
        computeSize.call(node3, node3.size);
      }
      const hidden = !!options3.hideOnZoom && app$1.canvas.ds.scale < 0.5 || widget.computedHeight <= 0 || widget.type === "converted-widget" || widget.type === "hidden";
      element.dataset.shouldHide = hidden ? "true" : "false";
      const isInVisibleNodes = element.dataset.isInVisibleNodes === "true";
      const isCollapsed = element.dataset.collapsed === "true";
      const actualHidden = hidden || !isInVisibleNodes || isCollapsed;
      const wasHidden = element.hidden;
      element.hidden = actualHidden;
      element.style.display = actualHidden ? "none" : null;
      if (actualHidden && !wasHidden) {
        widget.options.onHide?.(widget);
      }
      if (actualHidden) {
        return;
      }
      const margin = 10;
      const elRect = ctx.canvas.getBoundingClientRect();
      const transform2 = new DOMMatrix().scaleSelf(
        elRect.width / ctx.canvas.width,
        elRect.height / ctx.canvas.height
      ).multiplySelf(ctx.getTransform()).translateSelf(margin, margin + y2);
      const scale = new DOMMatrix().scaleSelf(transform2.a, transform2.d);
      Object.assign(element.style, {
        transformOrigin: "0 0",
        transform: scale,
        left: `${transform2.a + transform2.e}px`,
        top: `${transform2.d + transform2.f}px`,
        width: `${widgetWidth - margin * 2}px`,
        height: `${(widget.computedHeight ?? 50) - margin * 2}px`,
        position: "absolute",
        // @ts-expect-error
        zIndex: app$1.graph._nodes.indexOf(node3)
      });
      if (enableDomClipping) {
        element.style.clipPath = getClipPath(node3, element, elRect);
        element.style.willChange = "clip-path";
      }
      this.options.onDraw?.(widget);
    }, "draw"),
    element,
    options: options3,
    onRemove() {
      if (mouseDownHandler) {
        document.removeEventListener("mousedown", mouseDownHandler);
      }
      element.remove();
    }
  };
  for (const evt of options3.selectOn) {
    element.addEventListener(evt, () => {
      app$1.canvas.selectNode(this);
      app$1.canvas.bringToFront(this);
    });
  }
  this.addCustomWidget(widget);
  elementWidgets.add(this);
  const collapse = this.collapse;
  this.collapse = function() {
    collapse.apply(this, arguments);
    if (this.flags?.collapsed) {
      element.hidden = true;
      element.style.display = "none";
    }
    element.dataset.collapsed = this.flags?.collapsed ? "true" : "false";
  };
  const onRemoved = this.onRemoved;
  this.onRemoved = function() {
    element.remove();
    elementWidgets.delete(this);
    onRemoved?.apply(this, arguments);
  };
  if (!this[SIZE]) {
    this[SIZE] = true;
    const onResize3 = this.onResize;
    this.onResize = function(size2) {
      options3.beforeResize?.call(widget, this);
      computeSize.call(this, size2);
      onResize3?.apply(this, arguments);
      options3.afterResize?.call(widget, this);
    };
  }
  return widget;
};
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.domWidget = window.comfyAPI.domWidget || {};
window.comfyAPI.domWidget.addDomClippingSetting = addDomClippingSetting;
let controlValueRunBefore = false;
function updateControlWidgetLabel(widget) {
  let replacement = "after";
  let find2 = "before";
  if (controlValueRunBefore) {
    ;
    [find2, replacement] = [replacement, find2];
  }
  widget.label = (widget.label ?? widget.name).replace(find2, replacement);
}
__name(updateControlWidgetLabel, "updateControlWidgetLabel");
const IS_CONTROL_WIDGET = Symbol();
const HAS_EXECUTED = Symbol();
function getNumberDefaults(inputData, defaultStep, precision, enable_rounding) {
  let defaultVal = inputData[1]["default"];
  let { min, max, step: step2, round } = inputData[1];
  if (defaultVal == void 0) defaultVal = 0;
  if (min == void 0) min = 0;
  if (max == void 0) max = 2048;
  if (step2 == void 0) step2 = defaultStep;
  if (precision == void 0) {
    precision = Math.max(-Math.floor(Math.log10(step2)), 0);
  }
  if (enable_rounding && (round == void 0 || round === true)) {
    round = Math.round(1e6 * Math.pow(0.1, precision)) / 1e6;
  }
  return {
    val: defaultVal,
    config: { min, max, step: 10 * step2, round, precision }
  };
}
__name(getNumberDefaults, "getNumberDefaults");
function addValueControlWidget(node3, targetWidget, defaultValue = "randomize", values2, widgetName, inputData) {
  let name = inputData[1]?.control_after_generate;
  if (typeof name !== "string") {
    name = widgetName;
  }
  const widgets = addValueControlWidgets(
    node3,
    targetWidget,
    defaultValue,
    {
      addFilterList: false,
      controlAfterGenerateName: name
    },
    inputData
  );
  return widgets[0];
}
__name(addValueControlWidget, "addValueControlWidget");
function addValueControlWidgets(node3, targetWidget, defaultValue = "randomize", options3, inputData) {
  if (!defaultValue) defaultValue = "randomize";
  if (!options3) options3 = {};
  const getName = /* @__PURE__ */ __name((defaultName, optionName) => {
    let name = defaultName;
    if (options3[optionName]) {
      name = options3[optionName];
    } else if (typeof inputData?.[1]?.[defaultName] === "string") {
      name = inputData?.[1]?.[defaultName];
    } else if (inputData?.[1]?.control_prefix) {
      name = inputData?.[1]?.control_prefix + " " + name;
    }
    return name;
  }, "getName");
  const widgets = [];
  const valueControl = node3.addWidget(
    "combo",
    getName("control_after_generate", "controlAfterGenerateName"),
    defaultValue,
    function() {
    },
    {
      values: ["fixed", "increment", "decrement", "randomize"],
      serialize: false
      // Don't include this in prompt.
    }
  );
  valueControl.tooltip = "Allows the linked widget to be changed automatically, for example randomizing the noise seed.";
  valueControl[IS_CONTROL_WIDGET] = true;
  updateControlWidgetLabel(valueControl);
  widgets.push(valueControl);
  const isCombo = targetWidget.type === "combo";
  let comboFilter;
  if (isCombo) {
    valueControl.options.values.push("increment-wrap");
  }
  if (isCombo && options3.addFilterList !== false) {
    comboFilter = node3.addWidget(
      "string",
      getName("control_filter_list", "controlFilterListName"),
      "",
      function() {
      },
      {
        serialize: false
        // Don't include this in prompt.
      }
    );
    updateControlWidgetLabel(comboFilter);
    comboFilter.tooltip = "Allows for filtering the list of values when changing the value via the control generate mode. Allows for RegEx matches in the format /abc/ to only filter to values containing 'abc'.";
    widgets.push(comboFilter);
  }
  const applyWidgetControl = /* @__PURE__ */ __name(() => {
    var v2 = valueControl.value;
    if (isCombo && v2 !== "fixed") {
      let values2 = targetWidget.options.values;
      const filter4 = comboFilter?.value;
      if (filter4) {
        let check;
        if (filter4.startsWith("/") && filter4.endsWith("/")) {
          try {
            const regex = new RegExp(filter4.substring(1, filter4.length - 1));
            check = /* @__PURE__ */ __name((item2) => regex.test(item2), "check");
          } catch (error) {
            console.error(
              "Error constructing RegExp filter for node " + node3.id,
              filter4,
              error
            );
          }
        }
        if (!check) {
          const lower = filter4.toLocaleLowerCase();
          check = /* @__PURE__ */ __name((item2) => item2.toLocaleLowerCase().includes(lower), "check");
        }
        values2 = values2.filter((item2) => check(item2));
        if (!values2.length && targetWidget.options.values.length) {
          console.warn(
            "Filter for node " + node3.id + " has filtered out all items",
            filter4
          );
        }
      }
      let current_index = values2.indexOf(targetWidget.value);
      let current_length = values2.length;
      switch (v2) {
        case "increment":
          current_index += 1;
          break;
        case "increment-wrap":
          current_index += 1;
          if (current_index >= current_length) {
            current_index = 0;
          }
          break;
        case "decrement":
          current_index -= 1;
          break;
        case "randomize":
          current_index = Math.floor(Math.random() * current_length);
          break;
        default:
          break;
      }
      current_index = Math.max(0, current_index);
      current_index = Math.min(current_length - 1, current_index);
      if (current_index >= 0) {
        let value3 = values2[current_index];
        targetWidget.value = value3;
        targetWidget.callback(value3);
      }
    } else {
      let min = targetWidget.options.min;
      let max = targetWidget.options.max;
      max = Math.min(1125899906842624, max);
      min = Math.max(-1125899906842624, min);
      let range2 = (max - min) / (targetWidget.options.step / 10);
      switch (v2) {
        case "fixed":
          break;
        case "increment":
          targetWidget.value += targetWidget.options.step / 10;
          break;
        case "decrement":
          targetWidget.value -= targetWidget.options.step / 10;
          break;
        case "randomize":
          targetWidget.value = Math.floor(Math.random() * range2) * (targetWidget.options.step / 10) + min;
          break;
        default:
          break;
      }
      if (targetWidget.value < min) targetWidget.value = min;
      if (targetWidget.value > max) targetWidget.value = max;
      targetWidget.callback(targetWidget.value);
    }
  }, "applyWidgetControl");
  valueControl.beforeQueued = () => {
    if (controlValueRunBefore) {
      if (valueControl[HAS_EXECUTED]) {
        applyWidgetControl();
      }
    }
    valueControl[HAS_EXECUTED] = true;
  };
  valueControl.afterQueued = () => {
    if (!controlValueRunBefore) {
      applyWidgetControl();
    }
  };
  return widgets;
}
__name(addValueControlWidgets, "addValueControlWidgets");
function seedWidget(node3, inputName, inputData, app2, widgetName) {
  const seed = createIntWidget(node3, inputName, inputData, app2, true);
  const seedControl = addValueControlWidget(
    node3,
    seed.widget,
    "randomize",
    void 0,
    widgetName,
    inputData
  );
  seed.widget.linkedWidgets = [seedControl];
  return seed;
}
__name(seedWidget, "seedWidget");
function createIntWidget(node3, inputName, inputData, app2, isSeedInput = false) {
  const control = inputData[1]?.control_after_generate;
  if (!isSeedInput && control) {
    return seedWidget(
      node3,
      inputName,
      inputData,
      app2,
      typeof control === "string" ? control : void 0
    );
  }
  let widgetType = isSlider(inputData[1]["display"], app2);
  const { val, config } = getNumberDefaults(inputData, 1, 0, true);
  Object.assign(config, { precision: 0 });
  return {
    widget: node3.addWidget(
      widgetType,
      inputName,
      val,
      function(v2) {
        const s = this.options.step / 10;
        let sh = this.options.min % s;
        if (isNaN(sh)) {
          sh = 0;
        }
        this.value = Math.round((v2 - sh) / s) * s + sh;
      },
      config
    )
  };
}
__name(createIntWidget, "createIntWidget");
function addMultilineWidget(node3, name, opts, app2) {
  const inputEl = document.createElement("textarea");
  inputEl.className = "comfy-multiline-input";
  inputEl.value = opts.defaultVal;
  inputEl.placeholder = opts.placeholder || name;
  if (app2.vueAppReady) {
    inputEl.spellcheck = useSettingStore().get(
      "Comfy.TextareaWidget.Spellcheck"
    );
  }
  const widget = node3.addDOMWidget(name, "customtext", inputEl, {
    getValue() {
      return inputEl.value;
    },
    setValue(v2) {
      inputEl.value = v2;
    }
  });
  widget.inputEl = inputEl;
  inputEl.addEventListener("input", () => {
    widget.callback?.(widget.value);
  });
  return { minWidth: 400, minHeight: 200, widget };
}
__name(addMultilineWidget, "addMultilineWidget");
function isSlider(display, app2) {
  if (app2.ui.settings.getSettingValue("Comfy.DisableSliders")) {
    return "number";
  }
  return display === "slider" ? "slider" : "number";
}
__name(isSlider, "isSlider");
function initWidgets(app2) {
  app2.ui.settings.addSetting({
    id: "Comfy.WidgetControlMode",
    category: ["Comfy", "Node Widget", "WidgetControlMode"],
    name: "Widget control mode",
    tooltip: "Controls when widget values are updated (randomize/increment/decrement), either before the prompt is queued or after.",
    type: "combo",
    defaultValue: "after",
    options: ["before", "after"],
    onChange(value3) {
      controlValueRunBefore = value3 === "before";
      for (const n of app2.graph._nodes) {
        if (!n.widgets) continue;
        for (const w2 of n.widgets) {
          if (w2[IS_CONTROL_WIDGET]) {
            updateControlWidgetLabel(w2);
            if (w2.linkedWidgets) {
              for (const l of w2.linkedWidgets) {
                updateControlWidgetLabel(l);
              }
            }
          }
        }
      }
      app2.graph.setDirtyCanvas(true);
    }
  });
}
__name(initWidgets, "initWidgets");
const ComfyWidgets = {
  "INT:seed": seedWidget,
  "INT:noise_seed": seedWidget,
  FLOAT(node3, inputName, inputData, app2) {
    let widgetType = isSlider(inputData[1]["display"], app2);
    let precision = app2.ui.settings.getSettingValue(
      "Comfy.FloatRoundingPrecision"
    );
    let disable_rounding = app2.ui.settings.getSettingValue(
      "Comfy.DisableFloatRounding"
    );
    if (precision == 0) precision = void 0;
    const { val, config } = getNumberDefaults(
      inputData,
      0.5,
      precision,
      !disable_rounding
    );
    return {
      widget: node3.addWidget(
        widgetType,
        inputName,
        val,
        function(v2) {
          if (config.round) {
            this.value = Math.round((v2 + Number.EPSILON) / config.round) * config.round;
            if (this.value > config.max) this.value = config.max;
            if (this.value < config.min) this.value = config.min;
          } else {
            this.value = v2;
          }
        },
        config
      )
    };
  },
  INT(node3, inputName, inputData, app2) {
    return createIntWidget(node3, inputName, inputData, app2);
  },
  BOOLEAN(node3, inputName, inputData) {
    let defaultVal = false;
    let options3 = {};
    if (inputData[1]) {
      if (inputData[1].default) defaultVal = inputData[1].default;
      if (inputData[1].label_on) options3["on"] = inputData[1].label_on;
      if (inputData[1].label_off) options3["off"] = inputData[1].label_off;
    }
    return {
      widget: node3.addWidget("toggle", inputName, defaultVal, () => {
      }, options3)
    };
  },
  STRING(node3, inputName, inputData, app2) {
    const defaultVal = inputData[1].default || "";
    const multiline = !!inputData[1].multiline;
    let res;
    if (multiline) {
      res = addMultilineWidget(
        node3,
        inputName,
        { defaultVal, ...inputData[1] },
        app2
      );
    } else {
      res = {
        widget: node3.addWidget("text", inputName, defaultVal, () => {
        }, {})
      };
    }
    if (inputData[1].dynamicPrompts != void 0)
      res.widget.dynamicPrompts = inputData[1].dynamicPrompts;
    return res;
  },
  COMBO(node3, inputName, inputData) {
    const type = inputData[0];
    let defaultValue = type[0];
    if (inputData[1] && inputData[1].default) {
      defaultValue = inputData[1].default;
    }
    const res = {
      widget: node3.addWidget("combo", inputName, defaultValue, () => {
      }, {
        values: type
      })
    };
    if (inputData[1]?.control_after_generate) {
      res.widget.linkedWidgets = addValueControlWidgets(
        node3,
        res.widget,
        void 0,
        void 0,
        inputData
      );
    }
    return res;
  },
  IMAGEUPLOAD(node3, inputName, inputData, app2) {
    const imageWidget = node3.widgets.find(
      (w2) => w2.name === (inputData[1]?.widget ?? "image")
    );
    let uploadWidget;
    function showImage(name) {
      const img = new Image();
      img.onload = () => {
        node3.imgs = [img];
        app2.graph.setDirtyCanvas(true);
      };
      let folder_separator = name.lastIndexOf("/");
      let subfolder = "";
      if (folder_separator > -1) {
        subfolder = name.substring(0, folder_separator);
        name = name.substring(folder_separator + 1);
      }
      img.src = api.apiURL(
        `/view?filename=${encodeURIComponent(name)}&type=input&subfolder=${subfolder}${app2.getPreviewFormatParam()}${app2.getRandParam()}`
      );
      node3.setSizeForImage?.();
    }
    __name(showImage, "showImage");
    var default_value = imageWidget.value;
    Object.defineProperty(imageWidget, "value", {
      set: /* @__PURE__ */ __name(function(value3) {
        this._real_value = value3;
      }, "set"),
      get: /* @__PURE__ */ __name(function() {
        if (!this._real_value) {
          return default_value;
        }
        let value3 = this._real_value;
        if (value3.filename) {
          let real_value = value3;
          value3 = "";
          if (real_value.subfolder) {
            value3 = real_value.subfolder + "/";
          }
          value3 += real_value.filename;
          if (real_value.type && real_value.type !== "input")
            value3 += ` [${real_value.type}]`;
        }
        return value3;
      }, "get")
    });
    const cb = node3.callback;
    imageWidget.callback = function() {
      showImage(imageWidget.value);
      if (cb) {
        return cb.apply(this, arguments);
      }
    };
    requestAnimationFrame(() => {
      if (imageWidget.value) {
        showImage(imageWidget.value);
      }
    });
    async function uploadFile(file, updateNode, pasted = false) {
      try {
        const body = new FormData();
        body.append("image", file);
        if (pasted) body.append("subfolder", "pasted");
        const resp = await api.fetchApi("/upload/image", {
          method: "POST",
          body
        });
        if (resp.status === 200) {
          const data24 = await resp.json();
          let path = data24.name;
          if (data24.subfolder) path = data24.subfolder + "/" + path;
          if (!imageWidget.options.values.includes(path)) {
            imageWidget.options.values.push(path);
          }
          if (updateNode) {
            showImage(path);
            imageWidget.value = path;
          }
        } else {
          alert(resp.status + " - " + resp.statusText);
        }
      } catch (error) {
        alert(error);
      }
    }
    __name(uploadFile, "uploadFile");
    const fileInput2 = document.createElement("input");
    Object.assign(fileInput2, {
      type: "file",
      accept: "image/jpeg,image/png,image/webp",
      style: "display: none",
      onchange: /* @__PURE__ */ __name(async () => {
        if (fileInput2.files.length) {
          await uploadFile(fileInput2.files[0], true);
        }
      }, "onchange")
    });
    document.body.append(fileInput2);
    uploadWidget = node3.addWidget("button", inputName, "image", () => {
      fileInput2.click();
    });
    uploadWidget.label = "choose file to upload";
    uploadWidget.serialize = false;
    node3.onDragOver = function(e) {
      if (e.dataTransfer && e.dataTransfer.items) {
        const image = [...e.dataTransfer.items].find((f) => f.kind === "file");
        return !!image;
      }
      return false;
    };
    node3.onDragDrop = function(e) {
      console.log("onDragDrop called");
      let handled = false;
      for (const file of e.dataTransfer.files) {
        if (file.type.startsWith("image/")) {
          uploadFile(file, !handled);
          handled = true;
        }
      }
      return handled;
    };
    node3.pasteFile = function(file) {
      if (file.type.startsWith("image/")) {
        const is_pasted = file.name === "image.png" && file.lastModified - Date.now() < 2e3;
        uploadFile(file, true, is_pasted);
        return true;
      }
      return false;
    };
    return { widget: uploadWidget };
  }
};
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.widgets = window.comfyAPI.widgets || {};
window.comfyAPI.widgets.updateControlWidgetLabel = updateControlWidgetLabel;
window.comfyAPI.widgets.addValueControlWidget = addValueControlWidget;
window.comfyAPI.widgets.addValueControlWidgets = addValueControlWidgets;
window.comfyAPI.widgets.initWidgets = initWidgets;
window.comfyAPI.widgets.ComfyWidgets = ComfyWidgets;
const defaultGraph = {
  last_node_id: 9,
  last_link_id: 9,
  nodes: [
    {
      id: 7,
      type: "CLIPTextEncode",
      pos: [413, 389],
      size: [425.27801513671875, 180.6060791015625],
      flags: {},
      order: 3,
      mode: 0,
      inputs: [{ name: "clip", type: "CLIP", link: 5 }],
      outputs: [
        {
          name: "CONDITIONING",
          type: "CONDITIONING",
          links: [6],
          slot_index: 0
        }
      ],
      properties: {},
      widgets_values: ["text, watermark"]
    },
    {
      id: 6,
      type: "CLIPTextEncode",
      pos: [415, 186],
      size: [422.84503173828125, 164.31304931640625],
      flags: {},
      order: 2,
      mode: 0,
      inputs: [{ name: "clip", type: "CLIP", link: 3 }],
      outputs: [
        {
          name: "CONDITIONING",
          type: "CONDITIONING",
          links: [4],
          slot_index: 0
        }
      ],
      properties: {},
      widgets_values: [
        "beautiful scenery nature glass bottle landscape, , purple galaxy bottle,"
      ]
    },
    {
      id: 5,
      type: "EmptyLatentImage",
      pos: [473, 609],
      size: [315, 106],
      flags: {},
      order: 1,
      mode: 0,
      outputs: [{ name: "LATENT", type: "LATENT", links: [2], slot_index: 0 }],
      properties: {},
      widgets_values: [512, 512, 1]
    },
    {
      id: 3,
      type: "KSampler",
      pos: [863, 186],
      size: [315, 262],
      flags: {},
      order: 4,
      mode: 0,
      inputs: [
        { name: "model", type: "MODEL", link: 1 },
        { name: "positive", type: "CONDITIONING", link: 4 },
        { name: "negative", type: "CONDITIONING", link: 6 },
        { name: "latent_image", type: "LATENT", link: 2 }
      ],
      outputs: [{ name: "LATENT", type: "LATENT", links: [7], slot_index: 0 }],
      properties: {},
      widgets_values: [156680208700286, true, 20, 8, "euler", "normal", 1]
    },
    {
      id: 8,
      type: "VAEDecode",
      pos: [1209, 188],
      size: [210, 46],
      flags: {},
      order: 5,
      mode: 0,
      inputs: [
        { name: "samples", type: "LATENT", link: 7 },
        { name: "vae", type: "VAE", link: 8 }
      ],
      outputs: [{ name: "IMAGE", type: "IMAGE", links: [9], slot_index: 0 }],
      properties: {}
    },
    {
      id: 9,
      type: "SaveImage",
      pos: [1451, 189],
      size: [210, 26],
      flags: {},
      order: 6,
      mode: 0,
      inputs: [{ name: "images", type: "IMAGE", link: 9 }],
      properties: {}
    },
    {
      id: 4,
      type: "CheckpointLoaderSimple",
      pos: [26, 474],
      size: [315, 98],
      flags: {},
      order: 0,
      mode: 0,
      outputs: [
        { name: "MODEL", type: "MODEL", links: [1], slot_index: 0 },
        { name: "CLIP", type: "CLIP", links: [3, 5], slot_index: 1 },
        { name: "VAE", type: "VAE", links: [8], slot_index: 2 }
      ],
      properties: {},
      widgets_values: ["v1-5-pruned-emaonly.ckpt"]
    }
  ],
  links: [
    [1, 4, 0, 3, 0, "MODEL"],
    [2, 5, 0, 3, 3, "LATENT"],
    [3, 4, 1, 6, 0, "CLIP"],
    [4, 6, 0, 3, 1, "CONDITIONING"],
    [5, 4, 1, 7, 0, "CLIP"],
    [6, 7, 0, 3, 2, "CONDITIONING"],
    [7, 3, 0, 8, 0, "LATENT"],
    [8, 4, 2, 8, 1, "VAE"],
    [9, 8, 0, 9, 0, "IMAGE"]
  ],
  groups: [],
  config: {},
  extra: {},
  version: 0.4
};
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.defaultGraph = window.comfyAPI.defaultGraph || {};
window.comfyAPI.defaultGraph.defaultGraph = defaultGraph;
function getFromPngBuffer(buffer2) {
  const pngData = new Uint8Array(buffer2);
  const dataView = new DataView(pngData.buffer);
  if (dataView.getUint32(0) !== 2303741511) {
    console.error("Not a valid PNG file");
    return;
  }
  let offset = 8;
  let txt_chunks = {};
  while (offset < pngData.length) {
    const length = dataView.getUint32(offset);
    const type = String.fromCharCode(...pngData.slice(offset + 4, offset + 8));
    if (type === "tEXt" || type == "comf" || type === "iTXt") {
      let keyword_end = offset + 8;
      while (pngData[keyword_end] !== 0) {
        keyword_end++;
      }
      const keyword = String.fromCharCode(
        ...pngData.slice(offset + 8, keyword_end)
      );
      const contentArraySegment = pngData.slice(
        keyword_end + 1,
        offset + 8 + length
      );
      const contentJson = new TextDecoder("utf-8").decode(contentArraySegment);
      txt_chunks[keyword] = contentJson;
    }
    offset += 12 + length;
  }
  return txt_chunks;
}
__name(getFromPngBuffer, "getFromPngBuffer");
function getFromPngFile(file) {
  return new Promise((r) => {
    const reader = new FileReader();
    reader.onload = (event2) => {
      r(getFromPngBuffer(event2.target.result));
    };
    reader.readAsArrayBuffer(file);
  });
}
__name(getFromPngFile, "getFromPngFile");
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.png = window.comfyAPI.png || {};
window.comfyAPI.png.getFromPngBuffer = getFromPngBuffer;
window.comfyAPI.png.getFromPngFile = getFromPngFile;
function getFromFlacBuffer(buffer2) {
  const dataView = new DataView(buffer2);
  const signature = String.fromCharCode(...new Uint8Array(buffer2, 0, 4));
  if (signature !== "fLaC") {
    console.error("Not a valid FLAC file");
    return;
  }
  let offset = 4;
  let vorbisComment = null;
  while (offset < dataView.byteLength) {
    const isLastBlock = dataView.getUint8(offset) & 128;
    const blockType = dataView.getUint8(offset) & 127;
    const blockSize = dataView.getUint32(offset, false) & 16777215;
    offset += 4;
    if (blockType === 4) {
      vorbisComment = parseVorbisComment(
        new DataView(buffer2, offset, blockSize)
      );
    }
    offset += blockSize;
    if (isLastBlock) break;
  }
  return vorbisComment;
}
__name(getFromFlacBuffer, "getFromFlacBuffer");
function getFromFlacFile(file) {
  return new Promise((r) => {
    const reader = new FileReader();
    reader.onload = function(event2) {
      const arrayBuffer = event2.target.result;
      r(getFromFlacBuffer(arrayBuffer));
    };
    reader.readAsArrayBuffer(file);
  });
}
__name(getFromFlacFile, "getFromFlacFile");
function parseVorbisComment(dataView) {
  let offset = 0;
  const vendorLength = dataView.getUint32(offset, true);
  offset += 4;
  const vendorString = getString(dataView, offset, vendorLength);
  offset += vendorLength;
  const userCommentListLength = dataView.getUint32(offset, true);
  offset += 4;
  const comments = {};
  for (let i2 = 0; i2 < userCommentListLength; i2++) {
    const commentLength = dataView.getUint32(offset, true);
    offset += 4;
    const comment = getString(dataView, offset, commentLength);
    offset += commentLength;
    const ind = comment.indexOf("=");
    const key = comment.substring(0, ind);
    comments[key] = comment.substring(ind + 1);
  }
  return comments;
}
__name(parseVorbisComment, "parseVorbisComment");
function getString(dataView, offset, length) {
  let string = "";
  for (let i2 = 0; i2 < length; i2++) {
    string += String.fromCharCode(dataView.getUint8(offset + i2));
  }
  return string;
}
__name(getString, "getString");
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.flac = window.comfyAPI.flac || {};
window.comfyAPI.flac.getFromFlacBuffer = getFromFlacBuffer;
window.comfyAPI.flac.getFromFlacFile = getFromFlacFile;
function getPngMetadata(file) {
  return getFromPngFile(file);
}
__name(getPngMetadata, "getPngMetadata");
function getFlacMetadata(file) {
  return getFromFlacFile(file);
}
__name(getFlacMetadata, "getFlacMetadata");
function parseExifData(exifData) {
  const isLittleEndian = String.fromCharCode(...exifData.slice(0, 2)) === "II";
  function readInt(offset, isLittleEndian2, length) {
    let arr = exifData.slice(offset, offset + length);
    if (length === 2) {
      return new DataView(arr.buffer, arr.byteOffset, arr.byteLength).getUint16(
        0,
        isLittleEndian2
      );
    } else if (length === 4) {
      return new DataView(arr.buffer, arr.byteOffset, arr.byteLength).getUint32(
        0,
        isLittleEndian2
      );
    }
  }
  __name(readInt, "readInt");
  const ifdOffset = readInt(4, isLittleEndian, 4);
  function parseIFD(offset) {
    const numEntries = readInt(offset, isLittleEndian, 2);
    const result = {};
    for (let i2 = 0; i2 < numEntries; i2++) {
      const entryOffset = offset + 2 + i2 * 12;
      const tag = readInt(entryOffset, isLittleEndian, 2);
      const type = readInt(entryOffset + 2, isLittleEndian, 2);
      const numValues = readInt(entryOffset + 4, isLittleEndian, 4);
      const valueOffset = readInt(entryOffset + 8, isLittleEndian, 4);
      let value3;
      if (type === 2) {
        value3 = String.fromCharCode(
          ...exifData.slice(valueOffset, valueOffset + numValues - 1)
        );
      }
      result[tag] = value3;
    }
    return result;
  }
  __name(parseIFD, "parseIFD");
  const ifdData = parseIFD(ifdOffset);
  return ifdData;
}
__name(parseExifData, "parseExifData");
function splitValues(input) {
  var output = {};
  for (var key in input) {
    var value3 = input[key];
    var splitValues2 = value3.split(":", 2);
    output[splitValues2[0]] = splitValues2[1];
  }
  return output;
}
__name(splitValues, "splitValues");
function getWebpMetadata(file) {
  return new Promise((r) => {
    const reader = new FileReader();
    reader.onload = (event2) => {
      const webp = new Uint8Array(event2.target.result);
      const dataView = new DataView(webp.buffer);
      if (dataView.getUint32(0) !== 1380533830 || dataView.getUint32(8) !== 1464156752) {
        console.error("Not a valid WEBP file");
        r({});
        return;
      }
      let offset = 12;
      let txt_chunks = {};
      while (offset < webp.length) {
        const chunk_length = dataView.getUint32(offset + 4, true);
        const chunk_type = String.fromCharCode(
          ...webp.slice(offset, offset + 4)
        );
        if (chunk_type === "EXIF") {
          if (String.fromCharCode(...webp.slice(offset + 8, offset + 8 + 6)) == "Exif\0\0") {
            offset += 6;
          }
          let data24 = parseExifData(
            webp.slice(offset + 8, offset + 8 + chunk_length)
          );
          for (var key in data24) {
            var value3 = data24[key];
            let index2 = value3.indexOf(":");
            txt_chunks[value3.slice(0, index2)] = value3.slice(index2 + 1);
          }
          break;
        }
        offset += 8 + chunk_length;
      }
      r(txt_chunks);
    };
    reader.readAsArrayBuffer(file);
  });
}
__name(getWebpMetadata, "getWebpMetadata");
function getLatentMetadata(file) {
  return new Promise((r) => {
    const reader = new FileReader();
    reader.onload = (event2) => {
      const safetensorsData = new Uint8Array(event2.target.result);
      const dataView = new DataView(safetensorsData.buffer);
      let header_size = dataView.getUint32(0, true);
      let offset = 8;
      let header = JSON.parse(
        new TextDecoder().decode(
          safetensorsData.slice(offset, offset + header_size)
        )
      );
      r(header.__metadata__);
    };
    var slice = file.slice(0, 1024 * 1024 * 4);
    reader.readAsArrayBuffer(slice);
  });
}
__name(getLatentMetadata, "getLatentMetadata");
async function importA1111(graph, parameters) {
  const p2 = parameters.lastIndexOf("\nSteps:");
  if (p2 > -1) {
    const embeddings = await api.getEmbeddings();
    const opts = parameters.substr(p2).split("\n")[1].match(
      new RegExp('\\s*([^:]+:\\s*([^"\\{].*?|".*?"|\\{.*?\\}))\\s*(,|$)', "g")
    ).reduce((p3, n) => {
      const s = n.split(":");
      if (s[1].endsWith(",")) {
        s[1] = s[1].substr(0, s[1].length - 1);
      }
      p3[s[0].trim().toLowerCase()] = s[1].trim();
      return p3;
    }, {});
    const p22 = parameters.lastIndexOf("\nNegative prompt:", p2);
    if (p22 > -1) {
      let positive = parameters.substr(0, p22).trim();
      let negative = parameters.substring(p22 + 18, p2).trim();
      const ckptNode = LiteGraph.createNode("CheckpointLoaderSimple");
      const clipSkipNode = LiteGraph.createNode("CLIPSetLastLayer");
      const positiveNode = LiteGraph.createNode("CLIPTextEncode");
      const negativeNode = LiteGraph.createNode("CLIPTextEncode");
      const samplerNode = LiteGraph.createNode("KSampler");
      const imageNode = LiteGraph.createNode("EmptyLatentImage");
      const vaeNode = LiteGraph.createNode("VAEDecode");
      const vaeLoaderNode = LiteGraph.createNode("VAELoader");
      const saveNode = LiteGraph.createNode("SaveImage");
      let hrSamplerNode = null;
      let hrSteps = null;
      const ceil64 = /* @__PURE__ */ __name((v2) => Math.ceil(v2 / 64) * 64, "ceil64");
      const getWidget = /* @__PURE__ */ __name((node3, name) => {
        return node3.widgets.find((w2) => w2.name === name);
      }, "getWidget");
      const setWidgetValue = /* @__PURE__ */ __name((node3, name, value3, isOptionPrefix) => {
        const w2 = getWidget(node3, name);
        if (isOptionPrefix) {
          const o = w2.options.values.find((w22) => w22.startsWith(value3));
          if (o) {
            w2.value = o;
          } else {
            console.warn(`Unknown value '${value3}' for widget '${name}'`, node3);
            w2.value = value3;
          }
        } else {
          w2.value = value3;
        }
      }, "setWidgetValue");
      const createLoraNodes = /* @__PURE__ */ __name((clipNode, text, prevClip, prevModel) => {
        const loras = [];
        text = text.replace(/<lora:([^:]+:[^>]+)>/g, function(m, c) {
          const s = c.split(":");
          const weight = parseFloat(s[1]);
          if (isNaN(weight)) {
            console.warn("Invalid LORA", m);
          } else {
            loras.push({ name: s[0], weight });
          }
          return "";
        });
        for (const l of loras) {
          const loraNode = LiteGraph.createNode("LoraLoader");
          graph.add(loraNode);
          setWidgetValue(loraNode, "lora_name", l.name, true);
          setWidgetValue(loraNode, "strength_model", l.weight);
          setWidgetValue(loraNode, "strength_clip", l.weight);
          prevModel.node.connect(prevModel.index, loraNode, 0);
          prevClip.node.connect(prevClip.index, loraNode, 1);
          prevModel = { node: loraNode, index: 0 };
          prevClip = { node: loraNode, index: 1 };
        }
        prevClip.node.connect(1, clipNode, 0);
        prevModel.node.connect(0, samplerNode, 0);
        if (hrSamplerNode) {
          prevModel.node.connect(0, hrSamplerNode, 0);
        }
        return { text, prevModel, prevClip };
      }, "createLoraNodes");
      const replaceEmbeddings = /* @__PURE__ */ __name((text) => {
        if (!embeddings.length) return text;
        return text.replaceAll(
          new RegExp(
            "\\b(" + embeddings.map((e) => e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")).join("\\b|\\b") + ")\\b",
            "ig"
          ),
          "embedding:$1"
        );
      }, "replaceEmbeddings");
      const popOpt = /* @__PURE__ */ __name((name) => {
        const v2 = opts[name];
        delete opts[name];
        return v2;
      }, "popOpt");
      graph.clear();
      graph.add(ckptNode);
      graph.add(clipSkipNode);
      graph.add(positiveNode);
      graph.add(negativeNode);
      graph.add(samplerNode);
      graph.add(imageNode);
      graph.add(vaeNode);
      graph.add(vaeLoaderNode);
      graph.add(saveNode);
      ckptNode.connect(1, clipSkipNode, 0);
      clipSkipNode.connect(0, positiveNode, 0);
      clipSkipNode.connect(0, negativeNode, 0);
      ckptNode.connect(0, samplerNode, 0);
      positiveNode.connect(0, samplerNode, 1);
      negativeNode.connect(0, samplerNode, 2);
      imageNode.connect(0, samplerNode, 3);
      vaeNode.connect(0, saveNode, 0);
      samplerNode.connect(0, vaeNode, 0);
      vaeLoaderNode.connect(0, vaeNode, 1);
      const handlers2 = {
        model(v2) {
          setWidgetValue(ckptNode, "ckpt_name", v2, true);
        },
        vae(v2) {
          setWidgetValue(vaeLoaderNode, "vae_name", v2, true);
        },
        "cfg scale"(v2) {
          setWidgetValue(samplerNode, "cfg", +v2);
        },
        "clip skip"(v2) {
          setWidgetValue(clipSkipNode, "stop_at_clip_layer", -v2);
        },
        sampler(v2) {
          let name = v2.toLowerCase().replace("++", "pp").replaceAll(" ", "_");
          if (name.includes("karras")) {
            name = name.replace("karras", "").replace(/_+$/, "");
            setWidgetValue(samplerNode, "scheduler", "karras");
          } else {
            setWidgetValue(samplerNode, "scheduler", "normal");
          }
          const w2 = getWidget(samplerNode, "sampler_name");
          const o = w2.options.values.find(
            (w22) => w22 === name || w22 === "sample_" + name
          );
          if (o) {
            setWidgetValue(samplerNode, "sampler_name", o);
          }
        },
        size(v2) {
          const wxh = v2.split("x");
          const w2 = ceil64(+wxh[0]);
          const h2 = ceil64(+wxh[1]);
          const hrUp = popOpt("hires upscale");
          const hrSz = popOpt("hires resize");
          hrSteps = popOpt("hires steps");
          let hrMethod = popOpt("hires upscaler");
          setWidgetValue(imageNode, "width", w2);
          setWidgetValue(imageNode, "height", h2);
          if (hrUp || hrSz) {
            let uw, uh;
            if (hrUp) {
              uw = w2 * hrUp;
              uh = h2 * hrUp;
            } else {
              const s = hrSz.split("x");
              uw = +s[0];
              uh = +s[1];
            }
            let upscaleNode;
            let latentNode;
            if (hrMethod.startsWith("Latent")) {
              latentNode = upscaleNode = LiteGraph.createNode("LatentUpscale");
              graph.add(upscaleNode);
              samplerNode.connect(0, upscaleNode, 0);
              switch (hrMethod) {
                case "Latent (nearest-exact)":
                  hrMethod = "nearest-exact";
                  break;
              }
              setWidgetValue(upscaleNode, "upscale_method", hrMethod, true);
            } else {
              const decode = LiteGraph.createNode("VAEDecodeTiled");
              graph.add(decode);
              samplerNode.connect(0, decode, 0);
              vaeLoaderNode.connect(0, decode, 1);
              const upscaleLoaderNode = LiteGraph.createNode("UpscaleModelLoader");
              graph.add(upscaleLoaderNode);
              setWidgetValue(upscaleLoaderNode, "model_name", hrMethod, true);
              const modelUpscaleNode = LiteGraph.createNode(
                "ImageUpscaleWithModel"
              );
              graph.add(modelUpscaleNode);
              decode.connect(0, modelUpscaleNode, 1);
              upscaleLoaderNode.connect(0, modelUpscaleNode, 0);
              upscaleNode = LiteGraph.createNode("ImageScale");
              graph.add(upscaleNode);
              modelUpscaleNode.connect(0, upscaleNode, 0);
              const vaeEncodeNode = latentNode = LiteGraph.createNode("VAEEncodeTiled");
              graph.add(vaeEncodeNode);
              upscaleNode.connect(0, vaeEncodeNode, 0);
              vaeLoaderNode.connect(0, vaeEncodeNode, 1);
            }
            setWidgetValue(upscaleNode, "width", ceil64(uw));
            setWidgetValue(upscaleNode, "height", ceil64(uh));
            hrSamplerNode = LiteGraph.createNode("KSampler");
            graph.add(hrSamplerNode);
            ckptNode.connect(0, hrSamplerNode, 0);
            positiveNode.connect(0, hrSamplerNode, 1);
            negativeNode.connect(0, hrSamplerNode, 2);
            latentNode.connect(0, hrSamplerNode, 3);
            hrSamplerNode.connect(0, vaeNode, 0);
          }
        },
        steps(v2) {
          setWidgetValue(samplerNode, "steps", +v2);
        },
        seed(v2) {
          setWidgetValue(samplerNode, "seed", +v2);
        }
      };
      for (const opt in opts) {
        if (opt in handlers2) {
          handlers2[opt](popOpt(opt));
        }
      }
      if (hrSamplerNode) {
        setWidgetValue(
          hrSamplerNode,
          "steps",
          hrSteps ? +hrSteps : getWidget(samplerNode, "steps").value
        );
        setWidgetValue(
          hrSamplerNode,
          "cfg",
          getWidget(samplerNode, "cfg").value
        );
        setWidgetValue(
          hrSamplerNode,
          "scheduler",
          getWidget(samplerNode, "scheduler").value
        );
        setWidgetValue(
          hrSamplerNode,
          "sampler_name",
          getWidget(samplerNode, "sampler_name").value
        );
        setWidgetValue(
          hrSamplerNode,
          "denoise",
          +(popOpt("denoising strength") || "1")
        );
      }
      let n = createLoraNodes(
        positiveNode,
        positive,
        { node: clipSkipNode, index: 0 },
        { node: ckptNode, index: 0 }
      );
      positive = n.text;
      n = createLoraNodes(negativeNode, negative, n.prevClip, n.prevModel);
      negative = n.text;
      setWidgetValue(positiveNode, "text", replaceEmbeddings(positive));
      setWidgetValue(negativeNode, "text", replaceEmbeddings(negative));
      graph.arrange();
      for (const opt of [
        "model hash",
        "ensd",
        "version",
        "vae hash",
        "ti hashes",
        "lora hashes",
        "hashes"
      ]) {
        delete opts[opt];
      }
      console.warn("Unhandled parameters:", opts);
    }
  }
}
__name(importA1111, "importA1111");
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.pnginfo = window.comfyAPI.pnginfo || {};
window.comfyAPI.pnginfo.getPngMetadata = getPngMetadata;
window.comfyAPI.pnginfo.getFlacMetadata = getFlacMetadata;
window.comfyAPI.pnginfo.getWebpMetadata = getWebpMetadata;
window.comfyAPI.pnginfo.getLatentMetadata = getLatentMetadata;
window.comfyAPI.pnginfo.importA1111 = importA1111;
function calculateImageGrid(imgs, dw, dh) {
  let best = 0;
  let w2 = imgs[0].naturalWidth;
  let h2 = imgs[0].naturalHeight;
  const numImages = imgs.length;
  let cellWidth, cellHeight, cols, rows, shiftX;
  for (let c = 1; c <= numImages; c++) {
    const r = Math.ceil(numImages / c);
    const cW = dw / c;
    const cH = dh / r;
    const scaleX = cW / w2;
    const scaleY = cH / h2;
    const scale = Math.min(scaleX, scaleY, 1);
    const imageW = w2 * scale;
    const imageH = h2 * scale;
    const area = imageW * imageH * numImages;
    if (area > best) {
      best = area;
      cellWidth = imageW;
      cellHeight = imageH;
      cols = c;
      rows = r;
      shiftX = c * ((cW - imageW) / 2);
    }
  }
  return { cellWidth, cellHeight, cols, rows, shiftX };
}
__name(calculateImageGrid, "calculateImageGrid");
function createImageHost(node3) {
  const el = $el("div.comfy-img-preview");
  let currentImgs;
  let first = true;
  function updateSize() {
    let w2 = null;
    let h2 = null;
    if (currentImgs) {
      let elH = el.clientHeight;
      if (first) {
        first = false;
        if (elH < 190) {
          elH = 190;
        }
        el.style.setProperty("--comfy-widget-min-height", elH.toString());
      } else {
        el.style.setProperty("--comfy-widget-min-height", null);
      }
      const nw = node3.size[0];
      ({ cellWidth: w2, cellHeight: h2 } = calculateImageGrid(
        currentImgs,
        nw - 20,
        elH
      ));
      w2 += "px";
      h2 += "px";
      el.style.setProperty("--comfy-img-preview-width", w2);
      el.style.setProperty("--comfy-img-preview-height", h2);
    }
  }
  __name(updateSize, "updateSize");
  return {
    el,
    updateImages(imgs) {
      if (imgs !== currentImgs) {
        if (currentImgs == null) {
          requestAnimationFrame(() => {
            updateSize();
          });
        }
        el.replaceChildren(...imgs);
        currentImgs = imgs;
        node3.onResize(node3.size);
        node3.graph.setDirtyCanvas(true, true);
      }
    },
    getHeight() {
      updateSize();
    },
    onDraw() {
      el.style.pointerEvents = "all";
      const over = document.elementFromPoint(
        app$1.canvas.mouse[0],
        app$1.canvas.mouse[1]
      );
      el.style.pointerEvents = "none";
      if (!over) return;
      const idx = currentImgs.indexOf(over);
      node3.overIndex = idx;
    }
  };
}
__name(createImageHost, "createImageHost");
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.imagePreview = window.comfyAPI.imagePreview || {};
window.comfyAPI.imagePreview.calculateImageGrid = calculateImageGrid;
window.comfyAPI.imagePreview.createImageHost = createImageHost;
$el("style", {
  parent: document.head,
  textContent: `
        .draggable-item {
            position: relative;
            will-change: transform;
            user-select: none;
        }
        .draggable-item.is-idle {
            transition: 0.25s ease transform;
        }
        .draggable-item.is-draggable {
            z-index: 10;
        }
    `
});
class DraggableList extends EventTarget {
  static {
    __name(this, "DraggableList");
  }
  listContainer;
  draggableItem;
  pointerStartX;
  pointerStartY;
  scrollYMax;
  itemsGap = 0;
  items = [];
  itemSelector;
  handleClass = "drag-handle";
  off = [];
  offDrag = [];
  constructor(element, itemSelector) {
    super();
    this.listContainer = element;
    this.itemSelector = itemSelector;
    if (!this.listContainer) return;
    this.off.push(this.on(this.listContainer, "mousedown", this.dragStart));
    this.off.push(this.on(this.listContainer, "touchstart", this.dragStart));
    this.off.push(this.on(document, "mouseup", this.dragEnd));
    this.off.push(this.on(document, "touchend", this.dragEnd));
  }
  getAllItems() {
    if (!this.items?.length) {
      this.items = Array.from(
        this.listContainer.querySelectorAll(this.itemSelector)
      );
      this.items.forEach((element) => {
        element.classList.add("is-idle");
      });
    }
    return this.items;
  }
  getIdleItems() {
    return this.getAllItems().filter(
      (item2) => item2.classList.contains("is-idle")
    );
  }
  isItemAbove(item2) {
    return item2.hasAttribute("data-is-above");
  }
  isItemToggled(item2) {
    return item2.hasAttribute("data-is-toggled");
  }
  on(source, event2, listener, options3) {
    listener = listener.bind(this);
    source.addEventListener(event2, listener, options3);
    return () => source.removeEventListener(event2, listener);
  }
  dragStart(e) {
    if (e.target.classList.contains(this.handleClass)) {
      this.draggableItem = e.target.closest(this.itemSelector);
    }
    if (!this.draggableItem) return;
    this.pointerStartX = e.clientX || e.touches[0].clientX;
    this.pointerStartY = e.clientY || e.touches[0].clientY;
    this.scrollYMax = this.listContainer.scrollHeight - this.listContainer.clientHeight;
    this.setItemsGap();
    this.initDraggableItem();
    this.initItemsState();
    this.offDrag.push(this.on(document, "mousemove", this.drag));
    this.offDrag.push(
      this.on(document, "touchmove", this.drag, { passive: false })
    );
    this.dispatchEvent(
      new CustomEvent("dragstart", {
        detail: {
          element: this.draggableItem,
          position: this.getAllItems().indexOf(this.draggableItem)
        }
      })
    );
  }
  setItemsGap() {
    if (this.getIdleItems().length <= 1) {
      this.itemsGap = 0;
      return;
    }
    const item1 = this.getIdleItems()[0];
    const item2 = this.getIdleItems()[1];
    const item1Rect = item1.getBoundingClientRect();
    const item2Rect = item2.getBoundingClientRect();
    this.itemsGap = Math.abs(item1Rect.bottom - item2Rect.top);
  }
  initItemsState() {
    this.getIdleItems().forEach((item2, i2) => {
      if (this.getAllItems().indexOf(this.draggableItem) > i2) {
        item2.dataset.isAbove = "";
      }
    });
  }
  initDraggableItem() {
    this.draggableItem.classList.remove("is-idle");
    this.draggableItem.classList.add("is-draggable");
  }
  drag(e) {
    if (!this.draggableItem) return;
    e.preventDefault();
    const clientX = e.clientX || e.touches[0].clientX;
    const clientY = e.clientY || e.touches[0].clientY;
    const listRect = this.listContainer.getBoundingClientRect();
    if (clientY > listRect.bottom) {
      if (this.listContainer.scrollTop < this.scrollYMax) {
        this.listContainer.scrollBy(0, 10);
        this.pointerStartY -= 10;
      }
    } else if (clientY < listRect.top && this.listContainer.scrollTop > 0) {
      this.pointerStartY += 10;
      this.listContainer.scrollBy(0, -10);
    }
    const pointerOffsetX = clientX - this.pointerStartX;
    const pointerOffsetY = clientY - this.pointerStartY;
    this.updateIdleItemsStateAndPosition();
    this.draggableItem.style.transform = `translate(${pointerOffsetX}px, ${pointerOffsetY}px)`;
  }
  updateIdleItemsStateAndPosition() {
    const draggableItemRect = this.draggableItem.getBoundingClientRect();
    const draggableItemY = draggableItemRect.top + draggableItemRect.height / 2;
    this.getIdleItems().forEach((item2) => {
      const itemRect = item2.getBoundingClientRect();
      const itemY = itemRect.top + itemRect.height / 2;
      if (this.isItemAbove(item2)) {
        if (draggableItemY <= itemY) {
          item2.dataset.isToggled = "";
        } else {
          delete item2.dataset.isToggled;
        }
      } else {
        if (draggableItemY >= itemY) {
          item2.dataset.isToggled = "";
        } else {
          delete item2.dataset.isToggled;
        }
      }
    });
    this.getIdleItems().forEach((item2) => {
      if (this.isItemToggled(item2)) {
        const direction = this.isItemAbove(item2) ? 1 : -1;
        item2.style.transform = `translateY(${direction * (draggableItemRect.height + this.itemsGap)}px)`;
      } else {
        item2.style.transform = "";
      }
    });
  }
  dragEnd() {
    if (!this.draggableItem) return;
    this.applyNewItemsOrder();
    this.cleanup();
  }
  applyNewItemsOrder() {
    const reorderedItems = [];
    let oldPosition = -1;
    this.getAllItems().forEach((item2, index2) => {
      if (item2 === this.draggableItem) {
        oldPosition = index2;
        return;
      }
      if (!this.isItemToggled(item2)) {
        reorderedItems[index2] = item2;
        return;
      }
      const newIndex = this.isItemAbove(item2) ? index2 + 1 : index2 - 1;
      reorderedItems[newIndex] = item2;
    });
    for (let index2 = 0; index2 < this.getAllItems().length; index2++) {
      const item2 = reorderedItems[index2];
      if (typeof item2 === "undefined") {
        reorderedItems[index2] = this.draggableItem;
      }
    }
    reorderedItems.forEach((item2) => {
      this.listContainer.appendChild(item2);
    });
    this.items = reorderedItems;
    this.dispatchEvent(
      new CustomEvent("dragend", {
        detail: {
          element: this.draggableItem,
          oldPosition,
          newPosition: reorderedItems.indexOf(this.draggableItem)
        }
      })
    );
  }
  cleanup() {
    this.itemsGap = 0;
    this.items = [];
    this.unsetDraggableItem();
    this.unsetItemState();
    this.offDrag.forEach((f) => f());
    this.offDrag = [];
  }
  unsetDraggableItem() {
    this.draggableItem.style = null;
    this.draggableItem.classList.remove("is-draggable");
    this.draggableItem.classList.add("is-idle");
    this.draggableItem = null;
  }
  unsetItemState() {
    this.getIdleItems().forEach((item2, i2) => {
      delete item2.dataset.isAbove;
      delete item2.dataset.isToggled;
      item2.style.transform = "";
    });
  }
  dispose() {
    this.off.forEach((f) => f());
  }
}
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.draggableList = window.comfyAPI.draggableList || {};
window.comfyAPI.draggableList.DraggableList = DraggableList;
const parts = {
  d: /* @__PURE__ */ __name((d) => d.getDate(), "d"),
  M: /* @__PURE__ */ __name((d) => d.getMonth() + 1, "M"),
  h: /* @__PURE__ */ __name((d) => d.getHours(), "h"),
  m: /* @__PURE__ */ __name((d) => d.getMinutes(), "m"),
  s: /* @__PURE__ */ __name((d) => d.getSeconds(), "s")
};
const format$4 = Object.keys(parts).map((k) => k + k + "?").join("|") + "|yyy?y?";
function formatDate(text, date) {
  return text.replace(new RegExp(format$4, "g"), (text2) => {
    if (text2 === "yy") return (date.getFullYear() + "").substring(2);
    if (text2 === "yyyy") return date.getFullYear().toString();
    if (text2[0] in parts) {
      const p2 = parts[text2[0]](date);
      return (p2 + "").padStart(text2.length, "0");
    }
    return text2;
  });
}
__name(formatDate, "formatDate");
function clone(obj) {
  try {
    if (typeof structuredClone !== "undefined") {
      return structuredClone(obj);
    }
  } catch (error) {
  }
  return JSON.parse(JSON.stringify(obj));
}
__name(clone, "clone");
function applyTextReplacements(app2, value3) {
  return value3.replace(/%([^%]+)%/g, function(match, text) {
    const split = text.split(".");
    if (split.length !== 2) {
      if (split[0].startsWith("date:")) {
        return formatDate(split[0].substring(5), /* @__PURE__ */ new Date());
      }
      if (text !== "width" && text !== "height") {
        console.warn("Invalid replacement pattern", text);
      }
      return match;
    }
    let nodes = app2.graph._nodes.filter(
      (n) => n.properties?.["Node name for S&R"] === split[0]
    );
    if (!nodes.length) {
      nodes = app2.graph._nodes.filter((n) => n.title === split[0]);
    }
    if (!nodes.length) {
      console.warn("Unable to find node", split[0]);
      return match;
    }
    if (nodes.length > 1) {
      console.warn("Multiple nodes matched", split[0], "using first match");
    }
    const node3 = nodes[0];
    const widget = node3.widgets?.find((w2) => w2.name === split[1]);
    if (!widget) {
      console.warn("Unable to find widget", split[1], "on node", split[0], node3);
      return match;
    }
    return ((widget.value ?? "") + "").replaceAll(/\/|\\/g, "_");
  });
}
__name(applyTextReplacements, "applyTextReplacements");
async function addStylesheet(urlOrFile, relativeTo) {
  return new Promise((res, rej) => {
    let url;
    if (urlOrFile.endsWith(".js")) {
      url = urlOrFile.substr(0, urlOrFile.length - 2) + "css";
    } else {
      url = new URL(
        urlOrFile,
        relativeTo ?? `${window.location.protocol}//${window.location.host}`
      ).toString();
    }
    $el("link", {
      parent: document.head,
      rel: "stylesheet",
      type: "text/css",
      href: url,
      onload: res,
      onerror: rej
    });
  });
}
__name(addStylesheet, "addStylesheet");
function downloadBlob(filename, blob) {
  const url = URL.createObjectURL(blob);
  const a = $el("a", {
    href: url,
    download: filename,
    style: { display: "none" },
    parent: document.body
  });
  a.click();
  setTimeout(function() {
    a.remove();
    window.URL.revokeObjectURL(url);
  }, 0);
}
__name(downloadBlob, "downloadBlob");
function prop(target, name, defaultValue, onChanged) {
  let currentValue;
  Object.defineProperty(target, name, {
    get() {
      return currentValue;
    },
    set(newValue) {
      const prevValue = currentValue;
      currentValue = newValue;
      onChanged?.(currentValue, prevValue, target, name);
    }
  });
  return defaultValue;
}
__name(prop, "prop");
function getStorageValue(id2) {
  const clientId = api.clientId ?? api.initialClientId;
  return (clientId && sessionStorage.getItem(`${id2}:${clientId}`)) ?? localStorage.getItem(id2);
}
__name(getStorageValue, "getStorageValue");
function setStorageValue(id2, value3) {
  const clientId = api.clientId ?? api.initialClientId;
  if (clientId) {
    sessionStorage.setItem(`${id2}:${clientId}`, value3);
  }
  localStorage.setItem(id2, value3);
}
__name(setStorageValue, "setStorageValue");
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.utils = window.comfyAPI.utils || {};
window.comfyAPI.utils.clone = clone;
window.comfyAPI.utils.applyTextReplacements = applyTextReplacements;
window.comfyAPI.utils.addStylesheet = addStylesheet;
window.comfyAPI.utils.downloadBlob = downloadBlob;
window.comfyAPI.utils.prop = prop;
window.comfyAPI.utils.getStorageValue = getStorageValue;
window.comfyAPI.utils.setStorageValue = setStorageValue;
function rgbToHsl({ r, g, b }) {
  r /= 255;
  g /= 255;
  b /= 255;
  const max = Math.max(r, g, b), min = Math.min(r, g, b);
  let h2, s;
  const l = (max + min) / 2;
  if (max === min) {
    h2 = s = 0;
  } else {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r:
        h2 = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h2 = (b - r) / d + 2;
        break;
      case b:
        h2 = (r - g) / d + 4;
        break;
    }
    h2 /= 6;
  }
  return { h: h2, s, l };
}
__name(rgbToHsl, "rgbToHsl");
function hslToRgb({ h: h2, s, l }) {
  let r, g, b;
  if (s === 0) {
    r = g = b = l;
  } else {
    const hue2rgb = /* @__PURE__ */ __name((p22, q2, t) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1 / 6) return p22 + (q2 - p22) * 6 * t;
      if (t < 1 / 2) return q2;
      if (t < 2 / 3) return p22 + (q2 - p22) * (2 / 3 - t) * 6;
      return p22;
    }, "hue2rgb");
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p2 = 2 * l - q;
    r = hue2rgb(p2, q, h2 + 1 / 3);
    g = hue2rgb(p2, q, h2);
    b = hue2rgb(p2, q, h2 - 1 / 3);
  }
  return {
    r: Math.round(r * 255),
    g: Math.round(g * 255),
    b: Math.round(b * 255)
  };
}
__name(hslToRgb, "hslToRgb");
function hexToRgb(hex) {
  let r = 0, g = 0, b = 0;
  if (hex.length == 4) {
    r = parseInt(hex[1] + hex[1], 16);
    g = parseInt(hex[2] + hex[2], 16);
    b = parseInt(hex[3] + hex[3], 16);
  } else if (hex.length == 7) {
    r = parseInt(hex.slice(1, 3), 16);
    g = parseInt(hex.slice(3, 5), 16);
    b = parseInt(hex.slice(5, 7), 16);
  }
  return { r, g, b };
}
__name(hexToRgb, "hexToRgb");
function rgbToHex({ r, g, b }) {
  return "#" + [r, g, b].map((x2) => {
    const hex = x2.toString(16);
    return hex.length === 1 ? "0" + hex : hex;
  }).join("");
}
__name(rgbToHex, "rgbToHex");
function lightenColor(hex, amount) {
  let rgb = hexToRgb(hex);
  const hsl = rgbToHsl(rgb);
  hsl.l = Math.min(1, hsl.l + amount);
  rgb = hslToRgb(hsl);
  return rgbToHex(rgb);
}
__name(lightenColor, "lightenColor");
function applyClasses(element, classList, ...requiredClasses) {
  classList ??= "";
  let str;
  if (typeof classList === "string") {
    str = classList;
  } else if (classList instanceof Array) {
    str = classList.join(" ");
  } else {
    str = Object.entries(classList).reduce((p2, c) => {
      if (c[1]) {
        p2 += (p2.length ? " " : "") + c[0];
      }
      return p2;
    }, "");
  }
  element.className = str;
  if (requiredClasses) {
    element.classList.add(...requiredClasses);
  }
}
__name(applyClasses, "applyClasses");
function toggleElement(element, {
  onHide: onHide2,
  onShow
} = {}) {
  let placeholder;
  let hidden;
  return (value3) => {
    if (value3) {
      if (hidden) {
        hidden = false;
        placeholder.replaceWith(element);
      }
      onShow?.(element, value3);
    } else {
      if (!placeholder) {
        placeholder = document.createComment("");
      }
      hidden = true;
      element.replaceWith(placeholder);
      onHide2?.(element);
    }
  };
}
__name(toggleElement, "toggleElement");
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.utils = window.comfyAPI.utils || {};
window.comfyAPI.utils.applyClasses = applyClasses;
window.comfyAPI.utils.toggleElement = toggleElement;
class ComfyButton {
  static {
    __name(this, "ComfyButton");
  }
  #over = 0;
  #popupOpen = false;
  isOver = false;
  iconElement = $el("i.mdi");
  contentElement = $el("span");
  popup;
  element;
  overIcon;
  iconSize;
  content;
  icon;
  tooltip;
  classList;
  hidden;
  enabled;
  action;
  constructor({
    icon: icon2,
    overIcon,
    iconSize,
    content,
    tooltip,
    action,
    classList = "comfyui-button",
    visibilitySetting,
    app: app2,
    enabled = true
  }) {
    this.element = $el(
      "button",
      {
        onmouseenter: /* @__PURE__ */ __name(() => {
          this.isOver = true;
          if (this.overIcon) {
            this.updateIcon();
          }
        }, "onmouseenter"),
        onmouseleave: /* @__PURE__ */ __name(() => {
          this.isOver = false;
          if (this.overIcon) {
            this.updateIcon();
          }
        }, "onmouseleave")
      },
      [this.iconElement, this.contentElement]
    );
    this.icon = prop(
      this,
      "icon",
      icon2,
      toggleElement(this.iconElement, { onShow: this.updateIcon })
    );
    this.overIcon = prop(this, "overIcon", overIcon, () => {
      if (this.isOver) {
        this.updateIcon();
      }
    });
    this.iconSize = prop(this, "iconSize", iconSize, this.updateIcon);
    this.content = prop(
      this,
      "content",
      content,
      toggleElement(this.contentElement, {
        onShow: /* @__PURE__ */ __name((el, v2) => {
          if (typeof v2 === "string") {
            el.textContent = v2;
          } else {
            el.replaceChildren(v2);
          }
        }, "onShow")
      })
    );
    this.tooltip = prop(this, "tooltip", tooltip, (v2) => {
      if (v2) {
        this.element.title = v2;
      } else {
        this.element.removeAttribute("title");
      }
    });
    this.classList = prop(this, "classList", classList, this.updateClasses);
    this.hidden = prop(this, "hidden", false, this.updateClasses);
    this.enabled = prop(this, "enabled", enabled, () => {
      this.updateClasses();
      this.element.disabled = !this.enabled;
    });
    this.action = prop(this, "action", action);
    this.element.addEventListener("click", (e) => {
      if (this.popup) {
        if (!this.#over) {
          this.popup.toggle();
        }
      }
      this.action?.(e, this);
    });
    if (visibilitySetting?.id) {
      const settingUpdated = /* @__PURE__ */ __name(() => {
        this.hidden = app2.ui.settings.getSettingValue(visibilitySetting.id) !== visibilitySetting.showValue;
      }, "settingUpdated");
      app2.ui.settings.addEventListener(
        visibilitySetting.id + ".change",
        settingUpdated
      );
      settingUpdated();
    }
  }
  updateIcon = /* @__PURE__ */ __name(() => this.iconElement.className = `mdi mdi-${this.isOver && this.overIcon || this.icon}${this.iconSize ? " mdi-" + this.iconSize + "px" : ""}`, "updateIcon");
  updateClasses = /* @__PURE__ */ __name(() => {
    const internalClasses = [];
    if (this.hidden) {
      internalClasses.push("hidden");
    }
    if (!this.enabled) {
      internalClasses.push("disabled");
    }
    if (this.popup) {
      if (this.#popupOpen) {
        internalClasses.push("popup-open");
      } else {
        internalClasses.push("popup-closed");
      }
    }
    applyClasses(this.element, this.classList, ...internalClasses);
  }, "updateClasses");
  withPopup(popup, mode2 = "click") {
    this.popup = popup;
    if (mode2 === "hover") {
      for (const el of [this.element, this.popup.element]) {
        el.addEventListener("mouseenter", () => {
          this.popup.open = !!++this.#over;
        });
        el.addEventListener("mouseleave", () => {
          this.popup.open = !!--this.#over;
        });
      }
    }
    popup.addEventListener("change", () => {
      this.#popupOpen = popup.open;
      this.updateClasses();
    });
    return this;
  }
}
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.button = window.comfyAPI.button || {};
window.comfyAPI.button.ComfyButton = ComfyButton;
class ComfyButtonGroup {
  static {
    __name(this, "ComfyButtonGroup");
  }
  element = $el("div.comfyui-button-group");
  buttons;
  constructor(...buttons) {
    this.buttons = prop(this, "buttons", buttons, () => this.update());
  }
  insert(button, index2) {
    this.buttons.splice(index2, 0, button);
    this.update();
  }
  append(button) {
    this.buttons.push(button);
    this.update();
  }
  remove(indexOrButton) {
    if (typeof indexOrButton !== "number") {
      indexOrButton = this.buttons.indexOf(indexOrButton);
    }
    if (indexOrButton > -1) {
      const r = this.buttons.splice(indexOrButton, 1);
      this.update();
      return r;
    }
  }
  update() {
    this.element.replaceChildren(...this.buttons.map((b) => b["element"] ?? b));
  }
}
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.buttonGroup = window.comfyAPI.buttonGroup || {};
window.comfyAPI.buttonGroup.ComfyButtonGroup = ComfyButtonGroup;
class ComfyPopup extends EventTarget {
  static {
    __name(this, "ComfyPopup");
  }
  element = $el("div.comfyui-popup");
  open;
  children;
  target;
  ignoreTarget;
  container;
  position;
  closeOnEscape;
  horizontal;
  classList;
  constructor({
    target,
    container = document.body,
    classList = "",
    ignoreTarget = true,
    closeOnEscape = true,
    position: position2 = "absolute",
    horizontal: horizontal3 = "left"
  }, ...children) {
    super();
    this.target = target;
    this.ignoreTarget = ignoreTarget;
    this.container = container;
    this.position = position2;
    this.closeOnEscape = closeOnEscape;
    this.horizontal = horizontal3;
    container.append(this.element);
    this.children = prop(this, "children", children, () => {
      this.element.replaceChildren(...this.children);
      this.update();
    });
    this.classList = prop(
      this,
      "classList",
      classList,
      () => applyClasses(this.element, this.classList, "comfyui-popup", horizontal3)
    );
    this.open = prop(this, "open", false, (v2, o) => {
      if (v2 === o) return;
      if (v2) {
        this.#show();
      } else {
        this.#hide();
      }
    });
  }
  toggle() {
    this.open = !this.open;
  }
  #hide() {
    this.element.classList.remove("open");
    window.removeEventListener("resize", this.update);
    window.removeEventListener("click", this.#clickHandler, { capture: true });
    window.removeEventListener("keydown", this.#escHandler, { capture: true });
    this.dispatchEvent(new CustomEvent("close"));
    this.dispatchEvent(new CustomEvent("change"));
  }
  #show() {
    this.element.classList.add("open");
    this.update();
    window.addEventListener("resize", this.update);
    window.addEventListener("click", this.#clickHandler, { capture: true });
    if (this.closeOnEscape) {
      window.addEventListener("keydown", this.#escHandler, { capture: true });
    }
    this.dispatchEvent(new CustomEvent("open"));
    this.dispatchEvent(new CustomEvent("change"));
  }
  #escHandler = /* @__PURE__ */ __name((e) => {
    if (e.key === "Escape") {
      this.open = false;
      e.preventDefault();
      e.stopImmediatePropagation();
    }
  }, "#escHandler");
  #clickHandler = /* @__PURE__ */ __name((e) => {
    const target = e.target;
    if (!this.element.contains(target) && this.ignoreTarget && !this.target.contains(target)) {
      this.open = false;
    }
  }, "#clickHandler");
  update = /* @__PURE__ */ __name(() => {
    const rect = this.target.getBoundingClientRect();
    this.element.style.setProperty("--bottom", "unset");
    if (this.position === "absolute") {
      if (this.horizontal === "left") {
        this.element.style.setProperty("--left", rect.left + "px");
      } else {
        this.element.style.setProperty(
          "--left",
          rect.right - this.element.clientWidth + "px"
        );
      }
      this.element.style.setProperty("--top", rect.bottom + "px");
      this.element.style.setProperty("--limit", rect.bottom + "px");
    } else {
      this.element.style.setProperty("--left", "0px");
      this.element.style.setProperty("--top", rect.height + "px");
      this.element.style.setProperty("--limit", rect.height + "px");
    }
    const thisRect = this.element.getBoundingClientRect();
    if (thisRect.height < 30) {
      this.element.style.setProperty("--top", "unset");
      this.element.style.setProperty("--bottom", rect.height + 5 + "px");
      this.element.style.setProperty("--limit", rect.height + 5 + "px");
    }
  }, "update");
}
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.popup = window.comfyAPI.popup || {};
window.comfyAPI.popup.ComfyPopup = ComfyPopup;
class ComfySplitButton {
  static {
    __name(this, "ComfySplitButton");
  }
  arrow;
  element;
  popup;
  items;
  constructor({
    primary,
    mode: mode2,
    horizontal: horizontal3 = "left",
    position: position2 = "relative"
  }, ...items2) {
    this.arrow = new ComfyButton({
      icon: "chevron-down"
    });
    this.element = $el(
      "div.comfyui-split-button" + (mode2 === "hover" ? ".hover" : ""),
      [
        $el("div.comfyui-split-primary", primary.element),
        $el("div.comfyui-split-arrow", this.arrow.element)
      ]
    );
    this.popup = new ComfyPopup({
      target: this.element,
      container: position2 === "relative" ? this.element : document.body,
      classList: "comfyui-split-button-popup" + (mode2 === "hover" ? " hover" : ""),
      closeOnEscape: mode2 === "click",
      position: position2,
      horizontal: horizontal3
    });
    this.arrow.withPopup(this.popup, mode2);
    this.items = prop(this, "items", items2, () => this.update());
  }
  update() {
    this.popup.element.replaceChildren(
      ...this.items.map((b) => "element" in b ? b.element : b)
    );
  }
}
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.splitButton = window.comfyAPI.splitButton || {};
window.comfyAPI.splitButton.ComfySplitButton = ComfySplitButton;
class ComfyQueueOptions extends EventTarget {
  static {
    __name(this, "ComfyQueueOptions");
  }
  element = $el("div.comfyui-queue-options");
  app;
  batchCountInput;
  batchCount;
  batchCountRange;
  autoQueueMode;
  autoQueueEl;
  constructor(app2) {
    super();
    this.app = app2;
    this.batchCountInput = $el("input", {
      className: "comfyui-queue-batch-value",
      type: "number",
      min: "1",
      value: "1",
      oninput: /* @__PURE__ */ __name(() => this.batchCount = +this.batchCountInput.value, "oninput")
    });
    this.batchCountRange = $el("input", {
      type: "range",
      min: "1",
      max: "100",
      value: "1",
      oninput: /* @__PURE__ */ __name(() => this.batchCount = +this.batchCountRange.value, "oninput")
    });
    this.element.append(
      $el("div.comfyui-queue-batch", [
        $el(
          "label",
          {
            textContent: "Batch count: "
          },
          this.batchCountInput
        ),
        this.batchCountRange
      ])
    );
    const createOption = /* @__PURE__ */ __name((text, value3, checked4 = false) => $el(
      "label",
      { textContent: text },
      $el("input", {
        type: "radio",
        name: "AutoQueueMode",
        checked: checked4,
        value: value3,
        oninput: /* @__PURE__ */ __name((e) => this.autoQueueMode = e.target["value"], "oninput")
      })
    ), "createOption");
    this.autoQueueEl = $el("div.comfyui-queue-mode", [
      $el("span", "Auto Queue:"),
      createOption("Disabled", "", true),
      createOption("Instant", "instant"),
      createOption("On Change", "change")
    ]);
    this.element.append(this.autoQueueEl);
    this.batchCount = prop(this, "batchCount", 1, () => {
      this.batchCountInput.value = this.batchCount + "";
      this.batchCountRange.value = this.batchCount + "";
    });
    this.autoQueueMode = prop(this, "autoQueueMode", "Disabled", () => {
      this.dispatchEvent(
        new CustomEvent("autoQueueMode", {
          detail: this.autoQueueMode
        })
      );
    });
  }
}
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.queueOptions = window.comfyAPI.queueOptions || {};
window.comfyAPI.queueOptions.ComfyQueueOptions = ComfyQueueOptions;
class ComfyQueueButton {
  static {
    __name(this, "ComfyQueueButton");
  }
  element = $el("div.comfyui-queue-button");
  #internalQueueSize = 0;
  queuePrompt = /* @__PURE__ */ __name(async (e) => {
    this.#internalQueueSize += this.queueOptions.batchCount;
    await this.app.queuePrompt(
      e?.shiftKey ? -1 : 0,
      this.queueOptions.batchCount
    );
  }, "queuePrompt");
  queueOptions;
  app;
  autoQueueMode;
  graphHasChanged;
  constructor(app2) {
    this.app = app2;
    const queue2 = new ComfyButton({
      content: $el("div", [
        $el("span", {
          textContent: "Queue"
        })
      ]),
      icon: "play",
      classList: "comfyui-button",
      action: this.queuePrompt
    });
    this.queueOptions = new ComfyQueueOptions(app2);
    const btn = new ComfySplitButton(
      {
        primary: queue2,
        mode: "click",
        position: "absolute",
        horizontal: "right"
      },
      this.queueOptions.element
    );
    btn.element.classList.add("primary");
    this.element.append(btn.element);
    this.autoQueueMode = prop(this, "autoQueueMode", "", () => {
      switch (this.autoQueueMode) {
        case "instant":
          queue2.icon = "infinity";
          break;
        case "change":
          queue2.icon = "auto-mode";
          break;
        default:
          queue2.icon = "play";
          break;
      }
    });
    this.queueOptions.addEventListener(
      "autoQueueMode",
      (e) => this.autoQueueMode = e["detail"]
    );
    api.addEventListener("graphChanged", () => {
      if (this.autoQueueMode === "change") {
        if (this.#internalQueueSize) {
          this.graphHasChanged = true;
        } else {
          this.graphHasChanged = false;
          this.queuePrompt();
        }
      }
    });
    api.addEventListener(
      "status",
      ({ detail }) => {
        this.#internalQueueSize = detail?.exec_info?.queue_remaining;
        if (this.#internalQueueSize != null) {
          if (!this.#internalQueueSize && !app2.lastExecutionError) {
            if (this.autoQueueMode === "instant" || this.autoQueueMode === "change" && this.graphHasChanged) {
              this.graphHasChanged = false;
              this.queuePrompt();
            }
          }
        }
      }
    );
  }
}
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.queueButton = window.comfyAPI.queueButton || {};
window.comfyAPI.queueButton.ComfyQueueButton = ComfyQueueButton;
function createSpinner() {
  const div = document.createElement("div");
  div.innerHTML = `<div class="lds-ring"><div></div><div></div><div></div><div></div></div>`;
  return div.firstElementChild;
}
__name(createSpinner, "createSpinner");
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.spinner = window.comfyAPI.spinner || {};
window.comfyAPI.spinner.createSpinner = createSpinner;
class ChangeTracker {
  static {
    __name(this, "ChangeTracker");
  }
  static MAX_HISTORY = 50;
  #app;
  undo = [];
  redo = [];
  activeState = null;
  isOurLoad = false;
  workflow;
  ds;
  nodeOutputs;
  get app() {
    return this.#app ?? this.workflow.manager.app;
  }
  constructor(workflow) {
    this.workflow = workflow;
  }
  #setApp(app2) {
    this.#app = app2;
  }
  store() {
    this.ds = {
      scale: this.app.canvas.ds.scale,
      offset: [...this.app.canvas.ds.offset]
    };
  }
  restore() {
    if (this.ds) {
      this.app.canvas.ds.scale = this.ds.scale;
      this.app.canvas.ds.offset = this.ds.offset;
    }
    if (this.nodeOutputs) {
      this.app.nodeOutputs = this.nodeOutputs;
    }
  }
  checkState() {
    if (!this.app.graph) return;
    const currentState = this.app.graph.serialize();
    if (!this.activeState) {
      this.activeState = clone(currentState);
      return;
    }
    if (!ChangeTracker.graphEqual(this.activeState, currentState)) {
      this.undo.push(this.activeState);
      if (this.undo.length > ChangeTracker.MAX_HISTORY) {
        this.undo.shift();
      }
      this.activeState = clone(currentState);
      this.redo.length = 0;
      this.workflow.unsaved = true;
      api.dispatchEvent(
        new CustomEvent("graphChanged", { detail: this.activeState })
      );
    }
  }
  async updateState(source, target) {
    const prevState = source.pop();
    if (prevState) {
      target.push(this.activeState);
      this.isOurLoad = true;
      await this.app.loadGraphData(prevState, false, false, this.workflow, {
        showMissingModelsDialog: false,
        showMissingNodesDialog: false
      });
      this.activeState = prevState;
    }
  }
  async undoRedo(e) {
    if (e.ctrlKey || e.metaKey) {
      if (e.key === "y") {
        this.updateState(this.redo, this.undo);
        return true;
      } else if (e.key === "z") {
        this.updateState(this.undo, this.redo);
        return true;
      }
    }
  }
  static init(app2) {
    const changeTracker = /* @__PURE__ */ __name(() => app2.workflowManager.activeWorkflow?.changeTracker ?? globalTracker, "changeTracker");
    globalTracker.#setApp(app2);
    const loadGraphData = app2.loadGraphData;
    app2.loadGraphData = async function() {
      const v2 = await loadGraphData.apply(this, arguments);
      const ct = changeTracker();
      if (ct.isOurLoad) {
        ct.isOurLoad = false;
      } else {
        ct.checkState();
      }
      return v2;
    };
    let keyIgnored = false;
    window.addEventListener(
      "keydown",
      (e) => {
        const activeEl = document.activeElement;
        requestAnimationFrame(async () => {
          let bindInputEl;
          if (!app2.ui.autoQueueEnabled || app2.ui.autoQueueMode === "instant") {
            if (activeEl?.tagName === "INPUT" || activeEl?.["type"] === "textarea") {
              return;
            }
            bindInputEl = activeEl;
          }
          keyIgnored = e.key === "Control" || e.key === "Shift" || e.key === "Alt" || e.key === "Meta";
          if (keyIgnored) return;
          if (await changeTracker().undoRedo(e)) return;
          if (ChangeTracker.bindInput(app2, bindInputEl)) return;
          changeTracker().checkState();
        });
      },
      true
    );
    window.addEventListener("keyup", (e) => {
      if (keyIgnored) {
        keyIgnored = false;
        changeTracker().checkState();
      }
    });
    window.addEventListener("mouseup", () => {
      changeTracker().checkState();
    });
    api.addEventListener("promptQueued", () => {
      changeTracker().checkState();
    });
    api.addEventListener("graphCleared", () => {
      changeTracker().checkState();
    });
    const processMouseUp = LGraphCanvas.prototype.processMouseUp;
    LGraphCanvas.prototype.processMouseUp = function(e) {
      const v2 = processMouseUp.apply(this, arguments);
      changeTracker().checkState();
      return v2;
    };
    const processMouseDown = LGraphCanvas.prototype.processMouseDown;
    LGraphCanvas.prototype.processMouseDown = function(e) {
      const v2 = processMouseDown.apply(this, arguments);
      changeTracker().checkState();
      return v2;
    };
    const close4 = LiteGraph.ContextMenu.prototype.close;
    LiteGraph.ContextMenu.prototype.close = function(e) {
      const v2 = close4.apply(this, arguments);
      changeTracker().checkState();
      return v2;
    };
    const onNodeAdded = LiteGraph.LGraph.prototype.onNodeAdded;
    LiteGraph.LGraph.prototype.onNodeAdded = function() {
      const v2 = onNodeAdded?.apply(this, arguments);
      if (!app2?.configuringGraph) {
        const ct = changeTracker();
        if (!ct.isOurLoad) {
          ct.checkState();
        }
      }
      return v2;
    };
    api.addEventListener("executed", ({ detail }) => {
      const prompt2 = app2.workflowManager.queuedPrompts[detail.prompt_id];
      if (!prompt2?.workflow) return;
      const nodeOutputs = prompt2.workflow.changeTracker.nodeOutputs ??= {};
      const output = nodeOutputs[detail.node];
      if (detail.merge && output) {
        for (const k in detail.output ?? {}) {
          const v2 = output[k];
          if (v2 instanceof Array) {
            output[k] = v2.concat(detail.output[k]);
          } else {
            output[k] = detail.output[k];
          }
        }
      } else {
        nodeOutputs[detail.node] = detail.output;
      }
    });
  }
  static bindInput(app2, activeEl) {
    if (activeEl && activeEl.tagName !== "CANVAS" && activeEl.tagName !== "BODY") {
      for (const evt of ["change", "input", "blur"]) {
        if (`on${evt}` in activeEl) {
          const listener = /* @__PURE__ */ __name(() => {
            app2.workflowManager.activeWorkflow.changeTracker.checkState();
            activeEl.removeEventListener(evt, listener);
          }, "listener");
          activeEl.addEventListener(evt, listener);
          return true;
        }
      }
    }
  }
  static graphEqual(a, b, path = "") {
    if (a === b) return true;
    if (typeof a == "object" && a && typeof b == "object" && b) {
      const keys2 = Object.getOwnPropertyNames(a);
      if (keys2.length != Object.getOwnPropertyNames(b).length) {
        return false;
      }
      for (const key of keys2) {
        let av = a[key];
        let bv = b[key];
        if (!path && key === "nodes") {
          av = [...av].sort((a2, b2) => a2.id - b2.id);
          bv = [...bv].sort((a2, b2) => a2.id - b2.id);
        } else if (path === "extra.ds") {
          continue;
        }
        if (!ChangeTracker.graphEqual(av, bv, path + (path ? "." : "") + key)) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
}
const globalTracker = new ChangeTracker({});
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.changeTracker = window.comfyAPI.changeTracker || {};
window.comfyAPI.changeTracker.ChangeTracker = ChangeTracker;
class ComfyAsyncDialog extends ComfyDialog$1 {
  static {
    __name(this, "ComfyAsyncDialog");
  }
  #resolve;
  constructor(actions) {
    super(
      "dialog.comfy-dialog.comfyui-dialog",
      actions?.map((opt) => {
        if (typeof opt === "string") {
          opt = { text: opt };
        }
        return $el("button.comfyui-button", {
          type: "button",
          textContent: opt.text,
          onclick: /* @__PURE__ */ __name(() => this.close(opt.value ?? opt.text), "onclick")
        });
      })
    );
  }
  show(html) {
    this.element.addEventListener("close", () => {
      this.close();
    });
    super.show(html);
    return new Promise((resolve8) => {
      this.#resolve = resolve8;
    });
  }
  showModal(html) {
    this.element.addEventListener("close", () => {
      this.close();
    });
    super.show(html);
    this.element.showModal();
    return new Promise((resolve8) => {
      this.#resolve = resolve8;
    });
  }
  close(result = null) {
    this.#resolve(result);
    this.element.close();
    super.close();
  }
  static async prompt({ title = null, message: message3, actions }) {
    const dialog = new ComfyAsyncDialog(actions);
    const content = [$el("span", message3)];
    if (title) {
      content.unshift($el("h3", title));
    }
    const res = await dialog.showModal(content);
    dialog.element.remove();
    return res;
  }
}
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.asyncDialog = window.comfyAPI.asyncDialog || {};
window.comfyAPI.asyncDialog.ComfyAsyncDialog = ComfyAsyncDialog;
function appendJsonExt(path) {
  if (!path.toLowerCase().endsWith(".json")) {
    path += ".json";
  }
  return path;
}
__name(appendJsonExt, "appendJsonExt");
function trimJsonExt(path) {
  return path?.replace(/\.json$/, "");
}
__name(trimJsonExt, "trimJsonExt");
class ComfyWorkflowManager extends EventTarget {
  static {
    __name(this, "ComfyWorkflowManager");
  }
  #activePromptId = null;
  #unsavedCount = 0;
  #activeWorkflow;
  workflowLookup = {};
  workflows = [];
  openWorkflows = [];
  queuedPrompts = {};
  app;
  get activeWorkflow() {
    return this.#activeWorkflow ?? this.openWorkflows[0];
  }
  get activePromptId() {
    return this.#activePromptId;
  }
  get activePrompt() {
    return this.queuedPrompts[this.#activePromptId];
  }
  constructor(app2) {
    super();
    this.app = app2;
    ChangeTracker.init(app2);
    this.#bindExecutionEvents();
  }
  #bindExecutionEvents() {
    const emit2 = /* @__PURE__ */ __name(() => this.dispatchEvent(
      new CustomEvent("execute", { detail: this.activePrompt })
    ), "emit");
    let executing = null;
    api.addEventListener("execution_start", (e) => {
      this.#activePromptId = e.detail.prompt_id;
      this.queuedPrompts[this.#activePromptId] ??= { nodes: {} };
      emit2();
    });
    api.addEventListener("execution_cached", (e) => {
      if (!this.activePrompt) return;
      for (const n of e.detail.nodes) {
        this.activePrompt.nodes[n] = true;
      }
      emit2();
    });
    api.addEventListener("executed", (e) => {
      if (!this.activePrompt) return;
      this.activePrompt.nodes[e.detail.node] = true;
      emit2();
    });
    api.addEventListener("executing", (e) => {
      if (!this.activePrompt) return;
      if (executing) {
        this.activePrompt.nodes[executing] = true;
      }
      executing = e.detail;
      if (!executing) {
        delete this.queuedPrompts[this.#activePromptId];
        this.#activePromptId = null;
      }
      emit2();
    });
  }
  async loadWorkflows() {
    try {
      let favorites;
      const resp = await api.getUserData("workflows/.index.json");
      let info;
      if (resp.status === 200) {
        info = await resp.json();
        favorites = new Set(info?.favorites ?? []);
      } else {
        favorites = /* @__PURE__ */ new Set();
      }
      const workflows = (await api.listUserData("workflows", true, true)).map(
        (w2) => {
          let workflow = this.workflowLookup[w2[0]];
          if (!workflow) {
            workflow = new ComfyWorkflow(
              this,
              w2[0],
              w2.slice(1),
              favorites.has(w2[0])
            );
            this.workflowLookup[workflow.path] = workflow;
          }
          return workflow;
        }
      );
      this.workflows = workflows;
    } catch (error) {
      alert("Error loading workflows: " + (error.message ?? error));
      this.workflows = [];
    }
  }
  async saveWorkflowMetadata() {
    await api.storeUserData("workflows/.index.json", {
      favorites: [
        ...this.workflows.filter((w2) => w2.isFavorite).map((w2) => w2.path)
      ]
    });
  }
  /**
   * @param {string | ComfyWorkflow | null} workflow
   */
  setWorkflow(workflow) {
    if (workflow && typeof workflow === "string") {
      const found = this.workflows.find((w2) => w2.path === workflow);
      if (found) {
        workflow = found;
        workflow.unsaved = !workflow || getStorageValue("Comfy.PreviousWorkflowUnsaved") === "true";
      }
    }
    if (!(workflow instanceof ComfyWorkflow)) {
      workflow = new ComfyWorkflow(
        this,
        workflow || "Unsaved Workflow" + (this.#unsavedCount++ ? ` (${this.#unsavedCount})` : "")
      );
    }
    const index2 = this.openWorkflows.indexOf(workflow);
    if (index2 === -1) {
      this.openWorkflows.push(workflow);
    }
    this.#activeWorkflow = workflow;
    setStorageValue("Comfy.PreviousWorkflow", this.activeWorkflow.path ?? "");
    this.dispatchEvent(new CustomEvent("changeWorkflow"));
  }
  storePrompt({ nodes, id: id2 }) {
    this.queuedPrompts[id2] ??= {};
    this.queuedPrompts[id2].nodes = {
      ...nodes.reduce((p2, n) => {
        p2[n] = false;
        return p2;
      }, {}),
      ...this.queuedPrompts[id2].nodes
    };
    this.queuedPrompts[id2].workflow = this.activeWorkflow;
  }
  /**
   * @param {ComfyWorkflow} workflow
   */
  async closeWorkflow(workflow, warnIfUnsaved = true) {
    if (!workflow.isOpen) {
      return true;
    }
    if (workflow.unsaved && warnIfUnsaved) {
      const res = await ComfyAsyncDialog.prompt({
        title: "Save Changes?",
        message: `Do you want to save changes to "${workflow.path ?? workflow.name}" before closing?`,
        actions: ["Yes", "No", "Cancel"]
      });
      if (res === "Yes") {
        const active3 = this.activeWorkflow;
        if (active3 !== workflow) {
          await workflow.load();
        }
        if (!await workflow.save()) {
          if (active3 !== workflow) {
            await active3.load();
          }
          return;
        }
      } else if (res === "Cancel") {
        return;
      }
    }
    workflow.changeTracker = null;
    this.openWorkflows.splice(this.openWorkflows.indexOf(workflow), 1);
    if (this.openWorkflows.length) {
      this.#activeWorkflow = this.openWorkflows[0];
      await this.#activeWorkflow.load();
    } else {
      await this.app.loadGraphData();
    }
  }
}
class ComfyWorkflow {
  static {
    __name(this, "ComfyWorkflow");
  }
  #name;
  #path;
  #pathParts;
  #isFavorite = false;
  changeTracker = null;
  unsaved = false;
  manager;
  get name() {
    return this.#name;
  }
  get path() {
    return this.#path;
  }
  get pathParts() {
    return this.#pathParts;
  }
  get isFavorite() {
    return this.#isFavorite;
  }
  get isOpen() {
    return !!this.changeTracker;
  }
  constructor(manager, path, pathParts, isFavorite) {
    this.manager = manager;
    if (pathParts) {
      this.#updatePath(path, pathParts);
      this.#isFavorite = isFavorite;
    } else {
      this.#name = path;
      this.unsaved = true;
    }
  }
  #updatePath(path, pathParts) {
    this.#path = path;
    if (!pathParts) {
      if (!path.includes("\\")) {
        pathParts = path.split("/");
      } else {
        pathParts = path.split("\\");
      }
    }
    this.#pathParts = pathParts;
    this.#name = trimJsonExt(pathParts[pathParts.length - 1]);
  }
  async getWorkflowData() {
    const resp = await api.getUserData("workflows/" + this.path);
    if (resp.status !== 200) {
      alert(
        `Error loading workflow file '${this.path}': ${resp.status} ${resp.statusText}`
      );
      return;
    }
    return await resp.json();
  }
  load = /* @__PURE__ */ __name(async () => {
    if (this.isOpen) {
      await this.manager.app.loadGraphData(
        this.changeTracker.activeState,
        true,
        true,
        this,
        {
          showMissingModelsDialog: false,
          showMissingNodesDialog: false
        }
      );
    } else {
      const data24 = await this.getWorkflowData();
      if (!data24) return;
      await this.manager.app.loadGraphData(data24, true, true, this);
    }
  }, "load");
  async save(saveAs2 = false) {
    if (!this.path || saveAs2) {
      return !!await this.#save(null, false);
    } else {
      return !!await this.#save(this.path, true);
    }
  }
  async favorite(value3) {
    try {
      if (this.#isFavorite === value3) return;
      this.#isFavorite = value3;
      await this.manager.saveWorkflowMetadata();
      this.manager.dispatchEvent(new CustomEvent("favorite", { detail: this }));
    } catch (error) {
      alert(
        "Error favoriting workflow " + this.path + "\n" + (error.message ?? error)
      );
    }
  }
  async rename(path) {
    path = appendJsonExt(path);
    let resp = await api.moveUserData(
      "workflows/" + this.path,
      "workflows/" + path
    );
    if (resp.status === 409) {
      if (!confirm(
        `Workflow '${path}' already exists, do you want to overwrite it?`
      ))
        return resp;
      resp = await api.moveUserData(
        "workflows/" + this.path,
        "workflows/" + path,
        { overwrite: true }
      );
    }
    if (resp.status !== 200) {
      alert(
        `Error renaming workflow file '${this.path}': ${resp.status} ${resp.statusText}`
      );
      return;
    }
    const isFav = this.isFavorite;
    if (isFav) {
      await this.favorite(false);
    }
    path = (await resp.json()).substring("workflows/".length);
    this.#updatePath(path, null);
    if (isFav) {
      await this.favorite(true);
    }
    this.manager.dispatchEvent(new CustomEvent("rename", { detail: this }));
    setStorageValue("Comfy.PreviousWorkflow", this.path ?? "");
  }
  async insert() {
    const data24 = await this.getWorkflowData();
    if (!data24) return;
    const old = localStorage.getItem("litegrapheditor_clipboard");
    const graph = new LGraph(data24);
    const canvas = new LGraphCanvas(null, graph, {
      // @ts-expect-error
      skip_events: true,
      skip_render: true
    });
    canvas.selectNodes();
    canvas.copyToClipboard();
    this.manager.app.canvas.pasteFromClipboard();
    localStorage.setItem("litegrapheditor_clipboard", old);
  }
  async delete() {
    if (this.isFavorite) {
      await this.favorite(false);
    }
    const resp = await api.deleteUserData("workflows/" + this.path);
    if (resp.status !== 204) {
      alert(
        `Error removing user data file '${this.path}': ${resp.status} ${resp.statusText}`
      );
    }
    this.unsaved = true;
    this.#path = null;
    this.#pathParts = null;
    this.manager.workflows.splice(this.manager.workflows.indexOf(this), 1);
    this.manager.dispatchEvent(new CustomEvent("delete", { detail: this }));
  }
  track() {
    if (this.changeTracker) {
      this.changeTracker.restore();
    } else {
      this.changeTracker = new ChangeTracker(this);
    }
  }
  async #save(path, overwrite) {
    if (!path) {
      path = prompt(
        "Save workflow as:",
        trimJsonExt(this.path) ?? this.name ?? "workflow"
      );
      if (!path) return;
    }
    path = appendJsonExt(path);
    const p2 = await this.manager.app.graphToPrompt();
    const json = JSON.stringify(p2.workflow, null, 2);
    let resp = await api.storeUserData("workflows/" + path, json, {
      stringify: false,
      throwOnError: false,
      overwrite
    });
    if (resp.status === 409) {
      if (!confirm(
        `Workflow '${path}' already exists, do you want to overwrite it?`
      ))
        return;
      resp = await api.storeUserData("workflows/" + path, json, {
        stringify: false
      });
    }
    if (resp.status !== 200) {
      alert(
        `Error saving workflow '${this.path}': ${resp.status} ${resp.statusText}`
      );
      return;
    }
    path = (await resp.json()).substring("workflows/".length);
    if (!this.path) {
      this.#updatePath(path, null);
      await this.manager.loadWorkflows();
      this.unsaved = false;
      this.manager.dispatchEvent(new CustomEvent("rename", { detail: this }));
      setStorageValue("Comfy.PreviousWorkflow", this.path ?? "");
    } else if (path !== this.path) {
      await this.manager.loadWorkflows();
      const workflow = this.manager.workflowLookup[path];
      await workflow.load();
    } else {
      this.unsaved = false;
      this.manager.dispatchEvent(new CustomEvent("save", { detail: this }));
    }
    return true;
  }
}
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.workflows = window.comfyAPI.workflows || {};
window.comfyAPI.workflows.trimJsonExt = trimJsonExt;
window.comfyAPI.workflows.ComfyWorkflowManager = ComfyWorkflowManager;
window.comfyAPI.workflows.ComfyWorkflow = ComfyWorkflow;
class ComfyWorkflowsMenu {
  static {
    __name(this, "ComfyWorkflowsMenu");
  }
  #first = true;
  element = $el("div.comfyui-workflows");
  popup;
  app;
  buttonProgress;
  workflowLabel;
  button;
  content;
  unsaved;
  get open() {
    return this.popup.open;
  }
  set open(open2) {
    this.popup.open = open2;
  }
  constructor(app2) {
    this.app = app2;
    this.#bindEvents();
    const classList = {
      "comfyui-workflows-button": true,
      "comfyui-button": true,
      unsaved: getStorageValue("Comfy.PreviousWorkflowUnsaved") === "true",
      running: false
    };
    this.buttonProgress = $el("div.comfyui-workflows-button-progress");
    this.workflowLabel = $el("span.comfyui-workflows-label", "");
    this.button = new ComfyButton({
      content: $el("div.comfyui-workflows-button-inner", [
        $el("i.mdi.mdi-graph"),
        this.workflowLabel,
        this.buttonProgress
      ]),
      icon: "chevron-down",
      classList
    });
    this.element.append(this.button.element);
    this.popup = new ComfyPopup({
      target: this.element,
      classList: "comfyui-workflows-popup"
    });
    this.content = new ComfyWorkflowsContent(app2, this.popup);
    this.popup.children = [this.content.element];
    this.popup.addEventListener("change", () => {
      this.button.icon = "chevron-" + (this.popup.open ? "up" : "down");
    });
    this.button.withPopup(this.popup);
    this.unsaved = prop(this, "unsaved", classList.unsaved, (v2) => {
      classList.unsaved = v2;
      this.button.classList = classList;
      setStorageValue("Comfy.PreviousWorkflowUnsaved", v2);
    });
  }
  #updateProgress = /* @__PURE__ */ __name(() => {
    const prompt2 = this.app.workflowManager.activePrompt;
    let percent = 0;
    if (this.app.workflowManager.activeWorkflow === prompt2?.workflow) {
      const total = Object.values(prompt2.nodes);
      const done = total.filter(Boolean);
      percent = done.length / total.length * 100;
    }
    this.buttonProgress.style.width = percent + "%";
  }, "#updateProgress");
  #updateActive = /* @__PURE__ */ __name(() => {
    const active3 = this.app.workflowManager.activeWorkflow;
    this.button.tooltip = active3.path;
    this.workflowLabel.textContent = active3.name;
    this.unsaved = active3.unsaved;
    if (this.#first) {
      this.#first = false;
      this.content.load();
    }
    this.#updateProgress();
  }, "#updateActive");
  #bindEvents() {
    this.app.workflowManager.addEventListener(
      "changeWorkflow",
      this.#updateActive
    );
    this.app.workflowManager.addEventListener("rename", this.#updateActive);
    this.app.workflowManager.addEventListener("delete", this.#updateActive);
    this.app.workflowManager.addEventListener("save", () => {
      this.unsaved = this.app.workflowManager.activeWorkflow.unsaved;
    });
    this.app.workflowManager.addEventListener("execute", (e) => {
      this.#updateProgress();
    });
    api.addEventListener("graphChanged", () => {
      this.unsaved = true;
    });
  }
  #getMenuOptions(callback) {
    const menu = [];
    const directories = /* @__PURE__ */ new Map();
    for (const workflow of this.app.workflowManager.workflows || []) {
      const path = workflow.pathParts;
      if (!path) continue;
      let parent = menu;
      let currentPath = "";
      for (let i2 = 0; i2 < path.length - 1; i2++) {
        currentPath += "/" + path[i2];
        let newParent = directories.get(currentPath);
        if (!newParent) {
          newParent = {
            title: path[i2],
            has_submenu: true,
            submenu: {
              options: []
            }
          };
          parent.push(newParent);
          newParent = newParent.submenu.options;
          directories.set(currentPath, newParent);
        }
        parent = newParent;
      }
      parent.push({
        title: trimJsonExt(path[path.length - 1]),
        callback: /* @__PURE__ */ __name(() => callback(workflow), "callback")
      });
    }
    return menu;
  }
  #getFavoriteMenuOptions(callback) {
    const menu = [];
    for (const workflow of this.app.workflowManager.workflows || []) {
      if (workflow.isFavorite) {
        menu.push({
          title: " " + workflow.name,
          callback: /* @__PURE__ */ __name(() => callback(workflow), "callback")
        });
      }
    }
    return menu;
  }
  registerExtension(app2) {
    const self2 = this;
    app2.registerExtension({
      name: "Comfy.Workflows",
      async beforeRegisterNodeDef(nodeType) {
        function getImageWidget(node3) {
          const inputs = {
            ...node3.constructor?.nodeData?.input?.required,
            ...node3.constructor?.nodeData?.input?.optional
          };
          for (const input in inputs) {
            if (inputs[input][0] === "IMAGEUPLOAD") {
              const imageWidget = node3.widgets.find(
                (w2) => w2.name === (inputs[input]?.[1]?.widget ?? "image")
              );
              if (imageWidget) return imageWidget;
            }
          }
        }
        __name(getImageWidget, "getImageWidget");
        function setWidgetImage(node3, widget, img) {
          const url = new URL(img.src);
          const filename = url.searchParams.get("filename");
          const subfolder = url.searchParams.get("subfolder");
          const type = url.searchParams.get("type");
          const imageId = `${subfolder ? subfolder + "/" : ""}${filename} [${type}]`;
          widget.value = imageId;
          node3.imgs = [img];
          app2.graph.setDirtyCanvas(true, true);
        }
        __name(setWidgetImage, "setWidgetImage");
        async function sendToWorkflow(img, workflow) {
          const openWorkflow = app2.workflowManager.openWorkflows.find(
            (w2) => w2.path === workflow.path
          );
          if (openWorkflow) {
            workflow = openWorkflow;
          }
          await workflow.load();
          let options3 = [];
          const nodes = app2.graph.computeExecutionOrder(false);
          for (const node3 of nodes) {
            const widget = getImageWidget(node3);
            if (widget == null) continue;
            if (node3.title?.toLowerCase().includes("input")) {
              options3 = [{ widget, node: node3 }];
              break;
            } else {
              options3.push({ widget, node: node3 });
            }
          }
          if (!options3.length) {
            alert("No image nodes have been found in this workflow!");
            return;
          } else if (options3.length > 1) {
            const dialog = new WidgetSelectionDialog(options3);
            const res = await dialog.show(app2);
            if (!res) return;
            options3 = [res];
          }
          setWidgetImage(options3[0].node, options3[0].widget, img);
        }
        __name(sendToWorkflow, "sendToWorkflow");
        const getExtraMenuOptions = nodeType.prototype["getExtraMenuOptions"];
        nodeType.prototype["getExtraMenuOptions"] = function(_2, options3) {
          const r = getExtraMenuOptions?.apply?.(this, arguments);
          const setting = app2.ui.settings.getSettingValue(
            "Comfy.UseNewMenu",
            false
          );
          if (setting && setting != "Disabled") {
            const t = this;
            let img;
            if (t.imageIndex != null) {
              img = t.imgs?.[t.imageIndex];
            } else if (t.overIndex != null) {
              img = t.imgs?.[t.overIndex];
            }
            if (img) {
              let pos2 = options3.findIndex((o) => o.content === "Save Image");
              if (pos2 === -1) {
                pos2 = 0;
              } else {
                pos2++;
              }
              options3.splice(pos2, 0, {
                content: "Send to workflow",
                has_submenu: true,
                submenu: {
                  options: [
                    {
                      callback: /* @__PURE__ */ __name(() => sendToWorkflow(img, app2.workflowManager.activeWorkflow), "callback"),
                      title: "[Current workflow]"
                    },
                    ...self2.#getFavoriteMenuOptions(
                      sendToWorkflow.bind(null, img)
                    ),
                    null,
                    ...self2.#getMenuOptions(sendToWorkflow.bind(null, img))
                  ]
                }
              });
            }
          }
          return r;
        };
      }
    });
  }
}
class ComfyWorkflowsContent {
  static {
    __name(this, "ComfyWorkflowsContent");
  }
  element = $el("div.comfyui-workflows-panel");
  treeState = {};
  treeFiles = {};
  openFiles = /* @__PURE__ */ new Map();
  activeElement = null;
  spinner;
  openElement;
  favoritesElement;
  treeElement;
  app;
  popup;
  actions;
  filterText;
  treeRoot;
  constructor(app2, popup) {
    this.app = app2;
    this.popup = popup;
    this.actions = $el("div.comfyui-workflows-actions", [
      new ComfyButton({
        content: "Default",
        icon: "file-code",
        iconSize: 18,
        classList: "comfyui-button primary",
        tooltip: "Load default workflow",
        action: /* @__PURE__ */ __name(() => {
          popup.open = false;
          app2.loadGraphData();
          app2.resetView();
        }, "action")
      }).element,
      new ComfyButton({
        content: "Browse",
        icon: "folder",
        iconSize: 18,
        tooltip: "Browse for an image or exported workflow",
        action: /* @__PURE__ */ __name(() => {
          popup.open = false;
          app2.ui.loadFile();
        }, "action")
      }).element,
      new ComfyButton({
        content: "Blank",
        icon: "plus-thick",
        iconSize: 18,
        tooltip: "Create a new blank workflow",
        action: /* @__PURE__ */ __name(() => {
          app2.workflowManager.setWorkflow(null);
          app2.clean();
          app2.graph.clear();
          app2.workflowManager.activeWorkflow.track();
          popup.open = false;
        }, "action")
      }).element
    ]);
    this.spinner = createSpinner();
    this.element.replaceChildren(this.actions, this.spinner);
    this.popup.addEventListener("open", () => this.load());
    this.popup.addEventListener(
      "close",
      () => this.element.replaceChildren(this.actions, this.spinner)
    );
    this.app.workflowManager.addEventListener("favorite", (e) => {
      const workflow = e["detail"];
      const button = this.treeFiles[workflow.path]?.primary;
      if (!button) return;
      button.icon = this.#getFavoriteIcon(workflow);
      button.overIcon = this.#getFavoriteOverIcon(workflow);
      this.updateFavorites();
    });
    for (const e of ["save", "open", "close", "changeWorkflow"]) {
      app2.workflowManager.addEventListener(e, () => this.updateOpen());
    }
    this.app.workflowManager.addEventListener("rename", () => this.load());
    this.app.workflowManager.addEventListener(
      "execute",
      (e) => this.#updateActive()
    );
  }
  async load() {
    await this.app.workflowManager.loadWorkflows();
    this.updateTree();
    this.updateFavorites();
    this.updateOpen();
    this.element.replaceChildren(
      this.actions,
      this.openElement,
      this.favoritesElement,
      this.treeElement
    );
  }
  updateOpen() {
    const current = this.openElement;
    this.openFiles.clear();
    this.openElement = $el("div.comfyui-workflows-open", [
      $el("h3", "Open"),
      ...this.app.workflowManager.openWorkflows.map((w2) => {
        const wrapper = new WorkflowElement(this, w2, {
          primary: { element: $el("i.mdi.mdi-18px.mdi-progress-pencil") },
          buttons: [
            this.#getRenameButton(w2),
            new ComfyButton({
              icon: "close",
              iconSize: 18,
              classList: "comfyui-button comfyui-workflows-file-action",
              tooltip: "Close workflow",
              action: /* @__PURE__ */ __name((e) => {
                e.stopImmediatePropagation();
                this.app.workflowManager.closeWorkflow(w2);
              }, "action")
            })
          ]
        });
        if (w2.unsaved) {
          wrapper.element.classList.add("unsaved");
        }
        if (w2 === this.app.workflowManager.activeWorkflow) {
          wrapper.element.classList.add("active");
        }
        this.openFiles.set(w2, wrapper);
        return wrapper.element;
      })
    ]);
    this.#updateActive();
    current?.replaceWith(this.openElement);
  }
  updateFavorites() {
    const current = this.favoritesElement;
    const favorites = [
      ...this.app.workflowManager.workflows.filter((w2) => w2.isFavorite)
    ];
    this.favoritesElement = $el("div.comfyui-workflows-favorites", [
      $el("h3", "Favorites"),
      ...favorites.map((w2) => {
        return this.#getWorkflowElement(w2).element;
      }).filter(Boolean)
    ]);
    current?.replaceWith(this.favoritesElement);
  }
  filterTree() {
    if (!this.filterText) {
      this.treeRoot.classList.remove("filtered");
      for (const item2 of Object.values(this.treeFiles)) {
        item2.element.parentElement.style.removeProperty("display");
        this.showTreeParents(item2.element.parentElement);
      }
      return;
    }
    this.treeRoot.classList.add("filtered");
    const searchTerms = this.filterText.toLocaleLowerCase().split(" ");
    for (const item2 of Object.values(this.treeFiles)) {
      const parts2 = item2.workflow.pathParts;
      let termIndex = 0;
      let valid = false;
      for (const part of parts2) {
        let currentIndex = 0;
        do {
          currentIndex = part.indexOf(searchTerms[termIndex], currentIndex);
          if (currentIndex > -1) currentIndex += searchTerms[termIndex].length;
        } while (currentIndex !== -1 && ++termIndex < searchTerms.length);
        if (termIndex >= searchTerms.length) {
          valid = true;
          break;
        }
      }
      if (valid) {
        item2.element.parentElement.style.removeProperty("display");
        this.showTreeParents(item2.element.parentElement);
      } else {
        item2.element.parentElement.style.display = "none";
        this.hideTreeParents(item2.element.parentElement);
      }
    }
  }
  hideTreeParents(element) {
    if (element.parentElement?.classList.contains("comfyui-workflows-tree") === false) {
      for (let i2 = 1; i2 < element.parentElement.children.length; i2++) {
        const c = element.parentElement.children[i2];
        if (c.style.display !== "none") {
          return;
        }
      }
      element.parentElement.style.display = "none";
      this.hideTreeParents(element.parentElement);
    }
  }
  showTreeParents(element) {
    if (element.parentElement?.classList.contains("comfyui-workflows-tree") === false) {
      element.parentElement.style.removeProperty("display");
      this.showTreeParents(element.parentElement);
    }
  }
  updateTree() {
    const current = this.treeElement;
    const nodes = {};
    let typingTimeout;
    this.treeFiles = {};
    this.treeRoot = $el("ul.comfyui-workflows-tree");
    this.treeElement = $el("section", [
      $el("header", [
        $el("h3", "Browse"),
        $el("div.comfy-ui-workflows-search", [
          $el("i.mdi.mdi-18px.mdi-magnify"),
          $el("input", {
            placeholder: "Search",
            value: this.filterText ?? "",
            oninput: /* @__PURE__ */ __name((e) => {
              this.filterText = e.target["value"]?.trim();
              clearTimeout(typingTimeout);
              typingTimeout = setTimeout(() => this.filterTree(), 250);
            }, "oninput")
          })
        ])
      ]),
      this.treeRoot
    ]);
    for (const workflow of this.app.workflowManager.workflows) {
      if (!workflow.pathParts) continue;
      let currentPath = "";
      let currentRoot = this.treeRoot;
      for (let i2 = 0; i2 < workflow.pathParts.length; i2++) {
        currentPath += (currentPath ? "\\" : "") + workflow.pathParts[i2];
        const parentNode = nodes[currentPath] ?? this.#createNode(currentPath, workflow, i2, currentRoot);
        nodes[currentPath] = parentNode;
        currentRoot = parentNode;
      }
    }
    current?.replaceWith(this.treeElement);
    this.filterTree();
  }
  #expandNode(el, workflow, thisPath, i2) {
    const expanded2 = !el.classList.toggle("closed");
    if (expanded2) {
      let c = "";
      for (let j = 0; j <= i2; j++) {
        c += (c ? "\\" : "") + workflow.pathParts[j];
        this.treeState[c] = true;
      }
    } else {
      let c = thisPath;
      for (let j = i2 + 1; j < workflow.pathParts.length; j++) {
        c += (c ? "\\" : "") + workflow.pathParts[j];
        delete this.treeState[c];
      }
      delete this.treeState[thisPath];
    }
  }
  #updateActive() {
    this.#removeActive();
    const active3 = this.app.workflowManager.activePrompt;
    if (!active3?.workflow) return;
    const open2 = this.openFiles.get(active3.workflow);
    if (!open2) return;
    this.activeElement = open2;
    const total = Object.values(active3.nodes);
    const done = total.filter(Boolean);
    const percent = done.length / total.length;
    open2.element.classList.add("running");
    open2.element.style.setProperty("--progress", percent * 100 + "%");
    open2.primary.element.classList.remove("mdi-progress-pencil");
    open2.primary.element.classList.add("mdi-play");
  }
  #removeActive() {
    if (!this.activeElement) return;
    this.activeElement.element.classList.remove("running");
    this.activeElement.element.style.removeProperty("--progress");
    this.activeElement.primary.element.classList.add("mdi-progress-pencil");
    this.activeElement.primary.element.classList.remove("mdi-play");
  }
  #getFavoriteIcon(workflow) {
    return workflow.isFavorite ? "star" : "file-outline";
  }
  #getFavoriteOverIcon(workflow) {
    return workflow.isFavorite ? "star-off" : "star-outline";
  }
  #getFavoriteTooltip(workflow) {
    return workflow.isFavorite ? "Remove this workflow from your favorites" : "Add this workflow to your favorites";
  }
  #getFavoriteButton(workflow, primary) {
    return new ComfyButton({
      icon: this.#getFavoriteIcon(workflow),
      overIcon: this.#getFavoriteOverIcon(workflow),
      iconSize: 18,
      classList: "comfyui-button comfyui-workflows-file-action-favorite" + (primary ? " comfyui-workflows-file-action-primary" : ""),
      tooltip: this.#getFavoriteTooltip(workflow),
      action: /* @__PURE__ */ __name((e) => {
        e.stopImmediatePropagation();
        workflow.favorite(!workflow.isFavorite);
      }, "action")
    });
  }
  #getDeleteButton(workflow) {
    const deleteButton = new ComfyButton({
      icon: "delete",
      tooltip: "Delete this workflow",
      classList: "comfyui-button comfyui-workflows-file-action",
      iconSize: 18,
      action: /* @__PURE__ */ __name(async (e, btn) => {
        e.stopImmediatePropagation();
        if (btn.icon === "delete-empty") {
          btn.enabled = false;
          await workflow.delete();
          await this.load();
        } else {
          btn.icon = "delete-empty";
          btn.element.style.background = "red";
        }
      }, "action")
    });
    deleteButton.element.addEventListener("mouseleave", () => {
      deleteButton.icon = "delete";
      deleteButton.element.style.removeProperty("background");
    });
    return deleteButton;
  }
  #getInsertButton(workflow) {
    return new ComfyButton({
      icon: "file-move-outline",
      iconSize: 18,
      tooltip: "Insert this workflow into the current workflow",
      classList: "comfyui-button comfyui-workflows-file-action",
      action: /* @__PURE__ */ __name((e) => {
        if (!this.app.shiftDown) {
          this.popup.open = false;
        }
        e.stopImmediatePropagation();
        if (!this.app.shiftDown) {
          this.popup.open = false;
        }
        workflow.insert();
      }, "action")
    });
  }
  /** @param {ComfyWorkflow} workflow */
  #getRenameButton(workflow) {
    return new ComfyButton({
      icon: "pencil",
      tooltip: workflow.path ? "Rename this workflow" : "This workflow can't be renamed as it hasn't been saved.",
      classList: "comfyui-button comfyui-workflows-file-action",
      iconSize: 18,
      enabled: !!workflow.path,
      action: /* @__PURE__ */ __name(async (e) => {
        e.stopImmediatePropagation();
        const newName = prompt("Enter new name", workflow.path);
        if (newName) {
          await workflow.rename(newName);
        }
      }, "action")
    });
  }
  #getWorkflowElement(workflow) {
    return new WorkflowElement(this, workflow, {
      primary: this.#getFavoriteButton(workflow, true),
      buttons: [
        this.#getInsertButton(workflow),
        this.#getRenameButton(workflow),
        this.#getDeleteButton(workflow)
      ]
    });
  }
  #createLeafNode(workflow) {
    const fileNode = this.#getWorkflowElement(workflow);
    this.treeFiles[workflow.path] = fileNode;
    return fileNode;
  }
  #createNode(currentPath, workflow, i2, currentRoot) {
    const part = workflow.pathParts[i2];
    const parentNode = $el(
      "ul" + (this.treeState[currentPath] ? "" : ".closed"),
      {
        $: /* @__PURE__ */ __name((el) => {
          el.onclick = (e) => {
            this.#expandNode(el, workflow, currentPath, i2);
            e.stopImmediatePropagation();
          };
        }, "$")
      }
    );
    currentRoot.append(parentNode);
    const leaf2 = i2 === workflow.pathParts.length - 1;
    let nodeElement;
    if (leaf2) {
      nodeElement = this.#createLeafNode(workflow).element;
    } else {
      nodeElement = $el("li", [
        $el("i.mdi.mdi-18px.mdi-folder"),
        $el("span", part)
      ]);
    }
    parentNode.append(nodeElement);
    return parentNode;
  }
}
class WorkflowElement {
  static {
    __name(this, "WorkflowElement");
  }
  parent;
  workflow;
  primary;
  buttons;
  element;
  constructor(parent, workflow, {
    tagName = "li",
    primary,
    buttons
  }) {
    this.parent = parent;
    this.workflow = workflow;
    this.primary = primary;
    this.buttons = buttons;
    this.element = $el(
      tagName + ".comfyui-workflows-tree-file",
      {
        onclick: /* @__PURE__ */ __name(() => {
          workflow.load();
          this.parent.popup.open = false;
        }, "onclick"),
        title: this.workflow.path
      },
      [
        this.primary?.element,
        $el("span", workflow.name),
        ...buttons.map((b) => b.element)
      ]
    );
  }
}
class WidgetSelectionDialog extends ComfyAsyncDialog {
  static {
    __name(this, "WidgetSelectionDialog");
  }
  #options;
  constructor(options3) {
    super();
    this.#options = options3;
  }
  show(app2) {
    this.element.classList.add("comfy-widget-selection-dialog");
    return super.show(
      $el("div", [
        $el("h2", "Select image target"),
        $el(
          "p",
          "This workflow has multiple image loader nodes, you can rename a node to include 'input' in the title for it to be automatically selected, or select one below."
        ),
        $el(
          "section",
          this.#options.map((opt) => {
            return $el("div.comfy-widget-selection-item", [
              $el(
                "span",
                { dataset: { id: opt.node.id } },
                `${opt.node.title ?? opt.node.type} ${opt.widget.name}`
              ),
              $el(
                "button.comfyui-button",
                {
                  onclick: /* @__PURE__ */ __name(() => {
                    app2.canvas.ds.offset[0] = -opt.node.pos[0] + 50;
                    app2.canvas.ds.offset[1] = -opt.node.pos[1] + 50;
                    app2.canvas.selectNode(opt.node);
                    app2.graph.setDirtyCanvas(true, true);
                  }, "onclick")
                },
                "Show"
              ),
              $el(
                "button.comfyui-button.primary",
                {
                  onclick: /* @__PURE__ */ __name(() => {
                    this.close(opt);
                  }, "onclick")
                },
                "Select"
              )
            ]);
          })
        )
      ])
    );
  }
}
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.workflows = window.comfyAPI.workflows || {};
window.comfyAPI.workflows.ComfyWorkflowsMenu = ComfyWorkflowsMenu;
window.comfyAPI.workflows.ComfyWorkflowsContent = ComfyWorkflowsContent;
function getInterruptButton(visibility) {
  const btn = new ComfyButton({
    icon: "close",
    tooltip: "Cancel current generation",
    enabled: false,
    action: /* @__PURE__ */ __name(async () => {
      await api.interrupt();
      useToastStore().add({
        severity: "info",
        summary: "Interrupted",
        detail: "Execution has been interrupted",
        life: 1e3
      });
    }, "action"),
    classList: ["comfyui-button", "comfyui-interrupt-button", visibility]
  });
  api.addEventListener(
    "status",
    ({ detail }) => {
      const sz = detail?.exec_info?.queue_remaining;
      btn.enabled = sz > 0;
    }
  );
  return btn;
}
__name(getInterruptButton, "getInterruptButton");
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.interruptButton = window.comfyAPI.interruptButton || {};
window.comfyAPI.interruptButton.getInterruptButton = getInterruptButton;
const collapseOnMobile = /* @__PURE__ */ __name((t) => {
  ;
  (t.element ?? t).classList.add("comfyui-menu-mobile-collapse");
  return t;
}, "collapseOnMobile");
const showOnMobile = /* @__PURE__ */ __name((t) => {
  ;
  (t.element ?? t).classList.add("lt-lg-show");
  return t;
}, "showOnMobile");
class ComfyAppMenu {
  static {
    __name(this, "ComfyAppMenu");
  }
  #sizeBreak = "lg";
  #lastSizeBreaks = {
    lg: null,
    md: null,
    sm: null,
    xs: null
  };
  #sizeBreaks = Object.keys(this.#lastSizeBreaks);
  #cachedInnerSize = null;
  #cacheTimeout = null;
  app;
  workflows;
  logo;
  saveButton;
  actionsGroup;
  settingsGroup;
  viewGroup;
  mobileMenuButton;
  queueButton;
  element;
  menuPositionSetting;
  position;
  constructor(app2) {
    this.app = app2;
    this.workflows = new ComfyWorkflowsMenu(app2);
    const getSaveButton = /* @__PURE__ */ __name((t) => new ComfyButton({
      icon: "content-save",
      tooltip: "Save the current workflow",
      action: /* @__PURE__ */ __name(() => app2.workflowManager.activeWorkflow.save(), "action"),
      content: t
    }), "getSaveButton");
    this.logo = $el("h1.comfyui-logo.nlg-hide", { title: "ComfyUI" }, "ComfyUI");
    this.saveButton = new ComfySplitButton(
      {
        primary: getSaveButton(),
        mode: "hover",
        position: "absolute"
      },
      getSaveButton("Save"),
      new ComfyButton({
        icon: "content-save-edit",
        content: "Save As",
        tooltip: "Save the current graph as a new workflow",
        action: /* @__PURE__ */ __name(() => app2.workflowManager.activeWorkflow.save(true), "action")
      }),
      new ComfyButton({
        icon: "download",
        content: "Export",
        tooltip: "Export the current workflow as JSON",
        action: /* @__PURE__ */ __name(() => this.exportWorkflow("workflow", "workflow"), "action")
      }),
      new ComfyButton({
        icon: "api",
        content: "Export (API Format)",
        tooltip: "Export the current workflow as JSON for use with the ComfyUI API",
        action: /* @__PURE__ */ __name(() => this.exportWorkflow("workflow_api", "output"), "action"),
        visibilitySetting: { id: "Comfy.DevMode", showValue: true },
        app: app2
      })
    );
    this.actionsGroup = new ComfyButtonGroup(
      new ComfyButton({
        icon: "refresh",
        content: "Refresh",
        tooltip: "Refresh widgets in nodes to find new models or files",
        action: /* @__PURE__ */ __name(() => app2.refreshComboInNodes(), "action")
      }),
      new ComfyButton({
        icon: "clipboard-edit-outline",
        content: "Clipspace",
        tooltip: "Open Clipspace window",
        action: /* @__PURE__ */ __name(() => app2["openClipspace"](), "action")
      }),
      new ComfyButton({
        icon: "fit-to-page-outline",
        content: "Reset View",
        tooltip: "Reset the canvas view",
        action: /* @__PURE__ */ __name(() => app2.resetView(), "action")
      }),
      new ComfyButton({
        icon: "cancel",
        content: "Clear",
        tooltip: "Clears current workflow",
        action: /* @__PURE__ */ __name(() => {
          if (!app2.ui.settings.getSettingValue("Comfy.ConfirmClear", true) || confirm("Clear workflow?")) {
            app2.clean();
            app2.graph.clear();
            api.dispatchEvent(new CustomEvent("graphCleared"));
          }
        }, "action")
      })
    );
    this.settingsGroup = new ComfyButtonGroup();
    this.viewGroup = new ComfyButtonGroup(
      getInterruptButton("nlg-hide").element
    );
    this.mobileMenuButton = new ComfyButton({
      icon: "menu",
      action: /* @__PURE__ */ __name((_2, btn) => {
        btn.icon = this.element.classList.toggle("expanded") ? "menu-open" : "menu";
        window.dispatchEvent(new Event("resize"));
      }, "action"),
      classList: "comfyui-button comfyui-menu-button"
    });
    this.queueButton = new ComfyQueueButton(app2);
    this.element = $el("nav.comfyui-menu.lg", { style: { display: "none" } }, [
      this.logo,
      this.workflows.element,
      this.saveButton.element,
      collapseOnMobile(this.actionsGroup).element,
      $el("section.comfyui-menu-push"),
      collapseOnMobile(this.settingsGroup).element,
      collapseOnMobile(this.viewGroup).element,
      getInterruptButton("lt-lg-show").element,
      this.queueButton.element,
      showOnMobile(this.mobileMenuButton).element
    ]);
    let resizeHandler;
    this.menuPositionSetting = app2.ui.settings.addSetting({
      id: "Comfy.UseNewMenu",
      category: ["Comfy", "Menu", "UseNewMenu"],
      defaultValue: "Disabled",
      name: "Use new menu and workflow management.",
      experimental: true,
      tooltip: "On small screens the menu will always be at the top.",
      type: "combo",
      options: ["Disabled", "Top", "Bottom"],
      onChange: /* @__PURE__ */ __name(async (v2) => {
        if (v2 && v2 !== "Disabled") {
          if (!resizeHandler) {
            resizeHandler = /* @__PURE__ */ __name(() => {
              this.calculateSizeBreak();
            }, "resizeHandler");
            window.addEventListener("resize", resizeHandler);
          }
          this.updatePosition(v2);
        } else {
          if (resizeHandler) {
            window.removeEventListener("resize", resizeHandler);
            resizeHandler = null;
          }
          document.body.style.removeProperty("display");
          app2.ui.menuContainer.style.removeProperty("display");
          this.element.style.display = "none";
          app2.ui.restoreMenuPosition();
        }
        window.dispatchEvent(new Event("resize"));
      }, "onChange")
    });
  }
  updatePosition(v2) {
    document.body.style.display = "grid";
    this.app.ui.menuContainer.style.display = "none";
    this.element.style.removeProperty("display");
    this.position = v2;
    if (v2 === "Bottom") {
      this.app.bodyBottom.append(this.element);
    } else {
      this.app.bodyTop.prepend(this.element);
    }
    this.calculateSizeBreak();
  }
  updateSizeBreak(idx, prevIdx, direction) {
    const newSize = this.#sizeBreaks[idx];
    if (newSize === this.#sizeBreak) return;
    this.#cachedInnerSize = null;
    clearTimeout(this.#cacheTimeout);
    this.#sizeBreak = this.#sizeBreaks[idx];
    for (let i2 = 0; i2 < this.#sizeBreaks.length; i2++) {
      const sz = this.#sizeBreaks[i2];
      if (sz === this.#sizeBreak) {
        this.element.classList.add(sz);
      } else {
        this.element.classList.remove(sz);
      }
      if (i2 < idx) {
        this.element.classList.add("lt-" + sz);
      } else {
        this.element.classList.remove("lt-" + sz);
      }
    }
    if (idx) {
      if (this.position !== "Top") {
        this.updatePosition("Top");
      }
    } else if (this.position != this.menuPositionSetting.value) {
      this.updatePosition(this.menuPositionSetting.value);
    }
    if (!direction) {
      direction = prevIdx - idx;
    } else if (direction != prevIdx - idx) {
      return;
    }
    this.calculateSizeBreak(direction);
  }
  calculateSizeBreak(direction = 0) {
    let idx = this.#sizeBreaks.indexOf(this.#sizeBreak);
    const currIdx = idx;
    const innerSize = this.calculateInnerSize(idx);
    if (window.innerWidth >= this.#lastSizeBreaks[this.#sizeBreaks[idx - 1]]) {
      if (idx > 0) {
        idx--;
      }
    } else if (innerSize > this.element.clientWidth) {
      this.#lastSizeBreaks[this.#sizeBreak] = Math.max(
        window.innerWidth,
        innerSize
      );
      if (idx < this.#sizeBreaks.length - 1) {
        idx++;
      }
    }
    this.updateSizeBreak(idx, currIdx, direction);
  }
  calculateInnerSize(idx) {
    clearTimeout(this.#cacheTimeout);
    if (this.#cachedInnerSize) {
      this.#cacheTimeout = setTimeout(() => this.#cachedInnerSize = null, 100);
    } else {
      let innerSize = 0;
      let count = 1;
      for (const c of this.element.children) {
        if (c.classList.contains("comfyui-menu-push")) continue;
        if (idx && c.classList.contains("comfyui-menu-mobile-collapse"))
          continue;
        innerSize += c.clientWidth;
        count++;
      }
      innerSize += 8 * count;
      this.#cachedInnerSize = innerSize;
      this.#cacheTimeout = setTimeout(() => this.#cachedInnerSize = null, 100);
    }
    return this.#cachedInnerSize;
  }
  getFilename(defaultName) {
    if (this.app.ui.settings.getSettingValue("Comfy.PromptFilename", true)) {
      defaultName = prompt("Save workflow as:", defaultName);
      if (!defaultName) return;
      if (!defaultName.toLowerCase().endsWith(".json")) {
        defaultName += ".json";
      }
    }
    return defaultName;
  }
  async exportWorkflow(filename, promptProperty) {
    if (this.app.workflowManager.activeWorkflow?.path) {
      filename = this.app.workflowManager.activeWorkflow.name;
    }
    const p2 = await this.app.graphToPrompt();
    const json = JSON.stringify(p2[promptProperty], null, 2);
    const blob = new Blob([json], { type: "application/json" });
    const file = this.getFilename(filename);
    if (!file) return;
    downloadBlob(file, blob);
  }
}
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.index = window.comfyAPI.index || {};
window.comfyAPI.index.ComfyAppMenu = ComfyAppMenu;
const getNodeSource = /* @__PURE__ */ __name((python_module) => {
  const modules = python_module.split(".");
  if (["nodes", "comfy_extras"].includes(modules[0])) {
    return {
      type: "core",
      className: "comfy-core",
      displayText: "Comfy Core"
    };
  } else if (modules[0] === "custom_nodes") {
    return {
      type: "custom_nodes",
      className: "comfy-custom-nodes",
      displayText: modules[1]
    };
  } else {
    throw new Error(`Unknown node source: ${python_module}`);
  }
}, "getNodeSource");
function isArray$1(value3) {
  return !Array.isArray ? getTag(value3) === "[object Array]" : Array.isArray(value3);
}
__name(isArray$1, "isArray$1");
const INFINITY = 1 / 0;
function baseToString(value3) {
  if (typeof value3 == "string") {
    return value3;
  }
  let result = value3 + "";
  return result == "0" && 1 / value3 == -INFINITY ? "-0" : result;
}
__name(baseToString, "baseToString");
function toString(value3) {
  return value3 == null ? "" : baseToString(value3);
}
__name(toString, "toString");
function isString$2(value3) {
  return typeof value3 === "string";
}
__name(isString$2, "isString$2");
function isNumber$1(value3) {
  return typeof value3 === "number";
}
__name(isNumber$1, "isNumber$1");
function isBoolean$1(value3) {
  return value3 === true || value3 === false || isObjectLike(value3) && getTag(value3) == "[object Boolean]";
}
__name(isBoolean$1, "isBoolean$1");
function isObject$2(value3) {
  return typeof value3 === "object";
}
__name(isObject$2, "isObject$2");
function isObjectLike(value3) {
  return isObject$2(value3) && value3 !== null;
}
__name(isObjectLike, "isObjectLike");
function isDefined(value3) {
  return value3 !== void 0 && value3 !== null;
}
__name(isDefined, "isDefined");
function isBlank(value3) {
  return !value3.trim().length;
}
__name(isBlank, "isBlank");
function getTag(value3) {
  return value3 == null ? value3 === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(value3);
}
__name(getTag, "getTag");
const EXTENDED_SEARCH_UNAVAILABLE = "Extended search is not available";
const INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
const LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = /* @__PURE__ */ __name((key) => `Invalid value for key ${key}`, "LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY");
const PATTERN_LENGTH_TOO_LARGE = /* @__PURE__ */ __name((max) => `Pattern length exceeds max of ${max}.`, "PATTERN_LENGTH_TOO_LARGE");
const MISSING_KEY_PROPERTY = /* @__PURE__ */ __name((name) => `Missing ${name} property in key`, "MISSING_KEY_PROPERTY");
const INVALID_KEY_WEIGHT_VALUE = /* @__PURE__ */ __name((key) => `Property 'weight' in key '${key}' must be a positive integer`, "INVALID_KEY_WEIGHT_VALUE");
const hasOwn$1 = Object.prototype.hasOwnProperty;
class KeyStore {
  static {
    __name(this, "KeyStore");
  }
  constructor(keys2) {
    this._keys = [];
    this._keyMap = {};
    let totalWeight = 0;
    keys2.forEach((key) => {
      let obj = createKey(key);
      this._keys.push(obj);
      this._keyMap[obj.id] = obj;
      totalWeight += obj.weight;
    });
    this._keys.forEach((key) => {
      key.weight /= totalWeight;
    });
  }
  get(keyId) {
    return this._keyMap[keyId];
  }
  keys() {
    return this._keys;
  }
  toJSON() {
    return JSON.stringify(this._keys);
  }
}
function createKey(key) {
  let path = null;
  let id2 = null;
  let src = null;
  let weight = 1;
  let getFn = null;
  if (isString$2(key) || isArray$1(key)) {
    src = key;
    path = createKeyPath(key);
    id2 = createKeyId(key);
  } else {
    if (!hasOwn$1.call(key, "name")) {
      throw new Error(MISSING_KEY_PROPERTY("name"));
    }
    const name = key.name;
    src = name;
    if (hasOwn$1.call(key, "weight")) {
      weight = key.weight;
      if (weight <= 0) {
        throw new Error(INVALID_KEY_WEIGHT_VALUE(name));
      }
    }
    path = createKeyPath(name);
    id2 = createKeyId(name);
    getFn = key.getFn;
  }
  return { path, id: id2, weight, src, getFn };
}
__name(createKey, "createKey");
function createKeyPath(key) {
  return isArray$1(key) ? key : key.split(".");
}
__name(createKeyPath, "createKeyPath");
function createKeyId(key) {
  return isArray$1(key) ? key.join(".") : key;
}
__name(createKeyId, "createKeyId");
function get(obj, path) {
  let list = [];
  let arr = false;
  const deepGet = /* @__PURE__ */ __name((obj2, path2, index2) => {
    if (!isDefined(obj2)) {
      return;
    }
    if (!path2[index2]) {
      list.push(obj2);
    } else {
      let key = path2[index2];
      const value3 = obj2[key];
      if (!isDefined(value3)) {
        return;
      }
      if (index2 === path2.length - 1 && (isString$2(value3) || isNumber$1(value3) || isBoolean$1(value3))) {
        list.push(toString(value3));
      } else if (isArray$1(value3)) {
        arr = true;
        for (let i2 = 0, len = value3.length; i2 < len; i2 += 1) {
          deepGet(value3[i2], path2, index2 + 1);
        }
      } else if (path2.length) {
        deepGet(value3, path2, index2 + 1);
      }
    }
  }, "deepGet");
  deepGet(obj, isString$2(path) ? path.split(".") : path, 0);
  return arr ? list : list[0];
}
__name(get, "get");
const MatchOptions = {
  // Whether the matches should be included in the result set. When `true`, each record in the result
  // set will include the indices of the matched characters.
  // These can consequently be used for highlighting purposes.
  includeMatches: false,
  // When `true`, the matching function will continue to the end of a search pattern even if
  // a perfect match has already been located in the string.
  findAllMatches: false,
  // Minimum number of characters that must be matched before a result is considered a match
  minMatchCharLength: 1
};
const BasicOptions = {
  // When `true`, the algorithm continues searching to the end of the input even if a perfect
  // match is found before the end of the same input.
  isCaseSensitive: false,
  // When true, the matching function will continue to the end of a search pattern even if
  includeScore: false,
  // List of properties that will be searched. This also supports nested properties.
  keys: [],
  // Whether to sort the result list, by score
  shouldSort: true,
  // Default sort function: sort by ascending score, ascending index
  sortFn: /* @__PURE__ */ __name((a, b) => a.score === b.score ? a.idx < b.idx ? -1 : 1 : a.score < b.score ? -1 : 1, "sortFn")
};
const FuzzyOptions = {
  // Approximately where in the text is the pattern expected to be found?
  location: 0,
  // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
  // (of both letters and location), a threshold of '1.0' would match anything.
  threshold: 0.6,
  // Determines how close the match must be to the fuzzy location (specified above).
  // An exact letter match which is 'distance' characters away from the fuzzy location
  // would score as a complete mismatch. A distance of '0' requires the match be at
  // the exact location specified, a threshold of '1000' would require a perfect match
  // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
  distance: 100
};
const AdvancedOptions = {
  // When `true`, it enables the use of unix-like search commands
  useExtendedSearch: false,
  // The get function to use when fetching an object's properties.
  // The default will search nested paths *ie foo.bar.baz*
  getFn: get,
  // When `true`, search will ignore `location` and `distance`, so it won't matter
  // where in the string the pattern appears.
  // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score
  ignoreLocation: false,
  // When `true`, the calculation for the relevance score (used for sorting) will
  // ignore the field-length norm.
  // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm
  ignoreFieldNorm: false,
  // The weight to determine how much field length norm effects scoring.
  fieldNormWeight: 1
};
var Config = {
  ...BasicOptions,
  ...MatchOptions,
  ...FuzzyOptions,
  ...AdvancedOptions
};
const SPACE = /[^ ]+/g;
function norm(weight = 1, mantissa = 3) {
  const cache2 = /* @__PURE__ */ new Map();
  const m = Math.pow(10, mantissa);
  return {
    get(value3) {
      const numTokens = value3.match(SPACE).length;
      if (cache2.has(numTokens)) {
        return cache2.get(numTokens);
      }
      const norm2 = 1 / Math.pow(numTokens, 0.5 * weight);
      const n = parseFloat(Math.round(norm2 * m) / m);
      cache2.set(numTokens, n);
      return n;
    },
    clear() {
      cache2.clear();
    }
  };
}
__name(norm, "norm");
class FuseIndex {
  static {
    __name(this, "FuseIndex");
  }
  constructor({
    getFn = Config.getFn,
    fieldNormWeight = Config.fieldNormWeight
  } = {}) {
    this.norm = norm(fieldNormWeight, 3);
    this.getFn = getFn;
    this.isCreated = false;
    this.setIndexRecords();
  }
  setSources(docs = []) {
    this.docs = docs;
  }
  setIndexRecords(records = []) {
    this.records = records;
  }
  setKeys(keys2 = []) {
    this.keys = keys2;
    this._keysMap = {};
    keys2.forEach((key, idx) => {
      this._keysMap[key.id] = idx;
    });
  }
  create() {
    if (this.isCreated || !this.docs.length) {
      return;
    }
    this.isCreated = true;
    if (isString$2(this.docs[0])) {
      this.docs.forEach((doc2, docIndex) => {
        this._addString(doc2, docIndex);
      });
    } else {
      this.docs.forEach((doc2, docIndex) => {
        this._addObject(doc2, docIndex);
      });
    }
    this.norm.clear();
  }
  // Adds a doc to the end of the index
  add(doc2) {
    const idx = this.size();
    if (isString$2(doc2)) {
      this._addString(doc2, idx);
    } else {
      this._addObject(doc2, idx);
    }
  }
  // Removes the doc at the specified index of the index
  removeAt(idx) {
    this.records.splice(idx, 1);
    for (let i2 = idx, len = this.size(); i2 < len; i2 += 1) {
      this.records[i2].i -= 1;
    }
  }
  getValueForItemAtKeyId(item2, keyId) {
    return item2[this._keysMap[keyId]];
  }
  size() {
    return this.records.length;
  }
  _addString(doc2, docIndex) {
    if (!isDefined(doc2) || isBlank(doc2)) {
      return;
    }
    let record = {
      v: doc2,
      i: docIndex,
      n: this.norm.get(doc2)
    };
    this.records.push(record);
  }
  _addObject(doc2, docIndex) {
    let record = { i: docIndex, $: {} };
    this.keys.forEach((key, keyIndex) => {
      let value3 = key.getFn ? key.getFn(doc2) : this.getFn(doc2, key.path);
      if (!isDefined(value3)) {
        return;
      }
      if (isArray$1(value3)) {
        let subRecords = [];
        const stack2 = [{ nestedArrIndex: -1, value: value3 }];
        while (stack2.length) {
          const { nestedArrIndex, value: value4 } = stack2.pop();
          if (!isDefined(value4)) {
            continue;
          }
          if (isString$2(value4) && !isBlank(value4)) {
            let subRecord = {
              v: value4,
              i: nestedArrIndex,
              n: this.norm.get(value4)
            };
            subRecords.push(subRecord);
          } else if (isArray$1(value4)) {
            value4.forEach((item2, k) => {
              stack2.push({
                nestedArrIndex: k,
                value: item2
              });
            });
          } else ;
        }
        record.$[keyIndex] = subRecords;
      } else if (isString$2(value3) && !isBlank(value3)) {
        let subRecord = {
          v: value3,
          n: this.norm.get(value3)
        };
        record.$[keyIndex] = subRecord;
      }
    });
    this.records.push(record);
  }
  toJSON() {
    return {
      keys: this.keys,
      records: this.records
    };
  }
}
function createIndex(keys2, docs, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys2.map(createKey));
  myIndex.setSources(docs);
  myIndex.create();
  return myIndex;
}
__name(createIndex, "createIndex");
function parseIndex(data24, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const { keys: keys2, records } = data24;
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys2);
  myIndex.setIndexRecords(records);
  return myIndex;
}
__name(parseIndex, "parseIndex");
function computeScore$1(pattern, {
  errors = 0,
  currentLocation = 0,
  expectedLocation = 0,
  distance: distance2 = Config.distance,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  const accuracy = errors / pattern.length;
  if (ignoreLocation) {
    return accuracy;
  }
  const proximity = Math.abs(expectedLocation - currentLocation);
  if (!distance2) {
    return proximity ? 1 : accuracy;
  }
  return accuracy + proximity / distance2;
}
__name(computeScore$1, "computeScore$1");
function convertMaskToIndices(matchmask = [], minMatchCharLength = Config.minMatchCharLength) {
  let indices = [];
  let start2 = -1;
  let end = -1;
  let i2 = 0;
  for (let len = matchmask.length; i2 < len; i2 += 1) {
    let match = matchmask[i2];
    if (match && start2 === -1) {
      start2 = i2;
    } else if (!match && start2 !== -1) {
      end = i2 - 1;
      if (end - start2 + 1 >= minMatchCharLength) {
        indices.push([start2, end]);
      }
      start2 = -1;
    }
  }
  if (matchmask[i2 - 1] && i2 - start2 >= minMatchCharLength) {
    indices.push([start2, i2 - 1]);
  }
  return indices;
}
__name(convertMaskToIndices, "convertMaskToIndices");
const MAX_BITS = 32;
function search(text, pattern, patternAlphabet, {
  location: location2 = Config.location,
  distance: distance2 = Config.distance,
  threshold = Config.threshold,
  findAllMatches = Config.findAllMatches,
  minMatchCharLength = Config.minMatchCharLength,
  includeMatches = Config.includeMatches,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  if (pattern.length > MAX_BITS) {
    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
  }
  const patternLen = pattern.length;
  const textLen = text.length;
  const expectedLocation = Math.max(0, Math.min(location2, textLen));
  let currentThreshold = threshold;
  let bestLocation = expectedLocation;
  const computeMatches = minMatchCharLength > 1 || includeMatches;
  const matchMask = computeMatches ? Array(textLen) : [];
  let index2;
  while ((index2 = text.indexOf(pattern, bestLocation)) > -1) {
    let score = computeScore$1(pattern, {
      currentLocation: index2,
      expectedLocation,
      distance: distance2,
      ignoreLocation
    });
    currentThreshold = Math.min(score, currentThreshold);
    bestLocation = index2 + patternLen;
    if (computeMatches) {
      let i2 = 0;
      while (i2 < patternLen) {
        matchMask[index2 + i2] = 1;
        i2 += 1;
      }
    }
  }
  bestLocation = -1;
  let lastBitArr = [];
  let finalScore = 1;
  let binMax = patternLen + textLen;
  const mask3 = 1 << patternLen - 1;
  for (let i2 = 0; i2 < patternLen; i2 += 1) {
    let binMin = 0;
    let binMid = binMax;
    while (binMin < binMid) {
      const score2 = computeScore$1(pattern, {
        errors: i2,
        currentLocation: expectedLocation + binMid,
        expectedLocation,
        distance: distance2,
        ignoreLocation
      });
      if (score2 <= currentThreshold) {
        binMin = binMid;
      } else {
        binMax = binMid;
      }
      binMid = Math.floor((binMax - binMin) / 2 + binMin);
    }
    binMax = binMid;
    let start2 = Math.max(1, expectedLocation - binMid + 1);
    let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;
    let bitArr = Array(finish + 2);
    bitArr[finish + 1] = (1 << i2) - 1;
    for (let j = finish; j >= start2; j -= 1) {
      let currentLocation = j - 1;
      let charMatch = patternAlphabet[text.charAt(currentLocation)];
      if (computeMatches) {
        matchMask[currentLocation] = +!!charMatch;
      }
      bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;
      if (i2) {
        bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];
      }
      if (bitArr[j] & mask3) {
        finalScore = computeScore$1(pattern, {
          errors: i2,
          currentLocation,
          expectedLocation,
          distance: distance2,
          ignoreLocation
        });
        if (finalScore <= currentThreshold) {
          currentThreshold = finalScore;
          bestLocation = currentLocation;
          if (bestLocation <= expectedLocation) {
            break;
          }
          start2 = Math.max(1, 2 * expectedLocation - bestLocation);
        }
      }
    }
    const score = computeScore$1(pattern, {
      errors: i2 + 1,
      currentLocation: expectedLocation,
      expectedLocation,
      distance: distance2,
      ignoreLocation
    });
    if (score > currentThreshold) {
      break;
    }
    lastBitArr = bitArr;
  }
  const result = {
    isMatch: bestLocation >= 0,
    // Count exact matches (those with a score of 0) to be "almost" exact
    score: Math.max(1e-3, finalScore)
  };
  if (computeMatches) {
    const indices = convertMaskToIndices(matchMask, minMatchCharLength);
    if (!indices.length) {
      result.isMatch = false;
    } else if (includeMatches) {
      result.indices = indices;
    }
  }
  return result;
}
__name(search, "search");
function createPatternAlphabet(pattern) {
  let mask3 = {};
  for (let i2 = 0, len = pattern.length; i2 < len; i2 += 1) {
    const char = pattern.charAt(i2);
    mask3[char] = (mask3[char] || 0) | 1 << len - i2 - 1;
  }
  return mask3;
}
__name(createPatternAlphabet, "createPatternAlphabet");
class BitapSearch {
  static {
    __name(this, "BitapSearch");
  }
  constructor(pattern, {
    location: location2 = Config.location,
    threshold = Config.threshold,
    distance: distance2 = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    this.options = {
      location: location2,
      threshold,
      distance: distance2,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.chunks = [];
    if (!this.pattern.length) {
      return;
    }
    const addChunk = /* @__PURE__ */ __name((pattern2, startIndex) => {
      this.chunks.push({
        pattern: pattern2,
        alphabet: createPatternAlphabet(pattern2),
        startIndex
      });
    }, "addChunk");
    const len = this.pattern.length;
    if (len > MAX_BITS) {
      let i2 = 0;
      const remainder = len % MAX_BITS;
      const end = len - remainder;
      while (i2 < end) {
        addChunk(this.pattern.substr(i2, MAX_BITS), i2);
        i2 += MAX_BITS;
      }
      if (remainder) {
        const startIndex = len - MAX_BITS;
        addChunk(this.pattern.substr(startIndex), startIndex);
      }
    } else {
      addChunk(this.pattern, 0);
    }
  }
  searchIn(text) {
    const { isCaseSensitive, includeMatches } = this.options;
    if (!isCaseSensitive) {
      text = text.toLowerCase();
    }
    if (this.pattern === text) {
      let result2 = {
        isMatch: true,
        score: 0
      };
      if (includeMatches) {
        result2.indices = [[0, text.length - 1]];
      }
      return result2;
    }
    const {
      location: location2,
      distance: distance2,
      threshold,
      findAllMatches,
      minMatchCharLength,
      ignoreLocation
    } = this.options;
    let allIndices = [];
    let totalScore = 0;
    let hasMatches = false;
    this.chunks.forEach(({ pattern, alphabet, startIndex }) => {
      const { isMatch, score, indices } = search(text, pattern, alphabet, {
        location: location2 + startIndex,
        distance: distance2,
        threshold,
        findAllMatches,
        minMatchCharLength,
        includeMatches,
        ignoreLocation
      });
      if (isMatch) {
        hasMatches = true;
      }
      totalScore += score;
      if (isMatch && indices) {
        allIndices = [...allIndices, ...indices];
      }
    });
    let result = {
      isMatch: hasMatches,
      score: hasMatches ? totalScore / this.chunks.length : 1
    };
    if (hasMatches && includeMatches) {
      result.indices = allIndices;
    }
    return result;
  }
}
class BaseMatch {
  static {
    __name(this, "BaseMatch");
  }
  constructor(pattern) {
    this.pattern = pattern;
  }
  static isMultiMatch(pattern) {
    return getMatch(pattern, this.multiRegex);
  }
  static isSingleMatch(pattern) {
    return getMatch(pattern, this.singleRegex);
  }
  search() {
  }
}
function getMatch(pattern, exp) {
  const matches2 = pattern.match(exp);
  return matches2 ? matches2[1] : null;
}
__name(getMatch, "getMatch");
class ExactMatch extends BaseMatch {
  static {
    __name(this, "ExactMatch");
  }
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "exact";
  }
  static get multiRegex() {
    return /^="(.*)"$/;
  }
  static get singleRegex() {
    return /^=(.*)$/;
  }
  search(text) {
    const isMatch = text === this.pattern;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
}
class InverseExactMatch extends BaseMatch {
  static {
    __name(this, "InverseExactMatch");
  }
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"$/;
  }
  static get singleRegex() {
    return /^!(.*)$/;
  }
  search(text) {
    const index2 = text.indexOf(this.pattern);
    const isMatch = index2 === -1;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
}
class PrefixExactMatch extends BaseMatch {
  static {
    __name(this, "PrefixExactMatch");
  }
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "prefix-exact";
  }
  static get multiRegex() {
    return /^\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^\^(.*)$/;
  }
  search(text) {
    const isMatch = text.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
}
class InversePrefixExactMatch extends BaseMatch {
  static {
    __name(this, "InversePrefixExactMatch");
  }
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-prefix-exact";
  }
  static get multiRegex() {
    return /^!\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^!\^(.*)$/;
  }
  search(text) {
    const isMatch = !text.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
}
class SuffixExactMatch extends BaseMatch {
  static {
    __name(this, "SuffixExactMatch");
  }
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "suffix-exact";
  }
  static get multiRegex() {
    return /^"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^(.*)\$$/;
  }
  search(text) {
    const isMatch = text.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [text.length - this.pattern.length, text.length - 1]
    };
  }
}
class InverseSuffixExactMatch extends BaseMatch {
  static {
    __name(this, "InverseSuffixExactMatch");
  }
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-suffix-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^!(.*)\$$/;
  }
  search(text) {
    const isMatch = !text.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
}
class FuzzyMatch extends BaseMatch {
  static {
    __name(this, "FuzzyMatch");
  }
  constructor(pattern, {
    location: location2 = Config.location,
    threshold = Config.threshold,
    distance: distance2 = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    super(pattern);
    this._bitapSearch = new BitapSearch(pattern, {
      location: location2,
      threshold,
      distance: distance2,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    });
  }
  static get type() {
    return "fuzzy";
  }
  static get multiRegex() {
    return /^"(.*)"$/;
  }
  static get singleRegex() {
    return /^(.*)$/;
  }
  search(text) {
    return this._bitapSearch.searchIn(text);
  }
}
class IncludeMatch extends BaseMatch {
  static {
    __name(this, "IncludeMatch");
  }
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "include";
  }
  static get multiRegex() {
    return /^'"(.*)"$/;
  }
  static get singleRegex() {
    return /^'(.*)$/;
  }
  search(text) {
    let location2 = 0;
    let index2;
    const indices = [];
    const patternLen = this.pattern.length;
    while ((index2 = text.indexOf(this.pattern, location2)) > -1) {
      location2 = index2 + patternLen;
      indices.push([index2, location2 - 1]);
    }
    const isMatch = !!indices.length;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices
    };
  }
}
const searchers = [
  ExactMatch,
  IncludeMatch,
  PrefixExactMatch,
  InversePrefixExactMatch,
  InverseSuffixExactMatch,
  SuffixExactMatch,
  InverseExactMatch,
  FuzzyMatch
];
const searchersLen = searchers.length;
const SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
const OR_TOKEN = "|";
function parseQuery(pattern, options3 = {}) {
  return pattern.split(OR_TOKEN).map((item2) => {
    let query = item2.trim().split(SPACE_RE).filter((item3) => item3 && !!item3.trim());
    let results = [];
    for (let i2 = 0, len = query.length; i2 < len; i2 += 1) {
      const queryItem = query[i2];
      let found = false;
      let idx = -1;
      while (!found && ++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isMultiMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options3));
          found = true;
        }
      }
      if (found) {
        continue;
      }
      idx = -1;
      while (++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isSingleMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options3));
          break;
        }
      }
    }
    return results;
  });
}
__name(parseQuery, "parseQuery");
const MultiMatchSet = /* @__PURE__ */ new Set([FuzzyMatch.type, IncludeMatch.type]);
class ExtendedSearch {
  static {
    __name(this, "ExtendedSearch");
  }
  constructor(pattern, {
    isCaseSensitive = Config.isCaseSensitive,
    includeMatches = Config.includeMatches,
    minMatchCharLength = Config.minMatchCharLength,
    ignoreLocation = Config.ignoreLocation,
    findAllMatches = Config.findAllMatches,
    location: location2 = Config.location,
    threshold = Config.threshold,
    distance: distance2 = Config.distance
  } = {}) {
    this.query = null;
    this.options = {
      isCaseSensitive,
      includeMatches,
      minMatchCharLength,
      findAllMatches,
      ignoreLocation,
      location: location2,
      threshold,
      distance: distance2
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.query = parseQuery(this.pattern, this.options);
  }
  static condition(_2, options3) {
    return options3.useExtendedSearch;
  }
  searchIn(text) {
    const query = this.query;
    if (!query) {
      return {
        isMatch: false,
        score: 1
      };
    }
    const { includeMatches, isCaseSensitive } = this.options;
    text = isCaseSensitive ? text : text.toLowerCase();
    let numMatches = 0;
    let allIndices = [];
    let totalScore = 0;
    for (let i2 = 0, qLen = query.length; i2 < qLen; i2 += 1) {
      const searchers2 = query[i2];
      allIndices.length = 0;
      numMatches = 0;
      for (let j = 0, pLen = searchers2.length; j < pLen; j += 1) {
        const searcher = searchers2[j];
        const { isMatch, indices, score } = searcher.search(text);
        if (isMatch) {
          numMatches += 1;
          totalScore += score;
          if (includeMatches) {
            const type = searcher.constructor.type;
            if (MultiMatchSet.has(type)) {
              allIndices = [...allIndices, ...indices];
            } else {
              allIndices.push(indices);
            }
          }
        } else {
          totalScore = 0;
          numMatches = 0;
          allIndices.length = 0;
          break;
        }
      }
      if (numMatches) {
        let result = {
          isMatch: true,
          score: totalScore / numMatches
        };
        if (includeMatches) {
          result.indices = allIndices;
        }
        return result;
      }
    }
    return {
      isMatch: false,
      score: 1
    };
  }
}
const registeredSearchers = [];
function register$1(...args) {
  registeredSearchers.push(...args);
}
__name(register$1, "register$1");
function createSearcher(pattern, options3) {
  for (let i2 = 0, len = registeredSearchers.length; i2 < len; i2 += 1) {
    let searcherClass = registeredSearchers[i2];
    if (searcherClass.condition(pattern, options3)) {
      return new searcherClass(pattern, options3);
    }
  }
  return new BitapSearch(pattern, options3);
}
__name(createSearcher, "createSearcher");
const LogicalOperator = {
  AND: "$and",
  OR: "$or"
};
const KeyType = {
  PATH: "$path",
  PATTERN: "$val"
};
const isExpression = /* @__PURE__ */ __name((query) => !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]), "isExpression");
const isPath = /* @__PURE__ */ __name((query) => !!query[KeyType.PATH], "isPath");
const isLeaf = /* @__PURE__ */ __name((query) => !isArray$1(query) && isObject$2(query) && !isExpression(query), "isLeaf");
const convertToExplicit = /* @__PURE__ */ __name((query) => ({
  [LogicalOperator.AND]: Object.keys(query).map((key) => ({
    [key]: query[key]
  }))
}), "convertToExplicit");
function parse$1(query, options3, { auto = true } = {}) {
  const next2 = /* @__PURE__ */ __name((query2) => {
    let keys2 = Object.keys(query2);
    const isQueryPath = isPath(query2);
    if (!isQueryPath && keys2.length > 1 && !isExpression(query2)) {
      return next2(convertToExplicit(query2));
    }
    if (isLeaf(query2)) {
      const key = isQueryPath ? query2[KeyType.PATH] : keys2[0];
      const pattern = isQueryPath ? query2[KeyType.PATTERN] : query2[key];
      if (!isString$2(pattern)) {
        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));
      }
      const obj = {
        keyId: createKeyId(key),
        pattern
      };
      if (auto) {
        obj.searcher = createSearcher(pattern, options3);
      }
      return obj;
    }
    let node3 = {
      children: [],
      operator: keys2[0]
    };
    keys2.forEach((key) => {
      const value3 = query2[key];
      if (isArray$1(value3)) {
        value3.forEach((item2) => {
          node3.children.push(next2(item2));
        });
      }
    });
    return node3;
  }, "next");
  if (!isExpression(query)) {
    query = convertToExplicit(query);
  }
  return next2(query);
}
__name(parse$1, "parse$1");
function computeScore(results, { ignoreFieldNorm = Config.ignoreFieldNorm }) {
  results.forEach((result) => {
    let totalScore = 1;
    result.matches.forEach(({ key, norm: norm2, score }) => {
      const weight = key ? key.weight : null;
      totalScore *= Math.pow(
        score === 0 && weight ? Number.EPSILON : score,
        (weight || 1) * (ignoreFieldNorm ? 1 : norm2)
      );
    });
    result.score = totalScore;
  });
}
__name(computeScore, "computeScore");
function transformMatches(result, data24) {
  const matches2 = result.matches;
  data24.matches = [];
  if (!isDefined(matches2)) {
    return;
  }
  matches2.forEach((match) => {
    if (!isDefined(match.indices) || !match.indices.length) {
      return;
    }
    const { indices, value: value3 } = match;
    let obj = {
      indices,
      value: value3
    };
    if (match.key) {
      obj.key = match.key.src;
    }
    if (match.idx > -1) {
      obj.refIndex = match.idx;
    }
    data24.matches.push(obj);
  });
}
__name(transformMatches, "transformMatches");
function transformScore(result, data24) {
  data24.score = result.score;
}
__name(transformScore, "transformScore");
function format$3(results, docs, {
  includeMatches = Config.includeMatches,
  includeScore = Config.includeScore
} = {}) {
  const transformers = [];
  if (includeMatches) transformers.push(transformMatches);
  if (includeScore) transformers.push(transformScore);
  return results.map((result) => {
    const { idx } = result;
    const data24 = {
      item: docs[idx],
      refIndex: idx
    };
    if (transformers.length) {
      transformers.forEach((transformer) => {
        transformer(result, data24);
      });
    }
    return data24;
  });
}
__name(format$3, "format$3");
class Fuse {
  static {
    __name(this, "Fuse");
  }
  constructor(docs, options3 = {}, index2) {
    this.options = { ...Config, ...options3 };
    if (this.options.useExtendedSearch && false) {
      throw new Error(EXTENDED_SEARCH_UNAVAILABLE);
    }
    this._keyStore = new KeyStore(this.options.keys);
    this.setCollection(docs, index2);
  }
  setCollection(docs, index2) {
    this._docs = docs;
    if (index2 && !(index2 instanceof FuseIndex)) {
      throw new Error(INCORRECT_INDEX_TYPE);
    }
    this._myIndex = index2 || createIndex(this.options.keys, this._docs, {
      getFn: this.options.getFn,
      fieldNormWeight: this.options.fieldNormWeight
    });
  }
  add(doc2) {
    if (!isDefined(doc2)) {
      return;
    }
    this._docs.push(doc2);
    this._myIndex.add(doc2);
  }
  remove(predicate = () => false) {
    const results = [];
    for (let i2 = 0, len = this._docs.length; i2 < len; i2 += 1) {
      const doc2 = this._docs[i2];
      if (predicate(doc2, i2)) {
        this.removeAt(i2);
        i2 -= 1;
        len -= 1;
        results.push(doc2);
      }
    }
    return results;
  }
  removeAt(idx) {
    this._docs.splice(idx, 1);
    this._myIndex.removeAt(idx);
  }
  getIndex() {
    return this._myIndex;
  }
  search(query, { limit = -1 } = {}) {
    const {
      includeMatches,
      includeScore,
      shouldSort,
      sortFn,
      ignoreFieldNorm
    } = this.options;
    let results = isString$2(query) ? isString$2(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);
    computeScore(results, { ignoreFieldNorm });
    if (shouldSort) {
      results.sort(sortFn);
    }
    if (isNumber$1(limit) && limit > -1) {
      results = results.slice(0, limit);
    }
    return format$3(results, this._docs, {
      includeMatches,
      includeScore
    });
  }
  _searchStringList(query) {
    const searcher = createSearcher(query, this.options);
    const { records } = this._myIndex;
    const results = [];
    records.forEach(({ v: text, i: idx, n: norm2 }) => {
      if (!isDefined(text)) {
        return;
      }
      const { isMatch, score, indices } = searcher.searchIn(text);
      if (isMatch) {
        results.push({
          item: text,
          idx,
          matches: [{ score, value: text, norm: norm2, indices }]
        });
      }
    });
    return results;
  }
  _searchLogical(query) {
    const expression = parse$1(query, this.options);
    const evaluate = /* @__PURE__ */ __name((node3, item2, idx) => {
      if (!node3.children) {
        const { keyId, searcher } = node3;
        const matches2 = this._findMatches({
          key: this._keyStore.get(keyId),
          value: this._myIndex.getValueForItemAtKeyId(item2, keyId),
          searcher
        });
        if (matches2 && matches2.length) {
          return [
            {
              idx,
              item: item2,
              matches: matches2
            }
          ];
        }
        return [];
      }
      const res = [];
      for (let i2 = 0, len = node3.children.length; i2 < len; i2 += 1) {
        const child = node3.children[i2];
        const result = evaluate(child, item2, idx);
        if (result.length) {
          res.push(...result);
        } else if (node3.operator === LogicalOperator.AND) {
          return [];
        }
      }
      return res;
    }, "evaluate");
    const records = this._myIndex.records;
    const resultMap = {};
    const results = [];
    records.forEach(({ $: item2, i: idx }) => {
      if (isDefined(item2)) {
        let expResults = evaluate(expression, item2, idx);
        if (expResults.length) {
          if (!resultMap[idx]) {
            resultMap[idx] = { idx, item: item2, matches: [] };
            results.push(resultMap[idx]);
          }
          expResults.forEach(({ matches: matches2 }) => {
            resultMap[idx].matches.push(...matches2);
          });
        }
      }
    });
    return results;
  }
  _searchObjectList(query) {
    const searcher = createSearcher(query, this.options);
    const { keys: keys2, records } = this._myIndex;
    const results = [];
    records.forEach(({ $: item2, i: idx }) => {
      if (!isDefined(item2)) {
        return;
      }
      let matches2 = [];
      keys2.forEach((key, keyIndex) => {
        matches2.push(
          ...this._findMatches({
            key,
            value: item2[keyIndex],
            searcher
          })
        );
      });
      if (matches2.length) {
        results.push({
          idx,
          item: item2,
          matches: matches2
        });
      }
    });
    return results;
  }
  _findMatches({ key, value: value3, searcher }) {
    if (!isDefined(value3)) {
      return [];
    }
    let matches2 = [];
    if (isArray$1(value3)) {
      value3.forEach(({ v: text, i: idx, n: norm2 }) => {
        if (!isDefined(text)) {
          return;
        }
        const { isMatch, score, indices } = searcher.searchIn(text);
        if (isMatch) {
          matches2.push({
            score,
            key,
            value: text,
            idx,
            norm: norm2,
            indices
          });
        }
      });
    } else {
      const { v: text, n: norm2 } = value3;
      const { isMatch, score, indices } = searcher.searchIn(text);
      if (isMatch) {
        matches2.push({ score, key, value: text, norm: norm2, indices });
      }
    }
    return matches2;
  }
}
Fuse.version = "7.0.0";
Fuse.createIndex = createIndex;
Fuse.parseIndex = parseIndex;
Fuse.config = Config;
{
  Fuse.parseQuery = parse$1;
}
{
  register$1(ExtendedSearch);
}
class FuseSearch {
  static {
    __name(this, "FuseSearch");
  }
  fuse;
  keys;
  data;
  advancedScoring;
  constructor(data24, options3, createIndex2 = true, advancedScoring = false) {
    this.data = data24;
    this.keys = options3.keys ?? [];
    this.advancedScoring = advancedScoring;
    const index2 = createIndex2 && options3?.keys ? Fuse.createIndex(options3.keys, data24) : void 0;
    this.fuse = new Fuse(data24, options3, index2);
  }
  search(query, options3) {
    if (!query || query === "") {
      return [...this.data];
    }
    const fuseResult = this.fuse.search(query, options3);
    if (!this.advancedScoring) {
      return fuseResult.map((x2) => x2.item);
    }
    const aux = fuseResult.map((x2) => ({
      item: x2.item,
      scores: this.calcAuxScores(query.toLocaleLowerCase(), x2.item, x2.score)
    })).sort((a, b) => this.compareAux(a.scores, b.scores));
    return aux.map((x2) => x2.item);
  }
  calcAuxScores(query, entry, score) {
    let values2 = [];
    if (!this.keys.length) values2 = [entry];
    else values2 = this.keys.map((x2) => entry[x2]);
    const scores = values2.map((x2) => this.calcAuxSingle(query, x2, score));
    const result = scores.sort(this.compareAux)[0];
    const deprecated = values2.some(
      (x2) => x2.toLocaleLowerCase().includes("deprecated")
    );
    result[0] += deprecated && result[0] != 0 ? 5 : 0;
    return result;
  }
  calcAuxSingle(query, item2, score) {
    const itemWords = item2.split(/ |\b|(?<=[a-z])(?=[A-Z])|(?=[A-Z][a-z])/).map((x2) => x2.toLocaleLowerCase());
    const queryParts = query.split(" ");
    item2 = item2.toLocaleLowerCase();
    let main = 9;
    let aux1 = 0;
    let aux2 = 0;
    if (item2 == query) {
      main = 0;
    } else if (item2.startsWith(query)) {
      main = 1;
      aux2 = item2.length;
    } else if (itemWords.includes(query)) {
      main = 2;
      aux1 = item2.indexOf(query) + item2.length * 0.5;
      aux2 = item2.length;
    } else if (item2.includes(query)) {
      main = 3;
      aux1 = item2.indexOf(query) + item2.length * 0.5;
      aux2 = item2.length;
    } else if (queryParts.every((x2) => itemWords.includes(x2))) {
      const indexes = queryParts.map((x2) => itemWords.indexOf(x2));
      const min = Math.min(...indexes);
      const max = Math.max(...indexes);
      main = 4;
      aux1 = max - min + max * 0.5 + item2.length * 0.5;
      aux2 = item2.length;
    } else if (queryParts.every((x2) => item2.includes(x2))) {
      const min = Math.min(...queryParts.map((x2) => item2.indexOf(x2)));
      const max = Math.max(...queryParts.map((x2) => item2.indexOf(x2) + x2.length));
      main = 5;
      aux1 = max - min + max * 0.5 + item2.length * 0.5;
      aux2 = item2.length;
    }
    const lengthPenalty = 0.2 * (1 - Math.min(item2.length, query.length) / Math.max(item2.length, query.length));
    return [main, aux1, aux2, score + lengthPenalty];
  }
  compareAux(a, b) {
    return a[0] - b[0] || a[1] - b[1] || a[2] - b[2] || a[3] - b[3];
  }
}
class NodeFilter {
  static {
    __name(this, "NodeFilter");
  }
  fuseSearch;
  constructor(nodeDefs, options3) {
    this.fuseSearch = new FuseSearch(this.getAllNodeOptions(nodeDefs), options3);
  }
  getAllNodeOptions(nodeDefs) {
    return [
      ...new Set(
        nodeDefs.reduce((acc, nodeDef) => {
          return [...acc, ...this.getNodeOptions(nodeDef)];
        }, [])
      )
    ];
  }
  matches(node3, value3, extraOptions) {
    const matchWildcards = extraOptions?.matchWildcards !== false;
    if (matchWildcards && value3 === "*") {
      return true;
    }
    const options3 = this.getNodeOptions(node3);
    return options3.includes(value3) || matchWildcards && _.some(options3, (option4) => option4 === "*");
  }
}
class InputTypeFilter extends NodeFilter {
  static {
    __name(this, "InputTypeFilter");
  }
  id = "input";
  name = "Input Type";
  invokeSequence = "i";
  longInvokeSequence = "input";
  getNodeOptions(node3) {
    return node3.input.all.map((input) => input.type);
  }
}
class OutputTypeFilter extends NodeFilter {
  static {
    __name(this, "OutputTypeFilter");
  }
  id = "output";
  name = "Output Type";
  invokeSequence = "o";
  longInvokeSequence = "output";
  getNodeOptions(node3) {
    return node3.output.all.map((output) => output.type);
  }
}
class NodeSourceFilter extends NodeFilter {
  static {
    __name(this, "NodeSourceFilter");
  }
  id = "source";
  name = "Source";
  invokeSequence = "s";
  longInvokeSequence = "source";
  getNodeOptions(node3) {
    return [getNodeSource(node3.python_module).displayText];
  }
}
class NodeCategoryFilter extends NodeFilter {
  static {
    __name(this, "NodeCategoryFilter");
  }
  id = "category";
  name = "Category";
  invokeSequence = "c";
  longInvokeSequence = "category";
  getNodeOptions(node3) {
    return [node3.category];
  }
}
class NodeSearchService {
  static {
    __name(this, "NodeSearchService");
  }
  nodeFuseSearch;
  nodeFilters;
  constructor(data24) {
    this.nodeFuseSearch = new FuseSearch(
      data24,
      {
        keys: ["name", "display_name"],
        includeScore: true,
        threshold: 0.3,
        shouldSort: false,
        useExtendedSearch: true
      },
      true,
      true
    );
    const filterSearchOptions = {
      includeScore: true,
      threshold: 0.3,
      shouldSort: true
    };
    this.nodeFilters = [
      new InputTypeFilter(data24, filterSearchOptions),
      new OutputTypeFilter(data24, filterSearchOptions),
      new NodeCategoryFilter(data24, filterSearchOptions)
    ];
    if (data24[0].python_module !== void 0) {
      this.nodeFilters.push(new NodeSourceFilter(data24, filterSearchOptions));
    }
  }
  endsWithFilterStartSequence(query) {
    return query.endsWith(":");
  }
  searchNode(query, filters = [], options3, extraOptions) {
    const matchedNodes = this.nodeFuseSearch.search(query);
    const results = matchedNodes.filter((node3) => {
      return _.every(filters, (filterAndValue) => {
        const [filter4, value3] = filterAndValue;
        return filter4.matches(node3, value3, extraOptions);
      });
    });
    return options3?.limit ? results.slice(0, options3.limit) : results;
  }
  getFilterById(id2) {
    return this.nodeFilters.find((filter4) => filter4.id === id2);
  }
}
var TransformationType;
(function(TransformationType2) {
  TransformationType2[TransformationType2["PLAIN_TO_CLASS"] = 0] = "PLAIN_TO_CLASS";
  TransformationType2[TransformationType2["CLASS_TO_PLAIN"] = 1] = "CLASS_TO_PLAIN";
  TransformationType2[TransformationType2["CLASS_TO_CLASS"] = 2] = "CLASS_TO_CLASS";
})(TransformationType || (TransformationType = {}));
var MetadataStorage = (
  /** @class */
  function() {
    function MetadataStorage2() {
      this._typeMetadatas = /* @__PURE__ */ new Map();
      this._transformMetadatas = /* @__PURE__ */ new Map();
      this._exposeMetadatas = /* @__PURE__ */ new Map();
      this._excludeMetadatas = /* @__PURE__ */ new Map();
      this._ancestorsMap = /* @__PURE__ */ new Map();
    }
    __name(MetadataStorage2, "MetadataStorage");
    MetadataStorage2.prototype.addTypeMetadata = function(metadata) {
      if (!this._typeMetadatas.has(metadata.target)) {
        this._typeMetadatas.set(metadata.target, /* @__PURE__ */ new Map());
      }
      this._typeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);
    };
    MetadataStorage2.prototype.addTransformMetadata = function(metadata) {
      if (!this._transformMetadatas.has(metadata.target)) {
        this._transformMetadatas.set(metadata.target, /* @__PURE__ */ new Map());
      }
      if (!this._transformMetadatas.get(metadata.target).has(metadata.propertyName)) {
        this._transformMetadatas.get(metadata.target).set(metadata.propertyName, []);
      }
      this._transformMetadatas.get(metadata.target).get(metadata.propertyName).push(metadata);
    };
    MetadataStorage2.prototype.addExposeMetadata = function(metadata) {
      if (!this._exposeMetadatas.has(metadata.target)) {
        this._exposeMetadatas.set(metadata.target, /* @__PURE__ */ new Map());
      }
      this._exposeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);
    };
    MetadataStorage2.prototype.addExcludeMetadata = function(metadata) {
      if (!this._excludeMetadatas.has(metadata.target)) {
        this._excludeMetadatas.set(metadata.target, /* @__PURE__ */ new Map());
      }
      this._excludeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);
    };
    MetadataStorage2.prototype.findTransformMetadatas = function(target, propertyName, transformationType) {
      return this.findMetadatas(this._transformMetadatas, target, propertyName).filter(function(metadata) {
        if (!metadata.options)
          return true;
        if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true)
          return true;
        if (metadata.options.toClassOnly === true) {
          return transformationType === TransformationType.CLASS_TO_CLASS || transformationType === TransformationType.PLAIN_TO_CLASS;
        }
        if (metadata.options.toPlainOnly === true) {
          return transformationType === TransformationType.CLASS_TO_PLAIN;
        }
        return true;
      });
    };
    MetadataStorage2.prototype.findExcludeMetadata = function(target, propertyName) {
      return this.findMetadata(this._excludeMetadatas, target, propertyName);
    };
    MetadataStorage2.prototype.findExposeMetadata = function(target, propertyName) {
      return this.findMetadata(this._exposeMetadatas, target, propertyName);
    };
    MetadataStorage2.prototype.findExposeMetadataByCustomName = function(target, name) {
      return this.getExposedMetadatas(target).find(function(metadata) {
        return metadata.options && metadata.options.name === name;
      });
    };
    MetadataStorage2.prototype.findTypeMetadata = function(target, propertyName) {
      return this.findMetadata(this._typeMetadatas, target, propertyName);
    };
    MetadataStorage2.prototype.getStrategy = function(target) {
      var excludeMap = this._excludeMetadatas.get(target);
      var exclude = excludeMap && excludeMap.get(void 0);
      var exposeMap = this._exposeMetadatas.get(target);
      var expose = exposeMap && exposeMap.get(void 0);
      if (exclude && expose || !exclude && !expose)
        return "none";
      return exclude ? "excludeAll" : "exposeAll";
    };
    MetadataStorage2.prototype.getExposedMetadatas = function(target) {
      return this.getMetadata(this._exposeMetadatas, target);
    };
    MetadataStorage2.prototype.getExcludedMetadatas = function(target) {
      return this.getMetadata(this._excludeMetadatas, target);
    };
    MetadataStorage2.prototype.getExposedProperties = function(target, transformationType) {
      return this.getExposedMetadatas(target).filter(function(metadata) {
        if (!metadata.options)
          return true;
        if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true)
          return true;
        if (metadata.options.toClassOnly === true) {
          return transformationType === TransformationType.CLASS_TO_CLASS || transformationType === TransformationType.PLAIN_TO_CLASS;
        }
        if (metadata.options.toPlainOnly === true) {
          return transformationType === TransformationType.CLASS_TO_PLAIN;
        }
        return true;
      }).map(function(metadata) {
        return metadata.propertyName;
      });
    };
    MetadataStorage2.prototype.getExcludedProperties = function(target, transformationType) {
      return this.getExcludedMetadatas(target).filter(function(metadata) {
        if (!metadata.options)
          return true;
        if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true)
          return true;
        if (metadata.options.toClassOnly === true) {
          return transformationType === TransformationType.CLASS_TO_CLASS || transformationType === TransformationType.PLAIN_TO_CLASS;
        }
        if (metadata.options.toPlainOnly === true) {
          return transformationType === TransformationType.CLASS_TO_PLAIN;
        }
        return true;
      }).map(function(metadata) {
        return metadata.propertyName;
      });
    };
    MetadataStorage2.prototype.clear = function() {
      this._typeMetadatas.clear();
      this._exposeMetadatas.clear();
      this._excludeMetadatas.clear();
      this._ancestorsMap.clear();
    };
    MetadataStorage2.prototype.getMetadata = function(metadatas, target) {
      var metadataFromTargetMap = metadatas.get(target);
      var metadataFromTarget;
      if (metadataFromTargetMap) {
        metadataFromTarget = Array.from(metadataFromTargetMap.values()).filter(function(meta) {
          return meta.propertyName !== void 0;
        });
      }
      var metadataFromAncestors = [];
      for (var _i = 0, _a = this.getAncestors(target); _i < _a.length; _i++) {
        var ancestor = _a[_i];
        var ancestorMetadataMap = metadatas.get(ancestor);
        if (ancestorMetadataMap) {
          var metadataFromAncestor = Array.from(ancestorMetadataMap.values()).filter(function(meta) {
            return meta.propertyName !== void 0;
          });
          metadataFromAncestors.push.apply(metadataFromAncestors, metadataFromAncestor);
        }
      }
      return metadataFromAncestors.concat(metadataFromTarget || []);
    };
    MetadataStorage2.prototype.findMetadata = function(metadatas, target, propertyName) {
      var metadataFromTargetMap = metadatas.get(target);
      if (metadataFromTargetMap) {
        var metadataFromTarget = metadataFromTargetMap.get(propertyName);
        if (metadataFromTarget) {
          return metadataFromTarget;
        }
      }
      for (var _i = 0, _a = this.getAncestors(target); _i < _a.length; _i++) {
        var ancestor = _a[_i];
        var ancestorMetadataMap = metadatas.get(ancestor);
        if (ancestorMetadataMap) {
          var ancestorResult = ancestorMetadataMap.get(propertyName);
          if (ancestorResult) {
            return ancestorResult;
          }
        }
      }
      return void 0;
    };
    MetadataStorage2.prototype.findMetadatas = function(metadatas, target, propertyName) {
      var metadataFromTargetMap = metadatas.get(target);
      var metadataFromTarget;
      if (metadataFromTargetMap) {
        metadataFromTarget = metadataFromTargetMap.get(propertyName);
      }
      var metadataFromAncestorsTarget = [];
      for (var _i = 0, _a = this.getAncestors(target); _i < _a.length; _i++) {
        var ancestor = _a[_i];
        var ancestorMetadataMap = metadatas.get(ancestor);
        if (ancestorMetadataMap) {
          if (ancestorMetadataMap.has(propertyName)) {
            metadataFromAncestorsTarget.push.apply(metadataFromAncestorsTarget, ancestorMetadataMap.get(propertyName));
          }
        }
      }
      return metadataFromAncestorsTarget.slice().reverse().concat((metadataFromTarget || []).slice().reverse());
    };
    MetadataStorage2.prototype.getAncestors = function(target) {
      if (!target)
        return [];
      if (!this._ancestorsMap.has(target)) {
        var ancestors = [];
        for (var baseClass = Object.getPrototypeOf(target.prototype.constructor); typeof baseClass.prototype !== "undefined"; baseClass = Object.getPrototypeOf(baseClass.prototype.constructor)) {
          ancestors.push(baseClass);
        }
        this._ancestorsMap.set(target, ancestors);
      }
      return this._ancestorsMap.get(target);
    };
    return MetadataStorage2;
  }()
);
var defaultMetadataStorage = new MetadataStorage();
function getGlobal() {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof self !== "undefined") {
    return self;
  }
}
__name(getGlobal, "getGlobal");
function isPromise$1(p2) {
  return p2 !== null && typeof p2 === "object" && typeof p2.then === "function";
}
__name(isPromise$1, "isPromise$1");
var __spreadArray = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
    if (ar || !(i2 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
      ar[i2] = from[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function instantiateArrayType(arrayType2) {
  var array = new arrayType2();
  if (!(array instanceof Set) && !("push" in array)) {
    return [];
  }
  return array;
}
__name(instantiateArrayType, "instantiateArrayType");
var TransformOperationExecutor = (
  /** @class */
  function() {
    function TransformOperationExecutor2(transformationType, options3) {
      this.transformationType = transformationType;
      this.options = options3;
      this.recursionStack = /* @__PURE__ */ new Set();
    }
    __name(TransformOperationExecutor2, "TransformOperationExecutor");
    TransformOperationExecutor2.prototype.transform = function(source, value3, targetType, arrayType2, isMap2, level) {
      var _this = this;
      if (level === void 0) {
        level = 0;
      }
      if (Array.isArray(value3) || value3 instanceof Set) {
        var newValue_1 = arrayType2 && this.transformationType === TransformationType.PLAIN_TO_CLASS ? instantiateArrayType(arrayType2) : [];
        value3.forEach(function(subValue, index2) {
          var subSource = source ? source[index2] : void 0;
          if (!_this.options.enableCircularCheck || !_this.isCircular(subValue)) {
            var realTargetType = void 0;
            if (typeof targetType !== "function" && targetType && targetType.options && targetType.options.discriminator && targetType.options.discriminator.property && targetType.options.discriminator.subTypes) {
              if (_this.transformationType === TransformationType.PLAIN_TO_CLASS) {
                realTargetType = targetType.options.discriminator.subTypes.find(function(subType) {
                  return subType.name === subValue[targetType.options.discriminator.property];
                });
                var options3 = { newObject: newValue_1, object: subValue, property: void 0 };
                var newType = targetType.typeFunction(options3);
                realTargetType === void 0 ? realTargetType = newType : realTargetType = realTargetType.value;
                if (!targetType.options.keepDiscriminatorProperty)
                  delete subValue[targetType.options.discriminator.property];
              }
              if (_this.transformationType === TransformationType.CLASS_TO_CLASS) {
                realTargetType = subValue.constructor;
              }
              if (_this.transformationType === TransformationType.CLASS_TO_PLAIN) {
                subValue[targetType.options.discriminator.property] = targetType.options.discriminator.subTypes.find(function(subType) {
                  return subType.value === subValue.constructor;
                }).name;
              }
            } else {
              realTargetType = targetType;
            }
            var value_1 = _this.transform(subSource, subValue, realTargetType, void 0, subValue instanceof Map, level + 1);
            if (newValue_1 instanceof Set) {
              newValue_1.add(value_1);
            } else {
              newValue_1.push(value_1);
            }
          } else if (_this.transformationType === TransformationType.CLASS_TO_CLASS) {
            if (newValue_1 instanceof Set) {
              newValue_1.add(subValue);
            } else {
              newValue_1.push(subValue);
            }
          }
        });
        return newValue_1;
      } else if (targetType === String && !isMap2) {
        if (value3 === null || value3 === void 0)
          return value3;
        return String(value3);
      } else if (targetType === Number && !isMap2) {
        if (value3 === null || value3 === void 0)
          return value3;
        return Number(value3);
      } else if (targetType === Boolean && !isMap2) {
        if (value3 === null || value3 === void 0)
          return value3;
        return Boolean(value3);
      } else if ((targetType === Date || value3 instanceof Date) && !isMap2) {
        if (value3 instanceof Date) {
          return new Date(value3.valueOf());
        }
        if (value3 === null || value3 === void 0)
          return value3;
        return new Date(value3);
      } else if (!!getGlobal().Buffer && (targetType === Buffer || value3 instanceof Buffer) && !isMap2) {
        if (value3 === null || value3 === void 0)
          return value3;
        return Buffer.from(value3);
      } else if (isPromise$1(value3) && !isMap2) {
        return new Promise(function(resolve8, reject2) {
          value3.then(function(data24) {
            return resolve8(_this.transform(void 0, data24, targetType, void 0, void 0, level + 1));
          }, reject2);
        });
      } else if (!isMap2 && value3 !== null && typeof value3 === "object" && typeof value3.then === "function") {
        return value3;
      } else if (typeof value3 === "object" && value3 !== null) {
        if (!targetType && value3.constructor !== Object)
          if (!Array.isArray(value3) && value3.constructor === Array) {
          } else {
            targetType = value3.constructor;
          }
        if (!targetType && source)
          targetType = source.constructor;
        if (this.options.enableCircularCheck) {
          this.recursionStack.add(value3);
        }
        var keys2 = this.getKeys(targetType, value3, isMap2);
        var newValue = source ? source : {};
        if (!source && (this.transformationType === TransformationType.PLAIN_TO_CLASS || this.transformationType === TransformationType.CLASS_TO_CLASS)) {
          if (isMap2) {
            newValue = /* @__PURE__ */ new Map();
          } else if (targetType) {
            newValue = new targetType();
          } else {
            newValue = {};
          }
        }
        var _loop_1 = /* @__PURE__ */ __name(function(key2) {
          if (key2 === "__proto__" || key2 === "constructor") {
            return "continue";
          }
          var valueKey = key2;
          var newValueKey = key2, propertyName = key2;
          if (!this_1.options.ignoreDecorators && targetType) {
            if (this_1.transformationType === TransformationType.PLAIN_TO_CLASS) {
              var exposeMetadata = defaultMetadataStorage.findExposeMetadataByCustomName(targetType, key2);
              if (exposeMetadata) {
                propertyName = exposeMetadata.propertyName;
                newValueKey = exposeMetadata.propertyName;
              }
            } else if (this_1.transformationType === TransformationType.CLASS_TO_PLAIN || this_1.transformationType === TransformationType.CLASS_TO_CLASS) {
              var exposeMetadata = defaultMetadataStorage.findExposeMetadata(targetType, key2);
              if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {
                newValueKey = exposeMetadata.options.name;
              }
            }
          }
          var subValue = void 0;
          if (this_1.transformationType === TransformationType.PLAIN_TO_CLASS) {
            subValue = value3[valueKey];
          } else {
            if (value3 instanceof Map) {
              subValue = value3.get(valueKey);
            } else if (value3[valueKey] instanceof Function) {
              subValue = value3[valueKey]();
            } else {
              subValue = value3[valueKey];
            }
          }
          var type = void 0, isSubValueMap = subValue instanceof Map;
          if (targetType && isMap2) {
            type = targetType;
          } else if (targetType) {
            var metadata_1 = defaultMetadataStorage.findTypeMetadata(targetType, propertyName);
            if (metadata_1) {
              var options3 = { newObject: newValue, object: value3, property: propertyName };
              var newType = metadata_1.typeFunction ? metadata_1.typeFunction(options3) : metadata_1.reflectedType;
              if (metadata_1.options && metadata_1.options.discriminator && metadata_1.options.discriminator.property && metadata_1.options.discriminator.subTypes) {
                if (!(value3[valueKey] instanceof Array)) {
                  if (this_1.transformationType === TransformationType.PLAIN_TO_CLASS) {
                    type = metadata_1.options.discriminator.subTypes.find(function(subType) {
                      if (subValue && subValue instanceof Object && metadata_1.options.discriminator.property in subValue) {
                        return subType.name === subValue[metadata_1.options.discriminator.property];
                      }
                    });
                    type === void 0 ? type = newType : type = type.value;
                    if (!metadata_1.options.keepDiscriminatorProperty) {
                      if (subValue && subValue instanceof Object && metadata_1.options.discriminator.property in subValue) {
                        delete subValue[metadata_1.options.discriminator.property];
                      }
                    }
                  }
                  if (this_1.transformationType === TransformationType.CLASS_TO_CLASS) {
                    type = subValue.constructor;
                  }
                  if (this_1.transformationType === TransformationType.CLASS_TO_PLAIN) {
                    if (subValue) {
                      subValue[metadata_1.options.discriminator.property] = metadata_1.options.discriminator.subTypes.find(function(subType) {
                        return subType.value === subValue.constructor;
                      }).name;
                    }
                  }
                } else {
                  type = metadata_1;
                }
              } else {
                type = newType;
              }
              isSubValueMap = isSubValueMap || metadata_1.reflectedType === Map;
            } else if (this_1.options.targetMaps) {
              this_1.options.targetMaps.filter(function(map2) {
                return map2.target === targetType && !!map2.properties[propertyName];
              }).forEach(function(map2) {
                return type = map2.properties[propertyName];
              });
            } else if (this_1.options.enableImplicitConversion && this_1.transformationType === TransformationType.PLAIN_TO_CLASS) {
              var reflectedType = Reflect.getMetadata("design:type", targetType.prototype, propertyName);
              if (reflectedType) {
                type = reflectedType;
              }
            }
          }
          var arrayType_1 = Array.isArray(value3[valueKey]) ? this_1.getReflectedType(targetType, propertyName) : void 0;
          var subSource = source ? source[valueKey] : void 0;
          if (newValue.constructor.prototype) {
            var descriptor = Object.getOwnPropertyDescriptor(newValue.constructor.prototype, newValueKey);
            if ((this_1.transformationType === TransformationType.PLAIN_TO_CLASS || this_1.transformationType === TransformationType.CLASS_TO_CLASS) && // eslint-disable-next-line @typescript-eslint/unbound-method
            (descriptor && !descriptor.set || newValue[newValueKey] instanceof Function))
              return "continue";
          }
          if (!this_1.options.enableCircularCheck || !this_1.isCircular(subValue)) {
            var transformKey = this_1.transformationType === TransformationType.PLAIN_TO_CLASS ? newValueKey : key2;
            var finalValue = void 0;
            if (this_1.transformationType === TransformationType.CLASS_TO_PLAIN) {
              finalValue = value3[transformKey];
              finalValue = this_1.applyCustomTransformations(finalValue, targetType, transformKey, value3, this_1.transformationType);
              finalValue = value3[transformKey] === finalValue ? subValue : finalValue;
              finalValue = this_1.transform(subSource, finalValue, type, arrayType_1, isSubValueMap, level + 1);
            } else {
              if (subValue === void 0 && this_1.options.exposeDefaultValues) {
                finalValue = newValue[newValueKey];
              } else {
                finalValue = this_1.transform(subSource, subValue, type, arrayType_1, isSubValueMap, level + 1);
                finalValue = this_1.applyCustomTransformations(finalValue, targetType, transformKey, value3, this_1.transformationType);
              }
            }
            if (finalValue !== void 0 || this_1.options.exposeUnsetFields) {
              if (newValue instanceof Map) {
                newValue.set(newValueKey, finalValue);
              } else {
                newValue[newValueKey] = finalValue;
              }
            }
          } else if (this_1.transformationType === TransformationType.CLASS_TO_CLASS) {
            var finalValue = subValue;
            finalValue = this_1.applyCustomTransformations(finalValue, targetType, key2, value3, this_1.transformationType);
            if (finalValue !== void 0 || this_1.options.exposeUnsetFields) {
              if (newValue instanceof Map) {
                newValue.set(newValueKey, finalValue);
              } else {
                newValue[newValueKey] = finalValue;
              }
            }
          }
        }, "_loop_1");
        var this_1 = this;
        for (var _i = 0, keys_1 = keys2; _i < keys_1.length; _i++) {
          var key = keys_1[_i];
          _loop_1(key);
        }
        if (this.options.enableCircularCheck) {
          this.recursionStack.delete(value3);
        }
        return newValue;
      } else {
        return value3;
      }
    };
    TransformOperationExecutor2.prototype.applyCustomTransformations = function(value3, target, key, obj, transformationType) {
      var _this = this;
      var metadatas = defaultMetadataStorage.findTransformMetadatas(target, key, this.transformationType);
      if (this.options.version !== void 0) {
        metadatas = metadatas.filter(function(metadata) {
          if (!metadata.options)
            return true;
          return _this.checkVersion(metadata.options.since, metadata.options.until);
        });
      }
      if (this.options.groups && this.options.groups.length) {
        metadatas = metadatas.filter(function(metadata) {
          if (!metadata.options)
            return true;
          return _this.checkGroups(metadata.options.groups);
        });
      } else {
        metadatas = metadatas.filter(function(metadata) {
          return !metadata.options || !metadata.options.groups || !metadata.options.groups.length;
        });
      }
      metadatas.forEach(function(metadata) {
        value3 = metadata.transformFn({ value: value3, key, obj, type: transformationType, options: _this.options });
      });
      return value3;
    };
    TransformOperationExecutor2.prototype.isCircular = function(object) {
      return this.recursionStack.has(object);
    };
    TransformOperationExecutor2.prototype.getReflectedType = function(target, propertyName) {
      if (!target)
        return void 0;
      var meta = defaultMetadataStorage.findTypeMetadata(target, propertyName);
      return meta ? meta.reflectedType : void 0;
    };
    TransformOperationExecutor2.prototype.getKeys = function(target, object, isMap2) {
      var _this = this;
      var strategy = defaultMetadataStorage.getStrategy(target);
      if (strategy === "none")
        strategy = this.options.strategy || "exposeAll";
      var keys2 = [];
      if (strategy === "exposeAll" || isMap2) {
        if (object instanceof Map) {
          keys2 = Array.from(object.keys());
        } else {
          keys2 = Object.keys(object);
        }
      }
      if (isMap2) {
        return keys2;
      }
      if (this.options.ignoreDecorators && this.options.excludeExtraneousValues && target) {
        var exposedProperties = defaultMetadataStorage.getExposedProperties(target, this.transformationType);
        var excludedProperties = defaultMetadataStorage.getExcludedProperties(target, this.transformationType);
        keys2 = __spreadArray(__spreadArray([], exposedProperties, true), excludedProperties, true);
      }
      if (!this.options.ignoreDecorators && target) {
        var exposedProperties = defaultMetadataStorage.getExposedProperties(target, this.transformationType);
        if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {
          exposedProperties = exposedProperties.map(function(key) {
            var exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);
            if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {
              return exposeMetadata.options.name;
            }
            return key;
          });
        }
        if (this.options.excludeExtraneousValues) {
          keys2 = exposedProperties;
        } else {
          keys2 = keys2.concat(exposedProperties);
        }
        var excludedProperties_1 = defaultMetadataStorage.getExcludedProperties(target, this.transformationType);
        if (excludedProperties_1.length > 0) {
          keys2 = keys2.filter(function(key) {
            return !excludedProperties_1.includes(key);
          });
        }
        if (this.options.version !== void 0) {
          keys2 = keys2.filter(function(key) {
            var exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);
            if (!exposeMetadata || !exposeMetadata.options)
              return true;
            return _this.checkVersion(exposeMetadata.options.since, exposeMetadata.options.until);
          });
        }
        if (this.options.groups && this.options.groups.length) {
          keys2 = keys2.filter(function(key) {
            var exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);
            if (!exposeMetadata || !exposeMetadata.options)
              return true;
            return _this.checkGroups(exposeMetadata.options.groups);
          });
        } else {
          keys2 = keys2.filter(function(key) {
            var exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);
            return !exposeMetadata || !exposeMetadata.options || !exposeMetadata.options.groups || !exposeMetadata.options.groups.length;
          });
        }
      }
      if (this.options.excludePrefixes && this.options.excludePrefixes.length) {
        keys2 = keys2.filter(function(key) {
          return _this.options.excludePrefixes.every(function(prefix2) {
            return key.substr(0, prefix2.length) !== prefix2;
          });
        });
      }
      keys2 = keys2.filter(function(key, index2, self2) {
        return self2.indexOf(key) === index2;
      });
      return keys2;
    };
    TransformOperationExecutor2.prototype.checkVersion = function(since, until2) {
      var decision = true;
      if (decision && since)
        decision = this.options.version >= since;
      if (decision && until2)
        decision = this.options.version < until2;
      return decision;
    };
    TransformOperationExecutor2.prototype.checkGroups = function(groups) {
      if (!groups)
        return true;
      return this.options.groups.some(function(optionGroup) {
        return groups.includes(optionGroup);
      });
    };
    return TransformOperationExecutor2;
  }()
);
var defaultOptions = {
  enableCircularCheck: false,
  enableImplicitConversion: false,
  excludeExtraneousValues: false,
  excludePrefixes: void 0,
  exposeDefaultValues: false,
  exposeUnsetFields: true,
  groups: void 0,
  ignoreDecorators: false,
  strategy: void 0,
  targetMaps: void 0,
  version: void 0
};
var __assign$1 = function() {
  __assign$1 = Object.assign || function(t) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2))
        t[p2] = s[p2];
    }
    return t;
  };
  return __assign$1.apply(this, arguments);
};
var ClassTransformer = (
  /** @class */
  function() {
    function ClassTransformer2() {
    }
    __name(ClassTransformer2, "ClassTransformer");
    ClassTransformer2.prototype.instanceToPlain = function(object, options3) {
      var executor = new TransformOperationExecutor(TransformationType.CLASS_TO_PLAIN, __assign$1(__assign$1({}, defaultOptions), options3));
      return executor.transform(void 0, object, void 0, void 0, void 0, void 0);
    };
    ClassTransformer2.prototype.classToPlainFromExist = function(object, plainObject, options3) {
      var executor = new TransformOperationExecutor(TransformationType.CLASS_TO_PLAIN, __assign$1(__assign$1({}, defaultOptions), options3));
      return executor.transform(plainObject, object, void 0, void 0, void 0, void 0);
    };
    ClassTransformer2.prototype.plainToInstance = function(cls, plain, options3) {
      var executor = new TransformOperationExecutor(TransformationType.PLAIN_TO_CLASS, __assign$1(__assign$1({}, defaultOptions), options3));
      return executor.transform(void 0, plain, cls, void 0, void 0, void 0);
    };
    ClassTransformer2.prototype.plainToClassFromExist = function(clsObject, plain, options3) {
      var executor = new TransformOperationExecutor(TransformationType.PLAIN_TO_CLASS, __assign$1(__assign$1({}, defaultOptions), options3));
      return executor.transform(clsObject, plain, void 0, void 0, void 0, void 0);
    };
    ClassTransformer2.prototype.instanceToInstance = function(object, options3) {
      var executor = new TransformOperationExecutor(TransformationType.CLASS_TO_CLASS, __assign$1(__assign$1({}, defaultOptions), options3));
      return executor.transform(void 0, object, void 0, void 0, void 0, void 0);
    };
    ClassTransformer2.prototype.classToClassFromExist = function(object, fromObject, options3) {
      var executor = new TransformOperationExecutor(TransformationType.CLASS_TO_CLASS, __assign$1(__assign$1({}, defaultOptions), options3));
      return executor.transform(fromObject, object, void 0, void 0, void 0, void 0);
    };
    ClassTransformer2.prototype.serialize = function(object, options3) {
      return JSON.stringify(this.instanceToPlain(object, options3));
    };
    ClassTransformer2.prototype.deserialize = function(cls, json, options3) {
      var jsonObject = JSON.parse(json);
      return this.plainToInstance(cls, jsonObject, options3);
    };
    ClassTransformer2.prototype.deserializeArray = function(cls, json, options3) {
      var jsonObject = JSON.parse(json);
      return this.plainToInstance(cls, jsonObject, options3);
    };
    return ClassTransformer2;
  }()
);
function Exclude(options3) {
  if (options3 === void 0) {
    options3 = {};
  }
  return function(object, propertyName) {
    defaultMetadataStorage.addExcludeMetadata({
      target: object instanceof Function ? object : object.constructor,
      propertyName,
      options: options3
    });
  };
}
__name(Exclude, "Exclude");
function Expose(options3) {
  if (options3 === void 0) {
    options3 = {};
  }
  return function(object, propertyName) {
    defaultMetadataStorage.addExposeMetadata({
      target: object instanceof Function ? object : object.constructor,
      propertyName,
      options: options3
    });
  };
}
__name(Expose, "Expose");
function TransformInstanceToInstance(params) {
  return function(target, propertyKey, descriptor) {
    var classTransformer2 = new ClassTransformer();
    var originalMethod = descriptor.value;
    descriptor.value = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var result = originalMethod.apply(this, args);
      var isPromise2 = !!result && (typeof result === "object" || typeof result === "function") && typeof result.then === "function";
      return isPromise2 ? result.then(function(data24) {
        return classTransformer2.instanceToInstance(data24, params);
      }) : classTransformer2.instanceToInstance(result, params);
    };
  };
}
__name(TransformInstanceToInstance, "TransformInstanceToInstance");
function TransformInstanceToPlain(params) {
  return function(target, propertyKey, descriptor) {
    var classTransformer2 = new ClassTransformer();
    var originalMethod = descriptor.value;
    descriptor.value = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var result = originalMethod.apply(this, args);
      var isPromise2 = !!result && (typeof result === "object" || typeof result === "function") && typeof result.then === "function";
      return isPromise2 ? result.then(function(data24) {
        return classTransformer2.instanceToPlain(data24, params);
      }) : classTransformer2.instanceToPlain(result, params);
    };
  };
}
__name(TransformInstanceToPlain, "TransformInstanceToPlain");
function TransformPlainToInstance(classType, params) {
  return function(target, propertyKey, descriptor) {
    var classTransformer2 = new ClassTransformer();
    var originalMethod = descriptor.value;
    descriptor.value = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var result = originalMethod.apply(this, args);
      var isPromise2 = !!result && (typeof result === "object" || typeof result === "function") && typeof result.then === "function";
      return isPromise2 ? result.then(function(data24) {
        return classTransformer2.plainToInstance(classType, data24, params);
      }) : classTransformer2.plainToInstance(classType, result, params);
    };
  };
}
__name(TransformPlainToInstance, "TransformPlainToInstance");
function Transform(transformFn, options3) {
  if (options3 === void 0) {
    options3 = {};
  }
  return function(target, propertyName) {
    defaultMetadataStorage.addTransformMetadata({
      target: target.constructor,
      propertyName,
      transformFn,
      options: options3
    });
  };
}
__name(Transform, "Transform");
function Type(typeFunction, options3) {
  if (options3 === void 0) {
    options3 = {};
  }
  return function(target, propertyName) {
    var reflectedType = Reflect.getMetadata("design:type", target, propertyName);
    defaultMetadataStorage.addTypeMetadata({
      target: target.constructor,
      propertyName,
      reflectedType,
      typeFunction,
      options: options3
    });
  };
}
__name(Type, "Type");
var classTransformer = new ClassTransformer();
function classToPlain(object, options3) {
  return classTransformer.instanceToPlain(object, options3);
}
__name(classToPlain, "classToPlain");
function instanceToPlain(object, options3) {
  return classTransformer.instanceToPlain(object, options3);
}
__name(instanceToPlain, "instanceToPlain");
function classToPlainFromExist(object, plainObject, options3) {
  return classTransformer.classToPlainFromExist(object, plainObject, options3);
}
__name(classToPlainFromExist, "classToPlainFromExist");
function plainToClass(cls, plain, options3) {
  return classTransformer.plainToInstance(cls, plain, options3);
}
__name(plainToClass, "plainToClass");
function plainToInstance(cls, plain, options3) {
  return classTransformer.plainToInstance(cls, plain, options3);
}
__name(plainToInstance, "plainToInstance");
function plainToClassFromExist(clsObject, plain, options3) {
  return classTransformer.plainToClassFromExist(clsObject, plain, options3);
}
__name(plainToClassFromExist, "plainToClassFromExist");
function instanceToInstance(object, options3) {
  return classTransformer.instanceToInstance(object, options3);
}
__name(instanceToInstance, "instanceToInstance");
function classToClassFromExist(object, fromObject, options3) {
  return classTransformer.classToClassFromExist(object, fromObject, options3);
}
__name(classToClassFromExist, "classToClassFromExist");
function serialize(object, options3) {
  return classTransformer.serialize(object, options3);
}
__name(serialize, "serialize");
function deserialize(cls, json, options3) {
  return classTransformer.deserialize(cls, json, options3);
}
__name(deserialize, "deserialize");
function deserializeArray(cls, json, options3) {
  return classTransformer.deserializeArray(cls, json, options3);
}
__name(deserializeArray, "deserializeArray");
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = /* @__PURE__ */ __name((decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result) __defProp(target, key, result);
  return result;
}, "__decorateClass");
class BaseInputSpec {
  static {
    __name(this, "BaseInputSpec");
  }
  name;
  type;
  tooltip;
  default;
  forceInput;
  static isInputSpec(obj) {
    return Array.isArray(obj) && obj.length >= 1 && (typeof obj[0] === "string" || Array.isArray(obj[0]));
  }
}
__decorateClass([
  Type(() => Boolean)
], BaseInputSpec.prototype, "forceInput", 2);
class NumericInputSpec extends BaseInputSpec {
  static {
    __name(this, "NumericInputSpec");
  }
  min;
  max;
  step;
}
__decorateClass([
  Type(() => Number)
], NumericInputSpec.prototype, "min", 2);
__decorateClass([
  Type(() => Number)
], NumericInputSpec.prototype, "max", 2);
__decorateClass([
  Type(() => Number)
], NumericInputSpec.prototype, "step", 2);
class IntInputSpec extends NumericInputSpec {
  static {
    __name(this, "IntInputSpec");
  }
  type = "INT";
}
class FloatInputSpec extends NumericInputSpec {
  static {
    __name(this, "FloatInputSpec");
  }
  type = "FLOAT";
  round;
}
__decorateClass([
  Type(() => Number)
], FloatInputSpec.prototype, "round", 2);
class BooleanInputSpec extends BaseInputSpec {
  static {
    __name(this, "BooleanInputSpec");
  }
  type = "BOOLEAN";
  labelOn;
  labelOff;
}
class StringInputSpec extends BaseInputSpec {
  static {
    __name(this, "StringInputSpec");
  }
  type = "STRING";
  multiline;
  dynamicPrompts;
}
__decorateClass([
  Type(() => Boolean)
], StringInputSpec.prototype, "multiline", 2);
__decorateClass([
  Type(() => Boolean)
], StringInputSpec.prototype, "dynamicPrompts", 2);
class ComboInputSpec extends BaseInputSpec {
  static {
    __name(this, "ComboInputSpec");
  }
  type = "COMBO";
  comboOptions;
  controlAfterGenerate;
  imageUpload;
}
__decorateClass([
  Transform(({ value: value3 }) => value3[0])
], ComboInputSpec.prototype, "comboOptions", 2);
__decorateClass([
  Type(() => Boolean)
], ComboInputSpec.prototype, "controlAfterGenerate", 2);
__decorateClass([
  Type(() => Boolean)
], ComboInputSpec.prototype, "imageUpload", 2);
class CustomInputSpec extends BaseInputSpec {
  static {
    __name(this, "CustomInputSpec");
  }
}
const _ComfyInputsSpec = class _ComfyInputsSpec2 {
  static {
    __name(this, "_ComfyInputsSpec");
  }
  required = {};
  optional = {};
  hidden;
  static transformInputSpecRecord(record) {
    if (!record) return record;
    const result = {};
    for (const [key, value3] of Object.entries(record)) {
      result[key] = _ComfyInputsSpec2.transformSingleInputSpec(key, value3);
    }
    return result;
  }
  static transformSingleInputSpec(name, value3) {
    if (!BaseInputSpec.isInputSpec(value3)) return value3;
    const [typeRaw, _spec] = value3;
    const spec = _spec ?? {};
    const type = Array.isArray(typeRaw) ? "COMBO" : value3[0];
    switch (type) {
      case "INT":
        return plainToClass(IntInputSpec, { name, type, ...spec });
      case "FLOAT":
        return plainToClass(FloatInputSpec, { name, type, ...spec });
      case "BOOLEAN":
        return plainToClass(BooleanInputSpec, { name, type, ...spec });
      case "STRING":
        return plainToClass(StringInputSpec, { name, type, ...spec });
      case "COMBO":
        return plainToClass(ComboInputSpec, {
          name,
          type,
          ...spec,
          comboOptions: typeRaw,
          default: spec.default ?? typeRaw[0]
        });
      default:
        return plainToClass(CustomInputSpec, { name, type, ...spec });
    }
  }
  get all() {
    return [...Object.values(this.required), ...Object.values(this.optional)];
  }
  getInput(name) {
    return this.required[name] ?? this.optional[name];
  }
};
__decorateClass([
  Transform(({ value: value3 }) => _ComfyInputsSpec.transformInputSpecRecord(value3))
], _ComfyInputsSpec.prototype, "required", 2);
__decorateClass([
  Transform(({ value: value3 }) => _ComfyInputsSpec.transformInputSpecRecord(value3))
], _ComfyInputsSpec.prototype, "optional", 2);
let ComfyInputsSpec = _ComfyInputsSpec;
class ComfyOutputSpec {
  static {
    __name(this, "ComfyOutputSpec");
  }
  constructor(index2, name, type, is_list, comboOptions, tooltip) {
    this.index = index2;
    this.name = name;
    this.type = type;
    this.is_list = is_list;
    this.comboOptions = comboOptions;
    this.tooltip = tooltip;
  }
}
class ComfyOutputsSpec {
  static {
    __name(this, "ComfyOutputsSpec");
  }
  constructor(outputs) {
    this.outputs = outputs;
  }
  get all() {
    return this.outputs;
  }
}
const _ComfyNodeDefImpl = class _ComfyNodeDefImpl2 {
  static {
    __name(this, "_ComfyNodeDefImpl");
  }
  name;
  display_name;
  category;
  python_module;
  description;
  deprecated;
  experimental;
  input;
  output;
  static transformOutputSpec(obj) {
    const { output, output_is_list, output_name, output_tooltips } = obj;
    const result = output.map((type, index2) => {
      const typeString = Array.isArray(type) ? "COMBO" : type;
      return new ComfyOutputSpec(
        index2,
        output_name[index2],
        typeString,
        output_is_list[index2],
        Array.isArray(type) ? type : void 0,
        output_tooltips?.[index2]
      );
    });
    return new ComfyOutputsSpec(result);
  }
  get nodePath() {
    return (this.category ? this.category + "/" : "") + this.name;
  }
  get isDummyFolder() {
    return this.name === "";
  }
};
__decorateClass([
  Transform(({ value: value3, obj }) => value3 ?? obj.category === "", {
    toClassOnly: true
  }),
  Type(() => Boolean),
  Expose()
], _ComfyNodeDefImpl.prototype, "deprecated", 2);
__decorateClass([
  Transform(
    ({ value: value3, obj }) => value3 ?? obj.category.startsWith("_for_testing"),
    {
      toClassOnly: true
    }
  ),
  Type(() => Boolean),
  Expose()
], _ComfyNodeDefImpl.prototype, "experimental", 2);
__decorateClass([
  Type(() => ComfyInputsSpec)
], _ComfyNodeDefImpl.prototype, "input", 2);
__decorateClass([
  Transform(({ obj }) => _ComfyNodeDefImpl.transformOutputSpec(obj))
], _ComfyNodeDefImpl.prototype, "output", 2);
let ComfyNodeDefImpl = _ComfyNodeDefImpl;
const SYSTEM_NODE_DEFS = {
  PrimitiveNode: {
    name: "PrimitiveNode",
    display_name: "Primitive",
    category: "utils",
    input: { required: {}, optional: {} },
    output: ["*"],
    output_name: ["connect to widget input"],
    output_is_list: [false],
    python_module: "nodes",
    description: "Primitive values like numbers, strings, and booleans."
  },
  Reroute: {
    name: "Reroute",
    display_name: "Reroute",
    category: "utils",
    input: { required: { "": ["*"] }, optional: {} },
    output: ["*"],
    output_name: [""],
    output_is_list: [false],
    python_module: "nodes",
    description: "Reroute the connection to another node."
  },
  Note: {
    name: "Note",
    display_name: "Note",
    category: "utils",
    input: { required: {}, optional: {} },
    output: [],
    output_name: [],
    output_is_list: [],
    python_module: "nodes",
    description: "Node that add notes to your project"
  }
};
function buildNodeDefTree(nodeDefs) {
  return buildTree(
    nodeDefs,
    (nodeDef) => nodeDef.nodePath.split("/")
  );
}
__name(buildNodeDefTree, "buildNodeDefTree");
function createDummyFolderNodeDef(folderPath) {
  return plainToClass(ComfyNodeDefImpl, {
    name: "",
    display_name: "",
    category: folderPath.endsWith("/") ? folderPath.slice(0, -1) : folderPath,
    python_module: "nodes",
    description: "Dummy Folder Node (User should never see this string)"
  });
}
__name(createDummyFolderNodeDef, "createDummyFolderNodeDef");
const useNodeDefStore = defineStore("nodeDef", {
  state: /* @__PURE__ */ __name(() => ({
    nodeDefsByName: {},
    nodeDefsByDisplayName: {},
    widgets: {},
    showDeprecated: false,
    showExperimental: false
  }), "state"),
  getters: {
    nodeDefs(state) {
      return Object.values(state.nodeDefsByName);
    },
    // Node defs that are not deprecated
    visibleNodeDefs(state) {
      return this.nodeDefs.filter(
        (nodeDef) => (state.showDeprecated || !nodeDef.deprecated) && (state.showExperimental || !nodeDef.experimental)
      );
    },
    nodeSearchService() {
      return new NodeSearchService(this.visibleNodeDefs);
    },
    nodeTree() {
      return buildNodeDefTree(this.visibleNodeDefs);
    }
  },
  actions: {
    updateNodeDefs(nodeDefs) {
      const newNodeDefsByName = {};
      const nodeDefsByDisplayName = {};
      for (const nodeDef of nodeDefs) {
        const nodeDefImpl = plainToClass(ComfyNodeDefImpl, nodeDef);
        newNodeDefsByName[nodeDef.name] = nodeDefImpl;
        nodeDefsByDisplayName[nodeDef.display_name] = nodeDefImpl;
      }
      this.nodeDefsByName = newNodeDefsByName;
      this.nodeDefsByDisplayName = nodeDefsByDisplayName;
    },
    updateWidgets(widgets) {
      this.widgets = widgets;
    },
    getWidgetType(type, inputName) {
      if (type === "COMBO") {
        return "COMBO";
      } else if (`${type}:${inputName}` in this.widgets) {
        return `${type}:${inputName}`;
      } else if (type in this.widgets) {
        return type;
      } else {
        return null;
      }
    },
    inputIsWidget(spec) {
      return this.getWidgetType(spec.type, spec.name) !== null;
    }
  }
});
function _findInMetadata(metadata, ...keys2) {
  for (const key of keys2) {
    if (key in metadata) {
      return metadata[key];
    }
    for (const k in metadata) {
      if (k.endsWith(key)) {
        return metadata[k];
      }
    }
  }
  return null;
}
__name(_findInMetadata, "_findInMetadata");
class ComfyModelDef {
  static {
    __name(this, "ComfyModelDef");
  }
  /** Proper filename of the model */
  name = "";
  /** Directory containing the model, eg 'checkpoints' */
  directory = "";
  /** Title / display name of the model, sometimes same as the name but not always */
  title = "";
  /** Metadata: architecture ID for the model, such as 'stable-diffusion-xl-v1-base' */
  architecture_id = "";
  /** Metadata: author of the model */
  author = "";
  /** Metadata: resolution of the model, eg '1024x1024' */
  resolution = "";
  /** Metadata: description of the model */
  description = "";
  /** Metadata: usage hint for the model */
  usage_hint = "";
  /** Metadata: trigger phrase for the model */
  trigger_phrase = "";
  /** Metadata: tags list for the model */
  tags = [];
  /** Metadata: image for the model */
  image = "";
  /** Whether the model metadata has been loaded from the server, used for `load()` */
  has_loaded_metadata = false;
  constructor(name, directory) {
    this.name = name;
    this.title = name;
    this.directory = directory;
  }
  /** Loads the model metadata from the server, filling in this object if data is available */
  async load() {
    if (this.has_loaded_metadata) {
      return;
    }
    const metadata = await api.viewMetadata(this.directory, this.name);
    if (!metadata) {
      return;
    }
    this.title = _findInMetadata(
      metadata,
      "modelspec.title",
      "title",
      "display_name",
      "name"
    ) || this.name;
    this.architecture_id = _findInMetadata(metadata, "modelspec.architecture", "architecture") || "";
    this.author = _findInMetadata(metadata, "modelspec.author", "author") || "";
    this.description = _findInMetadata(metadata, "modelspec.description", "description") || "";
    this.resolution = _findInMetadata(metadata, "modelspec.resolution", "resolution") || "";
    this.usage_hint = _findInMetadata(metadata, "modelspec.usage_hint", "usage_hint") || "";
    this.trigger_phrase = _findInMetadata(metadata, "modelspec.trigger_phrase", "trigger_phrase") || "";
    this.image = _findInMetadata(
      metadata,
      "modelspec.thumbnail",
      "thumbnail",
      "image",
      "icon"
    ) || "";
    const tagsCommaSeparated = _findInMetadata(metadata, "modelspec.tags", "tags") || "";
    this.tags = tagsCommaSeparated.split(",").map((tag) => tag.trim());
    this.has_loaded_metadata = true;
  }
}
class ModelStore {
  static {
    __name(this, "ModelStore");
  }
  models = {};
  constructor(directory, models) {
    for (const model of models) {
      this.models[model] = new ComfyModelDef(model, directory);
    }
  }
  async loadModelMetadata(modelName) {
    if (this.models[modelName]) {
      await this.models[modelName].load();
    }
  }
}
const useModelStore = defineStore("modelStore", {
  state: /* @__PURE__ */ __name(() => ({
    modelStoreMap: {}
  }), "state"),
  actions: {
    async getModelsInFolderCached(folder) {
      if (folder in this.modelStoreMap) {
        return this.modelStoreMap[folder];
      }
      const models = await api.getModels(folder);
      if (!models) {
        return null;
      }
      const store = new ModelStore(folder, models);
      this.modelStoreMap[folder] = store;
      return store;
    },
    clearCache() {
      this.modelStoreMap = {};
    }
  }
});
const useWorkspaceStore = defineStore("workspace", {
  state: /* @__PURE__ */ __name(() => ({
    spinner: false,
    activeSidebarTab: null,
    sidebarTabs: []
  }), "state"),
  getters: {
    toast() {
      return useToastStore();
    }
  },
  actions: {
    updateActiveSidebarTab(tabId) {
      this.activeSidebarTab = tabId;
    },
    registerSidebarTab(tab) {
      this.sidebarTabs = [...this.sidebarTabs, tab];
    },
    unregisterSidebarTab(id2) {
      const index2 = this.sidebarTabs.findIndex((tab) => tab.id === id2);
      if (index2 !== -1) {
        const tab = this.sidebarTabs[index2];
        if (tab.type === "custom" && tab.destroy) {
          tab.destroy();
        }
        const newSidebarTabs = [...this.sidebarTabs];
        newSidebarTabs.splice(index2, 1);
        this.sidebarTabs = newSidebarTabs;
      }
    },
    getSidebarTabs() {
      return [...this.sidebarTabs];
    }
  }
});
const ANIM_PREVIEW_WIDGET = "$$comfy_animation_preview";
function sanitizeNodeName(string) {
  let entityMap = {
    "&": "",
    "<": "",
    ">": "",
    '"': "",
    "'": "",
    "`": "",
    "=": ""
  };
  return String(string).replace(/[&<>"'`=]/g, /* @__PURE__ */ __name(function fromEntityMap(s) {
    return entityMap[s];
  }, "fromEntityMap"));
}
__name(sanitizeNodeName, "sanitizeNodeName");
class ComfyApp {
  static {
    __name(this, "ComfyApp");
  }
  /**
   * List of entries to queue
   * @type {{number: number, batchCount: number}[]}
   */
  #queueItems = [];
  /**
   * If the queue is currently being processed
   * @type {boolean}
   */
  #processingQueue = false;
  /**
   * Content Clipboard
   * @type {serialized node object}
   */
  static clipspace = null;
  static clipspace_invalidate_handler = null;
  static open_maskeditor = null;
  static clipspace_return_node = null;
  // Force vite to import utils.ts as part of index.
  // Force import of DraggableList.
  static utils = {
    applyTextReplacements,
    addStylesheet,
    DraggableList
  };
  vueAppReady;
  ui;
  logging;
  extensions;
  extensionManager;
  _nodeOutputs;
  nodePreviewImages;
  shiftDown;
  graph;
  enableWorkflowViewRestore;
  canvas;
  dragOverNode;
  canvasEl;
  // x, y, scale
  zoom_drag_start;
  lastNodeErrors;
  runningNodeId;
  lastExecutionError;
  progress;
  configuringGraph;
  isNewUserSession;
  storageLocation;
  multiUserServer;
  ctx;
  widgets;
  workflowManager;
  bodyTop;
  bodyLeft;
  bodyRight;
  bodyBottom;
  canvasContainer;
  menu;
  constructor() {
    this.vueAppReady = false;
    this.ui = new ComfyUI(this);
    this.logging = new ComfyLogging(this);
    this.workflowManager = new ComfyWorkflowManager(this);
    this.bodyTop = $el("div.comfyui-body-top", { parent: document.body });
    this.bodyLeft = $el("div.comfyui-body-left", { parent: document.body });
    this.bodyRight = $el("div.comfyui-body-right", { parent: document.body });
    this.bodyBottom = $el("div.comfyui-body-bottom", { parent: document.body });
    this.canvasContainer = $el("div.graph-canvas-container", {
      parent: document.body
    });
    this.menu = new ComfyAppMenu(this);
    this.extensions = [];
    this.nodeOutputs = {};
    this.nodePreviewImages = {};
    this.shiftDown = false;
  }
  get nodeOutputs() {
    return this._nodeOutputs;
  }
  set nodeOutputs(value3) {
    this._nodeOutputs = value3;
    this.#invokeExtensions("onNodeOutputsUpdated", value3);
  }
  getPreviewFormatParam() {
    let preview_format = this.ui.settings.getSettingValue("Comfy.PreviewFormat");
    if (preview_format) return `&preview=${preview_format}`;
    else return "";
  }
  getRandParam() {
    return "&rand=" + Math.random();
  }
  static isImageNode(node3) {
    return node3.imgs || node3 && node3.widgets && node3.widgets.findIndex((obj) => obj.name === "image") >= 0;
  }
  static onClipspaceEditorSave() {
    if (ComfyApp.clipspace_return_node) {
      ComfyApp.pasteFromClipspace(ComfyApp.clipspace_return_node);
    }
  }
  static onClipspaceEditorClosed() {
    ComfyApp.clipspace_return_node = null;
  }
  static copyToClipspace(node3) {
    var widgets = null;
    if (node3.widgets) {
      widgets = node3.widgets.map(({ type, name, value: value3 }) => ({
        type,
        name,
        value: value3
      }));
    }
    var imgs = void 0;
    var orig_imgs = void 0;
    if (node3.imgs != void 0) {
      imgs = [];
      orig_imgs = [];
      for (let i2 = 0; i2 < node3.imgs.length; i2++) {
        imgs[i2] = new Image();
        imgs[i2].src = node3.imgs[i2].src;
        orig_imgs[i2] = imgs[i2];
      }
    }
    var selectedIndex = 0;
    if (node3.imageIndex) {
      selectedIndex = node3.imageIndex;
    }
    ComfyApp.clipspace = {
      widgets,
      imgs,
      original_imgs: orig_imgs,
      images: node3.images,
      selectedIndex,
      img_paste_mode: "selected"
      // reset to default im_paste_mode state on copy action
    };
    ComfyApp.clipspace_return_node = null;
    if (ComfyApp.clipspace_invalidate_handler) {
      ComfyApp.clipspace_invalidate_handler();
    }
  }
  static pasteFromClipspace(node3) {
    if (ComfyApp.clipspace) {
      if (ComfyApp.clipspace.imgs && node3.imgs) {
        if (node3.images && ComfyApp.clipspace.images) {
          if (ComfyApp.clipspace["img_paste_mode"] == "selected") {
            node3.images = [
              ComfyApp.clipspace.images[ComfyApp.clipspace["selectedIndex"]]
            ];
          } else {
            node3.images = ComfyApp.clipspace.images;
          }
          if (app$1.nodeOutputs[node3.id + ""])
            app$1.nodeOutputs[node3.id + ""].images = node3.images;
        }
        if (ComfyApp.clipspace.imgs) {
          if (ComfyApp.clipspace["img_paste_mode"] == "selected") {
            const img = new Image();
            img.src = ComfyApp.clipspace.imgs[ComfyApp.clipspace["selectedIndex"]].src;
            node3.imgs = [img];
            node3.imageIndex = 0;
          } else {
            const imgs = [];
            for (let i2 = 0; i2 < ComfyApp.clipspace.imgs.length; i2++) {
              imgs[i2] = new Image();
              imgs[i2].src = ComfyApp.clipspace.imgs[i2].src;
              node3.imgs = imgs;
            }
          }
        }
      }
      if (node3.widgets) {
        if (ComfyApp.clipspace.images) {
          const clip_image = ComfyApp.clipspace.images[ComfyApp.clipspace["selectedIndex"]];
          const index2 = node3.widgets.findIndex((obj) => obj.name === "image");
          if (index2 >= 0) {
            if (node3.widgets[index2].type != "image" && typeof node3.widgets[index2].value == "string" && clip_image.filename) {
              node3.widgets[index2].value = (clip_image.subfolder ? clip_image.subfolder + "/" : "") + clip_image.filename + (clip_image.type ? ` [${clip_image.type}]` : "");
            } else {
              node3.widgets[index2].value = clip_image;
            }
          }
        }
        if (ComfyApp.clipspace.widgets) {
          ComfyApp.clipspace.widgets.forEach(({ type, name, value: value3 }) => {
            const prop2 = Object.values(node3.widgets).find(
              // @ts-expect-errorg
              (obj) => obj.type === type && obj.name === name
            );
            if (prop2 && prop2.type != "button") {
              if (
                // @ts-expect-error
                prop2.type != "image" && // @ts-expect-error
                typeof prop2.value == "string" && value3.filename
              ) {
                prop2.value = (value3.subfolder ? value3.subfolder + "/" : "") + value3.filename + (value3.type ? ` [${value3.type}]` : "");
              } else {
                prop2.value = value3;
                prop2.callback(value3);
              }
            }
          });
        }
      }
      app$1.graph.setDirtyCanvas(true);
    }
  }
  /**
   * Invoke an extension callback
   * @param {keyof ComfyExtension} method The extension callback to execute
   * @param  {any[]} args Any arguments to pass to the callback
   * @returns
   */
  #invokeExtensions(method, ...args) {
    let results = [];
    for (const ext of this.extensions) {
      if (method in ext) {
        try {
          results.push(ext[method](...args, this));
        } catch (error) {
          console.error(
            `Error calling extension '${ext.name}' method '${method}'`,
            { error },
            { extension: ext },
            { args }
          );
        }
      }
    }
    return results;
  }
  /**
   * Invoke an async extension callback
   * Each callback will be invoked concurrently
   * @param {string} method The extension callback to execute
   * @param  {...any} args Any arguments to pass to the callback
   * @returns
   */
  async #invokeExtensionsAsync(method, ...args) {
    return await Promise.all(
      this.extensions.map(async (ext) => {
        if (method in ext) {
          try {
            return await ext[method](...args, this);
          } catch (error) {
            console.error(
              `Error calling extension '${ext.name}' method '${method}'`,
              { error },
              { extension: ext },
              { args }
            );
          }
        }
      })
    );
  }
  #addRestoreWorkflowView() {
    const serialize2 = LGraph.prototype.serialize;
    const self2 = this;
    LGraph.prototype.serialize = function() {
      const workflow = serialize2.apply(this, arguments);
      if (self2.enableWorkflowViewRestore.value) {
        if (!workflow.extra) {
          workflow.extra = {};
        }
        workflow.extra.ds = {
          scale: self2.canvas.ds.scale,
          offset: self2.canvas.ds.offset
        };
      } else if (workflow.extra?.ds) {
        delete workflow.extra.ds;
      }
      return workflow;
    };
    this.enableWorkflowViewRestore = this.ui.settings.addSetting({
      id: "Comfy.EnableWorkflowViewRestore",
      category: ["Comfy", "Workflow", "EnableWorkflowViewRestore"],
      name: "Save and restore canvas position and zoom level in workflows",
      type: "boolean",
      defaultValue: true
    });
  }
  /**
   * Adds special context menu handling for nodes
   * e.g. this adds Open Image functionality for nodes that show images
   * @param {*} node The node to add the menu handler
   */
  #addNodeContextMenuHandler(node3) {
    function getCopyImageOption(img) {
      if (typeof window.ClipboardItem === "undefined") return [];
      return [
        {
          content: "Copy Image",
          callback: /* @__PURE__ */ __name(async () => {
            const url = new URL(img.src);
            url.searchParams.delete("preview");
            const writeImage = /* @__PURE__ */ __name(async (blob) => {
              await navigator.clipboard.write([
                new ClipboardItem({
                  [blob.type]: blob
                })
              ]);
            }, "writeImage");
            try {
              const data24 = await fetch(url);
              const blob = await data24.blob();
              try {
                await writeImage(blob);
              } catch (error) {
                if (blob.type !== "image/png") {
                  const canvas = $el("canvas", {
                    width: img.naturalWidth,
                    height: img.naturalHeight
                  });
                  const ctx = canvas.getContext("2d");
                  let image;
                  if (typeof window.createImageBitmap === "undefined") {
                    image = new Image();
                    const p2 = new Promise((resolve8, reject2) => {
                      image.onload = resolve8;
                      image.onerror = reject2;
                    }).finally(() => {
                      URL.revokeObjectURL(image.src);
                    });
                    image.src = URL.createObjectURL(blob);
                    await p2;
                  } else {
                    image = await createImageBitmap(blob);
                  }
                  try {
                    ctx.drawImage(image, 0, 0);
                    canvas.toBlob(writeImage, "image/png");
                  } finally {
                    if (typeof image.close === "function") {
                      image.close();
                    }
                  }
                  return;
                }
                throw error;
              }
            } catch (error) {
              alert("Error copying image: " + (error.message ?? error));
            }
          }, "callback")
        }
      ];
    }
    __name(getCopyImageOption, "getCopyImageOption");
    node3.prototype.getExtraMenuOptions = function(_2, options3) {
      if (this.imgs) {
        let img;
        if (this.imageIndex != null) {
          img = this.imgs[this.imageIndex];
        } else if (this.overIndex != null) {
          img = this.imgs[this.overIndex];
        }
        if (img) {
          options3.unshift(
            {
              content: "Open Image",
              callback: /* @__PURE__ */ __name(() => {
                let url = new URL(img.src);
                url.searchParams.delete("preview");
                window.open(url, "_blank");
              }, "callback")
            },
            ...getCopyImageOption(img),
            {
              content: "Save Image",
              callback: /* @__PURE__ */ __name(() => {
                const a = document.createElement("a");
                let url = new URL(img.src);
                url.searchParams.delete("preview");
                a.href = url.toString();
                a.setAttribute(
                  "download",
                  new URLSearchParams(url.search).get("filename")
                );
                document.body.append(a);
                a.click();
                requestAnimationFrame(() => a.remove());
              }, "callback")
            }
          );
        }
      }
      options3.push({
        content: "Bypass",
        callback: /* @__PURE__ */ __name((obj) => {
          if (this.mode === 4) this.mode = 0;
          else this.mode = 4;
          this.graph.change();
        }, "callback")
      });
      if (!ComfyApp.clipspace_return_node) {
        options3.push({
          content: "Copy (Clipspace)",
          callback: /* @__PURE__ */ __name((obj) => {
            ComfyApp.copyToClipspace(this);
          }, "callback")
        });
        if (ComfyApp.clipspace != null) {
          options3.push({
            content: "Paste (Clipspace)",
            callback: /* @__PURE__ */ __name(() => {
              ComfyApp.pasteFromClipspace(this);
            }, "callback")
          });
        }
        if (ComfyApp.isImageNode(this)) {
          options3.push({
            content: "Open in MaskEditor",
            callback: /* @__PURE__ */ __name((obj) => {
              ComfyApp.copyToClipspace(this);
              ComfyApp.clipspace_return_node = this;
              ComfyApp.open_maskeditor();
            }, "callback")
          });
        }
      }
    };
  }
  #addNodeKeyHandler(node3) {
    const app2 = this;
    const origNodeOnKeyDown = node3.prototype.onKeyDown;
    node3.prototype.onKeyDown = function(e) {
      if (origNodeOnKeyDown && origNodeOnKeyDown.apply(this, e) === false) {
        return false;
      }
      if (this.flags.collapsed || !this.imgs || this.imageIndex === null) {
        return;
      }
      let handled = false;
      if (e.key === "ArrowLeft" || e.key === "ArrowRight") {
        if (e.key === "ArrowLeft") {
          this.imageIndex -= 1;
        } else if (e.key === "ArrowRight") {
          this.imageIndex += 1;
        }
        this.imageIndex %= this.imgs.length;
        if (this.imageIndex < 0) {
          this.imageIndex = this.imgs.length + this.imageIndex;
        }
        handled = true;
      } else if (e.key === "Escape") {
        this.imageIndex = null;
        handled = true;
      }
      if (handled === true) {
        e.preventDefault();
        e.stopImmediatePropagation();
        return false;
      }
    };
  }
  /**
   * Adds Custom drawing logic for nodes
   * e.g. Draws images and handles thumbnail navigation on nodes that output images
   * @param {*} node The node to add the draw handler
   */
  #addDrawBackgroundHandler(node3) {
    const app2 = this;
    function getImageTop(node22) {
      let shiftY;
      if (node22.imageOffset != null) {
        shiftY = node22.imageOffset;
      } else {
        if (node22.widgets?.length) {
          const w2 = node22.widgets[node22.widgets.length - 1];
          shiftY = w2.last_y;
          if (w2.computeSize) {
            shiftY += w2.computeSize()[1] + 4;
          } else if (w2.computedHeight) {
            shiftY += w2.computedHeight;
          } else {
            shiftY += LiteGraph.NODE_WIDGET_HEIGHT + 4;
          }
        } else {
          shiftY = node22.computeSize()[1];
        }
      }
      return shiftY;
    }
    __name(getImageTop, "getImageTop");
    node3.prototype.setSizeForImage = function(force) {
      if (!force && this.animatedImages) return;
      if (this.inputHeight || this.freeWidgetSpace > 210) {
        this.setSize(this.size);
        return;
      }
      const minHeight = getImageTop(this) + 220;
      if (this.size[1] < minHeight) {
        this.setSize([this.size[0], minHeight]);
      }
    };
    function unsafeDrawBackground(ctx) {
      if (!this.flags.collapsed) {
        let imgURLs = [];
        let imagesChanged = false;
        const output = app2.nodeOutputs[this.id + ""];
        if (output?.images) {
          this.animatedImages = output?.animated?.find(Boolean);
          if (this.images !== output.images) {
            this.images = output.images;
            imagesChanged = true;
            imgURLs = imgURLs.concat(
              output.images.map((params) => {
                return api.apiURL(
                  "/view?" + new URLSearchParams(params).toString() + (this.animatedImages ? "" : app2.getPreviewFormatParam()) + app2.getRandParam()
                );
              })
            );
          }
        }
        const preview2 = app2.nodePreviewImages[this.id + ""];
        if (this.preview !== preview2) {
          this.preview = preview2;
          imagesChanged = true;
          if (preview2 != null) {
            imgURLs.push(preview2);
          }
        }
        if (imagesChanged) {
          this.imageIndex = null;
          if (imgURLs.length > 0) {
            Promise.all(
              imgURLs.map((src) => {
                return new Promise((r) => {
                  const img = new Image();
                  img.onload = () => r(img);
                  img.onerror = () => r(null);
                  img.src = src;
                });
              })
            ).then((imgs) => {
              if ((!output || this.images === output.images) && (!preview2 || this.preview === preview2)) {
                this.imgs = imgs.filter(Boolean);
                this.setSizeForImage?.();
                app2.graph.setDirtyCanvas(true);
              }
            });
          } else {
            this.imgs = null;
          }
        }
        const is_all_same_aspect_ratio = /* @__PURE__ */ __name((imgs) => {
          let ratio2 = imgs[0].naturalWidth / imgs[0].naturalHeight;
          for (let i2 = 1; i2 < imgs.length; i2++) {
            let this_ratio = imgs[i2].naturalWidth / imgs[i2].naturalHeight;
            if (ratio2 != this_ratio) return false;
          }
          return true;
        }, "is_all_same_aspect_ratio");
        if (this.imgs?.length) {
          const widgetIdx = this.widgets?.findIndex(
            (w2) => w2.name === ANIM_PREVIEW_WIDGET
          );
          if (this.animatedImages) {
            if (widgetIdx > -1) {
              const widget = this.widgets[widgetIdx];
              widget.options.host.updateImages(this.imgs);
            } else {
              const host = createImageHost(this);
              this.setSizeForImage(true);
              const widget = this.addDOMWidget(
                ANIM_PREVIEW_WIDGET,
                "img",
                host.el,
                {
                  host,
                  getHeight: host.getHeight,
                  onDraw: host.onDraw,
                  hideOnZoom: false
                }
              );
              widget.serializeValue = () => void 0;
              widget.options.host.updateImages(this.imgs);
            }
            return;
          }
          if (widgetIdx > -1) {
            this.widgets[widgetIdx].onRemove?.();
            this.widgets.splice(widgetIdx, 1);
          }
          const canvas = app2.graph.list_of_graphcanvas[0];
          const mouse = canvas.graph_mouse;
          if (!canvas.pointer_is_down && this.pointerDown) {
            if (mouse[0] === this.pointerDown.pos[0] && mouse[1] === this.pointerDown.pos[1]) {
              this.imageIndex = this.pointerDown.index;
            }
            this.pointerDown = null;
          }
          let imageIndex = this.imageIndex;
          const numImages = this.imgs.length;
          if (numImages === 1 && !imageIndex) {
            this.imageIndex = imageIndex = 0;
          }
          const top = getImageTop(this);
          var shiftY = top;
          let dw = this.size[0];
          let dh = this.size[1];
          dh -= shiftY;
          if (imageIndex == null) {
            var cellWidth, cellHeight, shiftX, cell_padding, cols;
            const compact_mode = is_all_same_aspect_ratio(this.imgs);
            if (!compact_mode) {
              cell_padding = 2;
              const largestDimension = this.imgs.reduce(
                (acc, current) => Math.max(acc, current.naturalWidth, current.naturalHeight),
                0
              );
              const fakeImgs = [];
              fakeImgs.length = this.imgs.length;
              fakeImgs[0] = {
                naturalWidth: largestDimension,
                naturalHeight: largestDimension
              };
              ({ cellWidth, cellHeight, cols, shiftX } = calculateImageGrid(
                fakeImgs,
                dw,
                dh
              ));
            } else {
              cell_padding = 0;
              ({ cellWidth, cellHeight, cols, shiftX } = calculateImageGrid(
                this.imgs,
                dw,
                dh
              ));
            }
            let anyHovered = false;
            this.imageRects = [];
            for (let i2 = 0; i2 < numImages; i2++) {
              const img = this.imgs[i2];
              const row = Math.floor(i2 / cols);
              const col = i2 % cols;
              const x2 = col * cellWidth + shiftX;
              const y2 = row * cellHeight + shiftY;
              if (!anyHovered) {
                anyHovered = LiteGraph.isInsideRectangle(
                  mouse[0],
                  mouse[1],
                  x2 + this.pos[0],
                  y2 + this.pos[1],
                  cellWidth,
                  cellHeight
                );
                if (anyHovered) {
                  this.overIndex = i2;
                  let value3 = 110;
                  if (canvas.pointer_is_down) {
                    if (!this.pointerDown || this.pointerDown.index !== i2) {
                      this.pointerDown = { index: i2, pos: [...mouse] };
                    }
                    value3 = 125;
                  }
                  ctx.filter = `contrast(${value3}%) brightness(${value3}%)`;
                  canvas.canvas.style.cursor = "pointer";
                }
              }
              this.imageRects.push([x2, y2, cellWidth, cellHeight]);
              let wratio = cellWidth / img.width;
              let hratio = cellHeight / img.height;
              var ratio = Math.min(wratio, hratio);
              let imgHeight = ratio * img.height;
              let imgY = row * cellHeight + shiftY + (cellHeight - imgHeight) / 2;
              let imgWidth = ratio * img.width;
              let imgX = col * cellWidth + shiftX + (cellWidth - imgWidth) / 2;
              ctx.drawImage(
                img,
                imgX + cell_padding,
                imgY + cell_padding,
                imgWidth - cell_padding * 2,
                imgHeight - cell_padding * 2
              );
              if (!compact_mode) {
                ctx.strokeStyle = "#8F8F8F";
                ctx.lineWidth = 1;
                ctx.strokeRect(
                  x2 + cell_padding,
                  y2 + cell_padding,
                  cellWidth - cell_padding * 2,
                  cellHeight - cell_padding * 2
                );
              }
              ctx.filter = "none";
            }
            if (!anyHovered) {
              this.pointerDown = null;
              this.overIndex = null;
            }
          } else {
            let w2 = this.imgs[imageIndex].naturalWidth;
            let h2 = this.imgs[imageIndex].naturalHeight;
            const scaleX = dw / w2;
            const scaleY = dh / h2;
            const scale = Math.min(scaleX, scaleY, 1);
            w2 *= scale;
            h2 *= scale;
            let x2 = (dw - w2) / 2;
            let y2 = (dh - h2) / 2 + shiftY;
            ctx.drawImage(this.imgs[imageIndex], x2, y2, w2, h2);
            const drawButton = /* @__PURE__ */ __name((x22, y22, sz, text) => {
              const hovered = LiteGraph.isInsideRectangle(
                mouse[0],
                mouse[1],
                x22 + this.pos[0],
                y22 + this.pos[1],
                sz,
                sz
              );
              let fill = "#333";
              let textFill = "#fff";
              let isClicking = false;
              if (hovered) {
                canvas.canvas.style.cursor = "pointer";
                if (canvas.pointer_is_down) {
                  fill = "#1e90ff";
                  isClicking = true;
                } else {
                  fill = "#eee";
                  textFill = "#000";
                }
              } else {
                this.pointerWasDown = null;
              }
              ctx.fillStyle = fill;
              ctx.beginPath();
              ctx.roundRect(x22, y22, sz, sz, [4]);
              ctx.fill();
              ctx.fillStyle = textFill;
              ctx.font = "12px Arial";
              ctx.textAlign = "center";
              ctx.fillText(text, x22 + 15, y22 + 20);
              return isClicking;
            }, "drawButton");
            if (numImages > 1) {
              if (drawButton(
                dw - 40,
                dh + top - 40,
                30,
                `${this.imageIndex + 1}/${numImages}`
              )) {
                let i2 = this.imageIndex + 1 >= numImages ? 0 : this.imageIndex + 1;
                if (!this.pointerDown || !this.pointerDown.index === i2) {
                  this.pointerDown = { index: i2, pos: [...mouse] };
                }
              }
              if (drawButton(dw - 40, top + 10, 30, `x`)) {
                if (!this.pointerDown || !this.pointerDown.index === null) {
                  this.pointerDown = { index: null, pos: [...mouse] };
                }
              }
            }
          }
        }
      }
    }
    __name(unsafeDrawBackground, "unsafeDrawBackground");
    node3.prototype.onDrawBackground = function(ctx) {
      try {
        unsafeDrawBackground.call(this, ctx);
      } catch (error) {
        console.error("Error drawing node background", error);
      }
    };
  }
  /**
   * Adds a handler allowing drag+drop of files onto the window to load workflows
   */
  #addDropHandler() {
    document.addEventListener("drop", async (event2) => {
      event2.preventDefault();
      event2.stopPropagation();
      const n = this.dragOverNode;
      this.dragOverNode = null;
      if (n && n.onDragDrop && await n.onDragDrop(event2)) {
        return;
      }
      if (event2.dataTransfer.files.length && event2.dataTransfer.files[0].type !== "image/bmp") {
        await this.handleFile(event2.dataTransfer.files[0]);
      } else {
        const validTypes = ["text/uri-list", "text/x-moz-url"];
        const match = [...event2.dataTransfer.types].find(
          (t) => validTypes.find((v2) => t === v2)
        );
        if (match) {
          const uri = event2.dataTransfer.getData(match)?.split("\n")?.[0];
          if (uri) {
            await this.handleFile(await (await fetch(uri)).blob());
          }
        }
      }
    });
    this.canvasEl.addEventListener("dragleave", async () => {
      if (this.dragOverNode) {
        this.dragOverNode = null;
        this.graph.setDirtyCanvas(false, true);
      }
    });
    this.canvasEl.addEventListener(
      "dragover",
      (e) => {
        this.canvas.adjustMouseEvent(e);
        const node3 = this.graph.getNodeOnPos(e.canvasX, e.canvasY);
        if (node3) {
          if (node3.onDragOver && node3.onDragOver(e)) {
            this.dragOverNode = node3;
            requestAnimationFrame(() => {
              this.graph.setDirtyCanvas(false, true);
            });
            return;
          }
        }
        this.dragOverNode = null;
      },
      false
    );
  }
  /**
   * Adds a handler on paste that extracts and loads images or workflows from pasted JSON data
   */
  #addPasteHandler() {
    document.addEventListener("paste", async (e) => {
      if (this.shiftDown) return;
      let data24 = e.clipboardData || window.clipboardData;
      const items2 = data24.items;
      for (const item2 of items2) {
        if (item2.type.startsWith("image/")) {
          var imageNode = null;
          if (this.canvas.current_node && this.canvas.current_node.is_selected && ComfyApp.isImageNode(this.canvas.current_node)) {
            imageNode = this.canvas.current_node;
          }
          if (!imageNode) {
            const newNode = LiteGraph.createNode("LoadImage");
            newNode.pos = [...this.canvas.graph_mouse];
            imageNode = this.graph.add(newNode);
            this.graph.change();
          }
          const blob = item2.getAsFile();
          imageNode.pasteFile(blob);
          return;
        }
      }
      data24 = data24.getData("text/plain");
      let workflow;
      try {
        data24 = data24.slice(data24.indexOf("{"));
        workflow = JSON.parse(data24);
      } catch (err) {
        try {
          data24 = data24.slice(data24.indexOf("workflow\n"));
          data24 = data24.slice(data24.indexOf("{"));
          workflow = JSON.parse(data24);
        } catch (error) {
          console.error(error);
        }
      }
      if (workflow && workflow.version && workflow.nodes && workflow.extra) {
        await this.loadGraphData(workflow);
      } else {
        if (e.target instanceof HTMLTextAreaElement && e.target.type === "textarea" || e.target instanceof HTMLInputElement && e.target.type === "text") {
          return;
        }
        this.canvas.pasteFromClipboard();
      }
    });
  }
  /**
   * Adds a handler on copy that serializes selected nodes to JSON
   */
  #addCopyHandler() {
    document.addEventListener("copy", (e) => {
      if (!(e.target instanceof Element)) {
        return;
      }
      if (e.target instanceof HTMLTextAreaElement && e.target.type === "textarea" || e.target instanceof HTMLInputElement && e.target.type === "text") {
        return;
      }
      const isTargetInGraph = e.target.classList.contains("litegraph") || e.target.classList.contains("graph-canvas-container");
      if (isTargetInGraph && this.canvas.selected_nodes) {
        this.canvas.copyToClipboard();
        e.clipboardData.setData("text", " ");
        e.preventDefault();
        e.stopImmediatePropagation();
        return false;
      }
    });
  }
  /**
   * Handle mouse
   *
   * Move group by header
   */
  #addProcessMouseHandler() {
    const self2 = this;
    const origProcessMouseDown = LGraphCanvas.prototype.processMouseDown;
    LGraphCanvas.prototype.processMouseDown = function(e) {
      if (e.ctrlKey && e.shiftKey && e.buttons) {
        self2.zoom_drag_start = [e.x, e.y, this.ds.scale];
        return;
      }
      const res = origProcessMouseDown.apply(this, arguments);
      this.selected_group_moving = false;
      if (this.selected_group && !this.selected_group_resizing) {
        var font_size = this.selected_group.font_size || LiteGraph.DEFAULT_GROUP_FONT_SIZE;
        var height = font_size * 1.4;
        if (LiteGraph.isInsideRectangle(
          // @ts-expect-error
          e.canvasX,
          // @ts-expect-error
          e.canvasY,
          this.selected_group.pos[0],
          this.selected_group.pos[1],
          this.selected_group.size[0],
          height
        )) {
          this.selected_group_moving = true;
        }
      }
      return res;
    };
    const origProcessMouseMove = LGraphCanvas.prototype.processMouseMove;
    LGraphCanvas.prototype.processMouseMove = function(e) {
      if (e.ctrlKey && e.shiftKey && self2.zoom_drag_start) {
        if (!e.buttons) {
          self2.zoom_drag_start = null;
          return;
        }
        let deltaY = e.y - self2.zoom_drag_start[1];
        let startScale = self2.zoom_drag_start[2];
        let scale = startScale - deltaY / 100;
        this.ds.changeScale(scale, [
          self2.zoom_drag_start[0],
          self2.zoom_drag_start[1]
        ]);
        this.graph.change();
        return;
      }
      const orig_selected_group = this.selected_group;
      if (this.selected_group && !this.selected_group_resizing && !this.selected_group_moving) {
        this.selected_group = null;
      }
      const res = origProcessMouseMove.apply(this, arguments);
      if (orig_selected_group && !this.selected_group_resizing && !this.selected_group_moving) {
        this.selected_group = orig_selected_group;
      }
      return res;
    };
  }
  /**
   * Handle keypress
   *
   * Ctrl + M mute/unmute selected nodes
   */
  #addProcessKeyHandler() {
    const self2 = this;
    const origProcessKey = LGraphCanvas.prototype.processKey;
    LGraphCanvas.prototype.processKey = function(e) {
      if (!this.graph) {
        return;
      }
      var block_default = false;
      if (e.target instanceof Element && e.target.localName == "input") {
        return;
      }
      if (e.type == "keydown" && !e.repeat) {
        if (e.key === "m" && (e.metaKey || e.ctrlKey)) {
          if (this.selected_nodes) {
            for (var i2 in this.selected_nodes) {
              if (this.selected_nodes[i2].mode === 2) {
                this.selected_nodes[i2].mode = 0;
              } else {
                this.selected_nodes[i2].mode = 2;
              }
            }
          }
          block_default = true;
        }
        if (e.key === "b" && (e.metaKey || e.ctrlKey)) {
          if (this.selected_nodes) {
            for (var i2 in this.selected_nodes) {
              if (this.selected_nodes[i2].mode === 4) {
                this.selected_nodes[i2].mode = 0;
              } else {
                this.selected_nodes[i2].mode = 4;
              }
            }
          }
          block_default = true;
        }
        if (e.key === "p") {
          if (this.selected_nodes) {
            for (const i22 in this.selected_nodes) {
              const node3 = this.selected_nodes[i22];
              node3.pin();
            }
          }
          block_default = true;
        }
        if (e.key === "c" && e.altKey) {
          if (this.selected_nodes) {
            for (var i2 in this.selected_nodes) {
              this.selected_nodes[i2].collapse();
            }
          }
          block_default = true;
        }
        if (e.key === "c" && (e.metaKey || e.ctrlKey)) {
          return true;
        }
        if ((e.key === "v" || e.key == "V") && (e.metaKey || e.ctrlKey) && !e.shiftKey) {
          return true;
        }
        if (e.key === "+" && e.altKey) {
          block_default = true;
          let scale = this.ds.scale * 1.1;
          this.ds.changeScale(scale, [
            this.ds.element.width / 2,
            this.ds.element.height / 2
          ]);
          this.graph.change();
        }
        if (e.key === "-" && e.altKey) {
          block_default = true;
          let scale = this.ds.scale * 1 / 1.1;
          this.ds.changeScale(scale, [
            this.ds.element.width / 2,
            this.ds.element.height / 2
          ]);
          this.graph.change();
        }
      }
      this.graph.change();
      if (block_default) {
        e.preventDefault();
        e.stopImmediatePropagation();
        return false;
      }
      return origProcessKey.apply(this, arguments);
    };
  }
  /**
   * Draws group header bar
   */
  #addDrawGroupsHandler() {
    const self2 = this;
    const origDrawGroups = LGraphCanvas.prototype.drawGroups;
    LGraphCanvas.prototype.drawGroups = function(canvas, ctx) {
      if (!this.graph) {
        return;
      }
      var groups = this.graph._groups;
      ctx.save();
      ctx.globalAlpha = 0.7 * this.editor_alpha;
      for (var i2 = 0; i2 < groups.length; ++i2) {
        var group = groups[i2];
        if (!LiteGraph.overlapBounding(this.visible_area, group._bounding)) {
          continue;
        }
        ctx.fillStyle = group.color || "#335";
        ctx.strokeStyle = group.color || "#335";
        var pos2 = group._pos;
        var size2 = group._size;
        ctx.globalAlpha = 0.25 * this.editor_alpha;
        ctx.beginPath();
        var font_size = group.font_size || LiteGraph.DEFAULT_GROUP_FONT_SIZE;
        ctx.rect(pos2[0] + 0.5, pos2[1] + 0.5, size2[0], font_size * 1.4);
        ctx.fill();
        ctx.globalAlpha = this.editor_alpha;
      }
      ctx.restore();
      const res = origDrawGroups.apply(this, arguments);
      return res;
    };
  }
  /**
   * Draws node highlights (executing, drag drop) and progress bar
   */
  #addDrawNodeHandler() {
    const origDrawNodeShape = LGraphCanvas.prototype.drawNodeShape;
    const self2 = this;
    LGraphCanvas.prototype.drawNodeShape = function(node3, ctx, size2, fgcolor, bgcolor, selected2, mouse_over) {
      const res = origDrawNodeShape.apply(this, arguments);
      const nodeErrors = self2.lastNodeErrors?.[node3.id];
      let color = null;
      let lineWidth = 1;
      if (node3.id === +self2.runningNodeId) {
        color = "#0f0";
      } else if (self2.dragOverNode && node3.id === self2.dragOverNode.id) {
        color = "dodgerblue";
      } else if (nodeErrors?.errors) {
        color = "red";
        lineWidth = 2;
      } else if (self2.lastExecutionError && +self2.lastExecutionError.node_id === node3.id) {
        color = "#f0f";
        lineWidth = 2;
      }
      if (color) {
        const shape = (
          // @ts-expect-error
          node3._shape || node3.constructor.shape || LiteGraph.ROUND_SHAPE
        );
        ctx.lineWidth = lineWidth;
        ctx.globalAlpha = 0.8;
        ctx.beginPath();
        if (shape == LiteGraph.BOX_SHAPE)
          ctx.rect(
            -6,
            -6 - LiteGraph.NODE_TITLE_HEIGHT,
            12 + size2[0] + 1,
            12 + size2[1] + LiteGraph.NODE_TITLE_HEIGHT
          );
        else if (shape == LiteGraph.ROUND_SHAPE || shape == LiteGraph.CARD_SHAPE && node3.flags.collapsed)
          ctx.roundRect(
            -6,
            -6 - LiteGraph.NODE_TITLE_HEIGHT,
            12 + size2[0] + 1,
            12 + size2[1] + LiteGraph.NODE_TITLE_HEIGHT,
            this.round_radius * 2
          );
        else if (shape == LiteGraph.CARD_SHAPE)
          ctx.roundRect(
            -6,
            -6 - LiteGraph.NODE_TITLE_HEIGHT,
            12 + size2[0] + 1,
            12 + size2[1] + LiteGraph.NODE_TITLE_HEIGHT,
            [this.round_radius * 2, this.round_radius * 2, 2, 2]
          );
        else if (shape == LiteGraph.CIRCLE_SHAPE)
          ctx.arc(
            size2[0] * 0.5,
            size2[1] * 0.5,
            size2[0] * 0.5 + 6,
            0,
            Math.PI * 2
          );
        ctx.strokeStyle = color;
        ctx.stroke();
        ctx.strokeStyle = fgcolor;
        ctx.globalAlpha = 1;
      }
      if (self2.progress && node3.id === +self2.runningNodeId) {
        ctx.fillStyle = "green";
        ctx.fillRect(
          0,
          0,
          size2[0] * (self2.progress.value / self2.progress.max),
          6
        );
        ctx.fillStyle = bgcolor;
      }
      if (nodeErrors) {
        ctx.lineWidth = 2;
        ctx.strokeStyle = "red";
        for (const error of nodeErrors.errors) {
          if (error.extra_info && error.extra_info.input_name) {
            const inputIndex = node3.findInputSlot(error.extra_info.input_name);
            if (inputIndex !== -1) {
              let pos2 = node3.getConnectionPos(true, inputIndex);
              ctx.beginPath();
              ctx.arc(
                pos2[0] - node3.pos[0],
                pos2[1] - node3.pos[1],
                12,
                0,
                2 * Math.PI,
                false
              );
              ctx.stroke();
            }
          }
        }
      }
      return res;
    };
    const origDrawNode = LGraphCanvas.prototype.drawNode;
    LGraphCanvas.prototype.drawNode = function(node3, ctx) {
      var editor_alpha = this.editor_alpha;
      var old_color = node3.color;
      var old_bgcolor = node3.bgcolor;
      if (node3.mode === 2) {
        this.editor_alpha = 0.4;
      }
      if (node3.mode === 4) {
        node3.bgcolor = "#FF00FF";
        this.editor_alpha = 0.2;
      }
      const adjustColor = /* @__PURE__ */ __name((color) => {
        return color ? lightenColor(color, 0.5) : color;
      }, "adjustColor");
      if (app$1.ui.settings.getSettingValue("Comfy.ColorPalette") === "light") {
        node3.bgcolor = adjustColor(node3.bgcolor);
        node3.color = adjustColor(node3.color);
      }
      const res = origDrawNode.apply(this, arguments);
      this.editor_alpha = editor_alpha;
      node3.color = old_color;
      node3.bgcolor = old_bgcolor;
      return res;
    };
  }
  /**
   * Handles updates from the API socket
   */
  #addApiUpdateHandlers() {
    api.addEventListener(
      "status",
      ({ detail }) => {
        this.ui.setStatus(detail);
      }
    );
    api.addEventListener("progress", ({ detail }) => {
      if (this.workflowManager.activePrompt?.workflow && this.workflowManager.activePrompt.workflow !== this.workflowManager.activeWorkflow)
        return;
      this.progress = detail;
      this.graph.setDirtyCanvas(true, false);
    });
    api.addEventListener("executing", ({ detail }) => {
      if (this.workflowManager.activePrompt?.workflow && this.workflowManager.activePrompt.workflow !== this.workflowManager.activeWorkflow)
        return;
      this.progress = null;
      this.runningNodeId = detail;
      this.graph.setDirtyCanvas(true, false);
      delete this.nodePreviewImages[this.runningNodeId];
    });
    api.addEventListener("executed", ({ detail }) => {
      if (this.workflowManager.activePrompt?.workflow && this.workflowManager.activePrompt.workflow !== this.workflowManager.activeWorkflow)
        return;
      const output = this.nodeOutputs[detail.display_node || detail.node];
      if (detail.merge && output) {
        for (const k in detail.output ?? {}) {
          const v2 = output[k];
          if (v2 instanceof Array) {
            output[k] = v2.concat(detail.output[k]);
          } else {
            output[k] = detail.output[k];
          }
        }
      } else {
        this.nodeOutputs[detail.display_node || detail.node] = detail.output;
      }
      const node3 = this.graph.getNodeById(detail.display_node || detail.node);
      if (node3) {
        if (node3.onExecuted)
          node3.onExecuted(detail.output);
      }
    });
    api.addEventListener("execution_start", ({ detail }) => {
      this.runningNodeId = null;
      this.lastExecutionError = null;
      this.graph._nodes.forEach((node3) => {
        if (node3.onExecutionStart)
          node3.onExecutionStart();
      });
    });
    api.addEventListener("execution_error", ({ detail }) => {
      this.lastExecutionError = detail;
      showExecutionErrorDialog(detail);
      this.canvas.draw(true, true);
    });
    api.addEventListener("b_preview", ({ detail }) => {
      const id2 = this.runningNodeId;
      if (id2 == null) return;
      const blob = detail;
      const blobUrl = URL.createObjectURL(blob);
      this.nodePreviewImages[id2] = [blobUrl];
    });
    api.init();
  }
  #addKeyboardHandler() {
    window.addEventListener("keydown", (e) => {
      this.shiftDown = e.shiftKey;
    });
    window.addEventListener("keyup", (e) => {
      this.shiftDown = e.shiftKey;
    });
  }
  #addConfigureHandler() {
    const app2 = this;
    const configure = LGraph.prototype.configure;
    LGraph.prototype.configure = function() {
      app2.configuringGraph = true;
      try {
        return configure.apply(this, arguments);
      } finally {
        app2.configuringGraph = false;
      }
    };
  }
  #addAfterConfigureHandler() {
    const app2 = this;
    const onConfigure = app2.graph.onConfigure;
    app2.graph.onConfigure = function() {
      for (const node3 of app2.graph._nodes) {
        node3.onGraphConfigured?.();
      }
      const r = onConfigure?.apply(this, arguments);
      for (const node3 of app2.graph._nodes) {
        node3.onAfterGraphConfigured?.();
      }
      return r;
    };
  }
  /**
   * Loads all extensions from the API into the window in parallel
   */
  async #loadExtensions() {
    const extensions = await api.getExtensions();
    this.logging.addEntry("Comfy.App", "debug", { Extensions: extensions });
    await __vitePreload(() => import("./index-CrROdkG4.js"), true ? __vite__mapDeps([0,1]) : void 0, import.meta.url);
    await Promise.all(
      extensions.filter((extension) => !extension.includes("extensions/core")).map(async (ext) => {
        try {
          await import(
            /* @vite-ignore */
            api.fileURL(ext)
          );
        } catch (error) {
          console.error("Error loading extension", ext, error);
        }
      })
    );
    try {
      this.menu.workflows.registerExtension(this);
    } catch (error) {
      console.error(error);
    }
  }
  async #migrateSettings() {
    this.isNewUserSession = true;
    const settings = Object.keys(this.ui.settings).reduce((p2, n) => {
      const v2 = localStorage[`Comfy.Settings.${n}`];
      if (v2) {
        try {
          p2[n] = JSON.parse(v2);
        } catch (error) {
        }
      }
      return p2;
    }, {});
    await api.storeSettings(settings);
  }
  async #setUser() {
    const userConfig = await api.getUserConfig();
    this.storageLocation = userConfig.storage;
    if (typeof userConfig.migrated == "boolean") {
      if (!userConfig.migrated && this.storageLocation === "server") {
        await this.#migrateSettings();
      }
      return;
    }
    this.multiUserServer = true;
    let user = localStorage["Comfy.userId"];
    const users = userConfig.users ?? {};
    if (!user || !users[user]) {
      if (this.vueAppReady) useWorkspaceStore().spinner = false;
      const { UserSelectionScreen } = await __vitePreload(async () => {
        const { UserSelectionScreen: UserSelectionScreen2 } = await import("./userSelection-DSpF-zVD.js");
        return { UserSelectionScreen: UserSelectionScreen2 };
      }, true ? __vite__mapDeps([2,3]) : void 0, import.meta.url);
      this.ui.menuContainer.style.display = "none";
      const { userId, username, created: created3 } = await new UserSelectionScreen().show(users, user);
      this.ui.menuContainer.style.display = "";
      user = userId;
      localStorage["Comfy.userName"] = username;
      localStorage["Comfy.userId"] = user;
      if (created3) {
        api.user = user;
        await this.#migrateSettings();
      }
    }
    api.user = user;
    this.ui.settings.addSetting({
      id: "Comfy.SwitchUser",
      name: "Switch User",
      type: /* @__PURE__ */ __name((name) => {
        let currentUser = localStorage["Comfy.userName"];
        if (currentUser) {
          currentUser = ` (${currentUser})`;
        }
        return $el("tr", [
          $el("td", [
            $el("label", {
              textContent: name
            })
          ]),
          $el("td", [
            $el("button", {
              textContent: name + (currentUser ?? ""),
              onclick: /* @__PURE__ */ __name(() => {
                delete localStorage["Comfy.userId"];
                delete localStorage["Comfy.userName"];
                window.location.reload();
              }, "onclick")
            })
          ])
        ]);
      }, "type"),
      // TODO: Is that the correct default value?
      defaultValue: void 0
    });
  }
  /**
   * Set up the app on the page
   */
  async setup(canvasEl) {
    this.canvasEl = canvasEl;
    await this.#setUser();
    this.resizeCanvas();
    await Promise.all([
      this.workflowManager.loadWorkflows(),
      this.ui.settings.load()
    ]);
    await this.#loadExtensions();
    addDomClippingSetting();
    this.#addProcessMouseHandler();
    this.#addProcessKeyHandler();
    this.#addConfigureHandler();
    this.#addApiUpdateHandlers();
    this.#addRestoreWorkflowView();
    this.graph = new LGraph();
    this.#addAfterConfigureHandler();
    this.canvas = new LGraphCanvas(canvasEl, this.graph);
    this.ctx = canvasEl.getContext("2d");
    LiteGraph.alt_drag_do_clone_nodes = true;
    this.graph.start();
    this.resizeCanvas();
    window.addEventListener("resize", () => this.resizeCanvas());
    const ro = new ResizeObserver(() => this.resizeCanvas());
    ro.observe(this.bodyTop);
    ro.observe(this.bodyLeft);
    ro.observe(this.bodyRight);
    ro.observe(this.bodyBottom);
    await this.#invokeExtensionsAsync("init");
    await this.registerNodes();
    initWidgets(this);
    let restored = false;
    try {
      const loadWorkflow = /* @__PURE__ */ __name(async (json) => {
        if (json) {
          const workflow = JSON.parse(json);
          const workflowName = getStorageValue("Comfy.PreviousWorkflow");
          await this.loadGraphData(workflow, true, true, workflowName);
          return true;
        }
      }, "loadWorkflow");
      const clientId = api.initialClientId ?? api.clientId;
      restored = clientId && await loadWorkflow(
        sessionStorage.getItem(`workflow:${clientId}`)
      ) || await loadWorkflow(localStorage.getItem("workflow"));
    } catch (err) {
      console.error("Error loading previous workflow", err);
    }
    if (!restored) {
      await this.loadGraphData();
    }
    setInterval(() => {
      const sortNodes = this.vueAppReady && useSettingStore().get("Comfy.Workflow.SortNodeIdOnSave");
      const workflow = JSON.stringify(this.graph.serialize({ sortNodes }));
      localStorage.setItem("workflow", workflow);
      if (api.clientId) {
        sessionStorage.setItem(`workflow:${api.clientId}`, workflow);
      }
    }, 1e3);
    this.#addDrawNodeHandler();
    this.#addDrawGroupsHandler();
    this.#addDropHandler();
    this.#addCopyHandler();
    this.#addPasteHandler();
    this.#addKeyboardHandler();
    await this.#invokeExtensionsAsync("setup");
  }
  resizeCanvas() {
    const scale = Math.max(window.devicePixelRatio, 1);
    this.canvasEl.height = this.canvasEl.width = NaN;
    const { width: width2, height } = this.canvasEl.getBoundingClientRect();
    this.canvasEl.width = Math.round(width2 * scale);
    this.canvasEl.height = Math.round(height * scale);
    this.canvasEl.getContext("2d").scale(scale, scale);
    this.canvas?.draw(true, true);
  }
  updateVueAppNodeDefs(defs) {
    const rawDefs = Object.fromEntries(
      Object.entries(LiteGraph.registered_node_types).map(([name, node3]) => [
        name,
        {
          name,
          display_name: name,
          // @ts-expect-error
          category: node3.category || "__frontend_only__",
          input: { required: {}, optional: {} },
          output: [],
          output_name: [],
          output_is_list: [],
          python_module: "custom_nodes.frontend_only",
          description: `Frontend only node for ${name}`
        }
      ])
    );
    const allNodeDefs = {
      ...rawDefs,
      ...defs,
      ...SYSTEM_NODE_DEFS
    };
    const nodeDefStore = useNodeDefStore();
    const nodeDefArray = Object.values(allNodeDefs);
    this.#invokeExtensions("beforeRegisterVueAppNodeDefs", nodeDefArray, this);
    nodeDefStore.updateNodeDefs(nodeDefArray);
    nodeDefStore.updateWidgets(this.widgets);
  }
  /**
   * Registers nodes with the graph
   */
  async registerNodes() {
    const defs = await api.getNodeDefs();
    await this.registerNodesFromDefs(defs);
    await this.#invokeExtensionsAsync("registerCustomNodes");
    if (this.vueAppReady) {
      this.updateVueAppNodeDefs(defs);
    }
  }
  getWidgetType(inputData, inputName) {
    const type = inputData[0];
    if (Array.isArray(type)) {
      return "COMBO";
    } else if (`${type}:${inputName}` in this.widgets) {
      return `${type}:${inputName}`;
    } else if (type in this.widgets) {
      return type;
    } else {
      return null;
    }
  }
  async registerNodeDef(nodeId, nodeData) {
    const self2 = this;
    const node3 = class ComfyNode extends LGraphNode {
      static {
        __name(this, "ComfyNode");
      }
      static comfyClass = nodeData.name;
      // TODO: change to "title?" once litegraph.d.ts has been updated
      static title = nodeData.display_name || nodeData.name;
      static nodeData = nodeData;
      static category;
      constructor(title) {
        super(title);
        var inputs = nodeData["input"]["required"];
        if (nodeData["input"]["optional"] != void 0) {
          inputs = Object.assign(
            {},
            nodeData["input"]["required"],
            nodeData["input"]["optional"]
          );
        }
        const config = { minWidth: 1, minHeight: 1 };
        for (const inputName in inputs) {
          const inputData = inputs[inputName];
          const type = inputData[0];
          let widgetCreated = true;
          const widgetType = self2.getWidgetType(inputData, inputName);
          if (widgetType) {
            if (widgetType === "COMBO") {
              Object.assign(
                config,
                self2.widgets.COMBO(this, inputName, inputData, app$1) || {}
              );
            } else {
              Object.assign(
                config,
                self2.widgets[widgetType](this, inputName, inputData, app$1) || {}
              );
            }
          } else {
            this.addInput(inputName, type);
            widgetCreated = false;
          }
          if (widgetCreated && inputData[1]?.forceInput && config?.widget) {
            if (!config.widget.options) config.widget.options = {};
            config.widget.options.forceInput = inputData[1].forceInput;
          }
          if (widgetCreated && inputData[1]?.defaultInput && config?.widget) {
            if (!config.widget.options) config.widget.options = {};
            config.widget.options.defaultInput = inputData[1].defaultInput;
          }
        }
        for (const o in nodeData["output"]) {
          let output = nodeData["output"][o];
          if (output instanceof Array) output = "COMBO";
          const outputName = nodeData["output_name"][o] || output;
          const outputShape = nodeData["output_is_list"][o] ? LiteGraph.GRID_SHAPE : LiteGraph.CIRCLE_SHAPE;
          this.addOutput(outputName, output, { shape: outputShape });
        }
        const s = this.computeSize();
        s[0] = Math.max(config.minWidth, s[0] * 1.5);
        s[1] = Math.max(config.minHeight, s[1]);
        this.size = s;
        this.serialize_widgets = true;
        app$1.#invokeExtensionsAsync("nodeCreated", this);
      }
    };
    node3.prototype.comfyClass = nodeData.name;
    this.#addNodeContextMenuHandler(node3);
    this.#addDrawBackgroundHandler(node3);
    this.#addNodeKeyHandler(node3);
    await this.#invokeExtensionsAsync("beforeRegisterNodeDef", node3, nodeData);
    LiteGraph.registerNodeType(nodeId, node3);
    node3.category = nodeData.category;
  }
  async registerNodesFromDefs(defs) {
    await this.#invokeExtensionsAsync("addCustomNodeDefs", defs);
    this.widgets = Object.assign(
      {},
      ComfyWidgets,
      ...(await this.#invokeExtensionsAsync("getCustomWidgets")).filter(Boolean)
    );
    for (const nodeId in defs) {
      this.registerNodeDef(nodeId, defs[nodeId]);
    }
  }
  loadTemplateData(templateData) {
    if (!templateData?.templates) {
      return;
    }
    const old = localStorage.getItem("litegrapheditor_clipboard");
    var maxY, nodeBottom, node3;
    for (const template of templateData.templates) {
      if (!template?.data) {
        continue;
      }
      localStorage.setItem("litegrapheditor_clipboard", template.data);
      app$1.canvas.pasteFromClipboard();
      maxY = false;
      for (const i2 in app$1.canvas.selected_nodes) {
        node3 = app$1.canvas.selected_nodes[i2];
        nodeBottom = node3.pos[1] + node3.size[1];
        if (maxY === false || nodeBottom > maxY) {
          maxY = nodeBottom;
        }
      }
      app$1.canvas.graph_mouse[1] = maxY + 50;
    }
    localStorage.setItem("litegrapheditor_clipboard", old);
  }
  showMissingNodesError(missingNodeTypes, hasAddedNodes = true) {
    if (this.vueAppReady && useSettingStore().get("Comfy.Workflow.ShowMissingNodesWarning")) {
      showLoadWorkflowWarning({
        missingNodeTypes,
        hasAddedNodes,
        maximizable: true
      });
    }
    this.logging.addEntry("Comfy.App", "warn", {
      MissingNodes: missingNodeTypes
    });
  }
  showMissingModelsError(missingModels) {
    if (this.vueAppReady && useSettingStore().get("Comfy.Workflow.ShowMissingModelsWarning")) {
      showMissingModelsWarning({
        missingModels,
        maximizable: true
      });
    }
    this.logging.addEntry("Comfy.App", "warn", {
      MissingModels: missingModels
    });
  }
  async changeWorkflow(callback, workflow = null) {
    try {
      this.workflowManager.activeWorkflow?.changeTracker?.store();
    } catch (error) {
      console.error(error);
    }
    await callback();
    try {
      this.workflowManager.setWorkflow(workflow);
      this.workflowManager.activeWorkflow?.track();
    } catch (error) {
      console.error(error);
    }
  }
  async loadGraphData(graphData, clean = true, restore_view = true, workflow = null, { showMissingNodesDialog = true, showMissingModelsDialog = true } = {}) {
    if (clean !== false) {
      this.clean();
    }
    let reset_invalid_values = false;
    if (!graphData) {
      graphData = defaultGraph;
      reset_invalid_values = true;
    }
    if (typeof structuredClone === "undefined") {
      graphData = JSON.parse(JSON.stringify(graphData));
    } else {
      graphData = structuredClone(graphData);
    }
    try {
      this.workflowManager.setWorkflow(workflow);
    } catch (error) {
      console.error(error);
    }
    if (this.vueAppReady && useSettingStore().get("Comfy.Validation.Workflows")) {
      const validatedGraphData = await validateComfyWorkflow(
        graphData,
        /* onError=*/
        alert
      );
      graphData = validatedGraphData ?? graphData;
    }
    const missingNodeTypes = [];
    const missingModels = [];
    await this.#invokeExtensionsAsync(
      "beforeConfigureGraph",
      graphData,
      missingNodeTypes
      // TODO: missingModels
    );
    for (let n of graphData.nodes) {
      if (n.type == "T2IAdapterLoader") n.type = "ControlNetLoader";
      if (n.type == "ConditioningAverage ") n.type = "ConditioningAverage";
      if (n.type == "SDV_img2vid_Conditioning")
        n.type = "SVD_img2vid_Conditioning";
      if (!(n.type in LiteGraph.registered_node_types)) {
        missingNodeTypes.push(n.type);
        n.type = sanitizeNodeName(n.type);
      }
    }
    if (graphData.models && useSettingStore().get("Comfy.Workflow.ShowMissingModelsWarning")) {
      for (let m of graphData.models) {
        const models_available = await useModelStore().getModelsInFolderCached(
          m.directory
        );
        if (models_available === null) {
          m.directory_invalid = true;
          missingModels.push(m);
        } else if (!(m.name in models_available.models)) {
          missingModels.push(m);
        }
      }
    }
    try {
      this.graph.configure(graphData);
      if (restore_view && this.enableWorkflowViewRestore.value && graphData.extra?.ds) {
        this.canvas.ds.offset = graphData.extra.ds.offset;
        this.canvas.ds.scale = graphData.extra.ds.scale;
      }
      try {
        this.workflowManager.activeWorkflow?.track();
      } catch (error) {
      }
    } catch (error) {
      let errorHint = [];
      const filename = error.fileName || (error.stack || "").match(/(\/extensions\/.*\.js)/)?.[1];
      const pos2 = (filename || "").indexOf("/extensions/");
      if (pos2 > -1) {
        errorHint.push(
          $el("span", {
            textContent: "This may be due to the following script:"
          }),
          $el("br"),
          $el("span", {
            style: {
              fontWeight: "bold"
            },
            textContent: filename.substring(pos2)
          })
        );
      }
      this.ui.dialog.show(
        $el("div", [
          $el("p", {
            textContent: "Loading aborted due to error reloading workflow data"
          }),
          $el("pre", {
            style: { padding: "5px", backgroundColor: "rgba(255,0,0,0.2)" },
            textContent: error.toString()
          }),
          $el("pre", {
            style: {
              padding: "5px",
              color: "#ccc",
              fontSize: "10px",
              maxHeight: "50vh",
              overflow: "auto",
              backgroundColor: "rgba(0,0,0,0.2)"
            },
            textContent: error.stack || "No stacktrace available"
          }),
          ...errorHint
        ]).outerHTML
      );
      return;
    }
    for (const node3 of this.graph._nodes) {
      const size2 = node3.computeSize();
      size2[0] = Math.max(node3.size[0], size2[0]);
      size2[1] = Math.max(node3.size[1], size2[1]);
      node3.size = size2;
      if (node3.widgets) {
        for (let widget of node3.widgets) {
          if (node3.type == "KSampler" || node3.type == "KSamplerAdvanced") {
            if (widget.name == "sampler_name") {
              if (widget.value.startsWith("sample_")) {
                widget.value = widget.value.slice(7);
              }
            }
          }
          if (node3.type == "KSampler" || node3.type == "KSamplerAdvanced" || node3.type == "PrimitiveNode") {
            if (widget.name == "control_after_generate") {
              if (widget.value === true) {
                widget.value = "randomize";
              } else if (widget.value === false) {
                widget.value = "fixed";
              }
            }
          }
          if (reset_invalid_values) {
            if (widget.type == "combo") {
              if (!widget.options.values.includes(widget.value) && widget.options.values.length > 0) {
                widget.value = widget.options.values[0];
              }
            }
          }
        }
      }
      this.#invokeExtensions("loadedGraphNode", node3);
    }
    if (missingNodeTypes.length && showMissingNodesDialog) {
      this.showMissingNodesError(missingNodeTypes);
    }
    if (missingModels.length && showMissingModelsDialog) {
      this.showMissingModelsError(missingModels);
    }
    await this.#invokeExtensionsAsync("afterConfigureGraph", missingNodeTypes);
    requestAnimationFrame(() => {
      this.graph.setDirtyCanvas(true, true);
    });
  }
  /**
   * Converts the current graph workflow for sending to the API
   * @returns The workflow and node links
   */
  async graphToPrompt(graph = this.graph, clean = true) {
    for (const outerNode of this.graph.computeExecutionOrder(false)) {
      if (outerNode.widgets) {
        for (const widget of outerNode.widgets) {
          widget.beforeQueued?.();
        }
      }
      const innerNodes = outerNode.getInnerNodes ? outerNode.getInnerNodes() : [outerNode];
      for (const node3 of innerNodes) {
        if (node3.isVirtualNode) {
          if (node3.applyToGraph) {
            node3.applyToGraph();
          }
        }
      }
    }
    const sortNodes = this.vueAppReady && useSettingStore().get("Comfy.Workflow.SortNodeIdOnSave");
    const workflow = graph.serialize({ sortNodes });
    const output = {};
    for (const outerNode of graph.computeExecutionOrder(false)) {
      const skipNode = outerNode.mode === 2 || outerNode.mode === 4;
      const innerNodes = !skipNode && outerNode.getInnerNodes ? outerNode.getInnerNodes() : [outerNode];
      for (const node3 of innerNodes) {
        if (node3.isVirtualNode) {
          continue;
        }
        if (node3.mode === 2 || node3.mode === 4) {
          continue;
        }
        const inputs = {};
        const widgets = node3.widgets;
        if (widgets) {
          for (const i2 in widgets) {
            const widget = widgets[i2];
            if (!widget.options || widget.options.serialize !== false) {
              inputs[widget.name] = widget.serializeValue ? await widget.serializeValue(node3, i2) : widget.value;
            }
          }
        }
        for (let i2 in node3.inputs) {
          let parent = node3.getInputNode(i2);
          if (parent) {
            let link = node3.getInputLink(i2);
            while (parent.mode === 4 || parent.isVirtualNode) {
              let found = false;
              if (parent.isVirtualNode) {
                link = parent.getInputLink(link.origin_slot);
                if (link) {
                  parent = parent.getInputNode(link.target_slot);
                  if (parent) {
                    found = true;
                  }
                }
              } else if (link && parent.mode === 4) {
                let all_inputs = [link.origin_slot];
                if (parent.inputs) {
                  all_inputs = all_inputs.concat(Object.keys(parent.inputs));
                  for (let parent_input in all_inputs) {
                    parent_input = all_inputs[parent_input];
                    if (parent.inputs[parent_input]?.type === node3.inputs[i2].type) {
                      link = parent.getInputLink(parent_input);
                      if (link) {
                        parent = parent.getInputNode(parent_input);
                      }
                      found = true;
                      break;
                    }
                  }
                }
              }
              if (!found) {
                break;
              }
            }
            if (link) {
              if (parent?.updateLink) {
                link = parent.updateLink(link);
              }
              if (link) {
                inputs[node3.inputs[i2].name] = [
                  String(link.origin_id),
                  parseInt(link.origin_slot)
                ];
              }
            }
          }
        }
        let node_data = {
          inputs,
          class_type: node3.comfyClass
        };
        if (this.ui.settings.getSettingValue("Comfy.DevMode")) {
          node_data["_meta"] = {
            title: node3.title
          };
        }
        output[String(node3.id)] = node_data;
      }
    }
    if (clean) {
      for (const o in output) {
        for (const i2 in output[o].inputs) {
          if (Array.isArray(output[o].inputs[i2]) && output[o].inputs[i2].length === 2 && !output[output[o].inputs[i2][0]]) {
            delete output[o].inputs[i2];
          }
        }
      }
    }
    return { workflow, output };
  }
  #formatPromptError(error) {
    if (error == null) {
      return "(unknown error)";
    } else if (typeof error === "string") {
      return error;
    } else if (error.stack && error.message) {
      return error.toString();
    } else if (error.response) {
      let message3 = error.response.error.message;
      if (error.response.error.details)
        message3 += ": " + error.response.error.details;
      for (const [nodeID, nodeError] of Object.entries(
        error.response.node_errors
      )) {
        message3 += "\n" + nodeError.class_type + ":";
        for (const errorReason of nodeError.errors) {
          message3 += "\n    - " + errorReason.message + ": " + errorReason.details;
        }
      }
      return message3;
    }
    return "(unknown error)";
  }
  async queuePrompt(number2, batchCount = 1) {
    this.#queueItems.push({ number: number2, batchCount });
    if (this.#processingQueue) {
      return;
    }
    this.#processingQueue = true;
    this.lastNodeErrors = null;
    try {
      while (this.#queueItems.length) {
        ;
        ({ number: number2, batchCount } = this.#queueItems.pop());
        for (let i2 = 0; i2 < batchCount; i2++) {
          const p2 = await this.graphToPrompt();
          try {
            const res = await api.queuePrompt(number2, p2);
            this.lastNodeErrors = res.node_errors;
            if (this.lastNodeErrors.length > 0) {
              this.canvas.draw(true, true);
            } else {
              try {
                this.workflowManager.storePrompt({
                  id: res.prompt_id,
                  nodes: Object.keys(p2.output)
                });
              } catch (error) {
              }
            }
          } catch (error) {
            const formattedError = this.#formatPromptError(error);
            this.ui.dialog.show(formattedError);
            if (error.response) {
              this.lastNodeErrors = error.response.node_errors;
              this.canvas.draw(true, true);
            }
            break;
          }
          for (const n of p2.workflow.nodes) {
            const node3 = this.graph.getNodeById(n.id);
            if (node3.widgets) {
              for (const widget of node3.widgets) {
                if (widget.afterQueued) {
                  widget.afterQueued();
                }
              }
            }
          }
          this.canvas.draw(true, true);
          await this.ui.queue.update();
        }
      }
    } finally {
      this.#processingQueue = false;
    }
    api.dispatchEvent(
      new CustomEvent("promptQueued", { detail: { number: number2, batchCount } })
    );
    return !this.lastNodeErrors;
  }
  showErrorOnFileLoad(file) {
    this.ui.dialog.show(
      $el("div", [
        $el("p", { textContent: `Unable to find workflow in ${file.name}` })
      ]).outerHTML
    );
  }
  /**
   * Loads workflow data from the specified file
   * @param {File} file
   */
  async handleFile(file) {
    const removeExt = /* @__PURE__ */ __name((f) => {
      if (!f) return f;
      const p2 = f.lastIndexOf(".");
      if (p2 === -1) return f;
      return f.substring(0, p2);
    }, "removeExt");
    const fileName = removeExt(file.name);
    if (file.type === "image/png") {
      const pngInfo = await getPngMetadata(file);
      if (pngInfo?.workflow) {
        await this.loadGraphData(
          JSON.parse(pngInfo.workflow),
          true,
          true,
          fileName
        );
      } else if (pngInfo?.prompt) {
        this.loadApiJson(JSON.parse(pngInfo.prompt), fileName);
      } else if (pngInfo?.parameters) {
        this.changeWorkflow(() => {
          importA1111(this.graph, pngInfo.parameters);
        }, fileName);
      } else {
        this.showErrorOnFileLoad(file);
      }
    } else if (file.type === "image/webp") {
      const pngInfo = await getWebpMetadata(file);
      const workflow = pngInfo?.workflow || pngInfo?.Workflow;
      const prompt2 = pngInfo?.prompt || pngInfo?.Prompt;
      if (workflow) {
        this.loadGraphData(JSON.parse(workflow), true, true, fileName);
      } else if (prompt2) {
        this.loadApiJson(JSON.parse(prompt2), fileName);
      } else {
        this.showErrorOnFileLoad(file);
      }
    } else if (file.type === "audio/flac" || file.type === "audio/x-flac") {
      const pngInfo = await getFlacMetadata(file);
      const workflow = pngInfo?.workflow || pngInfo?.Workflow;
      const prompt2 = pngInfo?.prompt || pngInfo?.Prompt;
      if (workflow) {
        this.loadGraphData(JSON.parse(workflow), true, true, fileName);
      } else if (prompt2) {
        this.loadApiJson(JSON.parse(prompt2), fileName);
      } else {
        this.showErrorOnFileLoad(file);
      }
    } else if (file.type === "application/json" || file.name?.endsWith(".json")) {
      const reader = new FileReader();
      reader.onload = async () => {
        const readerResult = reader.result;
        const jsonContent = JSON.parse(readerResult);
        if (jsonContent?.templates) {
          this.loadTemplateData(jsonContent);
        } else if (this.isApiJson(jsonContent)) {
          this.loadApiJson(jsonContent, fileName);
        } else {
          await this.loadGraphData(
            JSON.parse(readerResult),
            true,
            false,
            fileName
          );
        }
      };
      reader.readAsText(file);
    } else if (file.name?.endsWith(".latent") || file.name?.endsWith(".safetensors")) {
      const info = await getLatentMetadata(file);
      if (info.workflow) {
        await this.loadGraphData(
          // @ts-expect-error
          JSON.parse(info.workflow),
          true,
          true,
          fileName
        );
      } else if (info.prompt) {
        this.loadApiJson(JSON.parse(info.prompt));
      } else {
        this.showErrorOnFileLoad(file);
      }
    } else {
      this.showErrorOnFileLoad(file);
    }
  }
  isApiJson(data24) {
    return Object.values(data24).every((v2) => v2.class_type);
  }
  loadApiJson(apiData, fileName) {
    const missingNodeTypes = Object.values(apiData).filter(
      // @ts-expect-error
      (n) => !LiteGraph.registered_node_types[n.class_type]
    );
    if (missingNodeTypes.length) {
      this.showMissingNodesError(
        // @ts-expect-error
        missingNodeTypes.map((t) => t.class_type),
        false
      );
      return;
    }
    const ids = Object.keys(apiData);
    app$1.graph.clear();
    for (const id2 of ids) {
      const data24 = apiData[id2];
      const node3 = LiteGraph.createNode(data24.class_type);
      node3.id = isNaN(+id2) ? id2 : +id2;
      node3.title = data24._meta?.title ?? node3.title;
      app$1.graph.add(node3);
    }
    this.changeWorkflow(() => {
      for (const id2 of ids) {
        const data24 = apiData[id2];
        const node3 = app$1.graph.getNodeById(id2);
        for (const input in data24.inputs ?? {}) {
          const value3 = data24.inputs[input];
          if (value3 instanceof Array) {
            const [fromId, fromSlot] = value3;
            const fromNode = app$1.graph.getNodeById(fromId);
            let toSlot = node3.inputs?.findIndex((inp) => inp.name === input);
            if (toSlot == null || toSlot === -1) {
              try {
                const widget = node3.widgets?.find((w2) => w2.name === input);
                if (widget && node3.convertWidgetToInput?.(widget)) {
                  toSlot = node3.inputs?.length - 1;
                }
              } catch (error) {
              }
            }
            if (toSlot != null || toSlot !== -1) {
              fromNode.connect(fromSlot, node3, toSlot);
            }
          } else {
            const widget = node3.widgets?.find((w2) => w2.name === input);
            if (widget) {
              widget.value = value3;
              widget.callback?.(value3);
            }
          }
        }
      }
      app$1.graph.arrange();
    }, fileName);
    for (const id2 of ids) {
      const data24 = apiData[id2];
      const node3 = app$1.graph.getNodeById(id2);
      for (const input in data24.inputs ?? {}) {
        const value3 = data24.inputs[input];
        if (value3 instanceof Array) {
          const [fromId, fromSlot] = value3;
          const fromNode = app$1.graph.getNodeById(fromId);
          let toSlot = node3.inputs?.findIndex((inp) => inp.name === input);
          if (toSlot == null || toSlot === -1) {
            try {
              const widget = node3.widgets?.find((w2) => w2.name === input);
              if (widget && node3.convertWidgetToInput?.(widget)) {
                toSlot = node3.inputs?.length - 1;
              }
            } catch (error) {
            }
          }
          if (toSlot != null || toSlot !== -1) {
            fromNode.connect(fromSlot, node3, toSlot);
          }
        } else {
          const widget = node3.widgets?.find((w2) => w2.name === input);
          if (widget) {
            widget.value = value3;
            widget.callback?.(value3);
          }
        }
      }
    }
    app$1.graph.arrange();
  }
  /**
   * Registers a Comfy web extension with the app
   * @param {ComfyExtension} extension
   */
  registerExtension(extension) {
    if (!extension.name) {
      throw new Error("Extensions must have a 'name' property.");
    }
    if (extension.name === "pysssss.Locking") {
      console.log("pysssss.Locking is replaced by pin/unpin in ComfyUI core.");
      return;
    }
    if (this.extensions.find((ext) => ext.name === extension.name)) {
      throw new Error(`Extension named '${extension.name}' already registered.`);
    }
    this.extensions.push(extension);
  }
  /**
   * Refresh combo list on whole nodes
   */
  async refreshComboInNodes() {
    const requestToastMessage = {
      severity: "info",
      summary: "Update",
      detail: "Update requested"
    };
    if (this.vueAppReady) {
      useToastStore().add(requestToastMessage);
      useModelStore().clearCache();
    }
    const defs = await api.getNodeDefs();
    for (const nodeId in defs) {
      this.registerNodeDef(nodeId, defs[nodeId]);
    }
    for (let nodeNum in this.graph._nodes) {
      const node3 = this.graph._nodes[nodeNum];
      const def2 = defs[node3.type];
      node3.refreshComboInNode?.(defs);
      if (!def2) continue;
      for (const widgetNum in node3.widgets) {
        const widget = node3.widgets[widgetNum];
        if (widget.type == "combo" && def2["input"]["required"][widget.name] !== void 0) {
          widget.options.values = def2["input"]["required"][widget.name][0];
          if (widget.name != "image" && !widget.options.values.includes(widget.value)) {
            widget.value = widget.options.values[0];
            widget.callback(widget.value);
          }
        }
      }
    }
    await this.#invokeExtensionsAsync("refreshComboInNodes", defs);
    if (this.vueAppReady) {
      this.updateVueAppNodeDefs(defs);
      useToastStore().remove(requestToastMessage);
      useToastStore().add({
        severity: "success",
        summary: "Updated",
        detail: "Node definitions updated",
        life: 1e3
      });
    }
  }
  resetView() {
    app$1.canvas.ds.scale = 1;
    app$1.canvas.ds.offset = [0, 0];
    app$1.graph.setDirtyCanvas(true, true);
  }
  /**
   * Clean current state
   */
  clean() {
    this.nodeOutputs = {};
    this.nodePreviewImages = {};
    this.lastNodeErrors = null;
    this.lastExecutionError = null;
    this.runningNodeId = null;
  }
  addNodeOnGraph(nodeDef, options3 = {}) {
    const node3 = LiteGraph.createNode(
      nodeDef.name,
      nodeDef.display_name,
      options3
    );
    this.graph.add(node3);
    return node3;
  }
  clientPosToCanvasPos(pos2) {
    const rect = this.canvasContainer.getBoundingClientRect();
    const containerOffsets = [rect.left, rect.top];
    return _.zip(pos2, this.canvas.ds.offset, containerOffsets).map(
      ([p2, o1, o2]) => (p2 - o2) / this.canvas.ds.scale - o1
    );
  }
  canvasPosToClientPos(pos2) {
    const rect = this.canvasContainer.getBoundingClientRect();
    const containerOffsets = [rect.left, rect.top];
    return _.zip(pos2, this.canvas.ds.offset, containerOffsets).map(
      ([p2, o1, o2]) => (p2 + o1) * this.canvas.ds.scale + o2
    );
  }
  getCanvasCenter() {
    const dpi = Math.max(window.devicePixelRatio ?? 1, 1);
    const [x2, y2, w2, h2] = app$1.canvas.ds.visible_area;
    return [x2 + w2 / dpi / 2, y2 + h2 / dpi / 2];
  }
  goToNode(nodeId) {
    const graphNode = this.graph.getNodeById(nodeId);
    if (!graphNode) return;
    this.canvas.centerOnNode(graphNode);
  }
}
const app$1 = new ComfyApp();
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.app = window.comfyAPI.app || {};
window.comfyAPI.app.ANIM_PREVIEW_WIDGET = ANIM_PREVIEW_WIDGET;
window.comfyAPI.app.ComfyApp = ComfyApp;
window.comfyAPI.app.app = app$1;
const _withScopeId$d = /* @__PURE__ */ __name((n) => (pushScopeId("data-v-8ac76bc5"), n = n(), popScopeId(), n), "_withScopeId$d");
const _hoisted_1$B = { class: "editable-text" };
const _hoisted_2$r = { key: 0 };
const _sfc_main$v = /* @__PURE__ */ defineComponent({
  __name: "EditableText",
  props: {
    modelValue: {},
    isEditing: { type: Boolean, default: false }
  },
  emits: ["update:modelValue", "edit"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const inputValue2 = ref(props.modelValue);
    const isEditingFinished = ref(false);
    const inputRef = ref(null);
    const finishEditing = /* @__PURE__ */ __name(() => {
      if (isEditingFinished.value) {
        return;
      }
      isEditingFinished.value = true;
      emit2("edit", inputValue2.value);
    }, "finishEditing");
    watch(
      () => props.isEditing,
      (newVal) => {
        if (newVal) {
          inputValue2.value = props.modelValue;
          isEditingFinished.value = false;
          nextTick(() => {
            if (!inputRef.value) return;
            const fileName = inputValue2.value.includes(".") ? inputValue2.value.split(".").slice(0, -1).join(".") : inputValue2.value;
            const start2 = 0;
            const end = fileName.length;
            const inputElement = inputRef.value.$el;
            inputElement.setSelectionRange(start2, end);
          });
        }
      },
      { immediate: true }
    );
    const vFocus = {
      mounted: /* @__PURE__ */ __name((el) => el.focus(), "mounted")
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$B, [
        !props.isEditing ? (openBlock(), createElementBlock("span", _hoisted_2$r, toDisplayString$1(_ctx.modelValue), 1)) : withDirectives((openBlock(), createBlock(unref(script$O), {
          key: 1,
          type: "text",
          size: "small",
          fluid: "",
          modelValue: inputValue2.value,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => inputValue2.value = $event),
          ref_key: "inputRef",
          ref: inputRef,
          onKeyup: withKeys(finishEditing, ["enter"]),
          onClick: _cache[1] || (_cache[1] = withModifiers(() => {
          }, ["stop"])),
          pt: {
            root: {
              onBlur: finishEditing
            }
          }
        }, null, 8, ["modelValue", "pt"])), [
          [vFocus]
        ])
      ]);
    };
  }
});
const EditableText = /* @__PURE__ */ _export_sfc(_sfc_main$v, [["__scopeId", "data-v-8ac76bc5"]]);
const _sfc_main$u = /* @__PURE__ */ defineComponent({
  __name: "TitleEditor",
  setup(__props) {
    const settingStore = useSettingStore();
    const showInput = ref(false);
    const editedTitle = ref("");
    const inputStyle = ref({
      position: "fixed",
      left: "0px",
      top: "0px",
      width: "200px",
      height: "20px",
      fontSize: "12px"
    });
    const titleEditorStore = useTitleEditorStore();
    const onEdit = /* @__PURE__ */ __name((newValue) => {
      if (titleEditorStore.titleEditorTarget && newValue.trim() !== "") {
        titleEditorStore.titleEditorTarget.title = newValue.trim();
        app$1.graph.setDirtyCanvas(true, true);
      }
      showInput.value = false;
      titleEditorStore.titleEditorTarget = null;
    }, "onEdit");
    watch(
      () => titleEditorStore.titleEditorTarget,
      (target) => {
        if (target === null) {
          return;
        }
        editedTitle.value = target.title;
        showInput.value = true;
        if (target instanceof LGraphGroup) {
          const group = target;
          const [x2, y2] = group.pos;
          const [w2, h2] = group.size;
          const [left, top] = app$1.canvasPosToClientPos([x2, y2]);
          inputStyle.value.left = `${left}px`;
          inputStyle.value.top = `${top}px`;
          const width2 = w2 * app$1.canvas.ds.scale;
          const height = group.titleHeight * app$1.canvas.ds.scale;
          inputStyle.value.width = `${width2}px`;
          inputStyle.value.height = `${height}px`;
          const fontSize = group.font_size * app$1.canvas.ds.scale;
          inputStyle.value.fontSize = `${fontSize}px`;
        } else if (target instanceof LGraphNode) {
          const node3 = target;
          const isCollapsed = node3.flags?.collapsed;
          const [x2, y2, nodeWidth, nodeHeight] = node3.getBounding();
          const canvasWidth = (
            // @ts-expect-error Remove after collapsed_width is exposed in LiteGraph
            isCollapsed && node3._collapsed_width ? node3._collapsed_width : nodeWidth
          );
          const canvasHeight = LiteGraph.NODE_TITLE_HEIGHT;
          const [left, top] = app$1.canvasPosToClientPos([x2, y2]);
          inputStyle.value.left = `${left}px`;
          inputStyle.value.top = `${top}px`;
          const width2 = canvasWidth * app$1.canvas.ds.scale;
          const height = canvasHeight * app$1.canvas.ds.scale;
          inputStyle.value.width = `${width2}px`;
          inputStyle.value.height = `${height}px`;
          const fontSize = 12 * app$1.canvas.ds.scale;
          inputStyle.value.fontSize = `${fontSize}px`;
        }
      }
    );
    const canvasEventHandler = /* @__PURE__ */ __name((event2) => {
      if (!settingStore.get("Comfy.Group.DoubleClickTitleToEdit")) {
        return;
      }
      if (event2.detail.subType === "group-double-click") {
        const group = event2.detail.group;
        const [x2, y2] = group.pos;
        const e = event2.detail.originalEvent;
        const relativeY = e.canvasY - y2;
        if (relativeY > group.titleHeight) {
          return;
        }
        titleEditorStore.titleEditorTarget = group;
      }
    }, "canvasEventHandler");
    const extension = {
      name: "Comfy.NodeTitleEditor",
      nodeCreated(node3) {
        const originalCallback = node3.onNodeTitleDblClick;
        node3.onNodeTitleDblClick = function(e, ...args) {
          if (!settingStore.get("Comfy.Node.DoubleClickTitleToEdit")) {
            return;
          }
          titleEditorStore.titleEditorTarget = this;
          if (typeof originalCallback === "function") {
            originalCallback.call(this, e, ...args);
          }
        };
      }
    };
    onMounted(() => {
      document.addEventListener("litegraph:canvas", canvasEventHandler);
      app$1.registerExtension(extension);
    });
    onUnmounted(() => {
      document.removeEventListener("litegraph:canvas", canvasEventHandler);
    });
    return (_ctx, _cache) => {
      return showInput.value ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: "group-title-editor node-title-editor",
        style: normalizeStyle(inputStyle.value)
      }, [
        createVNode(EditableText, {
          isEditing: showInput.value,
          modelValue: editedTitle.value,
          onEdit
        }, null, 8, ["isEditing", "modelValue"])
      ], 4)) : createCommentVNode("", true);
    };
  }
});
const TitleEditor = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["__scopeId", "data-v-f0cbabc5"]]);
var theme$e = /* @__PURE__ */ __name(function theme23(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-overlaybadge {\n    position: relative;\n}\n\n.p-overlaybadge .p-badge {\n    position: absolute;\n    top: 0;\n    right: 0;\n    transform: translate(50%, -50%);\n    transform-origin: 100% 0;\n    margin: 0;\n    outline-width: ".concat(dt3("overlaybadge.outline.width"), ";\n    outline-style: solid;\n    outline-color: ").concat(dt3("overlaybadge.outline.color"), ";\n}\n");
}, "theme");
var classes$f = {
  root: "p-overlaybadge"
};
var OverlayBadgeStyle = BaseStyle.extend({
  name: "overlaybadge",
  theme: theme$e,
  classes: classes$f
});
var script$1$f = {
  name: "OverlayBadge",
  "extends": script$K,
  style: OverlayBadgeStyle,
  provide: /* @__PURE__ */ __name(function provide24() {
    return {
      $pcOverlayBadge: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$q = {
  name: "OverlayBadge",
  "extends": script$1$f,
  inheritAttrs: false,
  components: {
    Badge: script$K
  }
};
function render$p(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_Badge = resolveComponent("Badge");
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("root")
  }, _ctx.ptmi("root")), [renderSlot(_ctx.$slots, "default"), createVNode(_component_Badge, mergeProps(_ctx.$props, {
    pt: _ctx.ptm("pcBadge")
  }), null, 16, ["pt"])], 16);
}
__name(render$p, "render$p");
script$q.render = render$p;
const _sfc_main$t = /* @__PURE__ */ defineComponent({
  __name: "SidebarIcon",
  props: {
    icon: String,
    selected: Boolean,
    tooltip: {
      type: String,
      default: ""
    },
    class: {
      type: String,
      default: ""
    },
    iconBadge: {
      type: [String, Function],
      default: ""
    }
  },
  emits: ["click"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const overlayValue = computed(
      () => typeof props.iconBadge === "function" ? props.iconBadge() || "" : props.iconBadge
    );
    const shouldShowBadge = computed(() => !!overlayValue.value);
    return (_ctx, _cache) => {
      const _directive_tooltip = resolveDirective("tooltip");
      return withDirectives((openBlock(), createBlock(unref(script$J), {
        class: normalizeClass(props.class),
        text: "",
        pt: {
          root: `side-bar-button ${props.selected ? "p-button-primary side-bar-button-selected" : "p-button-secondary"}`
        },
        onClick: _cache[0] || (_cache[0] = ($event) => emit2("click", $event))
      }, {
        icon: withCtx(() => [
          shouldShowBadge.value ? (openBlock(), createBlock(unref(script$q), {
            key: 0,
            value: overlayValue.value
          }, {
            default: withCtx(() => [
              createBaseVNode("i", {
                class: normalizeClass(props.icon + " side-bar-button-icon")
              }, null, 2)
            ]),
            _: 1
          }, 8, ["value"])) : (openBlock(), createElementBlock("i", {
            key: 1,
            class: normalizeClass(props.icon + " side-bar-button-icon")
          }, null, 2))
        ]),
        _: 1
      }, 8, ["class", "pt"])), [
        [_directive_tooltip, { value: props.tooltip, showDelay: 300, hideDelay: 300 }]
      ]);
    };
  }
});
const SidebarIcon = /* @__PURE__ */ _export_sfc(_sfc_main$t, [["__scopeId", "data-v-4f2f01b3"]]);
const _sfc_main$s = /* @__PURE__ */ defineComponent({
  __name: "SidebarThemeToggleIcon",
  setup(__props) {
    const previousDarkTheme = ref("dark");
    const currentTheme = computed(() => useSettingStore().get("Comfy.ColorPalette"));
    const isDarkMode = computed(() => currentTheme.value !== "light");
    const icon2 = computed(() => isDarkMode.value ? "pi pi-moon" : "pi pi-sun");
    const toggleTheme = /* @__PURE__ */ __name(() => {
      if (isDarkMode.value) {
        previousDarkTheme.value = currentTheme.value;
        useSettingStore().set("Comfy.ColorPalette", "light");
      } else {
        useSettingStore().set("Comfy.ColorPalette", previousDarkTheme.value);
      }
    }, "toggleTheme");
    return (_ctx, _cache) => {
      return openBlock(), createBlock(SidebarIcon, {
        icon: icon2.value,
        onClick: toggleTheme,
        tooltip: _ctx.$t("sideToolbar.themeToggle"),
        class: "comfy-vue-theme-toggle"
      }, null, 8, ["icon", "tooltip"]);
    };
  }
});
const _sfc_main$r = /* @__PURE__ */ defineComponent({
  __name: "SidebarSettingsToggleIcon",
  setup(__props) {
    const dialogStore = useDialogStore();
    const showSetting = /* @__PURE__ */ __name(() => {
      dialogStore.showDialog({
        headerComponent: SettingDialogHeader,
        component: SettingDialogContent
      });
    }, "showSetting");
    return (_ctx, _cache) => {
      return openBlock(), createBlock(SidebarIcon, {
        icon: "pi pi-cog",
        onClick: showSetting,
        tooltip: _ctx.$t("settings")
      }, null, 8, ["tooltip"]);
    };
  }
});
const _withScopeId$c = /* @__PURE__ */ __name((n) => (pushScopeId("data-v-ed7a1148"), n = n(), popScopeId(), n), "_withScopeId$c");
const _hoisted_1$A = { class: "side-tool-bar-end" };
const _hoisted_2$q = {
  key: 0,
  class: "sidebar-content-container"
};
const _sfc_main$q = /* @__PURE__ */ defineComponent({
  __name: "SideToolbar",
  setup(__props) {
    const workspaceStore = useWorkspaceStore();
    const settingStore = useSettingStore();
    const teleportTarget = computed(
      () => settingStore.get("Comfy.Sidebar.Location") === "left" ? ".comfyui-body-left" : ".comfyui-body-right"
    );
    const isSmall = computed(
      () => settingStore.get("Comfy.Sidebar.Size") === "small"
    );
    const tabs = computed(() => workspaceStore.getSidebarTabs());
    const selectedTab = computed(() => {
      const tabId = workspaceStore.activeSidebarTab;
      return tabs.value.find((tab) => tab.id === tabId) || null;
    });
    const mountCustomTab = /* @__PURE__ */ __name((tab, el) => {
      tab.render(el);
    }, "mountCustomTab");
    const onTabClick = /* @__PURE__ */ __name((item2) => {
      workspaceStore.updateActiveSidebarTab(
        workspaceStore.activeSidebarTab === item2.id ? null : item2.id
      );
    }, "onTabClick");
    onBeforeUnmount(() => {
      tabs.value.forEach((tab) => {
        if (tab.type === "custom" && tab.destroy) {
          tab.destroy();
        }
      });
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        (openBlock(), createBlock(Teleport, { to: teleportTarget.value }, [
          createBaseVNode("nav", {
            class: normalizeClass("side-tool-bar-container" + (isSmall.value ? " small-sidebar" : ""))
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(tabs.value, (tab) => {
              return openBlock(), createBlock(SidebarIcon, {
                key: tab.id,
                icon: tab.icon,
                iconBadge: tab.iconBadge,
                tooltip: tab.tooltip,
                selected: tab === selectedTab.value,
                class: normalizeClass(tab.id + "-tab-button"),
                onClick: /* @__PURE__ */ __name(($event) => onTabClick(tab), "onClick")
              }, null, 8, ["icon", "iconBadge", "tooltip", "selected", "class", "onClick"]);
            }), 128)),
            createBaseVNode("div", _hoisted_1$A, [
              createVNode(_sfc_main$s),
              createVNode(_sfc_main$r)
            ])
          ], 2)
        ], 8, ["to"])),
        selectedTab.value ? (openBlock(), createElementBlock("div", _hoisted_2$q, [
          selectedTab.value.type === "vue" ? (openBlock(), createBlock(resolveDynamicComponent(selectedTab.value.component), { key: 0 })) : (openBlock(), createElementBlock("div", {
            key: 1,
            ref: /* @__PURE__ */ __name((el) => {
              if (el)
                mountCustomTab(
                  selectedTab.value,
                  el
                );
            }, "ref")
          }, null, 512))
        ])) : createCommentVNode("", true)
      ], 64);
    };
  }
});
const SideToolbar = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["__scopeId", "data-v-ed7a1148"]]);
var theme$d = /* @__PURE__ */ __name(function theme24(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-splitter {\n    display: flex;\n    flex-wrap: nowrap;\n    border: 1px solid ".concat(dt3("splitter.border.color"), ";\n    background: ").concat(dt3("splitter.background"), ";\n    border-radius: ").concat(dt3("border.radius.md"), ";\n    color: ").concat(dt3("splitter.color"), ";\n}\n\n.p-splitter-vertical {\n    flex-direction: column;\n}\n\n.p-splitter-gutter {\n    flex-grow: 0;\n    flex-shrink: 0;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    z-index: 1;\n    background: ").concat(dt3("splitter.gutter.background"), ";\n}\n\n.p-splitter-gutter-handle {\n    border-radius: ").concat(dt3("splitter.handle.border.radius"), ";\n    background: ").concat(dt3("splitter.handle.background"), ";\n    transition: outline-color ").concat(dt3("splitter.transition.duration"), ", box-shadow ").concat(dt3("splitter.transition.duration"), ";\n    outline-color: transparent;\n}\n\n.p-splitter-gutter-handle:focus-visible {\n    box-shadow: ").concat(dt3("splitter.handle.focus.ring.shadow"), ";\n    outline: ").concat(dt3("splitter.handle.focus.ring.width"), " ").concat(dt3("splitter.handle.focus.ring.style"), " ").concat(dt3("splitter.handle.focus.ring.color"), ";\n    outline-offset: ").concat(dt3("splitter.handle.focus.ring.offset"), ";\n}\n\n.p-splitter-horizontal.p-splitter-resizing {\n    cursor: col-resize;\n    user-select: none;\n}\n\n.p-splitter-vertical.p-splitter-resizing {\n    cursor: row-resize;\n    user-select: none;\n}\n\n.p-splitter-horizontal > .p-splitter-gutter > .p-splitter-gutter-handle {\n    height: ").concat(dt3("splitter.handle.size"), ";\n    width: 100%;\n}\n\n.p-splitter-vertical > .p-splitter-gutter > .p-splitter-gutter-handle {\n    width: ").concat(dt3("splitter.handle.size"), ";\n    height: 100%;\n}\n\n.p-splitter-horizontal > .p-splitter-gutter {\n    cursor: col-resize;\n}\n\n.p-splitter-vertical > .p-splitter-gutter {\n    cursor: row-resize;\n}\n\n.p-splitterpanel {\n    flex-grow: 1;\n    overflow: hidden;\n}\n\n.p-splitterpanel-nested {\n    display: flex;\n}\n\n.p-splitterpanel .p-splitter {\n    flex-grow: 1;\n    border: 0 none;\n}\n");
}, "theme");
var classes$e = {
  root: /* @__PURE__ */ __name(function root14(_ref2) {
    var props = _ref2.props;
    return ["p-splitter p-component", "p-splitter-" + props.layout];
  }, "root"),
  gutter: "p-splitter-gutter",
  gutterHandle: "p-splitter-gutter-handle"
};
var inlineStyles$3 = {
  root: /* @__PURE__ */ __name(function root15(_ref3) {
    var props = _ref3.props;
    return [{
      display: "flex",
      "flex-wrap": "nowrap"
    }, props.layout === "vertical" ? {
      "flex-direction": "column"
    } : ""];
  }, "root")
};
var SplitterStyle = BaseStyle.extend({
  name: "splitter",
  theme: theme$d,
  classes: classes$e,
  inlineStyles: inlineStyles$3
});
var script$1$e = {
  name: "BaseSplitter",
  "extends": script$X,
  props: {
    layout: {
      type: String,
      "default": "horizontal"
    },
    gutterSize: {
      type: Number,
      "default": 4
    },
    stateKey: {
      type: String,
      "default": null
    },
    stateStorage: {
      type: String,
      "default": "session"
    },
    step: {
      type: Number,
      "default": 5
    }
  },
  style: SplitterStyle,
  provide: /* @__PURE__ */ __name(function provide25() {
    return {
      $pcSplitter: this,
      $parentInstance: this
    };
  }, "provide")
};
function _toConsumableArray$8(r) {
  return _arrayWithoutHoles$8(r) || _iterableToArray$8(r) || _unsupportedIterableToArray$a(r) || _nonIterableSpread$8();
}
__name(_toConsumableArray$8, "_toConsumableArray$8");
function _nonIterableSpread$8() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableSpread$8, "_nonIterableSpread$8");
function _unsupportedIterableToArray$a(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$a(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$a(r, a) : void 0;
  }
}
__name(_unsupportedIterableToArray$a, "_unsupportedIterableToArray$a");
function _iterableToArray$8(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
__name(_iterableToArray$8, "_iterableToArray$8");
function _arrayWithoutHoles$8(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$a(r);
}
__name(_arrayWithoutHoles$8, "_arrayWithoutHoles$8");
function _arrayLikeToArray$a(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
__name(_arrayLikeToArray$a, "_arrayLikeToArray$a");
var script$p = {
  name: "Splitter",
  "extends": script$1$e,
  inheritAttrs: false,
  emits: ["resizestart", "resizeend", "resize"],
  dragging: false,
  mouseMoveListener: null,
  mouseUpListener: null,
  touchMoveListener: null,
  touchEndListener: null,
  size: null,
  gutterElement: null,
  startPos: null,
  prevPanelElement: null,
  nextPanelElement: null,
  nextPanelSize: null,
  prevPanelSize: null,
  panelSizes: null,
  prevPanelIndex: null,
  timer: null,
  data: /* @__PURE__ */ __name(function data10() {
    return {
      prevSize: null
    };
  }, "data"),
  mounted: /* @__PURE__ */ __name(function mounted9() {
    var _this = this;
    if (this.panels && this.panels.length) {
      var initialized = false;
      if (this.isStateful()) {
        initialized = this.restoreState();
      }
      if (!initialized) {
        var children = _toConsumableArray$8(this.$el.children).filter(function(child) {
          return child.getAttribute("data-pc-name") === "splitterpanel";
        });
        var _panelSizes = [];
        this.panels.map(function(panel3, i2) {
          var panelInitialSize = panel3.props && panel3.props.size ? panel3.props.size : null;
          var panelSize = panelInitialSize || 100 / _this.panels.length;
          _panelSizes[i2] = panelSize;
          children[i2].style.flexBasis = "calc(" + panelSize + "% - " + (_this.panels.length - 1) * _this.gutterSize + "px)";
        });
        this.panelSizes = _panelSizes;
        this.prevSize = parseFloat(_panelSizes[0]).toFixed(4);
      }
    }
  }, "mounted"),
  beforeUnmount: /* @__PURE__ */ __name(function beforeUnmount5() {
    this.clear();
    this.unbindMouseListeners();
  }, "beforeUnmount"),
  methods: {
    isSplitterPanel: /* @__PURE__ */ __name(function isSplitterPanel(child) {
      return child.type.name === "SplitterPanel";
    }, "isSplitterPanel"),
    onResizeStart: /* @__PURE__ */ __name(function onResizeStart(event2, index2, isKeyDown) {
      this.gutterElement = event2.currentTarget || event2.target.parentElement;
      this.size = this.horizontal ? getWidth(this.$el) : getHeight(this.$el);
      if (!isKeyDown) {
        this.dragging = true;
        this.startPos = this.layout === "horizontal" ? event2.pageX || event2.changedTouches[0].pageX : event2.pageY || event2.changedTouches[0].pageY;
      }
      this.prevPanelElement = this.gutterElement.previousElementSibling;
      this.nextPanelElement = this.gutterElement.nextElementSibling;
      if (isKeyDown) {
        this.prevPanelSize = this.horizontal ? getOuterWidth(this.prevPanelElement, true) : getOuterHeight(this.prevPanelElement, true);
        this.nextPanelSize = this.horizontal ? getOuterWidth(this.nextPanelElement, true) : getOuterHeight(this.nextPanelElement, true);
      } else {
        this.prevPanelSize = 100 * (this.horizontal ? getOuterWidth(this.prevPanelElement, true) : getOuterHeight(this.prevPanelElement, true)) / this.size;
        this.nextPanelSize = 100 * (this.horizontal ? getOuterWidth(this.nextPanelElement, true) : getOuterHeight(this.nextPanelElement, true)) / this.size;
      }
      this.prevPanelIndex = index2;
      this.$emit("resizestart", {
        originalEvent: event2,
        sizes: this.panelSizes
      });
      this.$refs.gutter[index2].setAttribute("data-p-gutter-resizing", true);
      this.$el.setAttribute("data-p-resizing", true);
    }, "onResizeStart"),
    onResize: /* @__PURE__ */ __name(function onResize2(event2, step2, isKeyDown) {
      var newPos, newPrevPanelSize, newNextPanelSize;
      if (isKeyDown) {
        if (this.horizontal) {
          newPrevPanelSize = 100 * (this.prevPanelSize + step2) / this.size;
          newNextPanelSize = 100 * (this.nextPanelSize - step2) / this.size;
        } else {
          newPrevPanelSize = 100 * (this.prevPanelSize - step2) / this.size;
          newNextPanelSize = 100 * (this.nextPanelSize + step2) / this.size;
        }
      } else {
        if (this.horizontal) newPos = event2.pageX * 100 / this.size - this.startPos * 100 / this.size;
        else newPos = event2.pageY * 100 / this.size - this.startPos * 100 / this.size;
        newPrevPanelSize = this.prevPanelSize + newPos;
        newNextPanelSize = this.nextPanelSize - newPos;
      }
      if (this.validateResize(newPrevPanelSize, newNextPanelSize)) {
        this.prevPanelElement.style.flexBasis = "calc(" + newPrevPanelSize + "% - " + (this.panels.length - 1) * this.gutterSize + "px)";
        this.nextPanelElement.style.flexBasis = "calc(" + newNextPanelSize + "% - " + (this.panels.length - 1) * this.gutterSize + "px)";
        this.panelSizes[this.prevPanelIndex] = newPrevPanelSize;
        this.panelSizes[this.prevPanelIndex + 1] = newNextPanelSize;
        this.prevSize = parseFloat(newPrevPanelSize).toFixed(4);
      }
      this.$emit("resize", {
        originalEvent: event2,
        sizes: this.panelSizes
      });
    }, "onResize"),
    onResizeEnd: /* @__PURE__ */ __name(function onResizeEnd(event2) {
      if (this.isStateful()) {
        this.saveState();
      }
      this.$emit("resizeend", {
        originalEvent: event2,
        sizes: this.panelSizes
      });
      this.$refs.gutter.forEach(function(gutter) {
        return gutter.setAttribute("data-p-gutter-resizing", false);
      });
      this.$el.setAttribute("data-p-resizing", false);
      this.clear();
    }, "onResizeEnd"),
    repeat: /* @__PURE__ */ __name(function repeat3(event2, index2, step2) {
      this.onResizeStart(event2, index2, true);
      this.onResize(event2, step2, true);
    }, "repeat"),
    setTimer: /* @__PURE__ */ __name(function setTimer2(event2, index2, step2) {
      var _this2 = this;
      if (!this.timer) {
        this.timer = setInterval(function() {
          _this2.repeat(event2, index2, step2);
        }, 40);
      }
    }, "setTimer"),
    clearTimer: /* @__PURE__ */ __name(function clearTimer3() {
      if (this.timer) {
        clearInterval(this.timer);
        this.timer = null;
      }
    }, "clearTimer"),
    onGutterKeyUp: /* @__PURE__ */ __name(function onGutterKeyUp() {
      this.clearTimer();
      this.onResizeEnd();
    }, "onGutterKeyUp"),
    onGutterKeyDown: /* @__PURE__ */ __name(function onGutterKeyDown(event2, index2) {
      switch (event2.code) {
        case "ArrowLeft": {
          if (this.layout === "horizontal") {
            this.setTimer(event2, index2, this.step * -1);
          }
          event2.preventDefault();
          break;
        }
        case "ArrowRight": {
          if (this.layout === "horizontal") {
            this.setTimer(event2, index2, this.step);
          }
          event2.preventDefault();
          break;
        }
        case "ArrowDown": {
          if (this.layout === "vertical") {
            this.setTimer(event2, index2, this.step * -1);
          }
          event2.preventDefault();
          break;
        }
        case "ArrowUp": {
          if (this.layout === "vertical") {
            this.setTimer(event2, index2, this.step);
          }
          event2.preventDefault();
          break;
        }
      }
    }, "onGutterKeyDown"),
    onGutterMouseDown: /* @__PURE__ */ __name(function onGutterMouseDown(event2, index2) {
      this.onResizeStart(event2, index2);
      this.bindMouseListeners();
    }, "onGutterMouseDown"),
    onGutterTouchStart: /* @__PURE__ */ __name(function onGutterTouchStart(event2, index2) {
      this.onResizeStart(event2, index2);
      this.bindTouchListeners();
      event2.preventDefault();
    }, "onGutterTouchStart"),
    onGutterTouchMove: /* @__PURE__ */ __name(function onGutterTouchMove(event2) {
      this.onResize(event2);
      event2.preventDefault();
    }, "onGutterTouchMove"),
    onGutterTouchEnd: /* @__PURE__ */ __name(function onGutterTouchEnd(event2) {
      this.onResizeEnd(event2);
      this.unbindTouchListeners();
      event2.preventDefault();
    }, "onGutterTouchEnd"),
    bindMouseListeners: /* @__PURE__ */ __name(function bindMouseListeners() {
      var _this3 = this;
      if (!this.mouseMoveListener) {
        this.mouseMoveListener = function(event2) {
          return _this3.onResize(event2);
        };
        document.addEventListener("mousemove", this.mouseMoveListener);
      }
      if (!this.mouseUpListener) {
        this.mouseUpListener = function(event2) {
          _this3.onResizeEnd(event2);
          _this3.unbindMouseListeners();
        };
        document.addEventListener("mouseup", this.mouseUpListener);
      }
    }, "bindMouseListeners"),
    bindTouchListeners: /* @__PURE__ */ __name(function bindTouchListeners() {
      var _this4 = this;
      if (!this.touchMoveListener) {
        this.touchMoveListener = function(event2) {
          return _this4.onResize(event2.changedTouches[0]);
        };
        document.addEventListener("touchmove", this.touchMoveListener);
      }
      if (!this.touchEndListener) {
        this.touchEndListener = function(event2) {
          _this4.resizeEnd(event2);
          _this4.unbindTouchListeners();
        };
        document.addEventListener("touchend", this.touchEndListener);
      }
    }, "bindTouchListeners"),
    validateResize: /* @__PURE__ */ __name(function validateResize(newPrevPanelSize, newNextPanelSize) {
      if (newPrevPanelSize > 100 || newPrevPanelSize < 0) return false;
      if (newNextPanelSize > 100 || newNextPanelSize < 0) return false;
      var prevPanelMinSize = getVNodeProp(this.panels[this.prevPanelIndex], "minSize");
      if (this.panels[this.prevPanelIndex].props && prevPanelMinSize && prevPanelMinSize > newPrevPanelSize) {
        return false;
      }
      var newPanelMinSize = getVNodeProp(this.panels[this.prevPanelIndex + 1], "minSize");
      if (this.panels[this.prevPanelIndex + 1].props && newPanelMinSize && newPanelMinSize > newNextPanelSize) {
        return false;
      }
      return true;
    }, "validateResize"),
    unbindMouseListeners: /* @__PURE__ */ __name(function unbindMouseListeners() {
      if (this.mouseMoveListener) {
        document.removeEventListener("mousemove", this.mouseMoveListener);
        this.mouseMoveListener = null;
      }
      if (this.mouseUpListener) {
        document.removeEventListener("mouseup", this.mouseUpListener);
        this.mouseUpListener = null;
      }
    }, "unbindMouseListeners"),
    unbindTouchListeners: /* @__PURE__ */ __name(function unbindTouchListeners() {
      if (this.touchMoveListener) {
        document.removeEventListener("touchmove", this.touchMoveListener);
        this.touchMoveListener = null;
      }
      if (this.touchEndListener) {
        document.removeEventListener("touchend", this.touchEndListener);
        this.touchEndListener = null;
      }
    }, "unbindTouchListeners"),
    clear: /* @__PURE__ */ __name(function clear2() {
      this.dragging = false;
      this.size = null;
      this.startPos = null;
      this.prevPanelElement = null;
      this.nextPanelElement = null;
      this.prevPanelSize = null;
      this.nextPanelSize = null;
      this.gutterElement = null;
      this.prevPanelIndex = null;
    }, "clear"),
    isStateful: /* @__PURE__ */ __name(function isStateful() {
      return this.stateKey != null;
    }, "isStateful"),
    getStorage: /* @__PURE__ */ __name(function getStorage() {
      switch (this.stateStorage) {
        case "local":
          return window.localStorage;
        case "session":
          return window.sessionStorage;
        default:
          throw new Error(this.stateStorage + ' is not a valid value for the state storage, supported values are "local" and "session".');
      }
    }, "getStorage"),
    saveState: /* @__PURE__ */ __name(function saveState() {
      if (isArray$3(this.panelSizes)) {
        this.getStorage().setItem(this.stateKey, JSON.stringify(this.panelSizes));
      }
    }, "saveState"),
    restoreState: /* @__PURE__ */ __name(function restoreState() {
      var _this5 = this;
      var storage = this.getStorage();
      var stateString = storage.getItem(this.stateKey);
      if (stateString) {
        this.panelSizes = JSON.parse(stateString);
        var children = _toConsumableArray$8(this.$el.children).filter(function(child) {
          return child.getAttribute("data-pc-name") === "splitterpanel";
        });
        children.forEach(function(child, i2) {
          child.style.flexBasis = "calc(" + _this5.panelSizes[i2] + "% - " + (_this5.panels.length - 1) * _this5.gutterSize + "px)";
        });
        return true;
      }
      return false;
    }, "restoreState")
  },
  computed: {
    panels: /* @__PURE__ */ __name(function panels() {
      var _this6 = this;
      var panels2 = [];
      this.$slots["default"]().forEach(function(child) {
        if (_this6.isSplitterPanel(child)) {
          panels2.push(child);
        } else if (child.children instanceof Array) {
          child.children.forEach(function(nestedChild) {
            if (_this6.isSplitterPanel(nestedChild)) {
              panels2.push(nestedChild);
            }
          });
        }
      });
      return panels2;
    }, "panels"),
    gutterStyle: /* @__PURE__ */ __name(function gutterStyle() {
      if (this.horizontal) return {
        width: this.gutterSize + "px"
      };
      else return {
        height: this.gutterSize + "px"
      };
    }, "gutterStyle"),
    horizontal: /* @__PURE__ */ __name(function horizontal2() {
      return this.layout === "horizontal";
    }, "horizontal"),
    getPTOptions: /* @__PURE__ */ __name(function getPTOptions5() {
      var _this$$parentInstance;
      return {
        context: {
          nested: (_this$$parentInstance = this.$parentInstance) === null || _this$$parentInstance === void 0 ? void 0 : _this$$parentInstance.nestedState
        }
      };
    }, "getPTOptions")
  }
};
var _hoisted_1$z = ["onMousedown", "onTouchstart", "onTouchmove", "onTouchend"];
var _hoisted_2$p = ["aria-orientation", "aria-valuenow", "onKeydown"];
function render$o(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("root"),
    style: _ctx.sx("root"),
    "data-p-resizing": false
  }, _ctx.ptmi("root", $options.getPTOptions)), [(openBlock(true), createElementBlock(Fragment, null, renderList($options.panels, function(panel3, i2) {
    return openBlock(), createElementBlock(Fragment, {
      key: i2
    }, [(openBlock(), createBlock(resolveDynamicComponent(panel3), {
      tabindex: "-1"
    })), i2 !== $options.panels.length - 1 ? (openBlock(), createElementBlock("div", mergeProps({
      key: 0,
      ref_for: true,
      ref: "gutter",
      "class": _ctx.cx("gutter"),
      role: "separator",
      tabindex: "-1",
      onMousedown: /* @__PURE__ */ __name(function onMousedown($event) {
        return $options.onGutterMouseDown($event, i2);
      }, "onMousedown"),
      onTouchstart: /* @__PURE__ */ __name(function onTouchstart($event) {
        return $options.onGutterTouchStart($event, i2);
      }, "onTouchstart"),
      onTouchmove: /* @__PURE__ */ __name(function onTouchmove($event) {
        return $options.onGutterTouchMove($event, i2);
      }, "onTouchmove"),
      onTouchend: /* @__PURE__ */ __name(function onTouchend($event) {
        return $options.onGutterTouchEnd($event, i2);
      }, "onTouchend"),
      "data-p-gutter-resizing": false
    }, _ctx.ptm("gutter")), [createBaseVNode("div", mergeProps({
      "class": _ctx.cx("gutterHandle"),
      tabindex: "0",
      style: [$options.gutterStyle],
      "aria-orientation": _ctx.layout,
      "aria-valuenow": $data.prevSize,
      onKeyup: _cache[0] || (_cache[0] = function() {
        return $options.onGutterKeyUp && $options.onGutterKeyUp.apply($options, arguments);
      }),
      onKeydown: /* @__PURE__ */ __name(function onKeydown3($event) {
        return $options.onGutterKeyDown($event, i2);
      }, "onKeydown"),
      ref_for: true
    }, _ctx.ptm("gutterHandle")), null, 16, _hoisted_2$p)], 16, _hoisted_1$z)) : createCommentVNode("", true)], 64);
  }), 128))], 16);
}
__name(render$o, "render$o");
script$p.render = render$o;
var classes$d = {
  root: /* @__PURE__ */ __name(function root16(_ref) {
    var instance = _ref.instance;
    return ["p-splitterpanel", {
      "p-splitterpanel-nested": instance.isNested
    }];
  }, "root")
};
var SplitterPanelStyle = BaseStyle.extend({
  name: "splitterpanel",
  classes: classes$d
});
var script$1$d = {
  name: "BaseSplitterPanel",
  "extends": script$X,
  props: {
    size: {
      type: Number,
      "default": null
    },
    minSize: {
      type: Number,
      "default": null
    }
  },
  style: SplitterPanelStyle,
  provide: /* @__PURE__ */ __name(function provide26() {
    return {
      $pcSplitterPanel: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$o = {
  name: "SplitterPanel",
  "extends": script$1$d,
  inheritAttrs: false,
  data: /* @__PURE__ */ __name(function data11() {
    return {
      nestedState: null
    };
  }, "data"),
  computed: {
    isNested: /* @__PURE__ */ __name(function isNested() {
      var _this = this;
      return this.$slots["default"]().some(function(child) {
        _this.nestedState = child.type.name === "Splitter" ? true : null;
        return _this.nestedState;
      });
    }, "isNested"),
    getPTOptions: /* @__PURE__ */ __name(function getPTOptions6() {
      return {
        context: {
          nested: this.isNested
        }
      };
    }, "getPTOptions")
  }
};
function render$n(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    ref: "container",
    "class": _ctx.cx("root")
  }, _ctx.ptmi("root", $options.getPTOptions)), [renderSlot(_ctx.$slots, "default")], 16);
}
__name(render$n, "render$n");
script$o.render = render$n;
const _withScopeId$b = /* @__PURE__ */ __name((n) => (pushScopeId("data-v-edca8328"), n = n(), popScopeId(), n), "_withScopeId$b");
const _hoisted_1$y = /* @__PURE__ */ _withScopeId$b(() => /* @__PURE__ */ createBaseVNode("div", null, null, -1));
const _sfc_main$p = /* @__PURE__ */ defineComponent({
  __name: "LiteGraphCanvasSplitterOverlay",
  setup(__props) {
    const settingStore = useSettingStore();
    const sidebarLocation = computed(
      () => settingStore.get("Comfy.Sidebar.Location")
    );
    const sidebarPanelVisible = computed(
      () => useWorkspaceStore().activeSidebarTab !== null
    );
    const gutterClass = computed(() => {
      return sidebarPanelVisible.value ? "" : "gutter-hidden";
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(script$p), {
        class: "splitter-overlay",
        "pt:gutter": gutterClass.value
      }, {
        default: withCtx(() => [
          sidebarLocation.value === "left" ? withDirectives((openBlock(), createBlock(unref(script$o), {
            key: 0,
            class: "side-bar-panel",
            minSize: 10,
            size: 20
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "side-bar-panel", {}, void 0, true)
            ]),
            _: 3
          }, 512)), [
            [vShow, sidebarPanelVisible.value]
          ]) : createCommentVNode("", true),
          createVNode(unref(script$o), {
            class: "graph-canvas-panel",
            size: 100
          }, {
            default: withCtx(() => [
              _hoisted_1$y
            ]),
            _: 1
          }),
          sidebarLocation.value === "right" ? withDirectives((openBlock(), createBlock(unref(script$o), {
            key: 1,
            class: "side-bar-panel",
            minSize: 10,
            size: 20
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "side-bar-panel", {}, void 0, true)
            ]),
            _: 3
          }, 512)), [
            [vShow, sidebarPanelVisible.value]
          ]) : createCommentVNode("", true)
        ]),
        _: 3
      }, 8, ["pt:gutter"]);
    };
  }
});
const LiteGraphCanvasSplitterOverlay = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["__scopeId", "data-v-edca8328"]]);
var theme$c = /* @__PURE__ */ __name(function theme25(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-autocomplete {\n    display: inline-flex;\n}\n\n.p-autocomplete-loader {\n    position: absolute;\n    top: 50%;\n    margin-top: -0.5rem;\n    right: ".concat(dt3("autocomplete.padding.x"), ";\n}\n\n.p-autocomplete:has(.p-autocomplete-dropdown) .p-autocomplete-loader {\n    right: calc(").concat(dt3("autocomplete.dropdown.width"), " + ").concat(dt3("autocomplete.padding.x"), ");\n}\n\n.p-autocomplete:has(.p-autocomplete-dropdown) .p-autocomplete-input {\n    flex: 1 1 auto;\n    width: 1%;\n}\n\n.p-autocomplete:has(.p-autocomplete-dropdown) .p-autocomplete-input,\n.p-autocomplete:has(.p-autocomplete-dropdown) .p-autocomplete-input-multiple {\n    border-top-right-radius: 0;\n    border-bottom-right-radius: 0;\n}\n\n.p-autocomplete-dropdown {\n    cursor: pointer;\n    display: inline-flex;\n    cursor: pointer;\n    user-select: none;\n    align-items: center;\n    justify-content: center;\n    overflow: hidden;\n    position: relative;\n    width: ").concat(dt3("autocomplete.dropdown.width"), ";\n    border-top-right-radius: ").concat(dt3("autocomplete.dropdown.border.radius"), ";\n    border-bottom-right-radius: ").concat(dt3("autocomplete.dropdown.border.radius"), ";\n    background: ").concat(dt3("autocomplete.dropdown.background"), ";\n    border: 1px solid ").concat(dt3("autocomplete.dropdown.border.color"), ";\n    border-left: 0 none;\n    color: ").concat(dt3("autocomplete.dropdown.color"), ";\n    transition: background ").concat(dt3("autocomplete.transition.duration"), ", color ").concat(dt3("autocomplete.transition.duration"), ", border-color ").concat(dt3("autocomplete.transition.duration"), ", outline-color ").concat(dt3("autocomplete.transition.duration"), ", box-shadow ").concat(dt3("autocomplete.transition.duration"), ";\n    outline-color: transparent;\n}\n\n.p-autocomplete-dropdown:not(:disabled):hover {\n    background: ").concat(dt3("autocomplete.dropdown.hover.background"), ";\n    border-color: ").concat(dt3("autocomplete.dropdown.hover.border.color"), ";\n    color: ").concat(dt3("autocomplete.dropdown.hover.color"), ";\n}\n\n.p-autocomplete-dropdown:not(:disabled):active {\n    background: ").concat(dt3("autocomplete.dropdown.active.background"), ";\n    border-color: ").concat(dt3("autocomplete.dropdown.active.border.color"), ";\n    color: ").concat(dt3("autocomplete.dropdown.active.color"), ";\n}\n\n.p-autocomplete-dropdown:focus-visible {\n    box-shadow: ").concat(dt3("autocomplete.dropdown.focus.ring.shadow"), ";\n    outline: ").concat(dt3("autocomplete.dropdown.focus.ring.width"), " ").concat(dt3("autocomplete.dropdown.focus.ring.style"), " ").concat(dt3("autocomplete.dropdown.focus.ring.color"), ";\n    outline-offset: ").concat(dt3("autocomplete.dropdown.focus.ring.offset"), ";\n}\n\n.p-autocomplete .p-autocomplete-overlay {\n    min-width: 100%;\n}\n\n.p-autocomplete-overlay {\n    position: absolute;\n    overflow: auto;\n    top: 0;\n    left: 0;\n    background: ").concat(dt3("autocomplete.overlay.background"), ";\n    color: ").concat(dt3("autocomplete.overlay.color"), ";\n    border: 1px solid ").concat(dt3("autocomplete.overlay.border.color"), ";\n    border-radius: ").concat(dt3("autocomplete.overlay.border.radius"), ";\n    box-shadow: ").concat(dt3("autocomplete.overlay.shadow"), ";\n}\n\n.p-autocomplete-list {\n    margin: 0;\n    padding: 0;\n    list-style-type: none;\n    display: flex;\n    flex-direction: column;\n    gap: ").concat(dt3("autocomplete.list.gap"), ";\n    padding: ").concat(dt3("autocomplete.list.padding"), ";\n}\n\n.p-autocomplete-option {\n    cursor: pointer;\n    white-space: nowrap;\n    position: relative;\n    overflow: hidden;\n    display: flex;\n    align-items: center;\n    padding: ").concat(dt3("autocomplete.option.padding"), ";\n    border: 0 none;\n    color: ").concat(dt3("autocomplete.option.color"), ";\n    background: transparent;\n    transition: background ").concat(dt3("autocomplete.transition.duration"), ", color ").concat(dt3("autocomplete.transition.duration"), ", border-color ").concat(dt3("autocomplete.transition.duration"), ";\n    border-radius: ").concat(dt3("autocomplete.option.border.radius"), ";\n}\n\n.p-autocomplete-option:not(.p-autocomplete-option-selected):not(.p-disabled).p-focus {\n    background: ").concat(dt3("autocomplete.option.focus.background"), ";\n    color: ").concat(dt3("autocomplete.option.focus.color"), ";\n}\n\n.p-autocomplete-option-selected {\n    background: ").concat(dt3("autocomplete.option.selected.background"), ";\n    color: ").concat(dt3("autocomplete.option.selected.color"), ";\n}\n\n.p-autocomplete-option-selected.p-focus {\n    background: ").concat(dt3("autocomplete.option.selected.focus.background"), ";\n    color: ").concat(dt3("autocomplete.option.selected.focus.color"), ";\n}\n\n.p-autocomplete-option-group {\n    margin: 0;\n    padding: ").concat(dt3("autocomplete.option.group.padding"), ";\n    color: ").concat(dt3("autocomplete.option.group.color"), ";\n    background: ").concat(dt3("autocomplete.option.group.background"), ";\n    font-weight: ").concat(dt3("autocomplete.option.group.font.weight"), ";\n}\n\n.p-autocomplete-input-multiple {\n    margin: 0;\n    list-style-type: none;\n    cursor: text;\n    overflow: hidden;\n    display: flex;\n    align-items: center;\n    flex-wrap: wrap;\n    padding: calc(").concat(dt3("autocomplete.padding.y"), " / 2) ").concat(dt3("autocomplete.padding.x"), ";\n    gap: calc(").concat(dt3("autocomplete.padding.y"), " / 2);\n    color: ").concat(dt3("autocomplete.color"), ";\n    background: ").concat(dt3("autocomplete.background"), ";\n    border: 1px solid ").concat(dt3("autocomplete.border.color"), ";\n    border-radius: ").concat(dt3("autocomplete.border.radius"), ";\n    width: 100%;\n    transition: background ").concat(dt3("autocomplete.transition.duration"), ", color ").concat(dt3("autocomplete.transition.duration"), ", border-color ").concat(dt3("autocomplete.transition.duration"), ", outline-color ").concat(dt3("autocomplete.transition.duration"), ", box-shadow ").concat(dt3("autocomplete.transition.duration"), ";\n    outline-color: transparent;\n    box-shadow: ").concat(dt3("autocomplete.shadow"), ";\n}\n\n.p-autocomplete:not(.p-disabled):hover .p-autocomplete-input-multiple {\n    border-color: ").concat(dt3("autocomplete.hover.border.color"), ";\n}\n\n.p-autocomplete:not(.p-disabled).p-focus .p-autocomplete-input-multiple {\n    border-color: ").concat(dt3("autocomplete.focus.border.color"), ";\n    box-shadow: ").concat(dt3("autocomplete.focus.ring.shadow"), ";\n    outline: ").concat(dt3("autocomplete.focus.ring.width"), " ").concat(dt3("autocomplete.focus.ring.style"), " ").concat(dt3("autocomplete.focus.ring.color"), ";\n    outline-offset: ").concat(dt3("autocomplete.focus.ring.offset"), ";\n}\n\n.p-autocomplete.p-invalid .p-autocomplete-input-multiple {\n    border-color: ").concat(dt3("autocomplete.invalid.border.color"), ";\n}\n\n.p-variant-filled.p-autocomplete-input-multiple {\n    background: ").concat(dt3("autocomplete.filled.background"), ";\n}\n\n.p-autocomplete:not(.p-disabled).p-focus .p-variant-filled.p-autocomplete-input-multiple  {\n    background: ").concat(dt3("autocomplete.filled.focus.background"), ";\n}\n\n.p-autocomplete.p-disabled .p-autocomplete-input-multiple {\n    opacity: 1;\n    background: ").concat(dt3("autocomplete.disabled.background"), ";\n    color: ").concat(dt3("autocomplete.disabled.color"), ";\n}\n\n.p-autocomplete-chip.p-chip {\n    padding-top: calc(").concat(dt3("autocomplete.padding.y"), " / 2);\n    padding-bottom: calc(").concat(dt3("autocomplete.padding.y"), " / 2);\n    border-radius: ").concat(dt3("autocomplete.chip.border.radius"), ";\n}\n\n.p-autocomplete-input-multiple:has(.p-autocomplete-chip) {\n    padding-left: calc(").concat(dt3("autocomplete.padding.y"), " / 2);\n    padding-right: calc(").concat(dt3("autocomplete.padding.y"), " / 2);\n}\n\n.p-autocomplete-chip-item.p-focus .p-autocomplete-chip {\n    background: ").concat(dt3("inputchips.chip.focus.background"), ";\n    color: ").concat(dt3("inputchips.chip.focus.color"), ";\n}\n\n.p-autocomplete-input-chip {\n    flex: 1 1 auto;\n    display: inline-flex;\n    padding-top: calc(").concat(dt3("autocomplete.padding.y"), " / 2);\n    padding-bottom: calc(").concat(dt3("autocomplete.padding.y"), " / 2);\n}\n\n.p-autocomplete-input-chip input {\n    border: 0 none;\n    outline: 0 none;\n    background: transparent;\n    margin: 0;\n    padding: 0;\n    box-shadow: none;\n    border-radius: 0;\n    width: 100%;\n    font-family: inherit;\n    font-feature-settings: inherit;\n    font-size: 1rem;\n    color: inherit;\n}\n\n.p-autocomplete-input-chip input::placeholder {\n    color: ").concat(dt3("autocomplete.placeholder.color"), ";\n}\n\n.p-autocomplete-empty-message {\n    padding: ").concat(dt3("autocomplete.empty.message.padding"), ";\n}\n\n.p-autocomplete-fluid {\n    display: flex;\n}\n\n.p-autocomplete-fluid:has(.p-autocomplete-dropdown) .p-autocomplete-input {\n    width: 1%;\n}\n");
}, "theme");
var inlineStyles$2 = {
  root: {
    position: "relative"
  }
};
var classes$c = {
  root: /* @__PURE__ */ __name(function root17(_ref2) {
    var instance = _ref2.instance, props = _ref2.props;
    return ["p-autocomplete p-component p-inputwrapper", {
      "p-disabled": props.disabled,
      "p-invalid": props.invalid,
      "p-focus": instance.focused,
      "p-inputwrapper-filled": props.modelValue || isNotEmpty(instance.inputValue),
      "p-inputwrapper-focus": instance.focused,
      "p-autocomplete-open": instance.overlayVisible,
      "p-autocomplete-fluid": props.fluid
    }];
  }, "root"),
  pcInput: "p-autocomplete-input",
  inputMultiple: /* @__PURE__ */ __name(function inputMultiple(_ref3) {
    var props = _ref3.props, instance = _ref3.instance;
    return ["p-autocomplete-input-multiple", {
      "p-variant-filled": props.variant ? props.variant === "filled" : instance.$primevue.config.inputStyle === "filled" || instance.$primevue.config.inputVariant === "filled"
    }];
  }, "inputMultiple"),
  chipItem: /* @__PURE__ */ __name(function chipItem(_ref4) {
    var instance = _ref4.instance, i2 = _ref4.i;
    return ["p-autocomplete-chip-item", {
      "p-focus": instance.focusedMultipleOptionIndex === i2
    }];
  }, "chipItem"),
  pcChip: "p-autocomplete-chip",
  chipIcon: "p-autocomplete-chip-icon",
  inputChip: "p-autocomplete-input-chip",
  loader: "p-autocomplete-loader",
  dropdown: "p-autocomplete-dropdown",
  overlay: "p-autocomplete-overlay p-component",
  list: "p-autocomplete-list",
  optionGroup: "p-autocomplete-option-group",
  option: /* @__PURE__ */ __name(function option3(_ref5) {
    var instance = _ref5.instance, _option = _ref5.option, i2 = _ref5.i, getItemOptions = _ref5.getItemOptions;
    return ["p-autocomplete-option", {
      "p-autocomplete-option-selected": instance.isSelected(_option),
      "p-focus": instance.focusedOptionIndex === instance.getOptionIndex(i2, getItemOptions),
      "p-disabled": instance.isOptionDisabled(_option)
    }];
  }, "option"),
  emptyMessage: "p-autocomplete-empty-message"
};
var AutoCompleteStyle = BaseStyle.extend({
  name: "autocomplete",
  theme: theme$c,
  classes: classes$c,
  inlineStyles: inlineStyles$2
});
var script$1$c = {
  name: "BaseAutoComplete",
  "extends": script$X,
  props: {
    modelValue: null,
    suggestions: {
      type: Array,
      "default": null
    },
    optionLabel: null,
    optionDisabled: null,
    optionGroupLabel: null,
    optionGroupChildren: null,
    scrollHeight: {
      type: String,
      "default": "14rem"
    },
    dropdown: {
      type: Boolean,
      "default": false
    },
    dropdownMode: {
      type: String,
      "default": "blank"
    },
    multiple: {
      type: Boolean,
      "default": false
    },
    loading: {
      type: Boolean,
      "default": false
    },
    variant: {
      type: String,
      "default": null
    },
    invalid: {
      type: Boolean,
      "default": false
    },
    disabled: {
      type: Boolean,
      "default": false
    },
    placeholder: {
      type: String,
      "default": null
    },
    dataKey: {
      type: String,
      "default": null
    },
    minLength: {
      type: Number,
      "default": 1
    },
    delay: {
      type: Number,
      "default": 300
    },
    appendTo: {
      type: [String, Object],
      "default": "body"
    },
    forceSelection: {
      type: Boolean,
      "default": false
    },
    completeOnFocus: {
      type: Boolean,
      "default": false
    },
    inputId: {
      type: String,
      "default": null
    },
    inputStyle: {
      type: Object,
      "default": null
    },
    inputClass: {
      type: [String, Object],
      "default": null
    },
    panelStyle: {
      type: Object,
      "default": null
    },
    panelClass: {
      type: [String, Object],
      "default": null
    },
    overlayStyle: {
      type: Object,
      "default": null
    },
    overlayClass: {
      type: [String, Object],
      "default": null
    },
    dropdownIcon: {
      type: String,
      "default": null
    },
    dropdownClass: {
      type: [String, Object],
      "default": null
    },
    loader: {
      type: String,
      "default": null
    },
    loadingIcon: {
      type: String,
      "default": null
    },
    removeTokenIcon: {
      type: String,
      "default": null
    },
    chipIcon: {
      type: String,
      "default": null
    },
    virtualScrollerOptions: {
      type: Object,
      "default": null
    },
    autoOptionFocus: {
      type: Boolean,
      "default": false
    },
    selectOnFocus: {
      type: Boolean,
      "default": false
    },
    focusOnHover: {
      type: Boolean,
      "default": true
    },
    searchLocale: {
      type: String,
      "default": void 0
    },
    searchMessage: {
      type: String,
      "default": null
    },
    selectionMessage: {
      type: String,
      "default": null
    },
    emptySelectionMessage: {
      type: String,
      "default": null
    },
    emptySearchMessage: {
      type: String,
      "default": null
    },
    tabindex: {
      type: Number,
      "default": 0
    },
    typeahead: {
      type: Boolean,
      "default": true
    },
    ariaLabel: {
      type: String,
      "default": null
    },
    ariaLabelledby: {
      type: String,
      "default": null
    },
    fluid: {
      type: Boolean,
      "default": false
    }
  },
  style: AutoCompleteStyle,
  provide: /* @__PURE__ */ __name(function provide27() {
    return {
      $pcAutoComplete: this,
      $parentInstance: this
    };
  }, "provide")
};
function _typeof$1$3(o) {
  "@babel/helpers - typeof";
  return _typeof$1$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$1$3(o);
}
__name(_typeof$1$3, "_typeof$1$3");
function _toConsumableArray$7(r) {
  return _arrayWithoutHoles$7(r) || _iterableToArray$7(r) || _unsupportedIterableToArray$9(r) || _nonIterableSpread$7();
}
__name(_toConsumableArray$7, "_toConsumableArray$7");
function _nonIterableSpread$7() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableSpread$7, "_nonIterableSpread$7");
function _unsupportedIterableToArray$9(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$9(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$9(r, a) : void 0;
  }
}
__name(_unsupportedIterableToArray$9, "_unsupportedIterableToArray$9");
function _iterableToArray$7(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
__name(_iterableToArray$7, "_iterableToArray$7");
function _arrayWithoutHoles$7(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$9(r);
}
__name(_arrayWithoutHoles$7, "_arrayWithoutHoles$7");
function _arrayLikeToArray$9(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
__name(_arrayLikeToArray$9, "_arrayLikeToArray$9");
var script$n = {
  name: "AutoComplete",
  "extends": script$1$c,
  inheritAttrs: false,
  emits: ["update:modelValue", "change", "focus", "blur", "item-select", "item-unselect", "option-select", "option-unselect", "dropdown-click", "clear", "complete", "before-show", "before-hide", "show", "hide"],
  outsideClickListener: null,
  resizeListener: null,
  scrollHandler: null,
  overlay: null,
  virtualScroller: null,
  searchTimeout: null,
  dirty: false,
  data: /* @__PURE__ */ __name(function data12() {
    return {
      id: this.$attrs.id,
      clicked: false,
      focused: false,
      focusedOptionIndex: -1,
      focusedMultipleOptionIndex: -1,
      overlayVisible: false,
      searching: false
    };
  }, "data"),
  watch: {
    "$attrs.id": /* @__PURE__ */ __name(function $attrsId5(newValue) {
      this.id = newValue || UniqueComponentId();
    }, "$attrsId"),
    suggestions: /* @__PURE__ */ __name(function suggestions() {
      if (this.searching) {
        this.show();
        this.focusedOptionIndex = this.overlayVisible && this.autoOptionFocus ? this.findFirstFocusedOptionIndex() : -1;
        this.searching = false;
      }
      this.autoUpdateModel();
    }, "suggestions")
  },
  mounted: /* @__PURE__ */ __name(function mounted10() {
    this.id = this.id || UniqueComponentId();
    this.autoUpdateModel();
  }, "mounted"),
  updated: /* @__PURE__ */ __name(function updated6() {
    if (this.overlayVisible) {
      this.alignOverlay();
    }
  }, "updated"),
  beforeUnmount: /* @__PURE__ */ __name(function beforeUnmount6() {
    this.unbindOutsideClickListener();
    this.unbindResizeListener();
    if (this.scrollHandler) {
      this.scrollHandler.destroy();
      this.scrollHandler = null;
    }
    if (this.overlay) {
      ZIndex.clear(this.overlay);
      this.overlay = null;
    }
  }, "beforeUnmount"),
  methods: {
    getOptionIndex: /* @__PURE__ */ __name(function getOptionIndex3(index2, fn) {
      return this.virtualScrollerDisabled ? index2 : fn && fn(index2)["index"];
    }, "getOptionIndex"),
    getOptionLabel: /* @__PURE__ */ __name(function getOptionLabel3(option4) {
      return this.optionLabel ? resolveFieldData(option4, this.optionLabel) : option4;
    }, "getOptionLabel"),
    getOptionValue: /* @__PURE__ */ __name(function getOptionValue4(option4) {
      return option4;
    }, "getOptionValue"),
    getOptionRenderKey: /* @__PURE__ */ __name(function getOptionRenderKey3(option4, index2) {
      return (this.dataKey ? resolveFieldData(option4, this.dataKey) : this.getOptionLabel(option4)) + "_" + index2;
    }, "getOptionRenderKey"),
    getPTOptions: /* @__PURE__ */ __name(function getPTOptions7(option4, itemOptions, index2, key) {
      return this.ptm(key, {
        context: {
          selected: this.isSelected(option4),
          focused: this.focusedOptionIndex === this.getOptionIndex(index2, itemOptions),
          disabled: this.isOptionDisabled(option4)
        }
      });
    }, "getPTOptions"),
    isOptionDisabled: /* @__PURE__ */ __name(function isOptionDisabled3(option4) {
      return this.optionDisabled ? resolveFieldData(option4, this.optionDisabled) : false;
    }, "isOptionDisabled"),
    isOptionGroup: /* @__PURE__ */ __name(function isOptionGroup3(option4) {
      return this.optionGroupLabel && option4.optionGroup && option4.group;
    }, "isOptionGroup"),
    getOptionGroupLabel: /* @__PURE__ */ __name(function getOptionGroupLabel3(optionGroup) {
      return resolveFieldData(optionGroup, this.optionGroupLabel);
    }, "getOptionGroupLabel"),
    getOptionGroupChildren: /* @__PURE__ */ __name(function getOptionGroupChildren3(optionGroup) {
      return resolveFieldData(optionGroup, this.optionGroupChildren);
    }, "getOptionGroupChildren"),
    getAriaPosInset: /* @__PURE__ */ __name(function getAriaPosInset3(index2) {
      var _this = this;
      return (this.optionGroupLabel ? index2 - this.visibleOptions.slice(0, index2).filter(function(option4) {
        return _this.isOptionGroup(option4);
      }).length : index2) + 1;
    }, "getAriaPosInset"),
    show: /* @__PURE__ */ __name(function show3(isFocus) {
      this.$emit("before-show");
      this.dirty = true;
      this.overlayVisible = true;
      this.focusedOptionIndex = this.focusedOptionIndex !== -1 ? this.focusedOptionIndex : this.autoOptionFocus ? this.findFirstFocusedOptionIndex() : -1;
      isFocus && focus(this.multiple ? this.$refs.focusInput : this.$refs.focusInput.$el);
    }, "show"),
    hide: /* @__PURE__ */ __name(function hide3(isFocus) {
      var _this2 = this;
      var _hide = /* @__PURE__ */ __name(function _hide2() {
        _this2.$emit("before-hide");
        _this2.dirty = isFocus;
        _this2.overlayVisible = false;
        _this2.clicked = false;
        _this2.focusedOptionIndex = -1;
        isFocus && focus(_this2.multiple ? _this2.$refs.focusInput : _this2.$refs.focusInput.$el);
      }, "_hide");
      setTimeout(function() {
        _hide();
      }, 0);
    }, "hide"),
    onFocus: /* @__PURE__ */ __name(function onFocus5(event2) {
      if (this.disabled) {
        return;
      }
      if (!this.dirty && this.completeOnFocus) {
        this.search(event2, event2.target.value, "focus");
      }
      this.dirty = true;
      this.focused = true;
      if (this.overlayVisible) {
        this.focusedOptionIndex = this.focusedOptionIndex !== -1 ? this.focusedOptionIndex : this.overlayVisible && this.autoOptionFocus ? this.findFirstFocusedOptionIndex() : -1;
        this.scrollInView(this.focusedOptionIndex);
      }
      this.$emit("focus", event2);
    }, "onFocus"),
    onBlur: /* @__PURE__ */ __name(function onBlur5(event2) {
      this.dirty = false;
      this.focused = false;
      this.focusedOptionIndex = -1;
      this.$emit("blur", event2);
    }, "onBlur"),
    onKeyDown: /* @__PURE__ */ __name(function onKeyDown5(event2) {
      if (this.disabled) {
        event2.preventDefault();
        return;
      }
      switch (event2.code) {
        case "ArrowDown":
          this.onArrowDownKey(event2);
          break;
        case "ArrowUp":
          this.onArrowUpKey(event2);
          break;
        case "ArrowLeft":
          this.onArrowLeftKey(event2);
          break;
        case "ArrowRight":
          this.onArrowRightKey(event2);
          break;
        case "Home":
          this.onHomeKey(event2);
          break;
        case "End":
          this.onEndKey(event2);
          break;
        case "PageDown":
          this.onPageDownKey(event2);
          break;
        case "PageUp":
          this.onPageUpKey(event2);
          break;
        case "Enter":
        case "NumpadEnter":
          this.onEnterKey(event2);
          break;
        case "Escape":
          this.onEscapeKey(event2);
          break;
        case "Tab":
          this.onTabKey(event2);
          break;
        case "Backspace":
          this.onBackspaceKey(event2);
          break;
      }
      this.clicked = false;
    }, "onKeyDown"),
    onInput: /* @__PURE__ */ __name(function onInput2(event2) {
      var _this3 = this;
      if (this.typeahead) {
        if (this.searchTimeout) {
          clearTimeout(this.searchTimeout);
        }
        var query = event2.target.value;
        if (!this.multiple) {
          this.updateModel(event2, query);
        }
        if (query.length === 0) {
          this.hide();
          this.$emit("clear");
        } else {
          if (query.length >= this.minLength) {
            this.focusedOptionIndex = -1;
            this.searchTimeout = setTimeout(function() {
              _this3.search(event2, query, "input");
            }, this.delay);
          } else {
            this.hide();
          }
        }
      }
    }, "onInput"),
    onChange: /* @__PURE__ */ __name(function onChange2(event2) {
      var _this4 = this;
      if (this.forceSelection) {
        var valid = false;
        if (this.visibleOptions && !this.multiple) {
          var value3 = this.multiple ? this.$refs.focusInput.value : this.$refs.focusInput.$el.value;
          var matchedValue = this.visibleOptions.find(function(option4) {
            return _this4.isOptionMatched(option4, value3 || "");
          });
          if (matchedValue !== void 0) {
            valid = true;
            !this.isSelected(matchedValue) && this.onOptionSelect(event2, matchedValue);
          }
        }
        if (!valid) {
          if (this.multiple) this.$refs.focusInput.value = "";
          else this.$refs.focusInput.$el.value = "";
          this.$emit("clear");
          !this.multiple && this.updateModel(event2, null);
        }
      }
    }, "onChange"),
    onMultipleContainerFocus: /* @__PURE__ */ __name(function onMultipleContainerFocus() {
      if (this.disabled) {
        return;
      }
      this.focused = true;
    }, "onMultipleContainerFocus"),
    onMultipleContainerBlur: /* @__PURE__ */ __name(function onMultipleContainerBlur() {
      this.focusedMultipleOptionIndex = -1;
      this.focused = false;
    }, "onMultipleContainerBlur"),
    onMultipleContainerKeyDown: /* @__PURE__ */ __name(function onMultipleContainerKeyDown(event2) {
      if (this.disabled) {
        event2.preventDefault();
        return;
      }
      switch (event2.code) {
        case "ArrowLeft":
          this.onArrowLeftKeyOnMultiple(event2);
          break;
        case "ArrowRight":
          this.onArrowRightKeyOnMultiple(event2);
          break;
        case "Backspace":
          this.onBackspaceKeyOnMultiple(event2);
          break;
      }
    }, "onMultipleContainerKeyDown"),
    onContainerClick: /* @__PURE__ */ __name(function onContainerClick2(event2) {
      this.clicked = true;
      if (this.disabled || this.searching || this.loading || this.isInputClicked(event2) || this.isDropdownClicked(event2)) {
        return;
      }
      if (!this.overlay || !this.overlay.contains(event2.target)) {
        focus(this.multiple ? this.$refs.focusInput : this.$refs.focusInput.$el);
      }
    }, "onContainerClick"),
    onDropdownClick: /* @__PURE__ */ __name(function onDropdownClick(event2) {
      var query = void 0;
      if (this.overlayVisible) {
        this.hide(true);
      } else {
        focus(this.multiple ? this.$refs.focusInput : this.$refs.focusInput.$el);
        query = this.$refs.focusInput.$el.value;
        if (this.dropdownMode === "blank") this.search(event2, "", "dropdown");
        else if (this.dropdownMode === "current") this.search(event2, query, "dropdown");
      }
      this.$emit("dropdown-click", {
        originalEvent: event2,
        query
      });
    }, "onDropdownClick"),
    onOptionSelect: /* @__PURE__ */ __name(function onOptionSelect3(event2, option4) {
      var isHide = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      var value3 = this.getOptionValue(option4);
      if (this.multiple) {
        this.$refs.focusInput.value = "";
        if (!this.isSelected(option4)) {
          this.updateModel(event2, [].concat(_toConsumableArray$7(this.modelValue || []), [value3]));
        }
      } else {
        this.updateModel(event2, value3);
      }
      this.$emit("item-select", {
        originalEvent: event2,
        value: option4
      });
      this.$emit("option-select", {
        originalEvent: event2,
        value: option4
      });
      isHide && this.hide(true);
    }, "onOptionSelect"),
    onOptionMouseMove: /* @__PURE__ */ __name(function onOptionMouseMove3(event2, index2) {
      if (this.focusOnHover) {
        this.changeFocusedOptionIndex(event2, index2);
      }
    }, "onOptionMouseMove"),
    onOverlayClick: /* @__PURE__ */ __name(function onOverlayClick2(event2) {
      OverlayEventBus.emit("overlay-click", {
        originalEvent: event2,
        target: this.$el
      });
    }, "onOverlayClick"),
    onOverlayKeyDown: /* @__PURE__ */ __name(function onOverlayKeyDown2(event2) {
      switch (event2.code) {
        case "Escape":
          this.onEscapeKey(event2);
          break;
      }
    }, "onOverlayKeyDown"),
    onArrowDownKey: /* @__PURE__ */ __name(function onArrowDownKey3(event2) {
      if (!this.overlayVisible) {
        return;
      }
      var optionIndex = this.focusedOptionIndex !== -1 ? this.findNextOptionIndex(this.focusedOptionIndex) : this.clicked ? this.findFirstOptionIndex() : this.findFirstFocusedOptionIndex();
      this.changeFocusedOptionIndex(event2, optionIndex);
      event2.preventDefault();
    }, "onArrowDownKey"),
    onArrowUpKey: /* @__PURE__ */ __name(function onArrowUpKey3(event2) {
      if (!this.overlayVisible) {
        return;
      }
      if (event2.altKey) {
        if (this.focusedOptionIndex !== -1) {
          this.onOptionSelect(event2, this.visibleOptions[this.focusedOptionIndex]);
        }
        this.overlayVisible && this.hide();
        event2.preventDefault();
      } else {
        var optionIndex = this.focusedOptionIndex !== -1 ? this.findPrevOptionIndex(this.focusedOptionIndex) : this.clicked ? this.findLastOptionIndex() : this.findLastFocusedOptionIndex();
        this.changeFocusedOptionIndex(event2, optionIndex);
        event2.preventDefault();
      }
    }, "onArrowUpKey"),
    onArrowLeftKey: /* @__PURE__ */ __name(function onArrowLeftKey3(event2) {
      var target = event2.currentTarget;
      this.focusedOptionIndex = -1;
      if (this.multiple) {
        if (isEmpty(target.value) && this.hasSelectedOption) {
          focus(this.$refs.multiContainer);
          this.focusedMultipleOptionIndex = this.modelValue.length;
        } else {
          event2.stopPropagation();
        }
      }
    }, "onArrowLeftKey"),
    onArrowRightKey: /* @__PURE__ */ __name(function onArrowRightKey(event2) {
      this.focusedOptionIndex = -1;
      this.multiple && event2.stopPropagation();
    }, "onArrowRightKey"),
    onHomeKey: /* @__PURE__ */ __name(function onHomeKey3(event2) {
      var currentTarget = event2.currentTarget;
      var len = currentTarget.value.length;
      currentTarget.setSelectionRange(0, event2.shiftKey ? len : 0);
      this.focusedOptionIndex = -1;
      event2.preventDefault();
    }, "onHomeKey"),
    onEndKey: /* @__PURE__ */ __name(function onEndKey3(event2) {
      var currentTarget = event2.currentTarget;
      var len = currentTarget.value.length;
      currentTarget.setSelectionRange(event2.shiftKey ? 0 : len, len);
      this.focusedOptionIndex = -1;
      event2.preventDefault();
    }, "onEndKey"),
    onPageUpKey: /* @__PURE__ */ __name(function onPageUpKey3(event2) {
      this.scrollInView(0);
      event2.preventDefault();
    }, "onPageUpKey"),
    onPageDownKey: /* @__PURE__ */ __name(function onPageDownKey3(event2) {
      this.scrollInView(this.visibleOptions.length - 1);
      event2.preventDefault();
    }, "onPageDownKey"),
    onEnterKey: /* @__PURE__ */ __name(function onEnterKey3(event2) {
      if (!this.typeahead) {
        if (this.multiple) {
          this.updateModel(event2, [].concat(_toConsumableArray$7(this.modelValue || []), [event2.target.value]));
          this.$refs.focusInput.value = "";
        }
      } else {
        if (!this.overlayVisible) {
          this.focusedOptionIndex = -1;
          this.onArrowDownKey(event2);
        } else {
          if (this.focusedOptionIndex !== -1) {
            this.onOptionSelect(event2, this.visibleOptions[this.focusedOptionIndex]);
          }
          this.hide();
        }
      }
    }, "onEnterKey"),
    onEscapeKey: /* @__PURE__ */ __name(function onEscapeKey2(event2) {
      this.overlayVisible && this.hide(true);
      event2.preventDefault();
    }, "onEscapeKey"),
    onTabKey: /* @__PURE__ */ __name(function onTabKey2(event2) {
      if (this.focusedOptionIndex !== -1) {
        this.onOptionSelect(event2, this.visibleOptions[this.focusedOptionIndex]);
      }
      this.overlayVisible && this.hide();
    }, "onTabKey"),
    onBackspaceKey: /* @__PURE__ */ __name(function onBackspaceKey2(event2) {
      if (this.multiple) {
        if (isNotEmpty(this.modelValue) && !this.$refs.focusInput.value) {
          var removedValue = this.modelValue[this.modelValue.length - 1];
          var newValue = this.modelValue.slice(0, -1);
          this.$emit("update:modelValue", newValue);
          this.$emit("item-unselect", {
            originalEvent: event2,
            value: removedValue
          });
          this.$emit("option-unselect", {
            originalEvent: event2,
            value: removedValue
          });
        }
        event2.stopPropagation();
      }
    }, "onBackspaceKey"),
    onArrowLeftKeyOnMultiple: /* @__PURE__ */ __name(function onArrowLeftKeyOnMultiple() {
      this.focusedMultipleOptionIndex = this.focusedMultipleOptionIndex < 1 ? 0 : this.focusedMultipleOptionIndex - 1;
    }, "onArrowLeftKeyOnMultiple"),
    onArrowRightKeyOnMultiple: /* @__PURE__ */ __name(function onArrowRightKeyOnMultiple() {
      this.focusedMultipleOptionIndex++;
      if (this.focusedMultipleOptionIndex > this.modelValue.length - 1) {
        this.focusedMultipleOptionIndex = -1;
        focus(this.$refs.focusInput);
      }
    }, "onArrowRightKeyOnMultiple"),
    onBackspaceKeyOnMultiple: /* @__PURE__ */ __name(function onBackspaceKeyOnMultiple(event2) {
      if (this.focusedMultipleOptionIndex !== -1) {
        this.removeOption(event2, this.focusedMultipleOptionIndex);
      }
    }, "onBackspaceKeyOnMultiple"),
    onOverlayEnter: /* @__PURE__ */ __name(function onOverlayEnter2(el) {
      ZIndex.set("overlay", el, this.$primevue.config.zIndex.overlay);
      addStyle(el, {
        position: "absolute",
        top: "0",
        left: "0"
      });
      this.alignOverlay();
    }, "onOverlayEnter"),
    onOverlayAfterEnter: /* @__PURE__ */ __name(function onOverlayAfterEnter2() {
      this.bindOutsideClickListener();
      this.bindScrollListener();
      this.bindResizeListener();
      this.$emit("show");
    }, "onOverlayAfterEnter"),
    onOverlayLeave: /* @__PURE__ */ __name(function onOverlayLeave2() {
      this.unbindOutsideClickListener();
      this.unbindScrollListener();
      this.unbindResizeListener();
      this.$emit("hide");
      this.overlay = null;
    }, "onOverlayLeave"),
    onOverlayAfterLeave: /* @__PURE__ */ __name(function onOverlayAfterLeave2(el) {
      ZIndex.clear(el);
    }, "onOverlayAfterLeave"),
    alignOverlay: /* @__PURE__ */ __name(function alignOverlay3() {
      var target = this.multiple ? this.$refs.multiContainer : this.$refs.focusInput.$el;
      if (this.appendTo === "self") {
        relativePosition(this.overlay, target);
      } else {
        this.overlay.style.minWidth = getOuterWidth(target) + "px";
        absolutePosition(this.overlay, target);
      }
    }, "alignOverlay"),
    bindOutsideClickListener: /* @__PURE__ */ __name(function bindOutsideClickListener2() {
      var _this5 = this;
      if (!this.outsideClickListener) {
        this.outsideClickListener = function(event2) {
          if (_this5.overlayVisible && _this5.overlay && _this5.isOutsideClicked(event2)) {
            _this5.hide();
          }
        };
        document.addEventListener("click", this.outsideClickListener);
      }
    }, "bindOutsideClickListener"),
    unbindOutsideClickListener: /* @__PURE__ */ __name(function unbindOutsideClickListener2() {
      if (this.outsideClickListener) {
        document.removeEventListener("click", this.outsideClickListener);
        this.outsideClickListener = null;
      }
    }, "unbindOutsideClickListener"),
    bindScrollListener: /* @__PURE__ */ __name(function bindScrollListener3() {
      var _this6 = this;
      if (!this.scrollHandler) {
        this.scrollHandler = new ConnectedOverlayScrollHandler(this.$refs.container, function() {
          if (_this6.overlayVisible) {
            _this6.hide();
          }
        });
      }
      this.scrollHandler.bindScrollListener();
    }, "bindScrollListener"),
    unbindScrollListener: /* @__PURE__ */ __name(function unbindScrollListener3() {
      if (this.scrollHandler) {
        this.scrollHandler.unbindScrollListener();
      }
    }, "unbindScrollListener"),
    bindResizeListener: /* @__PURE__ */ __name(function bindResizeListener3() {
      var _this7 = this;
      if (!this.resizeListener) {
        this.resizeListener = function() {
          if (_this7.overlayVisible && !isTouchDevice()) {
            _this7.hide();
          }
        };
        window.addEventListener("resize", this.resizeListener);
      }
    }, "bindResizeListener"),
    unbindResizeListener: /* @__PURE__ */ __name(function unbindResizeListener3() {
      if (this.resizeListener) {
        window.removeEventListener("resize", this.resizeListener);
        this.resizeListener = null;
      }
    }, "unbindResizeListener"),
    isOutsideClicked: /* @__PURE__ */ __name(function isOutsideClicked(event2) {
      return !this.overlay.contains(event2.target) && !this.isInputClicked(event2) && !this.isDropdownClicked(event2);
    }, "isOutsideClicked"),
    isInputClicked: /* @__PURE__ */ __name(function isInputClicked(event2) {
      if (this.multiple) return event2.target === this.$refs.multiContainer || this.$refs.multiContainer.contains(event2.target);
      else return event2.target === this.$refs.focusInput.$el;
    }, "isInputClicked"),
    isDropdownClicked: /* @__PURE__ */ __name(function isDropdownClicked(event2) {
      return this.$refs.dropdownButton ? event2.target === this.$refs.dropdownButton || this.$refs.dropdownButton.contains(event2.target) : false;
    }, "isDropdownClicked"),
    isOptionMatched: /* @__PURE__ */ __name(function isOptionMatched3(option4, value3) {
      var _this$getOptionLabel;
      return this.isValidOption(option4) && ((_this$getOptionLabel = this.getOptionLabel(option4)) === null || _this$getOptionLabel === void 0 ? void 0 : _this$getOptionLabel.toLocaleLowerCase(this.searchLocale)) === value3.toLocaleLowerCase(this.searchLocale);
    }, "isOptionMatched"),
    isValidOption: /* @__PURE__ */ __name(function isValidOption3(option4) {
      return isNotEmpty(option4) && !(this.isOptionDisabled(option4) || this.isOptionGroup(option4));
    }, "isValidOption"),
    isValidSelectedOption: /* @__PURE__ */ __name(function isValidSelectedOption3(option4) {
      return this.isValidOption(option4) && this.isSelected(option4);
    }, "isValidSelectedOption"),
    isEquals: /* @__PURE__ */ __name(function isEquals2(value1, value22) {
      return equals(value1, value22, this.equalityKey);
    }, "isEquals"),
    isSelected: /* @__PURE__ */ __name(function isSelected3(option4) {
      var _this8 = this;
      var optionValue = this.getOptionValue(option4);
      return this.multiple ? (this.modelValue || []).some(function(value3) {
        return _this8.isEquals(value3, optionValue);
      }) : this.isEquals(this.modelValue, this.getOptionValue(option4));
    }, "isSelected"),
    findFirstOptionIndex: /* @__PURE__ */ __name(function findFirstOptionIndex3() {
      var _this9 = this;
      return this.visibleOptions.findIndex(function(option4) {
        return _this9.isValidOption(option4);
      });
    }, "findFirstOptionIndex"),
    findLastOptionIndex: /* @__PURE__ */ __name(function findLastOptionIndex3() {
      var _this10 = this;
      return findLastIndex(this.visibleOptions, function(option4) {
        return _this10.isValidOption(option4);
      });
    }, "findLastOptionIndex"),
    findNextOptionIndex: /* @__PURE__ */ __name(function findNextOptionIndex3(index2) {
      var _this11 = this;
      var matchedOptionIndex = index2 < this.visibleOptions.length - 1 ? this.visibleOptions.slice(index2 + 1).findIndex(function(option4) {
        return _this11.isValidOption(option4);
      }) : -1;
      return matchedOptionIndex > -1 ? matchedOptionIndex + index2 + 1 : index2;
    }, "findNextOptionIndex"),
    findPrevOptionIndex: /* @__PURE__ */ __name(function findPrevOptionIndex3(index2) {
      var _this12 = this;
      var matchedOptionIndex = index2 > 0 ? findLastIndex(this.visibleOptions.slice(0, index2), function(option4) {
        return _this12.isValidOption(option4);
      }) : -1;
      return matchedOptionIndex > -1 ? matchedOptionIndex : index2;
    }, "findPrevOptionIndex"),
    findSelectedOptionIndex: /* @__PURE__ */ __name(function findSelectedOptionIndex3() {
      var _this13 = this;
      return this.hasSelectedOption ? this.visibleOptions.findIndex(function(option4) {
        return _this13.isValidSelectedOption(option4);
      }) : -1;
    }, "findSelectedOptionIndex"),
    findFirstFocusedOptionIndex: /* @__PURE__ */ __name(function findFirstFocusedOptionIndex3() {
      var selectedIndex = this.findSelectedOptionIndex();
      return selectedIndex < 0 ? this.findFirstOptionIndex() : selectedIndex;
    }, "findFirstFocusedOptionIndex"),
    findLastFocusedOptionIndex: /* @__PURE__ */ __name(function findLastFocusedOptionIndex3() {
      var selectedIndex = this.findSelectedOptionIndex();
      return selectedIndex < 0 ? this.findLastOptionIndex() : selectedIndex;
    }, "findLastFocusedOptionIndex"),
    search: /* @__PURE__ */ __name(function search2(event2, query, source) {
      if (query === void 0 || query === null) {
        return;
      }
      if (source === "input" && query.trim().length === 0) {
        return;
      }
      this.searching = true;
      this.$emit("complete", {
        originalEvent: event2,
        query
      });
    }, "search"),
    removeOption: /* @__PURE__ */ __name(function removeOption2(event2, index2) {
      var _this14 = this;
      var removedOption = this.modelValue[index2];
      var value3 = this.modelValue.filter(function(_2, i2) {
        return i2 !== index2;
      }).map(function(option4) {
        return _this14.getOptionValue(option4);
      });
      this.updateModel(event2, value3);
      this.$emit("item-unselect", {
        originalEvent: event2,
        value: removedOption
      });
      this.$emit("option-unselect", {
        originalEvent: event2,
        value: removedOption
      });
      this.dirty = true;
      focus(this.multiple ? this.$refs.focusInput : this.$refs.focusInput.$el);
    }, "removeOption"),
    changeFocusedOptionIndex: /* @__PURE__ */ __name(function changeFocusedOptionIndex3(event2, index2) {
      if (this.focusedOptionIndex !== index2) {
        this.focusedOptionIndex = index2;
        this.scrollInView();
        if (this.selectOnFocus) {
          this.onOptionSelect(event2, this.visibleOptions[index2], false);
        }
      }
    }, "changeFocusedOptionIndex"),
    scrollInView: /* @__PURE__ */ __name(function scrollInView5() {
      var _this15 = this;
      var index2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : -1;
      this.$nextTick(function() {
        var id2 = index2 !== -1 ? "".concat(_this15.id, "_").concat(index2) : _this15.focusedOptionId;
        var element = findSingle(_this15.list, 'li[id="'.concat(id2, '"]'));
        if (element) {
          element.scrollIntoView && element.scrollIntoView({
            block: "nearest",
            inline: "start"
          });
        } else if (!_this15.virtualScrollerDisabled) {
          _this15.virtualScroller && _this15.virtualScroller.scrollToIndex(index2 !== -1 ? index2 : _this15.focusedOptionIndex);
        }
      });
    }, "scrollInView"),
    autoUpdateModel: /* @__PURE__ */ __name(function autoUpdateModel3() {
      if (this.selectOnFocus && this.autoOptionFocus && !this.hasSelectedOption) {
        this.focusedOptionIndex = this.findFirstFocusedOptionIndex();
        this.onOptionSelect(null, this.visibleOptions[this.focusedOptionIndex], false);
      }
    }, "autoUpdateModel"),
    updateModel: /* @__PURE__ */ __name(function updateModel5(event2, value3) {
      this.$emit("update:modelValue", value3);
      this.$emit("change", {
        originalEvent: event2,
        value: value3
      });
    }, "updateModel"),
    flatOptions: /* @__PURE__ */ __name(function flatOptions3(options3) {
      var _this16 = this;
      return (options3 || []).reduce(function(result, option4, index2) {
        result.push({
          optionGroup: option4,
          group: true,
          index: index2
        });
        var optionGroupChildren = _this16.getOptionGroupChildren(option4);
        optionGroupChildren && optionGroupChildren.forEach(function(o) {
          return result.push(o);
        });
        return result;
      }, []);
    }, "flatOptions"),
    overlayRef: /* @__PURE__ */ __name(function overlayRef2(el) {
      this.overlay = el;
    }, "overlayRef"),
    listRef: /* @__PURE__ */ __name(function listRef3(el, contentRef3) {
      this.list = el;
      contentRef3 && contentRef3(el);
    }, "listRef"),
    virtualScrollerRef: /* @__PURE__ */ __name(function virtualScrollerRef3(el) {
      this.virtualScroller = el;
    }, "virtualScrollerRef")
  },
  computed: {
    visibleOptions: /* @__PURE__ */ __name(function visibleOptions3() {
      return this.optionGroupLabel ? this.flatOptions(this.suggestions) : this.suggestions || [];
    }, "visibleOptions"),
    inputValue: /* @__PURE__ */ __name(function inputValue() {
      if (isNotEmpty(this.modelValue)) {
        if (_typeof$1$3(this.modelValue) === "object") {
          var label5 = this.getOptionLabel(this.modelValue);
          return label5 != null ? label5 : this.modelValue;
        } else {
          return this.modelValue;
        }
      } else {
        return "";
      }
    }, "inputValue"),
    hasSelectedOption: /* @__PURE__ */ __name(function hasSelectedOption3() {
      return isNotEmpty(this.modelValue);
    }, "hasSelectedOption"),
    equalityKey: /* @__PURE__ */ __name(function equalityKey3() {
      return this.dataKey;
    }, "equalityKey"),
    searchResultMessageText: /* @__PURE__ */ __name(function searchResultMessageText() {
      return isNotEmpty(this.visibleOptions) && this.overlayVisible ? this.searchMessageText.replaceAll("{0}", this.visibleOptions.length) : this.emptySearchMessageText;
    }, "searchResultMessageText"),
    searchMessageText: /* @__PURE__ */ __name(function searchMessageText() {
      return this.searchMessage || this.$primevue.config.locale.searchMessage || "";
    }, "searchMessageText"),
    emptySearchMessageText: /* @__PURE__ */ __name(function emptySearchMessageText() {
      return this.emptySearchMessage || this.$primevue.config.locale.emptySearchMessage || "";
    }, "emptySearchMessageText"),
    selectionMessageText: /* @__PURE__ */ __name(function selectionMessageText3() {
      return this.selectionMessage || this.$primevue.config.locale.selectionMessage || "";
    }, "selectionMessageText"),
    emptySelectionMessageText: /* @__PURE__ */ __name(function emptySelectionMessageText3() {
      return this.emptySelectionMessage || this.$primevue.config.locale.emptySelectionMessage || "";
    }, "emptySelectionMessageText"),
    selectedMessageText: /* @__PURE__ */ __name(function selectedMessageText3() {
      return this.hasSelectedOption ? this.selectionMessageText.replaceAll("{0}", this.multiple ? this.modelValue.length : "1") : this.emptySelectionMessageText;
    }, "selectedMessageText"),
    listAriaLabel: /* @__PURE__ */ __name(function listAriaLabel() {
      return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.listLabel : void 0;
    }, "listAriaLabel"),
    focusedOptionId: /* @__PURE__ */ __name(function focusedOptionId3() {
      return this.focusedOptionIndex !== -1 ? "".concat(this.id, "_").concat(this.focusedOptionIndex) : null;
    }, "focusedOptionId"),
    focusedMultipleOptionId: /* @__PURE__ */ __name(function focusedMultipleOptionId() {
      return this.focusedMultipleOptionIndex !== -1 ? "".concat(this.id, "_multiple_option_").concat(this.focusedMultipleOptionIndex) : null;
    }, "focusedMultipleOptionId"),
    ariaSetSize: /* @__PURE__ */ __name(function ariaSetSize3() {
      var _this17 = this;
      return this.visibleOptions.filter(function(option4) {
        return !_this17.isOptionGroup(option4);
      }).length;
    }, "ariaSetSize"),
    virtualScrollerDisabled: /* @__PURE__ */ __name(function virtualScrollerDisabled3() {
      return !this.virtualScrollerOptions;
    }, "virtualScrollerDisabled"),
    panelId: /* @__PURE__ */ __name(function panelId() {
      return this.id + "_panel";
    }, "panelId")
  },
  components: {
    InputText: script$O,
    VirtualScroller: script$M,
    Portal: script$z,
    ChevronDownIcon: script$B,
    SpinnerIcon: script$N,
    Chip: script$t
  },
  directives: {
    ripple: Ripple
  }
};
function _typeof$8(o) {
  "@babel/helpers - typeof";
  return _typeof$8 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$8(o);
}
__name(_typeof$8, "_typeof$8");
function ownKeys$9(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
__name(ownKeys$9, "ownKeys$9");
function _objectSpread$9(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$9(Object(t), true).forEach(function(r2) {
      _defineProperty$8(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$9(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
__name(_objectSpread$9, "_objectSpread$9");
function _defineProperty$8(e, r, t) {
  return (r = _toPropertyKey$7(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty$8, "_defineProperty$8");
function _toPropertyKey$7(t) {
  var i2 = _toPrimitive$7(t, "string");
  return "symbol" == _typeof$8(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$7, "_toPropertyKey$7");
function _toPrimitive$7(t, r) {
  if ("object" != _typeof$8(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$8(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive$7, "_toPrimitive$7");
var _hoisted_1$x = ["aria-activedescendant"];
var _hoisted_2$o = ["id", "aria-label", "aria-setsize", "aria-posinset"];
var _hoisted_3$c = ["id", "placeholder", "tabindex", "disabled", "aria-label", "aria-labelledby", "aria-expanded", "aria-controls", "aria-activedescendant", "aria-invalid"];
var _hoisted_4$8 = ["disabled", "aria-expanded", "aria-controls"];
var _hoisted_5$6 = ["id"];
var _hoisted_6$5 = ["id", "aria-label"];
var _hoisted_7$4 = ["id"];
var _hoisted_8$3 = ["id", "aria-label", "aria-selected", "aria-disabled", "aria-setsize", "aria-posinset", "onClick", "onMousemove", "data-p-selected", "data-p-focus", "data-p-disabled"];
function render$m(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_InputText = resolveComponent("InputText");
  var _component_Chip = resolveComponent("Chip");
  var _component_SpinnerIcon = resolveComponent("SpinnerIcon");
  var _component_VirtualScroller = resolveComponent("VirtualScroller");
  var _component_Portal = resolveComponent("Portal");
  var _directive_ripple = resolveDirective("ripple");
  return openBlock(), createElementBlock("div", mergeProps({
    ref: "container",
    "class": _ctx.cx("root"),
    style: _ctx.sx("root"),
    onClick: _cache[11] || (_cache[11] = function() {
      return $options.onContainerClick && $options.onContainerClick.apply($options, arguments);
    })
  }, _ctx.ptmi("root")), [!_ctx.multiple ? (openBlock(), createBlock(_component_InputText, {
    key: 0,
    ref: "focusInput",
    id: _ctx.inputId,
    type: "text",
    "class": normalizeClass([_ctx.cx("pcInput"), _ctx.inputClass]),
    style: normalizeStyle(_ctx.inputStyle),
    value: $options.inputValue,
    placeholder: _ctx.placeholder,
    tabindex: !_ctx.disabled ? _ctx.tabindex : -1,
    disabled: _ctx.disabled,
    invalid: _ctx.invalid,
    variant: _ctx.variant,
    autocomplete: "off",
    role: "combobox",
    "aria-label": _ctx.ariaLabel,
    "aria-labelledby": _ctx.ariaLabelledby,
    "aria-haspopup": "listbox",
    "aria-autocomplete": "list",
    "aria-expanded": $data.overlayVisible,
    "aria-controls": $options.panelId,
    "aria-activedescendant": $data.focused ? $options.focusedOptionId : void 0,
    onFocus: $options.onFocus,
    onBlur: $options.onBlur,
    onKeydown: $options.onKeyDown,
    onInput: $options.onInput,
    onChange: $options.onChange,
    unstyled: _ctx.unstyled,
    pt: _ctx.ptm("pcInput")
  }, null, 8, ["id", "class", "style", "value", "placeholder", "tabindex", "disabled", "invalid", "variant", "aria-label", "aria-labelledby", "aria-expanded", "aria-controls", "aria-activedescendant", "onFocus", "onBlur", "onKeydown", "onInput", "onChange", "unstyled", "pt"])) : createCommentVNode("", true), _ctx.multiple ? (openBlock(), createElementBlock("ul", mergeProps({
    key: 1,
    ref: "multiContainer",
    "class": _ctx.cx("inputMultiple"),
    tabindex: "-1",
    role: "listbox",
    "aria-orientation": "horizontal",
    "aria-activedescendant": $data.focused ? $options.focusedMultipleOptionId : void 0,
    onFocus: _cache[5] || (_cache[5] = function() {
      return $options.onMultipleContainerFocus && $options.onMultipleContainerFocus.apply($options, arguments);
    }),
    onBlur: _cache[6] || (_cache[6] = function() {
      return $options.onMultipleContainerBlur && $options.onMultipleContainerBlur.apply($options, arguments);
    }),
    onKeydown: _cache[7] || (_cache[7] = function() {
      return $options.onMultipleContainerKeyDown && $options.onMultipleContainerKeyDown.apply($options, arguments);
    })
  }, _ctx.ptm("inputMultiple")), [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.modelValue, function(option4, i2) {
    return openBlock(), createElementBlock("li", mergeProps({
      key: "".concat(i2, "_").concat($options.getOptionLabel(option4)),
      id: $data.id + "_multiple_option_" + i2,
      "class": _ctx.cx("chipItem", {
        i: i2
      }),
      role: "option",
      "aria-label": $options.getOptionLabel(option4),
      "aria-selected": true,
      "aria-setsize": _ctx.modelValue.length,
      "aria-posinset": i2 + 1,
      ref_for: true
    }, _ctx.ptm("chipItem")), [renderSlot(_ctx.$slots, "chip", mergeProps({
      "class": _ctx.cx("pcChip"),
      value: option4,
      index: i2,
      removeCallback: /* @__PURE__ */ __name(function removeCallback(event2) {
        return $options.removeOption(event2, i2);
      }, "removeCallback"),
      ref_for: true
    }, _ctx.ptm("pcChip")), function() {
      return [createVNode(_component_Chip, {
        "class": normalizeClass(_ctx.cx("pcChip")),
        label: $options.getOptionLabel(option4),
        removeIcon: _ctx.chipIcon || _ctx.removeTokenIcon,
        removable: "",
        unstyled: _ctx.unstyled,
        onRemove: /* @__PURE__ */ __name(function onRemove2($event) {
          return $options.removeOption($event, i2);
        }, "onRemove"),
        pt: _ctx.ptm("pcChip")
      }, {
        removeicon: withCtx(function() {
          return [renderSlot(_ctx.$slots, _ctx.$slots.chipicon ? "chipicon" : "removetokenicon", {
            "class": normalizeClass(_ctx.cx("chipIcon")),
            index: i2,
            removeCallback: /* @__PURE__ */ __name(function removeCallback(event2) {
              return $options.removeOption(event2, i2);
            }, "removeCallback")
          })];
        }),
        _: 2
      }, 1032, ["class", "label", "removeIcon", "unstyled", "onRemove", "pt"])];
    })], 16, _hoisted_2$o);
  }), 128)), createBaseVNode("li", mergeProps({
    "class": _ctx.cx("inputChip"),
    role: "option"
  }, _ctx.ptm("inputChip")), [createBaseVNode("input", mergeProps({
    ref: "focusInput",
    id: _ctx.inputId,
    type: "text",
    style: _ctx.inputStyle,
    "class": _ctx.inputClass,
    placeholder: _ctx.placeholder,
    tabindex: !_ctx.disabled ? _ctx.tabindex : -1,
    disabled: _ctx.disabled,
    autocomplete: "off",
    role: "combobox",
    "aria-label": _ctx.ariaLabel,
    "aria-labelledby": _ctx.ariaLabelledby,
    "aria-haspopup": "listbox",
    "aria-autocomplete": "list",
    "aria-expanded": $data.overlayVisible,
    "aria-controls": $data.id + "_list",
    "aria-activedescendant": $data.focused ? $options.focusedOptionId : void 0,
    "aria-invalid": _ctx.invalid || void 0,
    onFocus: _cache[0] || (_cache[0] = function() {
      return $options.onFocus && $options.onFocus.apply($options, arguments);
    }),
    onBlur: _cache[1] || (_cache[1] = function() {
      return $options.onBlur && $options.onBlur.apply($options, arguments);
    }),
    onKeydown: _cache[2] || (_cache[2] = function() {
      return $options.onKeyDown && $options.onKeyDown.apply($options, arguments);
    }),
    onInput: _cache[3] || (_cache[3] = function() {
      return $options.onInput && $options.onInput.apply($options, arguments);
    }),
    onChange: _cache[4] || (_cache[4] = function() {
      return $options.onChange && $options.onChange.apply($options, arguments);
    })
  }, _ctx.ptm("input")), null, 16, _hoisted_3$c)], 16)], 16, _hoisted_1$x)) : createCommentVNode("", true), $data.searching || _ctx.loading ? renderSlot(_ctx.$slots, _ctx.$slots.loader ? "loader" : "loadingicon", {
    key: 2,
    "class": normalizeClass(_ctx.cx("loader"))
  }, function() {
    return [_ctx.loader || _ctx.loadingIcon ? (openBlock(), createElementBlock("i", mergeProps({
      key: 0,
      "class": ["pi-spin", _ctx.cx("loader"), _ctx.loader, _ctx.loadingIcon],
      "aria-hidden": "true"
    }, _ctx.ptm("loader")), null, 16)) : (openBlock(), createBlock(_component_SpinnerIcon, mergeProps({
      key: 1,
      "class": _ctx.cx("loader"),
      spin: "",
      "aria-hidden": "true"
    }, _ctx.ptm("loader")), null, 16, ["class"]))];
  }) : createCommentVNode("", true), renderSlot(_ctx.$slots, _ctx.$slots.dropdown ? "dropdown" : "dropdownbutton", {
    toggleCallback: /* @__PURE__ */ __name(function toggleCallback(event2) {
      return $options.onDropdownClick(event2);
    }, "toggleCallback")
  }, function() {
    return [_ctx.dropdown ? (openBlock(), createElementBlock("button", mergeProps({
      key: 0,
      ref: "dropdownButton",
      type: "button",
      "class": [_ctx.cx("dropdown"), _ctx.dropdownClass],
      disabled: _ctx.disabled,
      "aria-haspopup": "listbox",
      "aria-expanded": $data.overlayVisible,
      "aria-controls": $options.panelId,
      onClick: _cache[8] || (_cache[8] = function() {
        return $options.onDropdownClick && $options.onDropdownClick.apply($options, arguments);
      })
    }, _ctx.ptm("dropdown")), [renderSlot(_ctx.$slots, "dropdownicon", {
      "class": normalizeClass(_ctx.dropdownIcon)
    }, function() {
      return [(openBlock(), createBlock(resolveDynamicComponent(_ctx.dropdownIcon ? "span" : "ChevronDownIcon"), mergeProps({
        "class": _ctx.dropdownIcon
      }, _ctx.ptm("dropdownIcon")), null, 16, ["class"]))];
    })], 16, _hoisted_4$8)) : createCommentVNode("", true)];
  }), createBaseVNode("span", mergeProps({
    role: "status",
    "aria-live": "polite",
    "class": "p-hidden-accessible"
  }, _ctx.ptm("hiddenSearchResult"), {
    "data-p-hidden-accessible": true
  }), toDisplayString$1($options.searchResultMessageText), 17), createVNode(_component_Portal, {
    appendTo: _ctx.appendTo
  }, {
    "default": withCtx(function() {
      return [createVNode(Transition, mergeProps({
        name: "p-connected-overlay",
        onEnter: $options.onOverlayEnter,
        onAfterEnter: $options.onOverlayAfterEnter,
        onLeave: $options.onOverlayLeave,
        onAfterLeave: $options.onOverlayAfterLeave
      }, _ctx.ptm("transition")), {
        "default": withCtx(function() {
          return [$data.overlayVisible ? (openBlock(), createElementBlock("div", mergeProps({
            key: 0,
            ref: $options.overlayRef,
            id: $options.panelId,
            "class": [_ctx.cx("overlay"), _ctx.panelClass, _ctx.overlayClass],
            style: _objectSpread$9(_objectSpread$9(_objectSpread$9({}, _ctx.panelStyle), _ctx.overlayStyle), {}, {
              "max-height": $options.virtualScrollerDisabled ? _ctx.scrollHeight : ""
            }),
            onClick: _cache[9] || (_cache[9] = function() {
              return $options.onOverlayClick && $options.onOverlayClick.apply($options, arguments);
            }),
            onKeydown: _cache[10] || (_cache[10] = function() {
              return $options.onOverlayKeyDown && $options.onOverlayKeyDown.apply($options, arguments);
            })
          }, _ctx.ptm("overlay")), [renderSlot(_ctx.$slots, "header", {
            value: _ctx.modelValue,
            suggestions: $options.visibleOptions
          }), createVNode(_component_VirtualScroller, mergeProps({
            ref: $options.virtualScrollerRef
          }, _ctx.virtualScrollerOptions, {
            style: {
              height: _ctx.scrollHeight
            },
            items: $options.visibleOptions,
            tabindex: -1,
            disabled: $options.virtualScrollerDisabled,
            pt: _ctx.ptm("virtualScroller")
          }), createSlots({
            content: withCtx(function(_ref) {
              var styleClass = _ref.styleClass, contentRef3 = _ref.contentRef, items2 = _ref.items, getItemOptions = _ref.getItemOptions, contentStyle = _ref.contentStyle, itemSize2 = _ref.itemSize;
              return [createBaseVNode("ul", mergeProps({
                ref: /* @__PURE__ */ __name(function ref2(el) {
                  return $options.listRef(el, contentRef3);
                }, "ref"),
                id: $data.id + "_list",
                "class": [_ctx.cx("list"), styleClass],
                style: contentStyle,
                role: "listbox",
                "aria-label": $options.listAriaLabel
              }, _ctx.ptm("list")), [(openBlock(true), createElementBlock(Fragment, null, renderList(items2, function(option4, i2) {
                return openBlock(), createElementBlock(Fragment, {
                  key: $options.getOptionRenderKey(option4, $options.getOptionIndex(i2, getItemOptions))
                }, [$options.isOptionGroup(option4) ? (openBlock(), createElementBlock("li", mergeProps({
                  key: 0,
                  id: $data.id + "_" + $options.getOptionIndex(i2, getItemOptions),
                  style: {
                    height: itemSize2 ? itemSize2 + "px" : void 0
                  },
                  "class": _ctx.cx("optionGroup"),
                  role: "option",
                  ref_for: true
                }, _ctx.ptm("optionGroup")), [renderSlot(_ctx.$slots, "optiongroup", {
                  option: option4.optionGroup,
                  index: $options.getOptionIndex(i2, getItemOptions)
                }, function() {
                  return [createTextVNode(toDisplayString$1($options.getOptionGroupLabel(option4.optionGroup)), 1)];
                })], 16, _hoisted_7$4)) : withDirectives((openBlock(), createElementBlock("li", mergeProps({
                  key: 1,
                  id: $data.id + "_" + $options.getOptionIndex(i2, getItemOptions),
                  style: {
                    height: itemSize2 ? itemSize2 + "px" : void 0
                  },
                  "class": _ctx.cx("option", {
                    option: option4,
                    i: i2,
                    getItemOptions
                  }),
                  role: "option",
                  "aria-label": $options.getOptionLabel(option4),
                  "aria-selected": $options.isSelected(option4),
                  "aria-disabled": $options.isOptionDisabled(option4),
                  "aria-setsize": $options.ariaSetSize,
                  "aria-posinset": $options.getAriaPosInset($options.getOptionIndex(i2, getItemOptions)),
                  onClick: /* @__PURE__ */ __name(function onClick3($event) {
                    return $options.onOptionSelect($event, option4);
                  }, "onClick"),
                  onMousemove: /* @__PURE__ */ __name(function onMousemove($event) {
                    return $options.onOptionMouseMove($event, $options.getOptionIndex(i2, getItemOptions));
                  }, "onMousemove"),
                  "data-p-selected": $options.isSelected(option4),
                  "data-p-focus": $data.focusedOptionIndex === $options.getOptionIndex(i2, getItemOptions),
                  "data-p-disabled": $options.isOptionDisabled(option4),
                  ref_for: true
                }, $options.getPTOptions(option4, getItemOptions, i2, "option")), [renderSlot(_ctx.$slots, "option", {
                  option: option4,
                  index: $options.getOptionIndex(i2, getItemOptions)
                }, function() {
                  return [createTextVNode(toDisplayString$1($options.getOptionLabel(option4)), 1)];
                })], 16, _hoisted_8$3)), [[_directive_ripple]])], 64);
              }), 128)), !items2 || items2 && items2.length === 0 ? (openBlock(), createElementBlock("li", mergeProps({
                key: 0,
                "class": _ctx.cx("emptyMessage"),
                role: "option"
              }, _ctx.ptm("emptyMessage")), [renderSlot(_ctx.$slots, "empty", {}, function() {
                return [createTextVNode(toDisplayString$1($options.searchResultMessageText), 1)];
              })], 16)) : createCommentVNode("", true)], 16, _hoisted_6$5)];
            }),
            _: 2
          }, [_ctx.$slots.loader ? {
            name: "loader",
            fn: withCtx(function(_ref2) {
              var options3 = _ref2.options;
              return [renderSlot(_ctx.$slots, "loader", {
                options: options3
              })];
            }),
            key: "0"
          } : void 0]), 1040, ["style", "items", "disabled", "pt"]), renderSlot(_ctx.$slots, "footer", {
            value: _ctx.modelValue,
            suggestions: $options.visibleOptions
          }), createBaseVNode("span", mergeProps({
            role: "status",
            "aria-live": "polite",
            "class": "p-hidden-accessible"
          }, _ctx.ptm("hiddenSelectedMessage"), {
            "data-p-hidden-accessible": true
          }), toDisplayString$1($options.selectedMessageText), 17)], 16, _hoisted_5$6)) : createCommentVNode("", true)];
        }),
        _: 3
      }, 16, ["onEnter", "onAfterEnter", "onLeave", "onAfterLeave"])];
    }),
    _: 3
  }, 8, ["appendTo"])], 16);
}
__name(render$m, "render$m");
script$n.render = render$m;
const _sfc_main$o = {
  name: "AutoCompletePlus",
  extends: script$n,
  emits: ["focused-option-changed"],
  mounted() {
    if (typeof script$n.mounted === "function") {
      script$n.mounted.call(this);
    }
    this.$watch(
      () => this.focusedOptionIndex,
      (newVal, oldVal) => {
        this.$emit("focused-option-changed", newVal);
      }
    );
  }
};
var script$m = {
  name: "WindowMaximizeIcon",
  "extends": script$U
};
var _hoisted_1$w = /* @__PURE__ */ createBaseVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M7 14H11.8C12.3835 14 12.9431 13.7682 13.3556 13.3556C13.7682 12.9431 14 12.3835 14 11.8V2.2C14 1.61652 13.7682 1.05694 13.3556 0.644365C12.9431 0.231785 12.3835 0 11.8 0H2.2C1.61652 0 1.05694 0.231785 0.644365 0.644365C0.231785 1.05694 0 1.61652 0 2.2V7C0 7.15913 0.063214 7.31174 0.175736 7.42426C0.288258 7.53679 0.44087 7.6 0.6 7.6C0.75913 7.6 0.911742 7.53679 1.02426 7.42426C1.13679 7.31174 1.2 7.15913 1.2 7V2.2C1.2 1.93478 1.30536 1.68043 1.49289 1.49289C1.68043 1.30536 1.93478 1.2 2.2 1.2H11.8C12.0652 1.2 12.3196 1.30536 12.5071 1.49289C12.6946 1.68043 12.8 1.93478 12.8 2.2V11.8C12.8 12.0652 12.6946 12.3196 12.5071 12.5071C12.3196 12.6946 12.0652 12.8 11.8 12.8H7C6.84087 12.8 6.68826 12.8632 6.57574 12.9757C6.46321 13.0883 6.4 13.2409 6.4 13.4C6.4 13.5591 6.46321 13.7117 6.57574 13.8243C6.68826 13.9368 6.84087 14 7 14ZM9.77805 7.42192C9.89013 7.534 10.0415 7.59788 10.2 7.59995C10.3585 7.59788 10.5099 7.534 10.622 7.42192C10.7341 7.30985 10.798 7.15844 10.8 6.99995V3.94242C10.8066 3.90505 10.8096 3.86689 10.8089 3.82843C10.8079 3.77159 10.7988 3.7157 10.7824 3.6623C10.756 3.55552 10.701 3.45698 10.622 3.37798C10.5099 3.2659 10.3585 3.20202 10.2 3.19995H7.00002C6.84089 3.19995 6.68828 3.26317 6.57576 3.37569C6.46324 3.48821 6.40002 3.64082 6.40002 3.79995C6.40002 3.95908 6.46324 4.11169 6.57576 4.22422C6.68828 4.33674 6.84089 4.39995 7.00002 4.39995H8.80006L6.19997 7.00005C6.10158 7.11005 6.04718 7.25246 6.04718 7.40005C6.04718 7.54763 6.10158 7.69004 6.19997 7.80005C6.30202 7.91645 6.44561 7.98824 6.59997 8.00005C6.75432 7.98824 6.89791 7.91645 6.99997 7.80005L9.60002 5.26841V6.99995C9.6021 7.15844 9.66598 7.30985 9.77805 7.42192ZM1.4 14H3.8C4.17066 13.9979 4.52553 13.8498 4.78763 13.5877C5.04973 13.3256 5.1979 12.9707 5.2 12.6V10.2C5.1979 9.82939 5.04973 9.47452 4.78763 9.21242C4.52553 8.95032 4.17066 8.80215 3.8 8.80005H1.4C1.02934 8.80215 0.674468 8.95032 0.412371 9.21242C0.150274 9.47452 0.00210008 9.82939 0 10.2V12.6C0.00210008 12.9707 0.150274 13.3256 0.412371 13.5877C0.674468 13.8498 1.02934 13.9979 1.4 14ZM1.25858 10.0586C1.29609 10.0211 1.34696 10 1.4 10H3.8C3.85304 10 3.90391 10.0211 3.94142 10.0586C3.97893 10.0961 4 10.147 4 10.2V12.6C4 12.6531 3.97893 12.704 3.94142 12.7415C3.90391 12.779 3.85304 12.8 3.8 12.8H1.4C1.34696 12.8 1.29609 12.779 1.25858 12.7415C1.22107 12.704 1.2 12.6531 1.2 12.6V10.2C1.2 10.147 1.22107 10.0961 1.25858 10.0586Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$n = [_hoisted_1$w];
function render$l(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$n, 16);
}
__name(render$l, "render$l");
script$m.render = render$l;
var script$l = {
  name: "WindowMinimizeIcon",
  "extends": script$U
};
var _hoisted_1$v = /* @__PURE__ */ createBaseVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M11.8 0H2.2C1.61652 0 1.05694 0.231785 0.644365 0.644365C0.231785 1.05694 0 1.61652 0 2.2V7C0 7.15913 0.063214 7.31174 0.175736 7.42426C0.288258 7.53679 0.44087 7.6 0.6 7.6C0.75913 7.6 0.911742 7.53679 1.02426 7.42426C1.13679 7.31174 1.2 7.15913 1.2 7V2.2C1.2 1.93478 1.30536 1.68043 1.49289 1.49289C1.68043 1.30536 1.93478 1.2 2.2 1.2H11.8C12.0652 1.2 12.3196 1.30536 12.5071 1.49289C12.6946 1.68043 12.8 1.93478 12.8 2.2V11.8C12.8 12.0652 12.6946 12.3196 12.5071 12.5071C12.3196 12.6946 12.0652 12.8 11.8 12.8H7C6.84087 12.8 6.68826 12.8632 6.57574 12.9757C6.46321 13.0883 6.4 13.2409 6.4 13.4C6.4 13.5591 6.46321 13.7117 6.57574 13.8243C6.68826 13.9368 6.84087 14 7 14H11.8C12.3835 14 12.9431 13.7682 13.3556 13.3556C13.7682 12.9431 14 12.3835 14 11.8V2.2C14 1.61652 13.7682 1.05694 13.3556 0.644365C12.9431 0.231785 12.3835 0 11.8 0ZM6.368 7.952C6.44137 7.98326 6.52025 7.99958 6.6 8H9.8C9.95913 8 10.1117 7.93678 10.2243 7.82426C10.3368 7.71174 10.4 7.55913 10.4 7.4C10.4 7.24087 10.3368 7.08826 10.2243 6.97574C10.1117 6.86321 9.95913 6.8 9.8 6.8H8.048L10.624 4.224C10.73 4.11026 10.7877 3.95982 10.7849 3.80438C10.7822 3.64894 10.7192 3.50063 10.6093 3.3907C10.4994 3.28077 10.3511 3.2178 10.1956 3.21506C10.0402 3.21232 9.88974 3.27002 9.776 3.376L7.2 5.952V4.2C7.2 4.04087 7.13679 3.88826 7.02426 3.77574C6.91174 3.66321 6.75913 3.6 6.6 3.6C6.44087 3.6 6.28826 3.66321 6.17574 3.77574C6.06321 3.88826 6 4.04087 6 4.2V7.4C6.00042 7.47975 6.01674 7.55862 6.048 7.632C6.07656 7.70442 6.11971 7.7702 6.17475 7.82524C6.2298 7.88029 6.29558 7.92344 6.368 7.952ZM1.4 8.80005H3.8C4.17066 8.80215 4.52553 8.95032 4.78763 9.21242C5.04973 9.47452 5.1979 9.82939 5.2 10.2V12.6C5.1979 12.9707 5.04973 13.3256 4.78763 13.5877C4.52553 13.8498 4.17066 13.9979 3.8 14H1.4C1.02934 13.9979 0.674468 13.8498 0.412371 13.5877C0.150274 13.3256 0.00210008 12.9707 0 12.6V10.2C0.00210008 9.82939 0.150274 9.47452 0.412371 9.21242C0.674468 8.95032 1.02934 8.80215 1.4 8.80005ZM3.94142 12.7415C3.97893 12.704 4 12.6531 4 12.6V10.2C4 10.147 3.97893 10.0961 3.94142 10.0586C3.90391 10.0211 3.85304 10 3.8 10H1.4C1.34696 10 1.29609 10.0211 1.25858 10.0586C1.22107 10.0961 1.2 10.147 1.2 10.2V12.6C1.2 12.6531 1.22107 12.704 1.25858 12.7415C1.29609 12.779 1.34696 12.8 1.4 12.8H3.8C3.85304 12.8 3.90391 12.779 3.94142 12.7415Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$m = [_hoisted_1$v];
function render$k(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$m, 16);
}
__name(render$k, "render$k");
script$l.render = render$k;
var FocusTrapStyle = BaseStyle.extend({
  name: "focustrap-directive"
});
var BaseFocusTrap = BaseDirective.extend({
  style: FocusTrapStyle
});
function _typeof$7(o) {
  "@babel/helpers - typeof";
  return _typeof$7 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$7(o);
}
__name(_typeof$7, "_typeof$7");
function ownKeys$8(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
__name(ownKeys$8, "ownKeys$8");
function _objectSpread$8(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$8(Object(t), true).forEach(function(r2) {
      _defineProperty$7(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$8(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
__name(_objectSpread$8, "_objectSpread$8");
function _defineProperty$7(e, r, t) {
  return (r = _toPropertyKey$6(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty$7, "_defineProperty$7");
function _toPropertyKey$6(t) {
  var i2 = _toPrimitive$6(t, "string");
  return "symbol" == _typeof$7(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$6, "_toPropertyKey$6");
function _toPrimitive$6(t, r) {
  if ("object" != _typeof$7(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$7(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive$6, "_toPrimitive$6");
var FocusTrap = BaseFocusTrap.extend("focustrap", {
  mounted: /* @__PURE__ */ __name(function mounted11(el, binding) {
    var _ref = binding.value || {}, disabled2 = _ref.disabled;
    if (!disabled2) {
      this.createHiddenFocusableElements(el, binding);
      this.bind(el, binding);
      this.autoElementFocus(el, binding);
    }
    el.setAttribute("data-pd-focustrap", true);
    this.$el = el;
  }, "mounted"),
  updated: /* @__PURE__ */ __name(function updated7(el, binding) {
    var _ref2 = binding.value || {}, disabled2 = _ref2.disabled;
    disabled2 && this.unbind(el);
  }, "updated"),
  unmounted: /* @__PURE__ */ __name(function unmounted5(el) {
    this.unbind(el);
  }, "unmounted"),
  methods: {
    getComputedSelector: /* @__PURE__ */ __name(function getComputedSelector(selector) {
      return ':not(.p-hidden-focusable):not([data-p-hidden-focusable="true"])'.concat(selector !== null && selector !== void 0 ? selector : "");
    }, "getComputedSelector"),
    bind: /* @__PURE__ */ __name(function bind2(el, binding) {
      var _this = this;
      var _ref3 = binding.value || {}, onFocusIn = _ref3.onFocusIn, onFocusOut = _ref3.onFocusOut;
      el.$_pfocustrap_mutationobserver = new MutationObserver(function(mutationList) {
        mutationList.forEach(function(mutation) {
          if (mutation.type === "childList" && !el.contains(document.activeElement)) {
            var findNextFocusableElement = /* @__PURE__ */ __name(function findNextFocusableElement2(_el) {
              var focusableElement = isFocusableElement(_el) ? isFocusableElement(_el, _this.getComputedSelector(el.$_pfocustrap_focusableselector)) ? _el : getFirstFocusableElement(el, _this.getComputedSelector(el.$_pfocustrap_focusableselector)) : getFirstFocusableElement(_el);
              return isNotEmpty(focusableElement) ? focusableElement : _el.nextSibling && findNextFocusableElement2(_el.nextSibling);
            }, "findNextFocusableElement");
            focus(findNextFocusableElement(mutation.nextSibling));
          }
        });
      });
      el.$_pfocustrap_mutationobserver.disconnect();
      el.$_pfocustrap_mutationobserver.observe(el, {
        childList: true
      });
      el.$_pfocustrap_focusinlistener = function(event2) {
        return onFocusIn && onFocusIn(event2);
      };
      el.$_pfocustrap_focusoutlistener = function(event2) {
        return onFocusOut && onFocusOut(event2);
      };
      el.addEventListener("focusin", el.$_pfocustrap_focusinlistener);
      el.addEventListener("focusout", el.$_pfocustrap_focusoutlistener);
    }, "bind"),
    unbind: /* @__PURE__ */ __name(function unbind(el) {
      el.$_pfocustrap_mutationobserver && el.$_pfocustrap_mutationobserver.disconnect();
      el.$_pfocustrap_focusinlistener && el.removeEventListener("focusin", el.$_pfocustrap_focusinlistener) && (el.$_pfocustrap_focusinlistener = null);
      el.$_pfocustrap_focusoutlistener && el.removeEventListener("focusout", el.$_pfocustrap_focusoutlistener) && (el.$_pfocustrap_focusoutlistener = null);
    }, "unbind"),
    autoFocus: /* @__PURE__ */ __name(function autoFocus(options3) {
      this.autoElementFocus(this.$el, {
        value: _objectSpread$8(_objectSpread$8({}, options3), {}, {
          autoFocus: true
        })
      });
    }, "autoFocus"),
    autoElementFocus: /* @__PURE__ */ __name(function autoElementFocus(el, binding) {
      var _ref4 = binding.value || {}, _ref4$autoFocusSelect = _ref4.autoFocusSelector, autoFocusSelector = _ref4$autoFocusSelect === void 0 ? "" : _ref4$autoFocusSelect, _ref4$firstFocusableS = _ref4.firstFocusableSelector, firstFocusableSelector = _ref4$firstFocusableS === void 0 ? "" : _ref4$firstFocusableS, _ref4$autoFocus = _ref4.autoFocus, autoFocus2 = _ref4$autoFocus === void 0 ? false : _ref4$autoFocus;
      var focusableElement = getFirstFocusableElement(el, "[autofocus]".concat(this.getComputedSelector(autoFocusSelector)));
      autoFocus2 && !focusableElement && (focusableElement = getFirstFocusableElement(el, this.getComputedSelector(firstFocusableSelector)));
      focus(focusableElement);
    }, "autoElementFocus"),
    onFirstHiddenElementFocus: /* @__PURE__ */ __name(function onFirstHiddenElementFocus(event2) {
      var _this$$el;
      var currentTarget = event2.currentTarget, relatedTarget = event2.relatedTarget;
      var focusableElement = relatedTarget === currentTarget.$_pfocustrap_lasthiddenfocusableelement || !((_this$$el = this.$el) !== null && _this$$el !== void 0 && _this$$el.contains(relatedTarget)) ? getFirstFocusableElement(currentTarget.parentElement, this.getComputedSelector(currentTarget.$_pfocustrap_focusableselector)) : currentTarget.$_pfocustrap_lasthiddenfocusableelement;
      focus(focusableElement);
    }, "onFirstHiddenElementFocus"),
    onLastHiddenElementFocus: /* @__PURE__ */ __name(function onLastHiddenElementFocus(event2) {
      var _this$$el2;
      var currentTarget = event2.currentTarget, relatedTarget = event2.relatedTarget;
      var focusableElement = relatedTarget === currentTarget.$_pfocustrap_firsthiddenfocusableelement || !((_this$$el2 = this.$el) !== null && _this$$el2 !== void 0 && _this$$el2.contains(relatedTarget)) ? getLastFocusableElement(currentTarget.parentElement, this.getComputedSelector(currentTarget.$_pfocustrap_focusableselector)) : currentTarget.$_pfocustrap_firsthiddenfocusableelement;
      focus(focusableElement);
    }, "onLastHiddenElementFocus"),
    createHiddenFocusableElements: /* @__PURE__ */ __name(function createHiddenFocusableElements(el, binding) {
      var _this2 = this;
      var _ref5 = binding.value || {}, _ref5$tabIndex = _ref5.tabIndex, tabIndex = _ref5$tabIndex === void 0 ? 0 : _ref5$tabIndex, _ref5$firstFocusableS = _ref5.firstFocusableSelector, firstFocusableSelector = _ref5$firstFocusableS === void 0 ? "" : _ref5$firstFocusableS, _ref5$lastFocusableSe = _ref5.lastFocusableSelector, lastFocusableSelector = _ref5$lastFocusableSe === void 0 ? "" : _ref5$lastFocusableSe;
      var createFocusableElement = /* @__PURE__ */ __name(function createFocusableElement2(onFocus8) {
        return createElement("span", {
          "class": "p-hidden-accessible p-hidden-focusable",
          tabIndex,
          role: "presentation",
          "aria-hidden": true,
          "data-p-hidden-accessible": true,
          "data-p-hidden-focusable": true,
          onFocus: onFocus8 === null || onFocus8 === void 0 ? void 0 : onFocus8.bind(_this2)
        });
      }, "createFocusableElement");
      var firstFocusableElement = createFocusableElement(this.onFirstHiddenElementFocus);
      var lastFocusableElement = createFocusableElement(this.onLastHiddenElementFocus);
      firstFocusableElement.$_pfocustrap_lasthiddenfocusableelement = lastFocusableElement;
      firstFocusableElement.$_pfocustrap_focusableselector = firstFocusableSelector;
      firstFocusableElement.setAttribute("data-pc-section", "firstfocusableelement");
      lastFocusableElement.$_pfocustrap_firsthiddenfocusableelement = firstFocusableElement;
      lastFocusableElement.$_pfocustrap_focusableselector = lastFocusableSelector;
      lastFocusableElement.setAttribute("data-pc-section", "lastfocusableelement");
      el.prepend(firstFocusableElement);
      el.append(lastFocusableElement);
    }, "createHiddenFocusableElements")
  }
});
var theme$b = /* @__PURE__ */ __name(function theme26(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-dialog {\n    max-height: 90%;\n    transform: scale(1);\n    border-radius: ".concat(dt3("dialog.border.radius"), ";\n    box-shadow: ").concat(dt3("dialog.shadow"), ";\n    background: ").concat(dt3("dialog.background"), ";\n    border: 1px solid ").concat(dt3("dialog.border.color"), ";\n    color: ").concat(dt3("dialog.color"), ";\n}\n\n.p-dialog-content {\n    overflow-y: auto;\n    padding: ").concat(dt3("dialog.content.padding"), ";\n}\n\n.p-dialog-header {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    flex-shrink: 0;\n    padding: ").concat(dt3("dialog.header.padding"), ";\n}\n\n.p-dialog-title {\n    font-weight: ").concat(dt3("dialog.title.font.weight"), ";\n    font-size: ").concat(dt3("dialog.title.font.size"), ";\n}\n\n.p-dialog-footer {\n    flex-shrink: 0;\n    padding: ").concat(dt3("dialog.footer.padding"), ";\n    display: flex;\n    justify-content: flex-end;\n    gap: ").concat(dt3("dialog.footer.gap"), ";\n}\n\n.p-dialog-header-actions {\n    display: flex;\n    align-items: center;\n    gap: ").concat(dt3("dialog.header.gap"), ";\n}\n.p-dialog-enter-active {\n    transition: all 150ms cubic-bezier(0, 0, 0.2, 1);\n}\n\n.p-dialog-leave-active {\n    transition: all 150ms cubic-bezier(0.4, 0, 0.2, 1);\n}\n\n.p-dialog-enter-from,\n.p-dialog-leave-to {\n    opacity: 0;\n    transform: scale(0.7);\n}\n\n.p-dialog-top .p-dialog,\n.p-dialog-bottom .p-dialog,\n.p-dialog-left .p-dialog,\n.p-dialog-right .p-dialog,\n.p-dialog-topleft .p-dialog,\n.p-dialog-topright .p-dialog,\n.p-dialog-bottomleft .p-dialog,\n.p-dialog-bottomright .p-dialog {\n    margin: 0.75rem;\n    transform: translate3d(0px, 0px, 0px);\n}\n\n.p-dialog-top .p-dialog-enter-active,\n.p-dialog-top .p-dialog-leave-active,\n.p-dialog-bottom .p-dialog-enter-active,\n.p-dialog-bottom .p-dialog-leave-active,\n.p-dialog-left .p-dialog-enter-active,\n.p-dialog-left .p-dialog-leave-active,\n.p-dialog-right .p-dialog-enter-active,\n.p-dialog-right .p-dialog-leave-active,\n.p-dialog-topleft .p-dialog-enter-active,\n.p-dialog-topleft .p-dialog-leave-active,\n.p-dialog-topright .p-dialog-enter-active,\n.p-dialog-topright .p-dialog-leave-active,\n.p-dialog-bottomleft .p-dialog-enter-active,\n.p-dialog-bottomleft .p-dialog-leave-active,\n.p-dialog-bottomright .p-dialog-enter-active,\n.p-dialog-bottomright .p-dialog-leave-active {\n    transition: all 0.3s ease-out;\n}\n\n.p-dialog-top .p-dialog-enter-from,\n.p-dialog-top .p-dialog-leave-to {\n    transform: translate3d(0px, -100%, 0px);\n}\n\n.p-dialog-bottom .p-dialog-enter-from,\n.p-dialog-bottom .p-dialog-leave-to {\n    transform: translate3d(0px, 100%, 0px);\n}\n\n.p-dialog-left .p-dialog-enter-from,\n.p-dialog-left .p-dialog-leave-to,\n.p-dialog-topleft .p-dialog-enter-from,\n.p-dialog-topleft .p-dialog-leave-to,\n.p-dialog-bottomleft .p-dialog-enter-from,\n.p-dialog-bottomleft .p-dialog-leave-to {\n    transform: translate3d(-100%, 0px, 0px);\n}\n\n.p-dialog-right .p-dialog-enter-from,\n.p-dialog-right .p-dialog-leave-to,\n.p-dialog-topright .p-dialog-enter-from,\n.p-dialog-topright .p-dialog-leave-to,\n.p-dialog-bottomright .p-dialog-enter-from,\n.p-dialog-bottomright .p-dialog-leave-to {\n    transform: translate3d(100%, 0px, 0px);\n}\n\n.p-dialog-maximized {\n    width: 100vw !important;\n    height: 100vh !important;\n    top: 0px !important;\n    left: 0px !important;\n    max-height: 100%;\n    height: 100%;\n    border-radius: 0;\n}\n\n.p-dialog-maximized .p-dialog-content {\n    flex-grow: 1;\n}\n");
}, "theme");
var inlineStyles$1 = {
  mask: /* @__PURE__ */ __name(function mask(_ref2) {
    var position2 = _ref2.position, modal = _ref2.modal;
    return {
      position: "fixed",
      height: "100%",
      width: "100%",
      left: 0,
      top: 0,
      display: "flex",
      justifyContent: position2 === "left" || position2 === "topleft" || position2 === "bottomleft" ? "flex-start" : position2 === "right" || position2 === "topright" || position2 === "bottomright" ? "flex-end" : "center",
      alignItems: position2 === "top" || position2 === "topleft" || position2 === "topright" ? "flex-start" : position2 === "bottom" || position2 === "bottomleft" || position2 === "bottomright" ? "flex-end" : "center",
      pointerEvents: modal ? "auto" : "none"
    };
  }, "mask"),
  root: {
    display: "flex",
    flexDirection: "column",
    pointerEvents: "auto"
  }
};
var classes$b = {
  mask: /* @__PURE__ */ __name(function mask2(_ref3) {
    var props = _ref3.props;
    var positions = ["left", "right", "top", "topleft", "topright", "bottom", "bottomleft", "bottomright"];
    var pos2 = positions.find(function(item2) {
      return item2 === props.position;
    });
    return ["p-dialog-mask", {
      "p-overlay-mask p-overlay-mask-enter": props.modal
    }, pos2 ? "p-dialog-".concat(pos2) : ""];
  }, "mask"),
  root: /* @__PURE__ */ __name(function root18(_ref4) {
    var props = _ref4.props, instance = _ref4.instance;
    return ["p-dialog p-component", {
      "p-dialog-maximized": props.maximizable && instance.maximized
    }];
  }, "root"),
  header: "p-dialog-header",
  title: "p-dialog-title",
  headerActions: "p-dialog-header-actions",
  pcMaximizeButton: "p-dialog-maximize-button",
  pcCloseButton: "p-dialog-close-button",
  content: "p-dialog-content",
  footer: "p-dialog-footer"
};
var DialogStyle = BaseStyle.extend({
  name: "dialog",
  theme: theme$b,
  classes: classes$b,
  inlineStyles: inlineStyles$1
});
var script$1$b = {
  name: "BaseDialog",
  "extends": script$X,
  props: {
    header: {
      type: null,
      "default": null
    },
    footer: {
      type: null,
      "default": null
    },
    visible: {
      type: Boolean,
      "default": false
    },
    modal: {
      type: Boolean,
      "default": null
    },
    contentStyle: {
      type: null,
      "default": null
    },
    contentClass: {
      type: String,
      "default": null
    },
    contentProps: {
      type: null,
      "default": null
    },
    maximizable: {
      type: Boolean,
      "default": false
    },
    dismissableMask: {
      type: Boolean,
      "default": false
    },
    closable: {
      type: Boolean,
      "default": true
    },
    closeOnEscape: {
      type: Boolean,
      "default": true
    },
    showHeader: {
      type: Boolean,
      "default": true
    },
    blockScroll: {
      type: Boolean,
      "default": false
    },
    baseZIndex: {
      type: Number,
      "default": 0
    },
    autoZIndex: {
      type: Boolean,
      "default": true
    },
    position: {
      type: String,
      "default": "center"
    },
    breakpoints: {
      type: Object,
      "default": null
    },
    draggable: {
      type: Boolean,
      "default": true
    },
    keepInViewport: {
      type: Boolean,
      "default": true
    },
    minX: {
      type: Number,
      "default": 0
    },
    minY: {
      type: Number,
      "default": 0
    },
    appendTo: {
      type: [String, Object],
      "default": "body"
    },
    closeIcon: {
      type: String,
      "default": void 0
    },
    maximizeIcon: {
      type: String,
      "default": void 0
    },
    minimizeIcon: {
      type: String,
      "default": void 0
    },
    closeButtonProps: {
      type: Object,
      "default": /* @__PURE__ */ __name(function _default2() {
        return {
          severity: "secondary",
          text: true,
          rounded: true
        };
      }, "_default")
    },
    maximizeButtonProps: {
      type: Object,
      "default": /* @__PURE__ */ __name(function _default3() {
        return {
          severity: "secondary",
          text: true,
          rounded: true
        };
      }, "_default")
    },
    _instance: null
  },
  style: DialogStyle,
  provide: /* @__PURE__ */ __name(function provide28() {
    return {
      $pcDialog: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$k = {
  name: "Dialog",
  "extends": script$1$b,
  inheritAttrs: false,
  emits: ["update:visible", "show", "hide", "after-hide", "maximize", "unmaximize", "dragend"],
  provide: /* @__PURE__ */ __name(function provide29() {
    var _this = this;
    return {
      dialogRef: computed(function() {
        return _this._instance;
      })
    };
  }, "provide"),
  data: /* @__PURE__ */ __name(function data13() {
    return {
      id: this.$attrs.id,
      containerVisible: this.visible,
      maximized: false,
      focusableMax: null,
      focusableClose: null
    };
  }, "data"),
  watch: {
    "$attrs.id": /* @__PURE__ */ __name(function $attrsId6(newValue) {
      this.id = newValue || UniqueComponentId();
    }, "$attrsId")
  },
  documentKeydownListener: null,
  container: null,
  mask: null,
  content: null,
  headerContainer: null,
  footerContainer: null,
  maximizableButton: null,
  closeButton: null,
  styleElement: null,
  dragging: null,
  documentDragListener: null,
  documentDragEndListener: null,
  lastPageX: null,
  lastPageY: null,
  updated: /* @__PURE__ */ __name(function updated8() {
    if (this.visible) {
      this.containerVisible = this.visible;
    }
  }, "updated"),
  beforeUnmount: /* @__PURE__ */ __name(function beforeUnmount7() {
    this.unbindDocumentState();
    this.unbindGlobalListeners();
    this.destroyStyle();
    if (this.mask && this.autoZIndex) {
      ZIndex.clear(this.mask);
    }
    this.container = null;
    this.mask = null;
  }, "beforeUnmount"),
  mounted: /* @__PURE__ */ __name(function mounted12() {
    this.id = this.id || UniqueComponentId();
    if (this.breakpoints) {
      this.createStyle();
    }
  }, "mounted"),
  methods: {
    close: /* @__PURE__ */ __name(function close2() {
      this.$emit("update:visible", false);
    }, "close"),
    onBeforeEnter: /* @__PURE__ */ __name(function onBeforeEnter(el) {
      el.setAttribute(this.attributeSelector, "");
    }, "onBeforeEnter"),
    onEnter: /* @__PURE__ */ __name(function onEnter() {
      this.$emit("show");
      this.focus();
      this.enableDocumentSettings();
      this.bindGlobalListeners();
      if (this.autoZIndex) {
        ZIndex.set("modal", this.mask, this.baseZIndex + this.$primevue.config.zIndex.modal);
      }
    }, "onEnter"),
    onBeforeLeave: /* @__PURE__ */ __name(function onBeforeLeave() {
      if (this.modal) {
        !this.isUnstyled && addClass(this.mask, "p-overlay-mask-leave");
      }
    }, "onBeforeLeave"),
    onLeave: /* @__PURE__ */ __name(function onLeave() {
      this.$emit("hide");
      this.focusableClose = null;
      this.focusableMax = null;
    }, "onLeave"),
    onAfterLeave: /* @__PURE__ */ __name(function onAfterLeave() {
      if (this.autoZIndex) {
        ZIndex.clear(this.mask);
      }
      this.containerVisible = false;
      this.unbindDocumentState();
      this.unbindGlobalListeners();
      this.$emit("after-hide");
    }, "onAfterLeave"),
    onMaskClick: /* @__PURE__ */ __name(function onMaskClick(event2) {
      if (this.dismissableMask && this.modal && this.mask === event2.target) {
        this.close();
      }
    }, "onMaskClick"),
    focus: /* @__PURE__ */ __name(function focus$1() {
      var findFocusableElement = /* @__PURE__ */ __name(function findFocusableElement2(container) {
        return container && container.querySelector("[autofocus]");
      }, "findFocusableElement");
      var focusTarget = this.$slots.footer && findFocusableElement(this.footerContainer);
      if (!focusTarget) {
        focusTarget = this.$slots.header && findFocusableElement(this.headerContainer);
        if (!focusTarget) {
          focusTarget = this.$slots["default"] && findFocusableElement(this.content);
          if (!focusTarget) {
            if (this.maximizable) {
              this.focusableMax = true;
              focusTarget = this.maximizableButton;
            } else {
              this.focusableClose = true;
              focusTarget = this.closeButton;
            }
          }
        }
      }
      if (focusTarget) {
        focus(focusTarget, {
          focusVisible: true
        });
      }
    }, "focus$1"),
    maximize: /* @__PURE__ */ __name(function maximize(event2) {
      if (this.maximized) {
        this.maximized = false;
        this.$emit("unmaximize", event2);
      } else {
        this.maximized = true;
        this.$emit("maximize", event2);
      }
      if (!this.modal) {
        this.maximized ? blockBodyScroll() : unblockBodyScroll();
      }
    }, "maximize"),
    enableDocumentSettings: /* @__PURE__ */ __name(function enableDocumentSettings() {
      if (this.modal || !this.modal && this.blockScroll || this.maximizable && this.maximized) {
        blockBodyScroll();
      }
    }, "enableDocumentSettings"),
    unbindDocumentState: /* @__PURE__ */ __name(function unbindDocumentState() {
      if (this.modal || !this.modal && this.blockScroll || this.maximizable && this.maximized) {
        unblockBodyScroll();
      }
    }, "unbindDocumentState"),
    onKeyDown: /* @__PURE__ */ __name(function onKeyDown6(event2) {
      if (event2.code === "Escape" && this.closeOnEscape) {
        this.close();
      }
    }, "onKeyDown"),
    bindDocumentKeyDownListener: /* @__PURE__ */ __name(function bindDocumentKeyDownListener() {
      if (!this.documentKeydownListener) {
        this.documentKeydownListener = this.onKeyDown.bind(this);
        window.document.addEventListener("keydown", this.documentKeydownListener);
      }
    }, "bindDocumentKeyDownListener"),
    unbindDocumentKeyDownListener: /* @__PURE__ */ __name(function unbindDocumentKeyDownListener() {
      if (this.documentKeydownListener) {
        window.document.removeEventListener("keydown", this.documentKeydownListener);
        this.documentKeydownListener = null;
      }
    }, "unbindDocumentKeyDownListener"),
    containerRef: /* @__PURE__ */ __name(function containerRef(el) {
      this.container = el;
    }, "containerRef"),
    maskRef: /* @__PURE__ */ __name(function maskRef(el) {
      this.mask = el;
    }, "maskRef"),
    contentRef: /* @__PURE__ */ __name(function contentRef2(el) {
      this.content = el;
    }, "contentRef"),
    headerContainerRef: /* @__PURE__ */ __name(function headerContainerRef(el) {
      this.headerContainer = el;
    }, "headerContainerRef"),
    footerContainerRef: /* @__PURE__ */ __name(function footerContainerRef(el) {
      this.footerContainer = el;
    }, "footerContainerRef"),
    maximizableRef: /* @__PURE__ */ __name(function maximizableRef(el) {
      this.maximizableButton = el ? el.$el : void 0;
    }, "maximizableRef"),
    closeButtonRef: /* @__PURE__ */ __name(function closeButtonRef(el) {
      this.closeButton = el ? el.$el : void 0;
    }, "closeButtonRef"),
    createStyle: /* @__PURE__ */ __name(function createStyle() {
      if (!this.styleElement && !this.isUnstyled) {
        var _this$$primevue;
        this.styleElement = document.createElement("style");
        this.styleElement.type = "text/css";
        setAttribute(this.styleElement, "nonce", (_this$$primevue = this.$primevue) === null || _this$$primevue === void 0 || (_this$$primevue = _this$$primevue.config) === null || _this$$primevue === void 0 || (_this$$primevue = _this$$primevue.csp) === null || _this$$primevue === void 0 ? void 0 : _this$$primevue.nonce);
        document.head.appendChild(this.styleElement);
        var innerHTML = "";
        for (var breakpoint in this.breakpoints) {
          innerHTML += "\n                        @media screen and (max-width: ".concat(breakpoint, ") {\n                            .p-dialog[").concat(this.attributeSelector, "] {\n                                width: ").concat(this.breakpoints[breakpoint], " !important;\n                            }\n                        }\n                    ");
        }
        this.styleElement.innerHTML = innerHTML;
      }
    }, "createStyle"),
    destroyStyle: /* @__PURE__ */ __name(function destroyStyle() {
      if (this.styleElement) {
        document.head.removeChild(this.styleElement);
        this.styleElement = null;
      }
    }, "destroyStyle"),
    initDrag: /* @__PURE__ */ __name(function initDrag(event2) {
      if (event2.target.closest("div").getAttribute("data-pc-section") === "headeractions") {
        return;
      }
      if (this.draggable) {
        this.dragging = true;
        this.lastPageX = event2.pageX;
        this.lastPageY = event2.pageY;
        this.container.style.margin = "0";
        document.body.setAttribute("data-p-unselectable-text", "true");
        !this.isUnstyled && addStyle(document.body, {
          "user-select": "none"
        });
      }
    }, "initDrag"),
    bindGlobalListeners: /* @__PURE__ */ __name(function bindGlobalListeners() {
      if (this.draggable) {
        this.bindDocumentDragListener();
        this.bindDocumentDragEndListener();
      }
      if (this.closeOnEscape && this.closable) {
        this.bindDocumentKeyDownListener();
      }
    }, "bindGlobalListeners"),
    unbindGlobalListeners: /* @__PURE__ */ __name(function unbindGlobalListeners() {
      this.unbindDocumentDragListener();
      this.unbindDocumentDragEndListener();
      this.unbindDocumentKeyDownListener();
    }, "unbindGlobalListeners"),
    bindDocumentDragListener: /* @__PURE__ */ __name(function bindDocumentDragListener() {
      var _this2 = this;
      this.documentDragListener = function(event2) {
        if (_this2.dragging) {
          var width2 = getOuterWidth(_this2.container);
          var height = getOuterHeight(_this2.container);
          var deltaX = event2.pageX - _this2.lastPageX;
          var deltaY = event2.pageY - _this2.lastPageY;
          var offset = _this2.container.getBoundingClientRect();
          var leftPos = offset.left + deltaX;
          var topPos = offset.top + deltaY;
          var viewport = getViewport();
          var containerComputedStyle = getComputedStyle(_this2.container);
          var marginLeft = parseFloat(containerComputedStyle.marginLeft);
          var marginTop = parseFloat(containerComputedStyle.marginTop);
          _this2.container.style.position = "fixed";
          if (_this2.keepInViewport) {
            if (leftPos >= _this2.minX && leftPos + width2 < viewport.width) {
              _this2.lastPageX = event2.pageX;
              _this2.container.style.left = leftPos - marginLeft + "px";
            }
            if (topPos >= _this2.minY && topPos + height < viewport.height) {
              _this2.lastPageY = event2.pageY;
              _this2.container.style.top = topPos - marginTop + "px";
            }
          } else {
            _this2.lastPageX = event2.pageX;
            _this2.container.style.left = leftPos - marginLeft + "px";
            _this2.lastPageY = event2.pageY;
            _this2.container.style.top = topPos - marginTop + "px";
          }
        }
      };
      window.document.addEventListener("mousemove", this.documentDragListener);
    }, "bindDocumentDragListener"),
    unbindDocumentDragListener: /* @__PURE__ */ __name(function unbindDocumentDragListener() {
      if (this.documentDragListener) {
        window.document.removeEventListener("mousemove", this.documentDragListener);
        this.documentDragListener = null;
      }
    }, "unbindDocumentDragListener"),
    bindDocumentDragEndListener: /* @__PURE__ */ __name(function bindDocumentDragEndListener() {
      var _this3 = this;
      this.documentDragEndListener = function(event2) {
        if (_this3.dragging) {
          _this3.dragging = false;
          document.body.removeAttribute("data-p-unselectable-text");
          !_this3.isUnstyled && (document.body.style["user-select"] = "");
          _this3.$emit("dragend", event2);
        }
      };
      window.document.addEventListener("mouseup", this.documentDragEndListener);
    }, "bindDocumentDragEndListener"),
    unbindDocumentDragEndListener: /* @__PURE__ */ __name(function unbindDocumentDragEndListener() {
      if (this.documentDragEndListener) {
        window.document.removeEventListener("mouseup", this.documentDragEndListener);
        this.documentDragEndListener = null;
      }
    }, "unbindDocumentDragEndListener")
  },
  computed: {
    maximizeIconComponent: /* @__PURE__ */ __name(function maximizeIconComponent() {
      return this.maximized ? this.minimizeIcon ? "span" : "WindowMinimizeIcon" : this.maximizeIcon ? "span" : "WindowMaximizeIcon";
    }, "maximizeIconComponent"),
    ariaLabelledById: /* @__PURE__ */ __name(function ariaLabelledById() {
      return this.header != null || this.$attrs["aria-labelledby"] !== null ? this.id + "_header" : null;
    }, "ariaLabelledById"),
    closeAriaLabel: /* @__PURE__ */ __name(function closeAriaLabel() {
      return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.close : void 0;
    }, "closeAriaLabel"),
    attributeSelector: /* @__PURE__ */ __name(function attributeSelector() {
      return UniqueComponentId();
    }, "attributeSelector")
  },
  directives: {
    ripple: Ripple,
    focustrap: FocusTrap
  },
  components: {
    Button: script$J,
    Portal: script$z,
    WindowMinimizeIcon: script$l,
    WindowMaximizeIcon: script$m,
    TimesIcon: script$A
  }
};
function _typeof$6(o) {
  "@babel/helpers - typeof";
  return _typeof$6 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$6(o);
}
__name(_typeof$6, "_typeof$6");
function ownKeys$7(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
__name(ownKeys$7, "ownKeys$7");
function _objectSpread$7(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$7(Object(t), true).forEach(function(r2) {
      _defineProperty$6(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$7(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
__name(_objectSpread$7, "_objectSpread$7");
function _defineProperty$6(e, r, t) {
  return (r = _toPropertyKey$5(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty$6, "_defineProperty$6");
function _toPropertyKey$5(t) {
  var i2 = _toPrimitive$5(t, "string");
  return "symbol" == _typeof$6(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$5, "_toPropertyKey$5");
function _toPrimitive$5(t, r) {
  if ("object" != _typeof$6(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$6(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive$5, "_toPrimitive$5");
var _hoisted_1$u = ["aria-labelledby", "aria-modal"];
var _hoisted_2$l = ["id"];
function render$j(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_Button = resolveComponent("Button");
  var _component_Portal = resolveComponent("Portal");
  var _directive_focustrap = resolveDirective("focustrap");
  return openBlock(), createBlock(_component_Portal, {
    appendTo: _ctx.appendTo
  }, {
    "default": withCtx(function() {
      return [$data.containerVisible ? (openBlock(), createElementBlock("div", mergeProps({
        key: 0,
        ref: $options.maskRef,
        "class": _ctx.cx("mask"),
        style: _ctx.sx("mask", true, {
          position: _ctx.position,
          modal: _ctx.modal
        }),
        onClick: _cache[1] || (_cache[1] = function() {
          return $options.onMaskClick && $options.onMaskClick.apply($options, arguments);
        })
      }, _ctx.ptm("mask")), [createVNode(Transition, mergeProps({
        name: "p-dialog",
        onBeforeEnter: $options.onBeforeEnter,
        onEnter: $options.onEnter,
        onBeforeLeave: $options.onBeforeLeave,
        onLeave: $options.onLeave,
        onAfterLeave: $options.onAfterLeave,
        appear: ""
      }, _ctx.ptm("transition")), {
        "default": withCtx(function() {
          return [_ctx.visible ? withDirectives((openBlock(), createElementBlock("div", mergeProps({
            key: 0,
            ref: $options.containerRef,
            "class": _ctx.cx("root"),
            style: _ctx.sx("root"),
            role: "dialog",
            "aria-labelledby": $options.ariaLabelledById,
            "aria-modal": _ctx.modal
          }, _ctx.ptmi("root")), [_ctx.$slots.container ? renderSlot(_ctx.$slots, "container", {
            key: 0,
            closeCallback: $options.close,
            maximizeCallback: /* @__PURE__ */ __name(function maximizeCallback(event2) {
              return $options.maximize(event2);
            }, "maximizeCallback")
          }) : (openBlock(), createElementBlock(Fragment, {
            key: 1
          }, [_ctx.showHeader ? (openBlock(), createElementBlock("div", mergeProps({
            key: 0,
            ref: $options.headerContainerRef,
            "class": _ctx.cx("header"),
            onMousedown: _cache[0] || (_cache[0] = function() {
              return $options.initDrag && $options.initDrag.apply($options, arguments);
            })
          }, _ctx.ptm("header")), [renderSlot(_ctx.$slots, "header", {
            "class": normalizeClass(_ctx.cx("title"))
          }, function() {
            return [_ctx.header ? (openBlock(), createElementBlock("span", mergeProps({
              key: 0,
              id: $options.ariaLabelledById,
              "class": _ctx.cx("title")
            }, _ctx.ptm("title")), toDisplayString$1(_ctx.header), 17, _hoisted_2$l)) : createCommentVNode("", true)];
          }), createBaseVNode("div", mergeProps({
            "class": _ctx.cx("headerActions")
          }, _ctx.ptm("headerActions")), [_ctx.maximizable ? (openBlock(), createBlock(_component_Button, mergeProps({
            key: 0,
            ref: $options.maximizableRef,
            autofocus: $data.focusableMax,
            "class": _ctx.cx("pcMaximizeButton"),
            onClick: $options.maximize,
            tabindex: _ctx.maximizable ? "0" : "-1",
            unstyled: _ctx.unstyled
          }, _ctx.maximizeButtonProps, {
            pt: _ctx.ptm("pcMaximizeButton"),
            "data-pc-group-section": "headericon"
          }), {
            icon: withCtx(function(slotProps) {
              return [renderSlot(_ctx.$slots, "maximizeicon", {
                maximized: $data.maximized
              }, function() {
                return [(openBlock(), createBlock(resolveDynamicComponent($options.maximizeIconComponent), mergeProps({
                  "class": [slotProps["class"], $data.maximized ? _ctx.minimizeIcon : _ctx.maximizeIcon]
                }, _ctx.ptm("pcMaximizeButton")["icon"]), null, 16, ["class"]))];
              })];
            }),
            _: 3
          }, 16, ["autofocus", "class", "onClick", "tabindex", "unstyled", "pt"])) : createCommentVNode("", true), _ctx.closable ? (openBlock(), createBlock(_component_Button, mergeProps({
            key: 1,
            ref: $options.closeButtonRef,
            autofocus: $data.focusableClose,
            "class": _ctx.cx("pcCloseButton"),
            onClick: $options.close,
            "aria-label": $options.closeAriaLabel,
            unstyled: _ctx.unstyled
          }, _ctx.closeButtonProps, {
            pt: _ctx.ptm("pcCloseButton"),
            "data-pc-group-section": "headericon"
          }), {
            icon: withCtx(function(slotProps) {
              return [renderSlot(_ctx.$slots, "closeicon", {}, function() {
                return [(openBlock(), createBlock(resolveDynamicComponent(_ctx.closeIcon ? "span" : "TimesIcon"), mergeProps({
                  "class": [_ctx.closeIcon, slotProps["class"]]
                }, _ctx.ptm("pcCloseButton")["icon"]), null, 16, ["class"]))];
              })];
            }),
            _: 3
          }, 16, ["autofocus", "class", "onClick", "aria-label", "unstyled", "pt"])) : createCommentVNode("", true)], 16)], 16)) : createCommentVNode("", true), createBaseVNode("div", mergeProps({
            ref: $options.contentRef,
            "class": [_ctx.cx("content"), _ctx.contentClass],
            style: _ctx.contentStyle
          }, _objectSpread$7(_objectSpread$7({}, _ctx.contentProps), _ctx.ptm("content"))), [renderSlot(_ctx.$slots, "default")], 16), _ctx.footer || _ctx.$slots.footer ? (openBlock(), createElementBlock("div", mergeProps({
            key: 1,
            ref: $options.footerContainerRef,
            "class": _ctx.cx("footer")
          }, _ctx.ptm("footer")), [renderSlot(_ctx.$slots, "footer", {}, function() {
            return [createTextVNode(toDisplayString$1(_ctx.footer), 1)];
          })], 16)) : createCommentVNode("", true)], 64))], 16, _hoisted_1$u)), [[_directive_focustrap, {
            disabled: !_ctx.modal
          }]]) : createCommentVNode("", true)];
        }),
        _: 3
      }, 16, ["onBeforeEnter", "onEnter", "onBeforeLeave", "onLeave", "onAfterLeave"])], 16)) : createCommentVNode("", true)];
    }),
    _: 3
  }, 8, ["appendTo"]);
}
__name(render$j, "render$j");
script$k.render = render$j;
var theme$a = /* @__PURE__ */ __name(function theme27(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-togglebutton {\n    display: inline-flex;\n    cursor: pointer;\n    user-select: none;\n    align-items: center;\n    justify-content: center;\n    overflow: hidden;\n    position: relative;\n    color: ".concat(dt3("togglebutton.color"), ";\n    background: ").concat(dt3("togglebutton.background"), ";\n    border: 1px solid ").concat(dt3("togglebutton.border.color"), ";\n    padding: ").concat(dt3("togglebutton.padding"), ";\n    font-size: 1rem;\n    font-family: inherit;\n    font-feature-settings: inherit;\n    transition: background ").concat(dt3("togglebutton.transition.duration"), ", color ").concat(dt3("togglebutton.transition.duration"), ", border-color ").concat(dt3("togglebutton.transition.duration"), ",\n        outline-color ").concat(dt3("togglebutton.transition.duration"), ", box-shadow ").concat(dt3("togglebutton.transition.duration"), ";\n    border-radius: ").concat(dt3("togglebutton.border.radius"), ";\n    outline-color: transparent;\n    font-weight: ").concat(dt3("togglebutton.font.weight"), ";\n}\n\n.p-togglebutton-content {\n    position: relative;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    gap: ").concat(dt3("togglebutton.gap"), ';\n}\n\n.p-togglebutton-label,\n.p-togglebutton-icon {\n    position: relative;\n    transition: none;\n}\n\n.p-togglebutton::before {\n    content: "";\n    background: transparent;\n    transition: background ').concat(dt3("togglebutton.transition.duration"), ", color ").concat(dt3("togglebutton.transition.duration"), ", border-color ").concat(dt3("togglebutton.transition.duration"), ",\n            outline-color ").concat(dt3("togglebutton.transition.duration"), ", box-shadow ").concat(dt3("togglebutton.transition.duration"), ";\n    position: absolute;\n    left: ").concat(dt3("togglebutton.content.left"), ";\n    top: ").concat(dt3("togglebutton.content.top"), ";\n    width: calc(100% - calc(2 *  ").concat(dt3("togglebutton.content.left"), "));\n    height: calc(100% - calc(2 *  ").concat(dt3("togglebutton.content.top"), "));\n    border-radius: ").concat(dt3("togglebutton.border.radius"), ";\n}\n\n.p-togglebutton.p-togglebutton-checked::before {\n    background: ").concat(dt3("togglebutton.content.checked.background"), ";\n    box-shadow: ").concat(dt3("togglebutton.content.checked.shadow"), ";\n}\n\n.p-togglebutton:not(:disabled):not(.p-togglebutton-checked):hover {\n    background: ").concat(dt3("togglebutton.hover.background"), ";\n    color: ").concat(dt3("togglebutton.hover.color"), ";\n}\n\n.p-togglebutton.p-togglebutton-checked {\n    background: ").concat(dt3("togglebutton.checked.background"), ";\n    border-color: ").concat(dt3("togglebutton.checked.border.color"), ";\n    color: ").concat(dt3("togglebutton.checked.color"), ";\n}\n\n.p-togglebutton:focus-visible {\n    box-shadow: ").concat(dt3("togglebutton.focus.ring.shadow"), ";\n    outline: ").concat(dt3("togglebutton.focus.ring.width"), " ").concat(dt3("togglebutton.focus.ring.style"), " ").concat(dt3("togglebutton.focus.ring.color"), ";\n    outline-offset: ").concat(dt3("togglebutton.focus.ring.offset"), ";\n}\n\n.p-togglebutton.p-invalid {\n    border-color: ").concat(dt3("togglebutton.invalid.border.color"), ";\n}\n\n.p-togglebutton:disabled {\n    opacity: 1;\n    cursor: default;\n    background: ").concat(dt3("togglebutton.disabled.background"), ";\n    border-color: ").concat(dt3("togglebutton.disabled.border.color"), ";\n    color: ").concat(dt3("togglebutton.disabled.color"), ";\n}\n\n.p-togglebutton-icon {\n    color: ").concat(dt3("togglebutton.icon.color"), ";\n}\n\n.p-togglebutton:not(:disabled):not(.p-togglebutton-checked):hover .p-togglebutton-icon {\n    color: ").concat(dt3("togglebutton.icon.hover.color"), ";\n}\n\n.p-togglebutton.p-togglebutton-checked .p-togglebutton-icon {\n    color: ").concat(dt3("togglebutton.icon.checked.color"), ";\n}\n\n.p-togglebutton:disabled .p-togglebutton-icon {\n    color: ").concat(dt3("togglebutton.icon.disabled.color"), ";\n}\n");
}, "theme");
var classes$a = {
  root: /* @__PURE__ */ __name(function root19(_ref2) {
    var instance = _ref2.instance, props = _ref2.props;
    return ["p-togglebutton p-component", {
      "p-togglebutton-checked": instance.active,
      "p-invalid": props.invalid
    }];
  }, "root"),
  content: "p-togglebutton-content",
  icon: "p-togglebutton-icon",
  label: "p-togglebutton-label"
};
var ToggleButtonStyle = BaseStyle.extend({
  name: "togglebutton",
  theme: theme$a,
  classes: classes$a
});
var script$1$a = {
  name: "BaseToggleButton",
  "extends": script$X,
  props: {
    modelValue: Boolean,
    onIcon: String,
    offIcon: String,
    onLabel: {
      type: String,
      "default": "Yes"
    },
    offLabel: {
      type: String,
      "default": "No"
    },
    iconPos: {
      type: String,
      "default": "left"
    },
    invalid: {
      type: Boolean,
      "default": false
    },
    disabled: {
      type: Boolean,
      "default": false
    },
    readonly: {
      type: Boolean,
      "default": false
    },
    tabindex: {
      type: Number,
      "default": null
    },
    ariaLabelledby: {
      type: String,
      "default": null
    },
    ariaLabel: {
      type: String,
      "default": null
    }
  },
  style: ToggleButtonStyle,
  provide: /* @__PURE__ */ __name(function provide30() {
    return {
      $pcToggleButton: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$j = {
  name: "ToggleButton",
  "extends": script$1$a,
  inheritAttrs: false,
  emits: ["update:modelValue", "change"],
  methods: {
    getPTOptions: /* @__PURE__ */ __name(function getPTOptions8(key) {
      var _ptm = key === "root" ? this.ptmi : this.ptm;
      return _ptm(key, {
        context: {
          active: this.active,
          disabled: this.disabled
        }
      });
    }, "getPTOptions"),
    onChange: /* @__PURE__ */ __name(function onChange3(event2) {
      if (!this.disabled && !this.readonly) {
        this.$emit("update:modelValue", !this.modelValue);
        this.$emit("change", event2);
      }
    }, "onChange")
  },
  computed: {
    active: /* @__PURE__ */ __name(function active2() {
      return this.modelValue === true;
    }, "active"),
    hasLabel: /* @__PURE__ */ __name(function hasLabel() {
      return isNotEmpty(this.onLabel) && isNotEmpty(this.offLabel);
    }, "hasLabel"),
    label: /* @__PURE__ */ __name(function label3() {
      return this.hasLabel ? this.modelValue ? this.onLabel : this.offLabel : "&nbsp;";
    }, "label")
  },
  directives: {
    ripple: Ripple
  }
};
var _hoisted_1$t = ["tabindex", "disabled", "aria-pressed", "data-p-checked", "data-p-disabled"];
function render$i(_ctx, _cache, $props, $setup, $data, $options) {
  var _directive_ripple = resolveDirective("ripple");
  return withDirectives((openBlock(), createElementBlock("button", mergeProps({
    type: "button",
    "class": _ctx.cx("root"),
    tabindex: _ctx.tabindex,
    disabled: _ctx.disabled,
    "aria-pressed": _ctx.modelValue,
    onClick: _cache[0] || (_cache[0] = function() {
      return $options.onChange && $options.onChange.apply($options, arguments);
    })
  }, $options.getPTOptions("root"), {
    "data-p-checked": $options.active,
    "data-p-disabled": _ctx.disabled
  }), [createBaseVNode("span", mergeProps({
    "class": _ctx.cx("content")
  }, $options.getPTOptions("content")), [renderSlot(_ctx.$slots, "default", {}, function() {
    return [renderSlot(_ctx.$slots, "icon", {
      value: _ctx.modelValue,
      "class": normalizeClass(_ctx.cx("icon"))
    }, function() {
      return [_ctx.onIcon || _ctx.offIcon ? (openBlock(), createElementBlock("span", mergeProps({
        key: 0,
        "class": [_ctx.cx("icon"), _ctx.modelValue ? _ctx.onIcon : _ctx.offIcon]
      }, $options.getPTOptions("icon")), null, 16)) : createCommentVNode("", true)];
    }), createBaseVNode("span", mergeProps({
      "class": _ctx.cx("label")
    }, $options.getPTOptions("label")), toDisplayString$1($options.label), 17)];
  })], 16)], 16, _hoisted_1$t)), [[_directive_ripple]]);
}
__name(render$i, "render$i");
script$j.render = render$i;
var theme$9 = /* @__PURE__ */ __name(function theme28(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-selectbutton {\n    display: inline-flex;\n    user-select: none;\n    vertical-align: bottom;\n    outline-color: transparent;\n    border-radius: ".concat(dt3("selectbutton.border.radius"), ";\n}\n\n.p-selectbutton .p-togglebutton {\n    border-radius: 0;\n    border-width: 1px 1px 1px 0;\n}\n\n.p-selectbutton .p-togglebutton:focus-visible {\n    position: relative;\n    z-index: 1;\n}\n\n.p-selectbutton .p-togglebutton:first-child {\n    border-left-width: 1px;\n    border-top-left-radius: ").concat(dt3("selectbutton.border.radius"), ";\n    border-bottom-left-radius: ").concat(dt3("selectbutton.border.radius"), ";\n}\n\n.p-selectbutton .p-togglebutton:last-child {\n    border-top-right-radius: ").concat(dt3("selectbutton.border.radius"), ";\n    border-bottom-right-radius: ").concat(dt3("selectbutton.border.radius"), ";\n}\n\n.p-selectbutton.p-invalid {\n    outline: 1px solid ").concat(dt3("selectbutton.invalid.border.color"), ";\n    outline-offset: 0;\n}\n");
}, "theme");
var classes$9 = {
  root: /* @__PURE__ */ __name(function root20(_ref2) {
    var props = _ref2.props;
    return ["p-selectbutton p-component", {
      "p-invalid": props.invalid
    }];
  }, "root")
};
var SelectButtonStyle = BaseStyle.extend({
  name: "selectbutton",
  theme: theme$9,
  classes: classes$9
});
var script$1$9 = {
  name: "BaseSelectButton",
  "extends": script$X,
  props: {
    modelValue: null,
    options: Array,
    optionLabel: null,
    optionValue: null,
    optionDisabled: null,
    multiple: Boolean,
    allowEmpty: {
      type: Boolean,
      "default": true
    },
    invalid: {
      type: Boolean,
      "default": false
    },
    disabled: Boolean,
    dataKey: null,
    ariaLabelledby: {
      type: String,
      "default": null
    }
  },
  style: SelectButtonStyle,
  provide: /* @__PURE__ */ __name(function provide31() {
    return {
      $pcSelectButton: this,
      $parentInstance: this
    };
  }, "provide")
};
function _createForOfIteratorHelper$4(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (!t) {
    if (Array.isArray(r) || (t = _unsupportedIterableToArray$8(r)) || e) {
      t && (r = t);
      var _n = 0, F = /* @__PURE__ */ __name(function F2() {
      }, "F");
      return { s: F, n: /* @__PURE__ */ __name(function n() {
        return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
      }, "n"), e: /* @__PURE__ */ __name(function e2(r2) {
        throw r2;
      }, "e"), f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o, a = true, u = false;
  return { s: /* @__PURE__ */ __name(function s() {
    t = t.call(r);
  }, "s"), n: /* @__PURE__ */ __name(function n() {
    var r2 = t.next();
    return a = r2.done, r2;
  }, "n"), e: /* @__PURE__ */ __name(function e2(r2) {
    u = true, o = r2;
  }, "e"), f: /* @__PURE__ */ __name(function f() {
    try {
      a || null == t["return"] || t["return"]();
    } finally {
      if (u) throw o;
    }
  }, "f") };
}
__name(_createForOfIteratorHelper$4, "_createForOfIteratorHelper$4");
function _toConsumableArray$6(r) {
  return _arrayWithoutHoles$6(r) || _iterableToArray$6(r) || _unsupportedIterableToArray$8(r) || _nonIterableSpread$6();
}
__name(_toConsumableArray$6, "_toConsumableArray$6");
function _nonIterableSpread$6() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableSpread$6, "_nonIterableSpread$6");
function _unsupportedIterableToArray$8(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$8(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$8(r, a) : void 0;
  }
}
__name(_unsupportedIterableToArray$8, "_unsupportedIterableToArray$8");
function _iterableToArray$6(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
__name(_iterableToArray$6, "_iterableToArray$6");
function _arrayWithoutHoles$6(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$8(r);
}
__name(_arrayWithoutHoles$6, "_arrayWithoutHoles$6");
function _arrayLikeToArray$8(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
__name(_arrayLikeToArray$8, "_arrayLikeToArray$8");
var script$i = {
  name: "SelectButton",
  "extends": script$1$9,
  inheritAttrs: false,
  emits: ["update:modelValue", "change"],
  methods: {
    getOptionLabel: /* @__PURE__ */ __name(function getOptionLabel4(option4) {
      return this.optionLabel ? resolveFieldData(option4, this.optionLabel) : option4;
    }, "getOptionLabel"),
    getOptionValue: /* @__PURE__ */ __name(function getOptionValue5(option4) {
      return this.optionValue ? resolveFieldData(option4, this.optionValue) : option4;
    }, "getOptionValue"),
    getOptionRenderKey: /* @__PURE__ */ __name(function getOptionRenderKey4(option4) {
      return this.dataKey ? resolveFieldData(option4, this.dataKey) : this.getOptionLabel(option4);
    }, "getOptionRenderKey"),
    getPTOptions: /* @__PURE__ */ __name(function getPTOptions9(option4, key) {
      return this.ptm(key, {
        context: {
          active: this.isSelected(option4),
          disabled: this.isOptionDisabled(option4),
          option: option4
        }
      });
    }, "getPTOptions"),
    isOptionDisabled: /* @__PURE__ */ __name(function isOptionDisabled4(option4) {
      return this.optionDisabled ? resolveFieldData(option4, this.optionDisabled) : false;
    }, "isOptionDisabled"),
    onOptionSelect: /* @__PURE__ */ __name(function onOptionSelect4(event2, option4, index2) {
      var _this = this;
      if (this.disabled || this.isOptionDisabled(option4)) {
        return;
      }
      var selected2 = this.isSelected(option4);
      if (selected2 && !this.allowEmpty) {
        return;
      }
      var optionValue = this.getOptionValue(option4);
      var newValue;
      if (this.multiple) {
        if (selected2) newValue = this.modelValue.filter(function(val) {
          return !equals(val, optionValue, _this.equalityKey);
        });
        else newValue = this.modelValue ? [].concat(_toConsumableArray$6(this.modelValue), [optionValue]) : [optionValue];
      } else {
        newValue = selected2 ? null : optionValue;
      }
      this.focusedIndex = index2;
      this.$emit("update:modelValue", newValue);
      this.$emit("change", {
        event: event2,
        value: newValue
      });
    }, "onOptionSelect"),
    isSelected: /* @__PURE__ */ __name(function isSelected4(option4) {
      var selected2 = false;
      var optionValue = this.getOptionValue(option4);
      if (this.multiple) {
        if (this.modelValue) {
          var _iterator = _createForOfIteratorHelper$4(this.modelValue), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var val = _step.value;
              if (equals(val, optionValue, this.equalityKey)) {
                selected2 = true;
                break;
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
      } else {
        selected2 = equals(this.modelValue, optionValue, this.equalityKey);
      }
      return selected2;
    }, "isSelected")
  },
  computed: {
    equalityKey: /* @__PURE__ */ __name(function equalityKey4() {
      return this.optionValue ? null : this.dataKey;
    }, "equalityKey")
  },
  directives: {
    ripple: Ripple
  },
  components: {
    ToggleButton: script$j
  }
};
var _hoisted_1$s = ["aria-labelledby"];
function render$h(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_ToggleButton = resolveComponent("ToggleButton");
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("root"),
    role: "group",
    "aria-labelledby": _ctx.ariaLabelledby
  }, _ctx.ptmi("root")), [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.options, function(option4, index2) {
    return openBlock(), createBlock(_component_ToggleButton, {
      key: $options.getOptionRenderKey(option4),
      modelValue: $options.isSelected(option4),
      onLabel: $options.getOptionLabel(option4),
      offLabel: $options.getOptionLabel(option4),
      disabled: _ctx.disabled || $options.isOptionDisabled(option4),
      unstyled: _ctx.unstyled,
      onChange: /* @__PURE__ */ __name(function onChange5($event) {
        return $options.onOptionSelect($event, option4, index2);
      }, "onChange"),
      pt: _ctx.ptm("pcButton")
    }, createSlots({
      _: 2
    }, [_ctx.$slots.option ? {
      name: "default",
      fn: withCtx(function() {
        return [renderSlot(_ctx.$slots, "option", {
          option: option4,
          index: index2
        }, function() {
          return [createBaseVNode("span", mergeProps({
            ref_for: true
          }, _ctx.ptm("pcButton")["label"]), toDisplayString$1($options.getOptionLabel(option4)), 17)];
        })];
      }),
      key: "0"
    } : void 0]), 1032, ["modelValue", "onLabel", "offLabel", "disabled", "unstyled", "onChange", "pt"]);
  }), 128))], 16, _hoisted_1$s);
}
__name(render$h, "render$h");
script$i.render = render$h;
const _withScopeId$a = /* @__PURE__ */ __name((n) => (pushScopeId("data-v-def4f809"), n = n(), popScopeId(), n), "_withScopeId$a");
const _hoisted_1$r = { class: "_content" };
const _hoisted_2$k = { class: "_footer" };
const _sfc_main$n = /* @__PURE__ */ defineComponent({
  __name: "NodeSearchFilter",
  emits: ["addFilter"],
  setup(__props, { emit: __emit }) {
    const filters = computed(() => nodeDefStore.nodeSearchService.nodeFilters);
    const selectedFilter = ref();
    const filterValues = computed(() => selectedFilter.value?.fuseSearch.data ?? []);
    const selectedFilterValue = ref("");
    const nodeDefStore = useNodeDefStore();
    onMounted(() => {
      selectedFilter.value = nodeDefStore.nodeSearchService.nodeFilters[0];
      updateSelectedFilterValue();
    });
    const emit2 = __emit;
    const updateSelectedFilterValue = /* @__PURE__ */ __name(() => {
      if (filterValues.value.includes(selectedFilterValue.value)) {
        return;
      }
      selectedFilterValue.value = filterValues.value[0];
    }, "updateSelectedFilterValue");
    const submit = /* @__PURE__ */ __name(() => {
      emit2("addFilter", [
        selectedFilter.value,
        selectedFilterValue.value
      ]);
    }, "submit");
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        createBaseVNode("div", _hoisted_1$r, [
          createVNode(unref(script$i), {
            modelValue: selectedFilter.value,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => selectedFilter.value = $event),
            options: filters.value,
            allowEmpty: false,
            optionLabel: "name",
            onChange: updateSelectedFilterValue
          }, null, 8, ["modelValue", "options"]),
          createVNode(unref(script$y), {
            modelValue: selectedFilterValue.value,
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => selectedFilterValue.value = $event),
            options: filterValues.value,
            filter: ""
          }, null, 8, ["modelValue", "options"])
        ]),
        createBaseVNode("div", _hoisted_2$k, [
          createVNode(unref(script$J), {
            type: "button",
            label: _ctx.$t("add"),
            onClick: submit
          }, null, 8, ["label"])
        ])
      ], 64);
    };
  }
});
const NodeSearchFilter = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["__scopeId", "data-v-def4f809"]]);
const _sfc_main$m = /* @__PURE__ */ defineComponent({
  __name: "NodeSourceChip",
  props: {
    python_module: {
      type: String,
      required: true
    }
  },
  setup(__props) {
    const props = __props;
    const nodeSource = computed(() => getNodeSource(props.python_module));
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(script$t), {
        class: normalizeClass(nodeSource.value.className)
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString$1(nodeSource.value.displayText), 1)
        ]),
        _: 1
      }, 8, ["class"]);
    };
  }
});
const NodeSourceChip = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["__scopeId", "data-v-b0730aa8"]]);
const _withScopeId$9 = /* @__PURE__ */ __name((n) => (pushScopeId("data-v-cbec679a"), n = n(), popScopeId(), n), "_withScopeId$9");
const _hoisted_1$q = { class: "_sb_node_preview" };
const _hoisted_2$j = { class: "_sb_table" };
const _hoisted_3$b = { class: "node_header" };
const _hoisted_4$7 = /* @__PURE__ */ _withScopeId$9(() => /* @__PURE__ */ createBaseVNode("div", { class: "_sb_dot headdot" }, null, -1));
const _hoisted_5$5 = /* @__PURE__ */ _withScopeId$9(() => /* @__PURE__ */ createBaseVNode("div", { class: "_sb_preview_badge" }, "PREVIEW", -1));
const _hoisted_6$4 = { class: "_sb_col" };
const _hoisted_7$3 = { class: "_sb_col" };
const _hoisted_8$2 = /* @__PURE__ */ _withScopeId$9(() => /* @__PURE__ */ createBaseVNode("div", { class: "_sb_col middle-column" }, null, -1));
const _hoisted_9$2 = { class: "_sb_col _sb_inherit" };
const _hoisted_10$2 = { class: "_sb_col" };
const _hoisted_11$2 = /* @__PURE__ */ _withScopeId$9(() => /* @__PURE__ */ createBaseVNode("div", { class: "_sb_col _sb_arrow" }, "", -1));
const _hoisted_12$1 = { class: "_sb_col" };
const _hoisted_13 = /* @__PURE__ */ _withScopeId$9(() => /* @__PURE__ */ createBaseVNode("div", { class: "_sb_col middle-column" }, null, -1));
const _hoisted_14 = { class: "_sb_col _sb_inherit" };
const _hoisted_15 = /* @__PURE__ */ _withScopeId$9(() => /* @__PURE__ */ createBaseVNode("div", { class: "_sb_col _sb_arrow" }, "", -1));
const _hoisted_16 = {
  key: 0,
  class: "_sb_description"
};
const _sfc_main$l = /* @__PURE__ */ defineComponent({
  __name: "NodePreview",
  props: {
    nodeDef: {
      type: ComfyNodeDefImpl,
      required: true
    }
  },
  setup(__props) {
    const props = __props;
    const nodeDefStore = useNodeDefStore();
    const nodeDef = props.nodeDef;
    const allInputDefs = nodeDef.input.all;
    const allOutputDefs = nodeDef.output.all;
    const slotInputDefs = allInputDefs.filter(
      (input) => !nodeDefStore.inputIsWidget(input)
    );
    const widgetInputDefs = allInputDefs.filter(
      (input) => nodeDefStore.inputIsWidget(input)
    );
    const truncateDefaultValue = /* @__PURE__ */ __name((value3, charLimit = 32) => {
      let stringValue;
      if (typeof value3 === "object" && value3 !== null) {
        stringValue = JSON.stringify(value3);
      } else if (Array.isArray(value3)) {
        stringValue = JSON.stringify(value3);
      } else if (typeof value3 === "string") {
        stringValue = value3;
      } else {
        stringValue = String(value3);
      }
      return _.truncate(stringValue, { length: charLimit });
    }, "truncateDefaultValue");
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$q, [
        createBaseVNode("div", _hoisted_2$j, [
          createBaseVNode("div", _hoisted_3$b, [
            _hoisted_4$7,
            createTextVNode(" " + toDisplayString$1(unref(nodeDef).display_name), 1)
          ]),
          _hoisted_5$5,
          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(_).zip(unref(slotInputDefs), unref(allOutputDefs)), ([slotInput, slotOutput]) => {
            return openBlock(), createElementBlock("div", {
              class: "_sb_row slot_row",
              key: (slotInput?.name || "") + (slotOutput?.index.toString() || "")
            }, [
              createBaseVNode("div", _hoisted_6$4, [
                slotInput ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(["_sb_dot", slotInput.type])
                }, null, 2)) : createCommentVNode("", true)
              ]),
              createBaseVNode("div", _hoisted_7$3, toDisplayString$1(slotInput ? slotInput.name : ""), 1),
              _hoisted_8$2,
              createBaseVNode("div", _hoisted_9$2, toDisplayString$1(slotOutput ? slotOutput.name : ""), 1),
              createBaseVNode("div", _hoisted_10$2, [
                slotOutput ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(["_sb_dot", slotOutput.type])
                }, null, 2)) : createCommentVNode("", true)
              ])
            ]);
          }), 128)),
          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(widgetInputDefs), (widgetInput) => {
            return openBlock(), createElementBlock("div", {
              class: "_sb_row _long_field",
              key: widgetInput.name
            }, [
              _hoisted_11$2,
              createBaseVNode("div", _hoisted_12$1, toDisplayString$1(widgetInput.name), 1),
              _hoisted_13,
              createBaseVNode("div", _hoisted_14, toDisplayString$1(truncateDefaultValue(widgetInput.default)), 1),
              _hoisted_15
            ]);
          }), 128))
        ]),
        unref(nodeDef).description ? (openBlock(), createElementBlock("div", _hoisted_16, toDisplayString$1(unref(nodeDef).description), 1)) : createCommentVNode("", true)
      ]);
    };
  }
});
const NodePreview = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["__scopeId", "data-v-cbec679a"]]);
/*!
  * shared v9.13.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
const inBrowser = typeof window !== "undefined";
let mark;
let measure;
if (false) {
  const perf2 = inBrowser && window.performance;
  if (perf2 && perf2.mark && perf2.measure && perf2.clearMarks && // @ts-ignore browser compat
  perf2.clearMeasures) {
    mark = /* @__PURE__ */ __name((tag) => {
      perf2.mark(tag);
    }, "mark");
    measure = /* @__PURE__ */ __name((name, startTag, endTag) => {
      perf2.measure(name, startTag, endTag);
      perf2.clearMarks(startTag);
      perf2.clearMarks(endTag);
    }, "measure");
  }
}
const RE_ARGS$1 = /\{([0-9a-zA-Z]+)\}/g;
function format$2(message3, ...args) {
  if (args.length === 1 && isObject$1(args[0])) {
    args = args[0];
  }
  if (!args || !args.hasOwnProperty) {
    args = {};
  }
  return message3.replace(RE_ARGS$1, (match, identifier) => {
    return args.hasOwnProperty(identifier) ? args[identifier] : "";
  });
}
__name(format$2, "format$2");
const makeSymbol = /* @__PURE__ */ __name((name, shareable = false) => !shareable ? Symbol(name) : Symbol.for(name), "makeSymbol");
const generateFormatCacheKey = /* @__PURE__ */ __name((locale2, key, source) => friendlyJSONstringify({ l: locale2, k: key, s: source }), "generateFormatCacheKey");
const friendlyJSONstringify = /* @__PURE__ */ __name((json) => JSON.stringify(json).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027"), "friendlyJSONstringify");
const isNumber = /* @__PURE__ */ __name((val) => typeof val === "number" && isFinite(val), "isNumber");
const isDate = /* @__PURE__ */ __name((val) => toTypeString(val) === "[object Date]", "isDate");
const isRegExp = /* @__PURE__ */ __name((val) => toTypeString(val) === "[object RegExp]", "isRegExp");
const isEmptyObject = /* @__PURE__ */ __name((val) => isPlainObject(val) && Object.keys(val).length === 0, "isEmptyObject");
const assign$1 = Object.assign;
let _globalThis;
const getGlobalThis = /* @__PURE__ */ __name(() => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
}, "getGlobalThis");
function escapeHtml(rawText) {
  return rawText.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
__name(escapeHtml, "escapeHtml");
const hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}
__name(hasOwn, "hasOwn");
const isArray = Array.isArray;
const isFunction$1 = /* @__PURE__ */ __name((val) => typeof val === "function", "isFunction$1");
const isString$1 = /* @__PURE__ */ __name((val) => typeof val === "string", "isString$1");
const isBoolean = /* @__PURE__ */ __name((val) => typeof val === "boolean", "isBoolean");
const isSymbol = /* @__PURE__ */ __name((val) => typeof val === "symbol", "isSymbol");
const isObject$1 = /* @__PURE__ */ __name((val) => val !== null && typeof val === "object", "isObject$1");
const isPromise = /* @__PURE__ */ __name((val) => {
  return isObject$1(val) && isFunction$1(val.then) && isFunction$1(val.catch);
}, "isPromise");
const objectToString = Object.prototype.toString;
const toTypeString = /* @__PURE__ */ __name((value3) => objectToString.call(value3), "toTypeString");
const isPlainObject = /* @__PURE__ */ __name((val) => {
  if (!isObject$1(val))
    return false;
  const proto = Object.getPrototypeOf(val);
  return proto === null || proto.constructor === Object;
}, "isPlainObject");
const toDisplayString = /* @__PURE__ */ __name((val) => {
  return val == null ? "" : isArray(val) || isPlainObject(val) && val.toString === objectToString ? JSON.stringify(val, null, 2) : String(val);
}, "toDisplayString");
function join$1(items2, separator = "") {
  return items2.reduce((str, item2, index2) => index2 === 0 ? str + item2 : str + separator + item2, "");
}
__name(join$1, "join$1");
const RANGE = 2;
function generateCodeFrame(source, start2 = 0, end = source.length) {
  const lines = source.split(/\r?\n/);
  let count = 0;
  const res = [];
  for (let i2 = 0; i2 < lines.length; i2++) {
    count += lines[i2].length + 1;
    if (count >= start2) {
      for (let j = i2 - RANGE; j <= i2 + RANGE || end > count; j++) {
        if (j < 0 || j >= lines.length)
          continue;
        const line = j + 1;
        res.push(`${line}${" ".repeat(3 - String(line).length)}|  ${lines[j]}`);
        const lineLength = lines[j].length;
        if (j === i2) {
          const pad = start2 - (count - lineLength) + 1;
          const length = Math.max(1, end > count ? lineLength - pad : end - start2);
          res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));
        } else if (j > i2) {
          if (end > count) {
            const length = Math.max(Math.min(end - count, lineLength), 1);
            res.push(`   |  ` + "^".repeat(length));
          }
          count += lineLength + 1;
        }
      }
      break;
    }
  }
  return res.join("\n");
}
__name(generateCodeFrame, "generateCodeFrame");
function incrementer(code2) {
  let current = code2;
  return () => ++current;
}
__name(incrementer, "incrementer");
function warn(msg, err) {
  if (typeof console !== "undefined") {
    console.warn(`[intlify] ` + msg);
    if (err) {
      console.warn(err.stack);
    }
  }
}
__name(warn, "warn");
const hasWarned = {};
function warnOnce(msg) {
  if (!hasWarned[msg]) {
    hasWarned[msg] = true;
    warn(msg);
  }
}
__name(warnOnce, "warnOnce");
function createEmitter() {
  const events2 = /* @__PURE__ */ new Map();
  const emitter = {
    events: events2,
    on(event2, handler6) {
      const handlers2 = events2.get(event2);
      const added = handlers2 && handlers2.push(handler6);
      if (!added) {
        events2.set(event2, [handler6]);
      }
    },
    off(event2, handler6) {
      const handlers2 = events2.get(event2);
      if (handlers2) {
        handlers2.splice(handlers2.indexOf(handler6) >>> 0, 1);
      }
    },
    emit(event2, payload) {
      (events2.get(event2) || []).slice().map((handler6) => handler6(payload));
      (events2.get("*") || []).slice().map((handler6) => handler6(event2, payload));
    }
  };
  return emitter;
}
__name(createEmitter, "createEmitter");
const isNotObjectOrIsArray = /* @__PURE__ */ __name((val) => !isObject$1(val) || isArray(val), "isNotObjectOrIsArray");
function deepCopy(src, des) {
  if (isNotObjectOrIsArray(src) || isNotObjectOrIsArray(des)) {
    throw new Error("Invalid value");
  }
  const stack2 = [{ src, des }];
  while (stack2.length) {
    const { src: src2, des: des2 } = stack2.pop();
    Object.keys(src2).forEach((key) => {
      if (isNotObjectOrIsArray(src2[key]) || isNotObjectOrIsArray(des2[key])) {
        des2[key] = src2[key];
      } else {
        stack2.push({ src: src2[key], des: des2[key] });
      }
    });
  }
}
__name(deepCopy, "deepCopy");
/*!
  * message-compiler v9.13.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
const LOCATION_STUB = {
  start: { line: 1, column: 1, offset: 0 },
  end: { line: 1, column: 1, offset: 0 }
};
function createPosition(line, column, offset) {
  return { line, column, offset };
}
__name(createPosition, "createPosition");
function createLocation(start2, end, source) {
  const loc = { start: start2, end };
  if (source != null) {
    loc.source = source;
  }
  return loc;
}
__name(createLocation, "createLocation");
const RE_ARGS = /\{([0-9a-zA-Z]+)\}/g;
function format$1(message3, ...args) {
  if (args.length === 1 && isObject(args[0])) {
    args = args[0];
  }
  if (!args || !args.hasOwnProperty) {
    args = {};
  }
  return message3.replace(RE_ARGS, (match, identifier) => {
    return args.hasOwnProperty(identifier) ? args[identifier] : "";
  });
}
__name(format$1, "format$1");
const assign = Object.assign;
const isString = /* @__PURE__ */ __name((val) => typeof val === "string", "isString");
const isObject = /* @__PURE__ */ __name((val) => val !== null && typeof val === "object", "isObject");
function join(items2, separator = "") {
  return items2.reduce((str, item2, index2) => index2 === 0 ? str + item2 : str + separator + item2, "");
}
__name(join, "join");
const CompileWarnCodes = {
  USE_MODULO_SYNTAX: 1,
  __EXTEND_POINT__: 2
};
const warnMessages$2 = {
  [CompileWarnCodes.USE_MODULO_SYNTAX]: `Use modulo before '{{0}}'.`
};
function createCompileWarn(code2, loc, ...args) {
  const msg = format$1(warnMessages$2[code2] || "", ...args || []);
  const message3 = { message: String(msg), code: code2 };
  if (loc) {
    message3.location = loc;
  }
  return message3;
}
__name(createCompileWarn, "createCompileWarn");
const CompileErrorCodes = {
  // tokenizer error codes
  EXPECTED_TOKEN: 1,
  INVALID_TOKEN_IN_PLACEHOLDER: 2,
  UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
  UNKNOWN_ESCAPE_SEQUENCE: 4,
  INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
  UNBALANCED_CLOSING_BRACE: 6,
  UNTERMINATED_CLOSING_BRACE: 7,
  EMPTY_PLACEHOLDER: 8,
  NOT_ALLOW_NEST_PLACEHOLDER: 9,
  INVALID_LINKED_FORMAT: 10,
  // parser error codes
  MUST_HAVE_MESSAGES_IN_PLURAL: 11,
  UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
  UNEXPECTED_EMPTY_LINKED_KEY: 13,
  UNEXPECTED_LEXICAL_ANALYSIS: 14,
  // generator error codes
  UNHANDLED_CODEGEN_NODE_TYPE: 15,
  // minifier error codes
  UNHANDLED_MINIFIER_NODE_TYPE: 16,
  // Special value for higher-order compilers to pick up the last code
  // to avoid collision of error codes. This should always be kept as the last
  // item.
  __EXTEND_POINT__: 17
};
const errorMessages$2 = {
  // tokenizer error messages
  [CompileErrorCodes.EXPECTED_TOKEN]: `Expected token: '{0}'`,
  [CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER]: `Invalid token in placeholder: '{0}'`,
  [CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: `Unterminated single quote in placeholder`,
  [CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE]: `Unknown escape sequence: \\{0}`,
  [CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE]: `Invalid unicode escape sequence: {0}`,
  [CompileErrorCodes.UNBALANCED_CLOSING_BRACE]: `Unbalanced closing brace`,
  [CompileErrorCodes.UNTERMINATED_CLOSING_BRACE]: `Unterminated closing brace`,
  [CompileErrorCodes.EMPTY_PLACEHOLDER]: `Empty placeholder`,
  [CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER]: `Not allowed nest placeholder`,
  [CompileErrorCodes.INVALID_LINKED_FORMAT]: `Invalid linked format`,
  // parser error messages
  [CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL]: `Plural must have messages`,
  [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER]: `Unexpected empty linked modifier`,
  [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY]: `Unexpected empty linked key`,
  [CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS]: `Unexpected lexical analysis in token: '{0}'`,
  // generator error messages
  [CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE]: `unhandled codegen node type: '{0}'`,
  // minimizer error messages
  [CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE]: `unhandled mimifier node type: '{0}'`
};
function createCompileError(code2, loc, options3 = {}) {
  const { domain, messages: messages2, args } = options3;
  const msg = format$1((messages2 || errorMessages$2)[code2] || "", ...args || []);
  const error = new SyntaxError(String(msg));
  error.code = code2;
  if (loc) {
    error.location = loc;
  }
  error.domain = domain;
  return error;
}
__name(createCompileError, "createCompileError");
function defaultOnError(error) {
  throw error;
}
__name(defaultOnError, "defaultOnError");
const RE_HTML_TAG = /<\/?[\w\s="/.':;#-\/]+>/;
const detectHtmlTag = /* @__PURE__ */ __name((source) => RE_HTML_TAG.test(source), "detectHtmlTag");
const CHAR_SP = " ";
const CHAR_CR = "\r";
const CHAR_LF = "\n";
const CHAR_LS = String.fromCharCode(8232);
const CHAR_PS = String.fromCharCode(8233);
function createScanner(str) {
  const _buf = str;
  let _index = 0;
  let _line = 1;
  let _column = 1;
  let _peekOffset = 0;
  const isCRLF = /* @__PURE__ */ __name((index3) => _buf[index3] === CHAR_CR && _buf[index3 + 1] === CHAR_LF, "isCRLF");
  const isLF = /* @__PURE__ */ __name((index3) => _buf[index3] === CHAR_LF, "isLF");
  const isPS = /* @__PURE__ */ __name((index3) => _buf[index3] === CHAR_PS, "isPS");
  const isLS = /* @__PURE__ */ __name((index3) => _buf[index3] === CHAR_LS, "isLS");
  const isLineEnd = /* @__PURE__ */ __name((index3) => isCRLF(index3) || isLF(index3) || isPS(index3) || isLS(index3), "isLineEnd");
  const index2 = /* @__PURE__ */ __name(() => _index, "index");
  const line = /* @__PURE__ */ __name(() => _line, "line");
  const column = /* @__PURE__ */ __name(() => _column, "column");
  const peekOffset = /* @__PURE__ */ __name(() => _peekOffset, "peekOffset");
  const charAt = /* @__PURE__ */ __name((offset) => isCRLF(offset) || isPS(offset) || isLS(offset) ? CHAR_LF : _buf[offset], "charAt");
  const currentChar = /* @__PURE__ */ __name(() => charAt(_index), "currentChar");
  const currentPeek = /* @__PURE__ */ __name(() => charAt(_index + _peekOffset), "currentPeek");
  function next2() {
    _peekOffset = 0;
    if (isLineEnd(_index)) {
      _line++;
      _column = 0;
    }
    if (isCRLF(_index)) {
      _index++;
    }
    _index++;
    _column++;
    return _buf[_index];
  }
  __name(next2, "next");
  function peek() {
    if (isCRLF(_index + _peekOffset)) {
      _peekOffset++;
    }
    _peekOffset++;
    return _buf[_index + _peekOffset];
  }
  __name(peek, "peek");
  function reset() {
    _index = 0;
    _line = 1;
    _column = 1;
    _peekOffset = 0;
  }
  __name(reset, "reset");
  function resetPeek(offset = 0) {
    _peekOffset = offset;
  }
  __name(resetPeek, "resetPeek");
  function skipToPeek() {
    const target = _index + _peekOffset;
    while (target !== _index) {
      next2();
    }
    _peekOffset = 0;
  }
  __name(skipToPeek, "skipToPeek");
  return {
    index: index2,
    line,
    column,
    peekOffset,
    charAt,
    currentChar,
    currentPeek,
    next: next2,
    peek,
    reset,
    resetPeek,
    skipToPeek
  };
}
__name(createScanner, "createScanner");
const EOF = void 0;
const DOT = ".";
const LITERAL_DELIMITER = "'";
const ERROR_DOMAIN$3 = "tokenizer";
function createTokenizer(source, options3 = {}) {
  const location2 = options3.location !== false;
  const _scnr = createScanner(source);
  const currentOffset = /* @__PURE__ */ __name(() => _scnr.index(), "currentOffset");
  const currentPosition = /* @__PURE__ */ __name(() => createPosition(_scnr.line(), _scnr.column(), _scnr.index()), "currentPosition");
  const _initLoc = currentPosition();
  const _initOffset = currentOffset();
  const _context = {
    currentType: 14,
    offset: _initOffset,
    startLoc: _initLoc,
    endLoc: _initLoc,
    lastType: 14,
    lastOffset: _initOffset,
    lastStartLoc: _initLoc,
    lastEndLoc: _initLoc,
    braceNest: 0,
    inLinked: false,
    text: ""
  };
  const context = /* @__PURE__ */ __name(() => _context, "context");
  const { onError } = options3;
  function emitError(code2, pos2, offset, ...args) {
    const ctx = context();
    pos2.column += offset;
    pos2.offset += offset;
    if (onError) {
      const loc = location2 ? createLocation(ctx.startLoc, pos2) : null;
      const err = createCompileError(code2, loc, {
        domain: ERROR_DOMAIN$3,
        args
      });
      onError(err);
    }
  }
  __name(emitError, "emitError");
  function getToken(context2, type, value3) {
    context2.endLoc = currentPosition();
    context2.currentType = type;
    const token = { type };
    if (location2) {
      token.loc = createLocation(context2.startLoc, context2.endLoc);
    }
    if (value3 != null) {
      token.value = value3;
    }
    return token;
  }
  __name(getToken, "getToken");
  const getEndToken = /* @__PURE__ */ __name((context2) => getToken(
    context2,
    14
    /* TokenTypes.EOF */
  ), "getEndToken");
  function eat(scnr, ch) {
    if (scnr.currentChar() === ch) {
      scnr.next();
      return ch;
    } else {
      emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);
      return "";
    }
  }
  __name(eat, "eat");
  function peekSpaces(scnr) {
    let buf = "";
    while (scnr.currentPeek() === CHAR_SP || scnr.currentPeek() === CHAR_LF) {
      buf += scnr.currentPeek();
      scnr.peek();
    }
    return buf;
  }
  __name(peekSpaces, "peekSpaces");
  function skipSpaces(scnr) {
    const buf = peekSpaces(scnr);
    scnr.skipToPeek();
    return buf;
  }
  __name(skipSpaces, "skipSpaces");
  function isIdentifierStart(ch) {
    if (ch === EOF) {
      return false;
    }
    const cc = ch.charCodeAt(0);
    return cc >= 97 && cc <= 122 || // a-z
    cc >= 65 && cc <= 90 || // A-Z
    cc === 95;
  }
  __name(isIdentifierStart, "isIdentifierStart");
  function isNumberStart(ch) {
    if (ch === EOF) {
      return false;
    }
    const cc = ch.charCodeAt(0);
    return cc >= 48 && cc <= 57;
  }
  __name(isNumberStart, "isNumberStart");
  function isNamedIdentifierStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 2) {
      return false;
    }
    peekSpaces(scnr);
    const ret = isIdentifierStart(scnr.currentPeek());
    scnr.resetPeek();
    return ret;
  }
  __name(isNamedIdentifierStart, "isNamedIdentifierStart");
  function isListIdentifierStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 2) {
      return false;
    }
    peekSpaces(scnr);
    const ch = scnr.currentPeek() === "-" ? scnr.peek() : scnr.currentPeek();
    const ret = isNumberStart(ch);
    scnr.resetPeek();
    return ret;
  }
  __name(isListIdentifierStart, "isListIdentifierStart");
  function isLiteralStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 2) {
      return false;
    }
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === LITERAL_DELIMITER;
    scnr.resetPeek();
    return ret;
  }
  __name(isLiteralStart, "isLiteralStart");
  function isLinkedDotStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 8) {
      return false;
    }
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === ".";
    scnr.resetPeek();
    return ret;
  }
  __name(isLinkedDotStart, "isLinkedDotStart");
  function isLinkedModifierStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 9) {
      return false;
    }
    peekSpaces(scnr);
    const ret = isIdentifierStart(scnr.currentPeek());
    scnr.resetPeek();
    return ret;
  }
  __name(isLinkedModifierStart, "isLinkedModifierStart");
  function isLinkedDelimiterStart(scnr, context2) {
    const { currentType } = context2;
    if (!(currentType === 8 || currentType === 12)) {
      return false;
    }
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === ":";
    scnr.resetPeek();
    return ret;
  }
  __name(isLinkedDelimiterStart, "isLinkedDelimiterStart");
  function isLinkedReferStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 10) {
      return false;
    }
    const fn = /* @__PURE__ */ __name(() => {
      const ch = scnr.currentPeek();
      if (ch === "{") {
        return isIdentifierStart(scnr.peek());
      } else if (ch === "@" || ch === "%" || ch === "|" || ch === ":" || ch === "." || ch === CHAR_SP || !ch) {
        return false;
      } else if (ch === CHAR_LF) {
        scnr.peek();
        return fn();
      } else {
        return isTextStart(scnr, false);
      }
    }, "fn");
    const ret = fn();
    scnr.resetPeek();
    return ret;
  }
  __name(isLinkedReferStart, "isLinkedReferStart");
  function isPluralStart(scnr) {
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === "|";
    scnr.resetPeek();
    return ret;
  }
  __name(isPluralStart, "isPluralStart");
  function detectModuloStart(scnr) {
    const spaces = peekSpaces(scnr);
    const ret = scnr.currentPeek() === "%" && scnr.peek() === "{";
    scnr.resetPeek();
    return {
      isModulo: ret,
      hasSpace: spaces.length > 0
    };
  }
  __name(detectModuloStart, "detectModuloStart");
  function isTextStart(scnr, reset = true) {
    const fn = /* @__PURE__ */ __name((hasSpace = false, prev2 = "", detectModulo = false) => {
      const ch = scnr.currentPeek();
      if (ch === "{") {
        return prev2 === "%" ? false : hasSpace;
      } else if (ch === "@" || !ch) {
        return prev2 === "%" ? true : hasSpace;
      } else if (ch === "%") {
        scnr.peek();
        return fn(hasSpace, "%", true);
      } else if (ch === "|") {
        return prev2 === "%" || detectModulo ? true : !(prev2 === CHAR_SP || prev2 === CHAR_LF);
      } else if (ch === CHAR_SP) {
        scnr.peek();
        return fn(true, CHAR_SP, detectModulo);
      } else if (ch === CHAR_LF) {
        scnr.peek();
        return fn(true, CHAR_LF, detectModulo);
      } else {
        return true;
      }
    }, "fn");
    const ret = fn();
    reset && scnr.resetPeek();
    return ret;
  }
  __name(isTextStart, "isTextStart");
  function takeChar(scnr, fn) {
    const ch = scnr.currentChar();
    if (ch === EOF) {
      return EOF;
    }
    if (fn(ch)) {
      scnr.next();
      return ch;
    }
    return null;
  }
  __name(takeChar, "takeChar");
  function isIdentifier(ch) {
    const cc = ch.charCodeAt(0);
    return cc >= 97 && cc <= 122 || // a-z
    cc >= 65 && cc <= 90 || // A-Z
    cc >= 48 && cc <= 57 || // 0-9
    cc === 95 || // _
    cc === 36;
  }
  __name(isIdentifier, "isIdentifier");
  function takeIdentifierChar(scnr) {
    return takeChar(scnr, isIdentifier);
  }
  __name(takeIdentifierChar, "takeIdentifierChar");
  function isNamedIdentifier(ch) {
    const cc = ch.charCodeAt(0);
    return cc >= 97 && cc <= 122 || // a-z
    cc >= 65 && cc <= 90 || // A-Z
    cc >= 48 && cc <= 57 || // 0-9
    cc === 95 || // _
    cc === 36 || // $
    cc === 45;
  }
  __name(isNamedIdentifier, "isNamedIdentifier");
  function takeNamedIdentifierChar(scnr) {
    return takeChar(scnr, isNamedIdentifier);
  }
  __name(takeNamedIdentifierChar, "takeNamedIdentifierChar");
  function isDigit(ch) {
    const cc = ch.charCodeAt(0);
    return cc >= 48 && cc <= 57;
  }
  __name(isDigit, "isDigit");
  function takeDigit(scnr) {
    return takeChar(scnr, isDigit);
  }
  __name(takeDigit, "takeDigit");
  function isHexDigit(ch) {
    const cc = ch.charCodeAt(0);
    return cc >= 48 && cc <= 57 || // 0-9
    cc >= 65 && cc <= 70 || // A-F
    cc >= 97 && cc <= 102;
  }
  __name(isHexDigit, "isHexDigit");
  function takeHexDigit(scnr) {
    return takeChar(scnr, isHexDigit);
  }
  __name(takeHexDigit, "takeHexDigit");
  function getDigits(scnr) {
    let ch = "";
    let num = "";
    while (ch = takeDigit(scnr)) {
      num += ch;
    }
    return num;
  }
  __name(getDigits, "getDigits");
  function readModulo(scnr) {
    skipSpaces(scnr);
    const ch = scnr.currentChar();
    if (ch !== "%") {
      emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);
    }
    scnr.next();
    return "%";
  }
  __name(readModulo, "readModulo");
  function readText(scnr) {
    let buf = "";
    while (true) {
      const ch = scnr.currentChar();
      if (ch === "{" || ch === "}" || ch === "@" || ch === "|" || !ch) {
        break;
      } else if (ch === "%") {
        if (isTextStart(scnr)) {
          buf += ch;
          scnr.next();
        } else {
          break;
        }
      } else if (ch === CHAR_SP || ch === CHAR_LF) {
        if (isTextStart(scnr)) {
          buf += ch;
          scnr.next();
        } else if (isPluralStart(scnr)) {
          break;
        } else {
          buf += ch;
          scnr.next();
        }
      } else {
        buf += ch;
        scnr.next();
      }
    }
    return buf;
  }
  __name(readText, "readText");
  function readNamedIdentifier(scnr) {
    skipSpaces(scnr);
    let ch = "";
    let name = "";
    while (ch = takeNamedIdentifierChar(scnr)) {
      name += ch;
    }
    if (scnr.currentChar() === EOF) {
      emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
    }
    return name;
  }
  __name(readNamedIdentifier, "readNamedIdentifier");
  function readListIdentifier(scnr) {
    skipSpaces(scnr);
    let value3 = "";
    if (scnr.currentChar() === "-") {
      scnr.next();
      value3 += `-${getDigits(scnr)}`;
    } else {
      value3 += getDigits(scnr);
    }
    if (scnr.currentChar() === EOF) {
      emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
    }
    return value3;
  }
  __name(readListIdentifier, "readListIdentifier");
  function isLiteral2(ch) {
    return ch !== LITERAL_DELIMITER && ch !== CHAR_LF;
  }
  __name(isLiteral2, "isLiteral");
  function readLiteral(scnr) {
    skipSpaces(scnr);
    eat(scnr, `'`);
    let ch = "";
    let literal = "";
    while (ch = takeChar(scnr, isLiteral2)) {
      if (ch === "\\") {
        literal += readEscapeSequence(scnr);
      } else {
        literal += ch;
      }
    }
    const current = scnr.currentChar();
    if (current === CHAR_LF || current === EOF) {
      emitError(CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, currentPosition(), 0);
      if (current === CHAR_LF) {
        scnr.next();
        eat(scnr, `'`);
      }
      return literal;
    }
    eat(scnr, `'`);
    return literal;
  }
  __name(readLiteral, "readLiteral");
  function readEscapeSequence(scnr) {
    const ch = scnr.currentChar();
    switch (ch) {
      case "\\":
      case `'`:
        scnr.next();
        return `\\${ch}`;
      case "u":
        return readUnicodeEscapeSequence(scnr, ch, 4);
      case "U":
        return readUnicodeEscapeSequence(scnr, ch, 6);
      default:
        emitError(CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE, currentPosition(), 0, ch);
        return "";
    }
  }
  __name(readEscapeSequence, "readEscapeSequence");
  function readUnicodeEscapeSequence(scnr, unicode, digits) {
    eat(scnr, unicode);
    let sequence = "";
    for (let i2 = 0; i2 < digits; i2++) {
      const ch = takeHexDigit(scnr);
      if (!ch) {
        emitError(CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE, currentPosition(), 0, `\\${unicode}${sequence}${scnr.currentChar()}`);
        break;
      }
      sequence += ch;
    }
    return `\\${unicode}${sequence}`;
  }
  __name(readUnicodeEscapeSequence, "readUnicodeEscapeSequence");
  function isInvalidIdentifier(ch) {
    return ch !== "{" && ch !== "}" && ch !== CHAR_SP && ch !== CHAR_LF;
  }
  __name(isInvalidIdentifier, "isInvalidIdentifier");
  function readInvalidIdentifier(scnr) {
    skipSpaces(scnr);
    let ch = "";
    let identifiers = "";
    while (ch = takeChar(scnr, isInvalidIdentifier)) {
      identifiers += ch;
    }
    return identifiers;
  }
  __name(readInvalidIdentifier, "readInvalidIdentifier");
  function readLinkedModifier(scnr) {
    let ch = "";
    let name = "";
    while (ch = takeIdentifierChar(scnr)) {
      name += ch;
    }
    return name;
  }
  __name(readLinkedModifier, "readLinkedModifier");
  function readLinkedRefer(scnr) {
    const fn = /* @__PURE__ */ __name((buf) => {
      const ch = scnr.currentChar();
      if (ch === "{" || ch === "%" || ch === "@" || ch === "|" || ch === "(" || ch === ")" || !ch) {
        return buf;
      } else if (ch === CHAR_SP) {
        return buf;
      } else if (ch === CHAR_LF || ch === DOT) {
        buf += ch;
        scnr.next();
        return fn(buf);
      } else {
        buf += ch;
        scnr.next();
        return fn(buf);
      }
    }, "fn");
    return fn("");
  }
  __name(readLinkedRefer, "readLinkedRefer");
  function readPlural(scnr) {
    skipSpaces(scnr);
    const plural = eat(
      scnr,
      "|"
      /* TokenChars.Pipe */
    );
    skipSpaces(scnr);
    return plural;
  }
  __name(readPlural, "readPlural");
  function readTokenInPlaceholder(scnr, context2) {
    let token = null;
    const ch = scnr.currentChar();
    switch (ch) {
      case "{":
        if (context2.braceNest >= 1) {
          emitError(CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER, currentPosition(), 0);
        }
        scnr.next();
        token = getToken(
          context2,
          2,
          "{"
          /* TokenChars.BraceLeft */
        );
        skipSpaces(scnr);
        context2.braceNest++;
        return token;
      case "}":
        if (context2.braceNest > 0 && context2.currentType === 2) {
          emitError(CompileErrorCodes.EMPTY_PLACEHOLDER, currentPosition(), 0);
        }
        scnr.next();
        token = getToken(
          context2,
          3,
          "}"
          /* TokenChars.BraceRight */
        );
        context2.braceNest--;
        context2.braceNest > 0 && skipSpaces(scnr);
        if (context2.inLinked && context2.braceNest === 0) {
          context2.inLinked = false;
        }
        return token;
      case "@":
        if (context2.braceNest > 0) {
          emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
        }
        token = readTokenInLinked(scnr, context2) || getEndToken(context2);
        context2.braceNest = 0;
        return token;
      default: {
        let validNamedIdentifier = true;
        let validListIdentifier = true;
        let validLiteral = true;
        if (isPluralStart(scnr)) {
          if (context2.braceNest > 0) {
            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
          }
          token = getToken(context2, 1, readPlural(scnr));
          context2.braceNest = 0;
          context2.inLinked = false;
          return token;
        }
        if (context2.braceNest > 0 && (context2.currentType === 5 || context2.currentType === 6 || context2.currentType === 7)) {
          emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
          context2.braceNest = 0;
          return readToken(scnr, context2);
        }
        if (validNamedIdentifier = isNamedIdentifierStart(scnr, context2)) {
          token = getToken(context2, 5, readNamedIdentifier(scnr));
          skipSpaces(scnr);
          return token;
        }
        if (validListIdentifier = isListIdentifierStart(scnr, context2)) {
          token = getToken(context2, 6, readListIdentifier(scnr));
          skipSpaces(scnr);
          return token;
        }
        if (validLiteral = isLiteralStart(scnr, context2)) {
          token = getToken(context2, 7, readLiteral(scnr));
          skipSpaces(scnr);
          return token;
        }
        if (!validNamedIdentifier && !validListIdentifier && !validLiteral) {
          token = getToken(context2, 13, readInvalidIdentifier(scnr));
          emitError(CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER, currentPosition(), 0, token.value);
          skipSpaces(scnr);
          return token;
        }
        break;
      }
    }
    return token;
  }
  __name(readTokenInPlaceholder, "readTokenInPlaceholder");
  function readTokenInLinked(scnr, context2) {
    const { currentType } = context2;
    let token = null;
    const ch = scnr.currentChar();
    if ((currentType === 8 || currentType === 9 || currentType === 12 || currentType === 10) && (ch === CHAR_LF || ch === CHAR_SP)) {
      emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
    }
    switch (ch) {
      case "@":
        scnr.next();
        token = getToken(
          context2,
          8,
          "@"
          /* TokenChars.LinkedAlias */
        );
        context2.inLinked = true;
        return token;
      case ".":
        skipSpaces(scnr);
        scnr.next();
        return getToken(
          context2,
          9,
          "."
          /* TokenChars.LinkedDot */
        );
      case ":":
        skipSpaces(scnr);
        scnr.next();
        return getToken(
          context2,
          10,
          ":"
          /* TokenChars.LinkedDelimiter */
        );
      default:
        if (isPluralStart(scnr)) {
          token = getToken(context2, 1, readPlural(scnr));
          context2.braceNest = 0;
          context2.inLinked = false;
          return token;
        }
        if (isLinkedDotStart(scnr, context2) || isLinkedDelimiterStart(scnr, context2)) {
          skipSpaces(scnr);
          return readTokenInLinked(scnr, context2);
        }
        if (isLinkedModifierStart(scnr, context2)) {
          skipSpaces(scnr);
          return getToken(context2, 12, readLinkedModifier(scnr));
        }
        if (isLinkedReferStart(scnr, context2)) {
          skipSpaces(scnr);
          if (ch === "{") {
            return readTokenInPlaceholder(scnr, context2) || token;
          } else {
            return getToken(context2, 11, readLinkedRefer(scnr));
          }
        }
        if (currentType === 8) {
          emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
        }
        context2.braceNest = 0;
        context2.inLinked = false;
        return readToken(scnr, context2);
    }
  }
  __name(readTokenInLinked, "readTokenInLinked");
  function readToken(scnr, context2) {
    let token = {
      type: 14
      /* TokenTypes.EOF */
    };
    if (context2.braceNest > 0) {
      return readTokenInPlaceholder(scnr, context2) || getEndToken(context2);
    }
    if (context2.inLinked) {
      return readTokenInLinked(scnr, context2) || getEndToken(context2);
    }
    const ch = scnr.currentChar();
    switch (ch) {
      case "{":
        return readTokenInPlaceholder(scnr, context2) || getEndToken(context2);
      case "}":
        emitError(CompileErrorCodes.UNBALANCED_CLOSING_BRACE, currentPosition(), 0);
        scnr.next();
        return getToken(
          context2,
          3,
          "}"
          /* TokenChars.BraceRight */
        );
      case "@":
        return readTokenInLinked(scnr, context2) || getEndToken(context2);
      default: {
        if (isPluralStart(scnr)) {
          token = getToken(context2, 1, readPlural(scnr));
          context2.braceNest = 0;
          context2.inLinked = false;
          return token;
        }
        const { isModulo, hasSpace } = detectModuloStart(scnr);
        if (isModulo) {
          return hasSpace ? getToken(context2, 0, readText(scnr)) : getToken(context2, 4, readModulo(scnr));
        }
        if (isTextStart(scnr)) {
          return getToken(context2, 0, readText(scnr));
        }
        break;
      }
    }
    return token;
  }
  __name(readToken, "readToken");
  function nextToken() {
    const { currentType, offset, startLoc, endLoc } = _context;
    _context.lastType = currentType;
    _context.lastOffset = offset;
    _context.lastStartLoc = startLoc;
    _context.lastEndLoc = endLoc;
    _context.offset = currentOffset();
    _context.startLoc = currentPosition();
    if (_scnr.currentChar() === EOF) {
      return getToken(
        _context,
        14
        /* TokenTypes.EOF */
      );
    }
    return readToken(_scnr, _context);
  }
  __name(nextToken, "nextToken");
  return {
    nextToken,
    currentOffset,
    currentPosition,
    context
  };
}
__name(createTokenizer, "createTokenizer");
const ERROR_DOMAIN$2 = "parser";
const KNOWN_ESCAPES = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
function fromEscapeSequence(match, codePoint4, codePoint6) {
  switch (match) {
    case `\\\\`:
      return `\\`;
    case `\\'`:
      return `'`;
    default: {
      const codePoint = parseInt(codePoint4 || codePoint6, 16);
      if (codePoint <= 55295 || codePoint >= 57344) {
        return String.fromCodePoint(codePoint);
      }
      return "";
    }
  }
}
__name(fromEscapeSequence, "fromEscapeSequence");
function createParser(options3 = {}) {
  const location2 = options3.location !== false;
  const { onError, onWarn } = options3;
  function emitError(tokenzer, code2, start2, offset, ...args) {
    const end = tokenzer.currentPosition();
    end.offset += offset;
    end.column += offset;
    if (onError) {
      const loc = location2 ? createLocation(start2, end) : null;
      const err = createCompileError(code2, loc, {
        domain: ERROR_DOMAIN$2,
        args
      });
      onError(err);
    }
  }
  __name(emitError, "emitError");
  function emitWarn(tokenzer, code2, start2, offset, ...args) {
    const end = tokenzer.currentPosition();
    end.offset += offset;
    end.column += offset;
    if (onWarn) {
      const loc = location2 ? createLocation(start2, end) : null;
      onWarn(createCompileWarn(code2, loc, args));
    }
  }
  __name(emitWarn, "emitWarn");
  function startNode(type, offset, loc) {
    const node3 = { type };
    if (location2) {
      node3.start = offset;
      node3.end = offset;
      node3.loc = { start: loc, end: loc };
    }
    return node3;
  }
  __name(startNode, "startNode");
  function endNode(node3, offset, pos2, type) {
    if (type) {
      node3.type = type;
    }
    if (location2) {
      node3.end = offset;
      if (node3.loc) {
        node3.loc.end = pos2;
      }
    }
  }
  __name(endNode, "endNode");
  function parseText(tokenizer, value3) {
    const context = tokenizer.context();
    const node3 = startNode(3, context.offset, context.startLoc);
    node3.value = value3;
    endNode(node3, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node3;
  }
  __name(parseText, "parseText");
  function parseList(tokenizer, index2) {
    const context = tokenizer.context();
    const { lastOffset: offset, lastStartLoc: loc } = context;
    const node3 = startNode(5, offset, loc);
    node3.index = parseInt(index2, 10);
    tokenizer.nextToken();
    endNode(node3, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node3;
  }
  __name(parseList, "parseList");
  function parseNamed(tokenizer, key, modulo) {
    const context = tokenizer.context();
    const { lastOffset: offset, lastStartLoc: loc } = context;
    const node3 = startNode(4, offset, loc);
    node3.key = key;
    if (modulo === true) {
      node3.modulo = true;
    }
    tokenizer.nextToken();
    endNode(node3, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node3;
  }
  __name(parseNamed, "parseNamed");
  function parseLiteral(tokenizer, value3) {
    const context = tokenizer.context();
    const { lastOffset: offset, lastStartLoc: loc } = context;
    const node3 = startNode(9, offset, loc);
    node3.value = value3.replace(KNOWN_ESCAPES, fromEscapeSequence);
    tokenizer.nextToken();
    endNode(node3, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node3;
  }
  __name(parseLiteral, "parseLiteral");
  function parseLinkedModifier(tokenizer) {
    const token = tokenizer.nextToken();
    const context = tokenizer.context();
    const { lastOffset: offset, lastStartLoc: loc } = context;
    const node3 = startNode(8, offset, loc);
    if (token.type !== 12) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER, context.lastStartLoc, 0);
      node3.value = "";
      endNode(node3, offset, loc);
      return {
        nextConsumeToken: token,
        node: node3
      };
    }
    if (token.value == null) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
    }
    node3.value = token.value || "";
    endNode(node3, tokenizer.currentOffset(), tokenizer.currentPosition());
    return {
      node: node3
    };
  }
  __name(parseLinkedModifier, "parseLinkedModifier");
  function parseLinkedKey(tokenizer, value3) {
    const context = tokenizer.context();
    const node3 = startNode(7, context.offset, context.startLoc);
    node3.value = value3;
    endNode(node3, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node3;
  }
  __name(parseLinkedKey, "parseLinkedKey");
  function parseLinked(tokenizer) {
    const context = tokenizer.context();
    const linkedNode = startNode(6, context.offset, context.startLoc);
    let token = tokenizer.nextToken();
    if (token.type === 9) {
      const parsed = parseLinkedModifier(tokenizer);
      linkedNode.modifier = parsed.node;
      token = parsed.nextConsumeToken || tokenizer.nextToken();
    }
    if (token.type !== 10) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
    }
    token = tokenizer.nextToken();
    if (token.type === 2) {
      token = tokenizer.nextToken();
    }
    switch (token.type) {
      case 11:
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        linkedNode.key = parseLinkedKey(tokenizer, token.value || "");
        break;
      case 5:
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        linkedNode.key = parseNamed(tokenizer, token.value || "");
        break;
      case 6:
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        linkedNode.key = parseList(tokenizer, token.value || "");
        break;
      case 7:
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        linkedNode.key = parseLiteral(tokenizer, token.value || "");
        break;
      default: {
        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY, context.lastStartLoc, 0);
        const nextContext = tokenizer.context();
        const emptyLinkedKeyNode = startNode(7, nextContext.offset, nextContext.startLoc);
        emptyLinkedKeyNode.value = "";
        endNode(emptyLinkedKeyNode, nextContext.offset, nextContext.startLoc);
        linkedNode.key = emptyLinkedKeyNode;
        endNode(linkedNode, nextContext.offset, nextContext.startLoc);
        return {
          nextConsumeToken: token,
          node: linkedNode
        };
      }
    }
    endNode(linkedNode, tokenizer.currentOffset(), tokenizer.currentPosition());
    return {
      node: linkedNode
    };
  }
  __name(parseLinked, "parseLinked");
  function parseMessage(tokenizer) {
    const context = tokenizer.context();
    const startOffset = context.currentType === 1 ? tokenizer.currentOffset() : context.offset;
    const startLoc = context.currentType === 1 ? context.endLoc : context.startLoc;
    const node3 = startNode(2, startOffset, startLoc);
    node3.items = [];
    let nextToken = null;
    let modulo = null;
    do {
      const token = nextToken || tokenizer.nextToken();
      nextToken = null;
      switch (token.type) {
        case 0:
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          node3.items.push(parseText(tokenizer, token.value || ""));
          break;
        case 6:
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          node3.items.push(parseList(tokenizer, token.value || ""));
          break;
        case 4:
          modulo = true;
          break;
        case 5:
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          node3.items.push(parseNamed(tokenizer, token.value || "", !!modulo));
          if (modulo) {
            emitWarn(tokenizer, CompileWarnCodes.USE_MODULO_SYNTAX, context.lastStartLoc, 0, getTokenCaption(token));
            modulo = null;
          }
          break;
        case 7:
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          node3.items.push(parseLiteral(tokenizer, token.value || ""));
          break;
        case 8: {
          const parsed = parseLinked(tokenizer);
          node3.items.push(parsed.node);
          nextToken = parsed.nextConsumeToken || null;
          break;
        }
      }
    } while (context.currentType !== 14 && context.currentType !== 1);
    const endOffset = context.currentType === 1 ? context.lastOffset : tokenizer.currentOffset();
    const endLoc = context.currentType === 1 ? context.lastEndLoc : tokenizer.currentPosition();
    endNode(node3, endOffset, endLoc);
    return node3;
  }
  __name(parseMessage, "parseMessage");
  function parsePlural(tokenizer, offset, loc, msgNode) {
    const context = tokenizer.context();
    let hasEmptyMessage = msgNode.items.length === 0;
    const node3 = startNode(1, offset, loc);
    node3.cases = [];
    node3.cases.push(msgNode);
    do {
      const msg = parseMessage(tokenizer);
      if (!hasEmptyMessage) {
        hasEmptyMessage = msg.items.length === 0;
      }
      node3.cases.push(msg);
    } while (context.currentType !== 14);
    if (hasEmptyMessage) {
      emitError(tokenizer, CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL, loc, 0);
    }
    endNode(node3, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node3;
  }
  __name(parsePlural, "parsePlural");
  function parseResource(tokenizer) {
    const context = tokenizer.context();
    const { offset, startLoc } = context;
    const msgNode = parseMessage(tokenizer);
    if (context.currentType === 14) {
      return msgNode;
    } else {
      return parsePlural(tokenizer, offset, startLoc, msgNode);
    }
  }
  __name(parseResource, "parseResource");
  function parse2(source) {
    const tokenizer = createTokenizer(source, assign({}, options3));
    const context = tokenizer.context();
    const node3 = startNode(0, context.offset, context.startLoc);
    if (location2 && node3.loc) {
      node3.loc.source = source;
    }
    node3.body = parseResource(tokenizer);
    if (options3.onCacheKey) {
      node3.cacheKey = options3.onCacheKey(source);
    }
    if (context.currentType !== 14) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, source[context.offset] || "");
    }
    endNode(node3, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node3;
  }
  __name(parse2, "parse");
  return { parse: parse2 };
}
__name(createParser, "createParser");
function getTokenCaption(token) {
  if (token.type === 14) {
    return "EOF";
  }
  const name = (token.value || "").replace(/\r?\n/gu, "\\n");
  return name.length > 10 ? name.slice(0, 9) + "" : name;
}
__name(getTokenCaption, "getTokenCaption");
function createTransformer(ast, options3 = {}) {
  const _context = {
    ast,
    helpers: /* @__PURE__ */ new Set()
  };
  const context = /* @__PURE__ */ __name(() => _context, "context");
  const helper = /* @__PURE__ */ __name((name) => {
    _context.helpers.add(name);
    return name;
  }, "helper");
  return { context, helper };
}
__name(createTransformer, "createTransformer");
function traverseNodes(nodes, transformer) {
  for (let i2 = 0; i2 < nodes.length; i2++) {
    traverseNode(nodes[i2], transformer);
  }
}
__name(traverseNodes, "traverseNodes");
function traverseNode(node3, transformer) {
  switch (node3.type) {
    case 1:
      traverseNodes(node3.cases, transformer);
      transformer.helper(
        "plural"
        /* HelperNameMap.PLURAL */
      );
      break;
    case 2:
      traverseNodes(node3.items, transformer);
      break;
    case 6: {
      const linked = node3;
      traverseNode(linked.key, transformer);
      transformer.helper(
        "linked"
        /* HelperNameMap.LINKED */
      );
      transformer.helper(
        "type"
        /* HelperNameMap.TYPE */
      );
      break;
    }
    case 5:
      transformer.helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      );
      transformer.helper(
        "list"
        /* HelperNameMap.LIST */
      );
      break;
    case 4:
      transformer.helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      );
      transformer.helper(
        "named"
        /* HelperNameMap.NAMED */
      );
      break;
  }
}
__name(traverseNode, "traverseNode");
function transform(ast, options3 = {}) {
  const transformer = createTransformer(ast);
  transformer.helper(
    "normalize"
    /* HelperNameMap.NORMALIZE */
  );
  ast.body && traverseNode(ast.body, transformer);
  const context = transformer.context();
  ast.helpers = Array.from(context.helpers);
}
__name(transform, "transform");
function optimize(ast) {
  const body = ast.body;
  if (body.type === 2) {
    optimizeMessageNode(body);
  } else {
    body.cases.forEach((c) => optimizeMessageNode(c));
  }
  return ast;
}
__name(optimize, "optimize");
function optimizeMessageNode(message3) {
  if (message3.items.length === 1) {
    const item2 = message3.items[0];
    if (item2.type === 3 || item2.type === 9) {
      message3.static = item2.value;
      delete item2.value;
    }
  } else {
    const values2 = [];
    for (let i2 = 0; i2 < message3.items.length; i2++) {
      const item2 = message3.items[i2];
      if (!(item2.type === 3 || item2.type === 9)) {
        break;
      }
      if (item2.value == null) {
        break;
      }
      values2.push(item2.value);
    }
    if (values2.length === message3.items.length) {
      message3.static = join(values2);
      for (let i2 = 0; i2 < message3.items.length; i2++) {
        const item2 = message3.items[i2];
        if (item2.type === 3 || item2.type === 9) {
          delete item2.value;
        }
      }
    }
  }
}
__name(optimizeMessageNode, "optimizeMessageNode");
const ERROR_DOMAIN$1 = "minifier";
function minify(node3) {
  node3.t = node3.type;
  switch (node3.type) {
    case 0: {
      const resource = node3;
      minify(resource.body);
      resource.b = resource.body;
      delete resource.body;
      break;
    }
    case 1: {
      const plural = node3;
      const cases = plural.cases;
      for (let i2 = 0; i2 < cases.length; i2++) {
        minify(cases[i2]);
      }
      plural.c = cases;
      delete plural.cases;
      break;
    }
    case 2: {
      const message3 = node3;
      const items2 = message3.items;
      for (let i2 = 0; i2 < items2.length; i2++) {
        minify(items2[i2]);
      }
      message3.i = items2;
      delete message3.items;
      if (message3.static) {
        message3.s = message3.static;
        delete message3.static;
      }
      break;
    }
    case 3:
    case 9:
    case 8:
    case 7: {
      const valueNode = node3;
      if (valueNode.value) {
        valueNode.v = valueNode.value;
        delete valueNode.value;
      }
      break;
    }
    case 6: {
      const linked = node3;
      minify(linked.key);
      linked.k = linked.key;
      delete linked.key;
      if (linked.modifier) {
        minify(linked.modifier);
        linked.m = linked.modifier;
        delete linked.modifier;
      }
      break;
    }
    case 5: {
      const list = node3;
      list.i = list.index;
      delete list.index;
      break;
    }
    case 4: {
      const named = node3;
      named.k = named.key;
      delete named.key;
      break;
    }
    default: {
      throw createCompileError(CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE, null, {
        domain: ERROR_DOMAIN$1,
        args: [node3.type]
      });
    }
  }
  delete node3.type;
}
__name(minify, "minify");
const ERROR_DOMAIN = "parser";
function createCodeGenerator(ast, options3) {
  const { sourceMap, filename, breakLineCode, needIndent: _needIndent } = options3;
  const location2 = options3.location !== false;
  const _context = {
    filename,
    code: "",
    column: 1,
    line: 1,
    offset: 0,
    map: void 0,
    breakLineCode,
    needIndent: _needIndent,
    indentLevel: 0
  };
  if (location2 && ast.loc) {
    _context.source = ast.loc.source;
  }
  const context = /* @__PURE__ */ __name(() => _context, "context");
  function push(code2, node3) {
    _context.code += code2;
  }
  __name(push, "push");
  function _newline(n, withBreakLine = true) {
    const _breakLineCode = withBreakLine ? breakLineCode : "";
    push(_needIndent ? _breakLineCode + `  `.repeat(n) : _breakLineCode);
  }
  __name(_newline, "_newline");
  function indent(withNewLine = true) {
    const level = ++_context.indentLevel;
    withNewLine && _newline(level);
  }
  __name(indent, "indent");
  function deindent(withNewLine = true) {
    const level = --_context.indentLevel;
    withNewLine && _newline(level);
  }
  __name(deindent, "deindent");
  function newline() {
    _newline(_context.indentLevel);
  }
  __name(newline, "newline");
  const helper = /* @__PURE__ */ __name((key) => `_${key}`, "helper");
  const needIndent = /* @__PURE__ */ __name(() => _context.needIndent, "needIndent");
  return {
    context,
    push,
    indent,
    deindent,
    newline,
    helper,
    needIndent
  };
}
__name(createCodeGenerator, "createCodeGenerator");
function generateLinkedNode(generator, node3) {
  const { helper } = generator;
  generator.push(`${helper(
    "linked"
    /* HelperNameMap.LINKED */
  )}(`);
  generateNode(generator, node3.key);
  if (node3.modifier) {
    generator.push(`, `);
    generateNode(generator, node3.modifier);
    generator.push(`, _type`);
  } else {
    generator.push(`, undefined, _type`);
  }
  generator.push(`)`);
}
__name(generateLinkedNode, "generateLinkedNode");
function generateMessageNode(generator, node3) {
  const { helper, needIndent } = generator;
  generator.push(`${helper(
    "normalize"
    /* HelperNameMap.NORMALIZE */
  )}([`);
  generator.indent(needIndent());
  const length = node3.items.length;
  for (let i2 = 0; i2 < length; i2++) {
    generateNode(generator, node3.items[i2]);
    if (i2 === length - 1) {
      break;
    }
    generator.push(", ");
  }
  generator.deindent(needIndent());
  generator.push("])");
}
__name(generateMessageNode, "generateMessageNode");
function generatePluralNode(generator, node3) {
  const { helper, needIndent } = generator;
  if (node3.cases.length > 1) {
    generator.push(`${helper(
      "plural"
      /* HelperNameMap.PLURAL */
    )}([`);
    generator.indent(needIndent());
    const length = node3.cases.length;
    for (let i2 = 0; i2 < length; i2++) {
      generateNode(generator, node3.cases[i2]);
      if (i2 === length - 1) {
        break;
      }
      generator.push(", ");
    }
    generator.deindent(needIndent());
    generator.push(`])`);
  }
}
__name(generatePluralNode, "generatePluralNode");
function generateResource(generator, node3) {
  if (node3.body) {
    generateNode(generator, node3.body);
  } else {
    generator.push("null");
  }
}
__name(generateResource, "generateResource");
function generateNode(generator, node3) {
  const { helper } = generator;
  switch (node3.type) {
    case 0:
      generateResource(generator, node3);
      break;
    case 1:
      generatePluralNode(generator, node3);
      break;
    case 2:
      generateMessageNode(generator, node3);
      break;
    case 6:
      generateLinkedNode(generator, node3);
      break;
    case 8:
      generator.push(JSON.stringify(node3.value), node3);
      break;
    case 7:
      generator.push(JSON.stringify(node3.value), node3);
      break;
    case 5:
      generator.push(`${helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      )}(${helper(
        "list"
        /* HelperNameMap.LIST */
      )}(${node3.index}))`, node3);
      break;
    case 4:
      generator.push(`${helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      )}(${helper(
        "named"
        /* HelperNameMap.NAMED */
      )}(${JSON.stringify(node3.key)}))`, node3);
      break;
    case 9:
      generator.push(JSON.stringify(node3.value), node3);
      break;
    case 3:
      generator.push(JSON.stringify(node3.value), node3);
      break;
    default: {
      throw createCompileError(CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE, null, {
        domain: ERROR_DOMAIN,
        args: [node3.type]
      });
    }
  }
}
__name(generateNode, "generateNode");
const generate = /* @__PURE__ */ __name((ast, options3 = {}) => {
  const mode2 = isString(options3.mode) ? options3.mode : "normal";
  const filename = isString(options3.filename) ? options3.filename : "message.intl";
  const sourceMap = !!options3.sourceMap;
  const breakLineCode = options3.breakLineCode != null ? options3.breakLineCode : mode2 === "arrow" ? ";" : "\n";
  const needIndent = options3.needIndent ? options3.needIndent : mode2 !== "arrow";
  const helpers = ast.helpers || [];
  const generator = createCodeGenerator(ast, {
    mode: mode2,
    filename,
    sourceMap,
    breakLineCode,
    needIndent
  });
  generator.push(mode2 === "normal" ? `function __msg__ (ctx) {` : `(ctx) => {`);
  generator.indent(needIndent);
  if (helpers.length > 0) {
    generator.push(`const { ${join(helpers.map((s) => `${s}: _${s}`), ", ")} } = ctx`);
    generator.newline();
  }
  generator.push(`return `);
  generateNode(generator, ast);
  generator.deindent(needIndent);
  generator.push(`}`);
  delete ast.helpers;
  const { code: code2, map: map2 } = generator.context();
  return {
    ast,
    code: code2,
    map: map2 ? map2.toJSON() : void 0
    // eslint-disable-line @typescript-eslint/no-explicit-any
  };
}, "generate");
function baseCompile$1(source, options3 = {}) {
  const assignedOptions = assign({}, options3);
  const jit = !!assignedOptions.jit;
  const enalbeMinify = !!assignedOptions.minify;
  const enambeOptimize = assignedOptions.optimize == null ? true : assignedOptions.optimize;
  const parser = createParser(assignedOptions);
  const ast = parser.parse(source);
  if (!jit) {
    transform(ast, assignedOptions);
    return generate(ast, assignedOptions);
  } else {
    enambeOptimize && optimize(ast);
    enalbeMinify && minify(ast);
    return { ast, code: "" };
  }
}
__name(baseCompile$1, "baseCompile$1");
/*!
  * core-base v9.13.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
function initFeatureFlags$1() {
  if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
    getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
  }
  if (typeof __INTLIFY_JIT_COMPILATION__ !== "boolean") {
    getGlobalThis().__INTLIFY_JIT_COMPILATION__ = false;
  }
  if (typeof __INTLIFY_DROP_MESSAGE_COMPILER__ !== "boolean") {
    getGlobalThis().__INTLIFY_DROP_MESSAGE_COMPILER__ = false;
  }
}
__name(initFeatureFlags$1, "initFeatureFlags$1");
const pathStateMachine = [];
pathStateMachine[
  0
  /* States.BEFORE_PATH */
] = {
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    0
    /* States.BEFORE_PATH */
  ],
  [
    "i"
    /* PathCharTypes.IDENT */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4
    /* States.IN_SUB_PATH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: [
    7
    /* States.AFTER_PATH */
  ]
};
pathStateMachine[
  1
  /* States.IN_PATH */
] = {
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    1
    /* States.IN_PATH */
  ],
  [
    "."
    /* PathCharTypes.DOT */
  ]: [
    2
    /* States.BEFORE_IDENT */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4
    /* States.IN_SUB_PATH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: [
    7
    /* States.AFTER_PATH */
  ]
};
pathStateMachine[
  2
  /* States.BEFORE_IDENT */
] = {
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    2
    /* States.BEFORE_IDENT */
  ],
  [
    "i"
    /* PathCharTypes.IDENT */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "0"
    /* PathCharTypes.ZERO */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ]
};
pathStateMachine[
  3
  /* States.IN_IDENT */
] = {
  [
    "i"
    /* PathCharTypes.IDENT */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "0"
    /* PathCharTypes.ZERO */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    1,
    1
    /* Actions.PUSH */
  ],
  [
    "."
    /* PathCharTypes.DOT */
  ]: [
    2,
    1
    /* Actions.PUSH */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4,
    1
    /* Actions.PUSH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: [
    7,
    1
    /* Actions.PUSH */
  ]
};
pathStateMachine[
  4
  /* States.IN_SUB_PATH */
] = {
  [
    "'"
    /* PathCharTypes.SINGLE_QUOTE */
  ]: [
    5,
    0
    /* Actions.APPEND */
  ],
  [
    '"'
    /* PathCharTypes.DOUBLE_QUOTE */
  ]: [
    6,
    0
    /* Actions.APPEND */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4,
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ],
  [
    "]"
    /* PathCharTypes.RIGHT_BRACKET */
  ]: [
    1,
    3
    /* Actions.PUSH_SUB_PATH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: 8,
  [
    "l"
    /* PathCharTypes.ELSE */
  ]: [
    4,
    0
    /* Actions.APPEND */
  ]
};
pathStateMachine[
  5
  /* States.IN_SINGLE_QUOTE */
] = {
  [
    "'"
    /* PathCharTypes.SINGLE_QUOTE */
  ]: [
    4,
    0
    /* Actions.APPEND */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: 8,
  [
    "l"
    /* PathCharTypes.ELSE */
  ]: [
    5,
    0
    /* Actions.APPEND */
  ]
};
pathStateMachine[
  6
  /* States.IN_DOUBLE_QUOTE */
] = {
  [
    '"'
    /* PathCharTypes.DOUBLE_QUOTE */
  ]: [
    4,
    0
    /* Actions.APPEND */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: 8,
  [
    "l"
    /* PathCharTypes.ELSE */
  ]: [
    6,
    0
    /* Actions.APPEND */
  ]
};
const literalValueRE = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
function isLiteral(exp) {
  return literalValueRE.test(exp);
}
__name(isLiteral, "isLiteral");
function stripQuotes(str) {
  const a = str.charCodeAt(0);
  const b = str.charCodeAt(str.length - 1);
  return a === b && (a === 34 || a === 39) ? str.slice(1, -1) : str;
}
__name(stripQuotes, "stripQuotes");
function getPathCharType(ch) {
  if (ch === void 0 || ch === null) {
    return "o";
  }
  const code2 = ch.charCodeAt(0);
  switch (code2) {
    case 91:
    case 93:
    case 46:
    case 34:
    case 39:
      return ch;
    case 95:
    case 36:
    case 45:
      return "i";
    case 9:
    case 10:
    case 13:
    case 160:
    case 65279:
    case 8232:
    case 8233:
      return "w";
  }
  return "i";
}
__name(getPathCharType, "getPathCharType");
function formatSubPath(path) {
  const trimmed = path.trim();
  if (path.charAt(0) === "0" && isNaN(parseInt(path))) {
    return false;
  }
  return isLiteral(trimmed) ? stripQuotes(trimmed) : "*" + trimmed;
}
__name(formatSubPath, "formatSubPath");
function parse(path) {
  const keys2 = [];
  let index2 = -1;
  let mode2 = 0;
  let subPathDepth = 0;
  let c;
  let key;
  let newChar;
  let type;
  let transition;
  let action;
  let typeMap;
  const actions = [];
  actions[
    0
    /* Actions.APPEND */
  ] = () => {
    if (key === void 0) {
      key = newChar;
    } else {
      key += newChar;
    }
  };
  actions[
    1
    /* Actions.PUSH */
  ] = () => {
    if (key !== void 0) {
      keys2.push(key);
      key = void 0;
    }
  };
  actions[
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ] = () => {
    actions[
      0
      /* Actions.APPEND */
    ]();
    subPathDepth++;
  };
  actions[
    3
    /* Actions.PUSH_SUB_PATH */
  ] = () => {
    if (subPathDepth > 0) {
      subPathDepth--;
      mode2 = 4;
      actions[
        0
        /* Actions.APPEND */
      ]();
    } else {
      subPathDepth = 0;
      if (key === void 0) {
        return false;
      }
      key = formatSubPath(key);
      if (key === false) {
        return false;
      } else {
        actions[
          1
          /* Actions.PUSH */
        ]();
      }
    }
  };
  function maybeUnescapeQuote() {
    const nextChar = path[index2 + 1];
    if (mode2 === 5 && nextChar === "'" || mode2 === 6 && nextChar === '"') {
      index2++;
      newChar = "\\" + nextChar;
      actions[
        0
        /* Actions.APPEND */
      ]();
      return true;
    }
  }
  __name(maybeUnescapeQuote, "maybeUnescapeQuote");
  while (mode2 !== null) {
    index2++;
    c = path[index2];
    if (c === "\\" && maybeUnescapeQuote()) {
      continue;
    }
    type = getPathCharType(c);
    typeMap = pathStateMachine[mode2];
    transition = typeMap[type] || typeMap[
      "l"
      /* PathCharTypes.ELSE */
    ] || 8;
    if (transition === 8) {
      return;
    }
    mode2 = transition[0];
    if (transition[1] !== void 0) {
      action = actions[transition[1]];
      if (action) {
        newChar = c;
        if (action() === false) {
          return;
        }
      }
    }
    if (mode2 === 7) {
      return keys2;
    }
  }
}
__name(parse, "parse");
const cache = /* @__PURE__ */ new Map();
function resolveWithKeyValue(obj, path) {
  return isObject$1(obj) ? obj[path] : null;
}
__name(resolveWithKeyValue, "resolveWithKeyValue");
function resolveValue(obj, path) {
  if (!isObject$1(obj)) {
    return null;
  }
  let hit = cache.get(path);
  if (!hit) {
    hit = parse(path);
    if (hit) {
      cache.set(path, hit);
    }
  }
  if (!hit) {
    return null;
  }
  const len = hit.length;
  let last = obj;
  let i2 = 0;
  while (i2 < len) {
    const val = last[hit[i2]];
    if (val === void 0) {
      return null;
    }
    if (isFunction$1(last)) {
      return null;
    }
    last = val;
    i2++;
  }
  return last;
}
__name(resolveValue, "resolveValue");
const DEFAULT_MODIFIER = /* @__PURE__ */ __name((str) => str, "DEFAULT_MODIFIER");
const DEFAULT_MESSAGE = /* @__PURE__ */ __name((ctx) => "", "DEFAULT_MESSAGE");
const DEFAULT_MESSAGE_DATA_TYPE = "text";
const DEFAULT_NORMALIZE = /* @__PURE__ */ __name((values2) => values2.length === 0 ? "" : join$1(values2), "DEFAULT_NORMALIZE");
const DEFAULT_INTERPOLATE = toDisplayString;
function pluralDefault(choice, choicesLength) {
  choice = Math.abs(choice);
  if (choicesLength === 2) {
    return choice ? choice > 1 ? 1 : 0 : 1;
  }
  return choice ? Math.min(choice, 2) : 0;
}
__name(pluralDefault, "pluralDefault");
function getPluralIndex(options3) {
  const index2 = isNumber(options3.pluralIndex) ? options3.pluralIndex : -1;
  return options3.named && (isNumber(options3.named.count) || isNumber(options3.named.n)) ? isNumber(options3.named.count) ? options3.named.count : isNumber(options3.named.n) ? options3.named.n : index2 : index2;
}
__name(getPluralIndex, "getPluralIndex");
function normalizeNamed(pluralIndex, props) {
  if (!props.count) {
    props.count = pluralIndex;
  }
  if (!props.n) {
    props.n = pluralIndex;
  }
}
__name(normalizeNamed, "normalizeNamed");
function createMessageContext(options3 = {}) {
  const locale2 = options3.locale;
  const pluralIndex = getPluralIndex(options3);
  const pluralRule = isObject$1(options3.pluralRules) && isString$1(locale2) && isFunction$1(options3.pluralRules[locale2]) ? options3.pluralRules[locale2] : pluralDefault;
  const orgPluralRule = isObject$1(options3.pluralRules) && isString$1(locale2) && isFunction$1(options3.pluralRules[locale2]) ? pluralDefault : void 0;
  const plural = /* @__PURE__ */ __name((messages2) => {
    return messages2[pluralRule(pluralIndex, messages2.length, orgPluralRule)];
  }, "plural");
  const _list = options3.list || [];
  const list = /* @__PURE__ */ __name((index2) => _list[index2], "list");
  const _named = options3.named || {};
  isNumber(options3.pluralIndex) && normalizeNamed(pluralIndex, _named);
  const named = /* @__PURE__ */ __name((key) => _named[key], "named");
  function message3(key) {
    const msg = isFunction$1(options3.messages) ? options3.messages(key) : isObject$1(options3.messages) ? options3.messages[key] : false;
    return !msg ? options3.parent ? options3.parent.message(key) : DEFAULT_MESSAGE : msg;
  }
  __name(message3, "message");
  const _modifier = /* @__PURE__ */ __name((name) => options3.modifiers ? options3.modifiers[name] : DEFAULT_MODIFIER, "_modifier");
  const normalize = isPlainObject(options3.processor) && isFunction$1(options3.processor.normalize) ? options3.processor.normalize : DEFAULT_NORMALIZE;
  const interpolate = isPlainObject(options3.processor) && isFunction$1(options3.processor.interpolate) ? options3.processor.interpolate : DEFAULT_INTERPOLATE;
  const type = isPlainObject(options3.processor) && isString$1(options3.processor.type) ? options3.processor.type : DEFAULT_MESSAGE_DATA_TYPE;
  const linked = /* @__PURE__ */ __name((key, ...args) => {
    const [arg1, arg2] = args;
    let type2 = "text";
    let modifier = "";
    if (args.length === 1) {
      if (isObject$1(arg1)) {
        modifier = arg1.modifier || modifier;
        type2 = arg1.type || type2;
      } else if (isString$1(arg1)) {
        modifier = arg1 || modifier;
      }
    } else if (args.length === 2) {
      if (isString$1(arg1)) {
        modifier = arg1 || modifier;
      }
      if (isString$1(arg2)) {
        type2 = arg2 || type2;
      }
    }
    const ret = message3(key)(ctx);
    const msg = (
      // The message in vnode resolved with linked are returned as an array by processor.nomalize
      type2 === "vnode" && isArray(ret) && modifier ? ret[0] : ret
    );
    return modifier ? _modifier(modifier)(msg, type2) : msg;
  }, "linked");
  const ctx = {
    [
      "list"
      /* HelperNameMap.LIST */
    ]: list,
    [
      "named"
      /* HelperNameMap.NAMED */
    ]: named,
    [
      "plural"
      /* HelperNameMap.PLURAL */
    ]: plural,
    [
      "linked"
      /* HelperNameMap.LINKED */
    ]: linked,
    [
      "message"
      /* HelperNameMap.MESSAGE */
    ]: message3,
    [
      "type"
      /* HelperNameMap.TYPE */
    ]: type,
    [
      "interpolate"
      /* HelperNameMap.INTERPOLATE */
    ]: interpolate,
    [
      "normalize"
      /* HelperNameMap.NORMALIZE */
    ]: normalize,
    [
      "values"
      /* HelperNameMap.VALUES */
    ]: assign$1({}, _list, _named)
  };
  return ctx;
}
__name(createMessageContext, "createMessageContext");
let devtools = null;
function setDevToolsHook(hook) {
  devtools = hook;
}
__name(setDevToolsHook, "setDevToolsHook");
function getDevToolsHook() {
  return devtools;
}
__name(getDevToolsHook, "getDevToolsHook");
function initI18nDevTools(i18n2, version2, meta) {
  devtools && devtools.emit("i18n:init", {
    timestamp: Date.now(),
    i18n: i18n2,
    version: version2,
    meta
  });
}
__name(initI18nDevTools, "initI18nDevTools");
const translateDevTools = /* @__PURE__ */ createDevToolsHook(
  "function:translate"
  /* IntlifyDevToolsHooks.FunctionTranslate */
);
function createDevToolsHook(hook) {
  return (payloads) => devtools && devtools.emit(hook, payloads);
}
__name(createDevToolsHook, "createDevToolsHook");
const code$1$1 = CompileWarnCodes.__EXTEND_POINT__;
const inc$1$1 = incrementer(code$1$1);
const CoreWarnCodes = {
  NOT_FOUND_KEY: code$1$1,
  // 2
  FALLBACK_TO_TRANSLATE: inc$1$1(),
  // 3
  CANNOT_FORMAT_NUMBER: inc$1$1(),
  // 4
  FALLBACK_TO_NUMBER_FORMAT: inc$1$1(),
  // 5
  CANNOT_FORMAT_DATE: inc$1$1(),
  // 6
  FALLBACK_TO_DATE_FORMAT: inc$1$1(),
  // 7
  EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER: inc$1$1(),
  // 8
  __EXTEND_POINT__: inc$1$1()
  // 9
};
const warnMessages$1 = {
  [CoreWarnCodes.NOT_FOUND_KEY]: `Not found '{key}' key in '{locale}' locale messages.`,
  [CoreWarnCodes.FALLBACK_TO_TRANSLATE]: `Fall back to translate '{key}' key with '{target}' locale.`,
  [CoreWarnCodes.CANNOT_FORMAT_NUMBER]: `Cannot format a number value due to not supported Intl.NumberFormat.`,
  [CoreWarnCodes.FALLBACK_TO_NUMBER_FORMAT]: `Fall back to number format '{key}' key with '{target}' locale.`,
  [CoreWarnCodes.CANNOT_FORMAT_DATE]: `Cannot format a date value due to not supported Intl.DateTimeFormat.`,
  [CoreWarnCodes.FALLBACK_TO_DATE_FORMAT]: `Fall back to datetime format '{key}' key with '{target}' locale.`,
  [CoreWarnCodes.EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER]: `This project is using Custom Message Compiler, which is an experimental feature. It may receive breaking changes or be removed in the future.`
};
function getWarnMessage$1(code2, ...args) {
  return format$2(warnMessages$1[code2], ...args);
}
__name(getWarnMessage$1, "getWarnMessage$1");
const code$2 = CompileErrorCodes.__EXTEND_POINT__;
const inc$2 = incrementer(code$2);
const CoreErrorCodes = {
  INVALID_ARGUMENT: code$2,
  // 17
  INVALID_DATE_ARGUMENT: inc$2(),
  // 18
  INVALID_ISO_DATE_ARGUMENT: inc$2(),
  // 19
  NOT_SUPPORT_NON_STRING_MESSAGE: inc$2(),
  // 20
  NOT_SUPPORT_LOCALE_PROMISE_VALUE: inc$2(),
  // 21
  NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: inc$2(),
  // 22
  NOT_SUPPORT_LOCALE_TYPE: inc$2(),
  // 23
  __EXTEND_POINT__: inc$2()
  // 24
};
function createCoreError(code2) {
  return createCompileError(code2, null, false ? { messages: errorMessages$1 } : void 0);
}
__name(createCoreError, "createCoreError");
const errorMessages$1 = {
  [CoreErrorCodes.INVALID_ARGUMENT]: "Invalid arguments",
  [CoreErrorCodes.INVALID_DATE_ARGUMENT]: "The date provided is an invalid Date object.Make sure your Date represents a valid date.",
  [CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT]: "The argument provided is not a valid ISO date string",
  [CoreErrorCodes.NOT_SUPPORT_NON_STRING_MESSAGE]: "Not support non-string message",
  [CoreErrorCodes.NOT_SUPPORT_LOCALE_PROMISE_VALUE]: "cannot support promise value",
  [CoreErrorCodes.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION]: "cannot support async function",
  [CoreErrorCodes.NOT_SUPPORT_LOCALE_TYPE]: "cannot support locale type"
};
function getLocale(context, options3) {
  return options3.locale != null ? resolveLocale(options3.locale) : resolveLocale(context.locale);
}
__name(getLocale, "getLocale");
let _resolveLocale;
function resolveLocale(locale2) {
  if (isString$1(locale2)) {
    return locale2;
  } else {
    if (isFunction$1(locale2)) {
      if (locale2.resolvedOnce && _resolveLocale != null) {
        return _resolveLocale;
      } else if (locale2.constructor.name === "Function") {
        const resolve8 = locale2();
        if (isPromise(resolve8)) {
          throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
        }
        return _resolveLocale = resolve8;
      } else {
        throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION);
      }
    } else {
      throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_TYPE);
    }
  }
}
__name(resolveLocale, "resolveLocale");
function fallbackWithSimple(ctx, fallback, start2) {
  return [.../* @__PURE__ */ new Set([
    start2,
    ...isArray(fallback) ? fallback : isObject$1(fallback) ? Object.keys(fallback) : isString$1(fallback) ? [fallback] : [start2]
  ])];
}
__name(fallbackWithSimple, "fallbackWithSimple");
function fallbackWithLocaleChain(ctx, fallback, start2) {
  const startLocale = isString$1(start2) ? start2 : DEFAULT_LOCALE;
  const context = ctx;
  if (!context.__localeChainCache) {
    context.__localeChainCache = /* @__PURE__ */ new Map();
  }
  let chain = context.__localeChainCache.get(startLocale);
  if (!chain) {
    chain = [];
    let block2 = [start2];
    while (isArray(block2)) {
      block2 = appendBlockToChain(chain, block2, fallback);
    }
    const defaults2 = isArray(fallback) || !isPlainObject(fallback) ? fallback : fallback["default"] ? fallback["default"] : null;
    block2 = isString$1(defaults2) ? [defaults2] : defaults2;
    if (isArray(block2)) {
      appendBlockToChain(chain, block2, false);
    }
    context.__localeChainCache.set(startLocale, chain);
  }
  return chain;
}
__name(fallbackWithLocaleChain, "fallbackWithLocaleChain");
function appendBlockToChain(chain, block2, blocks) {
  let follow = true;
  for (let i2 = 0; i2 < block2.length && isBoolean(follow); i2++) {
    const locale2 = block2[i2];
    if (isString$1(locale2)) {
      follow = appendLocaleToChain(chain, block2[i2], blocks);
    }
  }
  return follow;
}
__name(appendBlockToChain, "appendBlockToChain");
function appendLocaleToChain(chain, locale2, blocks) {
  let follow;
  const tokens = locale2.split("-");
  do {
    const target = tokens.join("-");
    follow = appendItemToChain(chain, target, blocks);
    tokens.splice(-1, 1);
  } while (tokens.length && follow === true);
  return follow;
}
__name(appendLocaleToChain, "appendLocaleToChain");
function appendItemToChain(chain, target, blocks) {
  let follow = false;
  if (!chain.includes(target)) {
    follow = true;
    if (target) {
      follow = target[target.length - 1] !== "!";
      const locale2 = target.replace(/!/g, "");
      chain.push(locale2);
      if ((isArray(blocks) || isPlainObject(blocks)) && blocks[locale2]) {
        follow = blocks[locale2];
      }
    }
  }
  return follow;
}
__name(appendItemToChain, "appendItemToChain");
const VERSION$1 = "9.13.1";
const NOT_REOSLVED = -1;
const DEFAULT_LOCALE = "en-US";
const MISSING_RESOLVE_VALUE = "";
const capitalize = /* @__PURE__ */ __name((str) => `${str.charAt(0).toLocaleUpperCase()}${str.substr(1)}`, "capitalize");
function getDefaultLinkedModifiers() {
  return {
    upper: /* @__PURE__ */ __name((val, type) => {
      return type === "text" && isString$1(val) ? val.toUpperCase() : type === "vnode" && isObject$1(val) && "__v_isVNode" in val ? val.children.toUpperCase() : val;
    }, "upper"),
    lower: /* @__PURE__ */ __name((val, type) => {
      return type === "text" && isString$1(val) ? val.toLowerCase() : type === "vnode" && isObject$1(val) && "__v_isVNode" in val ? val.children.toLowerCase() : val;
    }, "lower"),
    capitalize: /* @__PURE__ */ __name((val, type) => {
      return type === "text" && isString$1(val) ? capitalize(val) : type === "vnode" && isObject$1(val) && "__v_isVNode" in val ? capitalize(val.children) : val;
    }, "capitalize")
  };
}
__name(getDefaultLinkedModifiers, "getDefaultLinkedModifiers");
let _compiler;
function registerMessageCompiler(compiler) {
  _compiler = compiler;
}
__name(registerMessageCompiler, "registerMessageCompiler");
let _resolver;
function registerMessageResolver(resolver) {
  _resolver = resolver;
}
__name(registerMessageResolver, "registerMessageResolver");
let _fallbacker;
function registerLocaleFallbacker(fallbacker) {
  _fallbacker = fallbacker;
}
__name(registerLocaleFallbacker, "registerLocaleFallbacker");
let _additionalMeta = null;
const setAdditionalMeta = /* @__PURE__ */ __name(/* @__NO_SIDE_EFFECTS__ */ (meta) => {
  _additionalMeta = meta;
}, "setAdditionalMeta");
const getAdditionalMeta = /* @__PURE__ */ __name(/* @__NO_SIDE_EFFECTS__ */ () => _additionalMeta, "getAdditionalMeta");
let _fallbackContext = null;
const setFallbackContext = /* @__PURE__ */ __name((context) => {
  _fallbackContext = context;
}, "setFallbackContext");
const getFallbackContext = /* @__PURE__ */ __name(() => _fallbackContext, "getFallbackContext");
let _cid = 0;
function createCoreContext(options3 = {}) {
  const onWarn = isFunction$1(options3.onWarn) ? options3.onWarn : warn;
  const version2 = isString$1(options3.version) ? options3.version : VERSION$1;
  const locale2 = isString$1(options3.locale) || isFunction$1(options3.locale) ? options3.locale : DEFAULT_LOCALE;
  const _locale = isFunction$1(locale2) ? DEFAULT_LOCALE : locale2;
  const fallbackLocale = isArray(options3.fallbackLocale) || isPlainObject(options3.fallbackLocale) || isString$1(options3.fallbackLocale) || options3.fallbackLocale === false ? options3.fallbackLocale : _locale;
  const messages2 = isPlainObject(options3.messages) ? options3.messages : { [_locale]: {} };
  const datetimeFormats = isPlainObject(options3.datetimeFormats) ? options3.datetimeFormats : { [_locale]: {} };
  const numberFormats = isPlainObject(options3.numberFormats) ? options3.numberFormats : { [_locale]: {} };
  const modifiers = assign$1({}, options3.modifiers || {}, getDefaultLinkedModifiers());
  const pluralRules = options3.pluralRules || {};
  const missing = isFunction$1(options3.missing) ? options3.missing : null;
  const missingWarn = isBoolean(options3.missingWarn) || isRegExp(options3.missingWarn) ? options3.missingWarn : true;
  const fallbackWarn = isBoolean(options3.fallbackWarn) || isRegExp(options3.fallbackWarn) ? options3.fallbackWarn : true;
  const fallbackFormat = !!options3.fallbackFormat;
  const unresolving = !!options3.unresolving;
  const postTranslation = isFunction$1(options3.postTranslation) ? options3.postTranslation : null;
  const processor = isPlainObject(options3.processor) ? options3.processor : null;
  const warnHtmlMessage = isBoolean(options3.warnHtmlMessage) ? options3.warnHtmlMessage : true;
  const escapeParameter = !!options3.escapeParameter;
  const messageCompiler = isFunction$1(options3.messageCompiler) ? options3.messageCompiler : _compiler;
  if (false) {
    warnOnce(getWarnMessage$1(CoreWarnCodes.EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER));
  }
  const messageResolver = isFunction$1(options3.messageResolver) ? options3.messageResolver : _resolver || resolveWithKeyValue;
  const localeFallbacker = isFunction$1(options3.localeFallbacker) ? options3.localeFallbacker : _fallbacker || fallbackWithSimple;
  const fallbackContext = isObject$1(options3.fallbackContext) ? options3.fallbackContext : void 0;
  const internalOptions = options3;
  const __datetimeFormatters = isObject$1(internalOptions.__datetimeFormatters) ? internalOptions.__datetimeFormatters : /* @__PURE__ */ new Map();
  const __numberFormatters = isObject$1(internalOptions.__numberFormatters) ? internalOptions.__numberFormatters : /* @__PURE__ */ new Map();
  const __meta = isObject$1(internalOptions.__meta) ? internalOptions.__meta : {};
  _cid++;
  const context = {
    version: version2,
    cid: _cid,
    locale: locale2,
    fallbackLocale,
    messages: messages2,
    modifiers,
    pluralRules,
    missing,
    missingWarn,
    fallbackWarn,
    fallbackFormat,
    unresolving,
    postTranslation,
    processor,
    warnHtmlMessage,
    escapeParameter,
    messageCompiler,
    messageResolver,
    localeFallbacker,
    fallbackContext,
    onWarn,
    __meta
  };
  {
    context.datetimeFormats = datetimeFormats;
    context.numberFormats = numberFormats;
    context.__datetimeFormatters = __datetimeFormatters;
    context.__numberFormatters = __numberFormatters;
  }
  if (false) {
    context.__v_emitter = internalOptions.__v_emitter != null ? internalOptions.__v_emitter : void 0;
  }
  if (__INTLIFY_PROD_DEVTOOLS__) {
    initI18nDevTools(context, version2, __meta);
  }
  return context;
}
__name(createCoreContext, "createCoreContext");
function isTranslateFallbackWarn(fallback, key) {
  return fallback instanceof RegExp ? fallback.test(key) : fallback;
}
__name(isTranslateFallbackWarn, "isTranslateFallbackWarn");
function isTranslateMissingWarn(missing, key) {
  return missing instanceof RegExp ? missing.test(key) : missing;
}
__name(isTranslateMissingWarn, "isTranslateMissingWarn");
function handleMissing(context, key, locale2, missingWarn, type) {
  const { missing, onWarn } = context;
  if (false) {
    const emitter = context.__v_emitter;
    if (emitter) {
      emitter.emit("missing", {
        locale: locale2,
        key,
        type,
        groupId: `${type}:${key}`
      });
    }
  }
  if (missing !== null) {
    const ret = missing(context, locale2, key, type);
    return isString$1(ret) ? ret : key;
  } else {
    if (false) {
      onWarn(getWarnMessage$1(CoreWarnCodes.NOT_FOUND_KEY, { key, locale: locale2 }));
    }
    return key;
  }
}
__name(handleMissing, "handleMissing");
function updateFallbackLocale(ctx, locale2, fallback) {
  const context = ctx;
  context.__localeChainCache = /* @__PURE__ */ new Map();
  ctx.localeFallbacker(ctx, fallback, locale2);
}
__name(updateFallbackLocale, "updateFallbackLocale");
function isAlmostSameLocale(locale2, compareLocale) {
  if (locale2 === compareLocale)
    return false;
  return locale2.split("-")[0] === compareLocale.split("-")[0];
}
__name(isAlmostSameLocale, "isAlmostSameLocale");
function isImplicitFallback(targetLocale, locales) {
  const index2 = locales.indexOf(targetLocale);
  if (index2 === -1) {
    return false;
  }
  for (let i2 = index2 + 1; i2 < locales.length; i2++) {
    if (isAlmostSameLocale(targetLocale, locales[i2])) {
      return true;
    }
  }
  return false;
}
__name(isImplicitFallback, "isImplicitFallback");
function format(ast) {
  const msg = /* @__PURE__ */ __name((ctx) => formatParts(ctx, ast), "msg");
  return msg;
}
__name(format, "format");
function formatParts(ctx, ast) {
  const body = ast.b || ast.body;
  if ((body.t || body.type) === 1) {
    const plural = body;
    const cases = plural.c || plural.cases;
    return ctx.plural(cases.reduce((messages2, c) => [
      ...messages2,
      formatMessageParts(ctx, c)
    ], []));
  } else {
    return formatMessageParts(ctx, body);
  }
}
__name(formatParts, "formatParts");
function formatMessageParts(ctx, node3) {
  const _static = node3.s || node3.static;
  if (_static) {
    return ctx.type === "text" ? _static : ctx.normalize([_static]);
  } else {
    const messages2 = (node3.i || node3.items).reduce((acm, c) => [...acm, formatMessagePart(ctx, c)], []);
    return ctx.normalize(messages2);
  }
}
__name(formatMessageParts, "formatMessageParts");
function formatMessagePart(ctx, node3) {
  const type = node3.t || node3.type;
  switch (type) {
    case 3: {
      const text = node3;
      return text.v || text.value;
    }
    case 9: {
      const literal = node3;
      return literal.v || literal.value;
    }
    case 4: {
      const named = node3;
      return ctx.interpolate(ctx.named(named.k || named.key));
    }
    case 5: {
      const list = node3;
      return ctx.interpolate(ctx.list(list.i != null ? list.i : list.index));
    }
    case 6: {
      const linked = node3;
      const modifier = linked.m || linked.modifier;
      return ctx.linked(formatMessagePart(ctx, linked.k || linked.key), modifier ? formatMessagePart(ctx, modifier) : void 0, ctx.type);
    }
    case 7: {
      const linkedKey = node3;
      return linkedKey.v || linkedKey.value;
    }
    case 8: {
      const linkedModifier = node3;
      return linkedModifier.v || linkedModifier.value;
    }
    default:
      throw new Error(`unhandled node type on format message part: ${type}`);
  }
}
__name(formatMessagePart, "formatMessagePart");
const WARN_MESSAGE = `Detected HTML in '{source}' message. Recommend not using HTML messages to avoid XSS.`;
function checkHtmlMessage(source, warnHtmlMessage) {
  if (warnHtmlMessage && detectHtmlTag(source)) {
    warn(format$2(WARN_MESSAGE, { source }));
  }
}
__name(checkHtmlMessage, "checkHtmlMessage");
const defaultOnCacheKey = /* @__PURE__ */ __name((message3) => message3, "defaultOnCacheKey");
let compileCache = /* @__PURE__ */ Object.create(null);
function onCompileWarn(_warn) {
  if (_warn.code === CompileWarnCodes.USE_MODULO_SYNTAX) {
    warn(`The use of named interpolation with modulo syntax is deprecated. It will be removed in v10.
reference: https://vue-i18n.intlify.dev/guide/essentials/syntax#rails-i18n-format 
(message compiler warning message: ${_warn.message})`);
  }
}
__name(onCompileWarn, "onCompileWarn");
function clearCompileCache() {
  compileCache = /* @__PURE__ */ Object.create(null);
}
__name(clearCompileCache, "clearCompileCache");
const isMessageAST = /* @__PURE__ */ __name((val) => isObject$1(val) && (val.t === 0 || val.type === 0) && ("b" in val || "body" in val), "isMessageAST");
function baseCompile(message3, options3 = {}) {
  let detectError = false;
  const onError = options3.onError || defaultOnError;
  options3.onError = (err) => {
    detectError = true;
    onError(err);
  };
  return { ...baseCompile$1(message3, options3), detectError };
}
__name(baseCompile, "baseCompile");
const compileToFunction = /* @__PURE__ */ __name(/* @__NO_SIDE_EFFECTS__ */ (message3, context) => {
  if (!isString$1(message3)) {
    throw createCoreError(CoreErrorCodes.NOT_SUPPORT_NON_STRING_MESSAGE);
  }
  if (false) {
    context.onWarn = onCompileWarn;
  }
  {
    const warnHtmlMessage = isBoolean(context.warnHtmlMessage) ? context.warnHtmlMessage : true;
    const onCacheKey = context.onCacheKey || defaultOnCacheKey;
    const cacheKey = onCacheKey(message3);
    const cached = compileCache[cacheKey];
    if (cached) {
      return cached;
    }
    const { code: code2, detectError } = baseCompile(message3, context);
    const msg = new Function(`return ${code2}`)();
    return !detectError ? compileCache[cacheKey] = msg : msg;
  }
}, "compileToFunction");
function compile(message3, context) {
  if (false) {
    context.onWarn = onCompileWarn;
  }
  if (__INTLIFY_JIT_COMPILATION__ && !__INTLIFY_DROP_MESSAGE_COMPILER__ && isString$1(message3)) {
    const warnHtmlMessage = isBoolean(context.warnHtmlMessage) ? context.warnHtmlMessage : true;
    const onCacheKey = context.onCacheKey || defaultOnCacheKey;
    const cacheKey = onCacheKey(message3);
    const cached = compileCache[cacheKey];
    if (cached) {
      return cached;
    }
    const { ast, detectError } = baseCompile(message3, {
      ...context,
      location: false,
      jit: true
    });
    const msg = format(ast);
    return !detectError ? compileCache[cacheKey] = msg : msg;
  } else {
    if (false) {
      warn(`the message that is resolve with key '${context.key}' is not supported for jit compilation`);
      return () => message3;
    }
    const cacheKey = message3.cacheKey;
    if (cacheKey) {
      const cached = compileCache[cacheKey];
      if (cached) {
        return cached;
      }
      return compileCache[cacheKey] = format(message3);
    } else {
      return format(message3);
    }
  }
}
__name(compile, "compile");
const NOOP_MESSAGE_FUNCTION = /* @__PURE__ */ __name(() => "", "NOOP_MESSAGE_FUNCTION");
const isMessageFunction = /* @__PURE__ */ __name((val) => isFunction$1(val), "isMessageFunction");
function translate(context, ...args) {
  const { fallbackFormat, postTranslation, unresolving, messageCompiler, fallbackLocale, messages: messages2 } = context;
  const [key, options3] = parseTranslateArgs(...args);
  const missingWarn = isBoolean(options3.missingWarn) ? options3.missingWarn : context.missingWarn;
  const fallbackWarn = isBoolean(options3.fallbackWarn) ? options3.fallbackWarn : context.fallbackWarn;
  const escapeParameter = isBoolean(options3.escapeParameter) ? options3.escapeParameter : context.escapeParameter;
  const resolvedMessage = !!options3.resolvedMessage;
  const defaultMsgOrKey = isString$1(options3.default) || isBoolean(options3.default) ? !isBoolean(options3.default) ? options3.default : !messageCompiler ? () => key : key : fallbackFormat ? !messageCompiler ? () => key : key : "";
  const enableDefaultMsg = fallbackFormat || defaultMsgOrKey !== "";
  const locale2 = getLocale(context, options3);
  escapeParameter && escapeParams(options3);
  let [formatScope, targetLocale, message3] = !resolvedMessage ? resolveMessageFormat(context, key, locale2, fallbackLocale, fallbackWarn, missingWarn) : [
    key,
    locale2,
    messages2[locale2] || {}
  ];
  let format2 = formatScope;
  let cacheBaseKey = key;
  if (!resolvedMessage && !(isString$1(format2) || isMessageAST(format2) || isMessageFunction(format2))) {
    if (enableDefaultMsg) {
      format2 = defaultMsgOrKey;
      cacheBaseKey = format2;
    }
  }
  if (!resolvedMessage && (!(isString$1(format2) || isMessageAST(format2) || isMessageFunction(format2)) || !isString$1(targetLocale))) {
    return unresolving ? NOT_REOSLVED : key;
  }
  if (false) {
    warn(`The message format compilation is not supported in this build. Because message compiler isn't included. You need to pre-compilation all message format. So translate function return '${key}'.`);
    return key;
  }
  let occurred = false;
  const onError = /* @__PURE__ */ __name(() => {
    occurred = true;
  }, "onError");
  const msg = !isMessageFunction(format2) ? compileMessageFormat(context, key, targetLocale, format2, cacheBaseKey, onError) : format2;
  if (occurred) {
    return format2;
  }
  const ctxOptions = getMessageContextOptions(context, targetLocale, message3, options3);
  const msgContext = createMessageContext(ctxOptions);
  const messaged = evaluateMessage(context, msg, msgContext);
  const ret = postTranslation ? postTranslation(messaged, key) : messaged;
  if (__INTLIFY_PROD_DEVTOOLS__) {
    const payloads = {
      timestamp: Date.now(),
      key: isString$1(key) ? key : isMessageFunction(format2) ? format2.key : "",
      locale: targetLocale || (isMessageFunction(format2) ? format2.locale : ""),
      format: isString$1(format2) ? format2 : isMessageFunction(format2) ? format2.source : "",
      message: ret
    };
    payloads.meta = assign$1({}, context.__meta, /* @__PURE__ */ getAdditionalMeta() || {});
    translateDevTools(payloads);
  }
  return ret;
}
__name(translate, "translate");
function escapeParams(options3) {
  if (isArray(options3.list)) {
    options3.list = options3.list.map((item2) => isString$1(item2) ? escapeHtml(item2) : item2);
  } else if (isObject$1(options3.named)) {
    Object.keys(options3.named).forEach((key) => {
      if (isString$1(options3.named[key])) {
        options3.named[key] = escapeHtml(options3.named[key]);
      }
    });
  }
}
__name(escapeParams, "escapeParams");
function resolveMessageFormat(context, key, locale2, fallbackLocale, fallbackWarn, missingWarn) {
  const { messages: messages2, onWarn, messageResolver: resolveValue2, localeFallbacker } = context;
  const locales = localeFallbacker(context, fallbackLocale, locale2);
  let message3 = {};
  let targetLocale;
  let format2 = null;
  let from = locale2;
  let to = null;
  const type = "translate";
  for (let i2 = 0; i2 < locales.length; i2++) {
    targetLocale = to = locales[i2];
    if (false) {
      onWarn(getWarnMessage$1(CoreWarnCodes.FALLBACK_TO_TRANSLATE, {
        key,
        target: targetLocale
      }));
    }
    if (false) {
      const emitter = context.__v_emitter;
      if (emitter) {
        emitter.emit("fallback", {
          type,
          key,
          from,
          to,
          groupId: `${type}:${key}`
        });
      }
    }
    message3 = messages2[targetLocale] || {};
    let start2 = null;
    let startTag;
    let endTag;
    if (false) {
      start2 = window.performance.now();
      startTag = "intlify-message-resolve-start";
      endTag = "intlify-message-resolve-end";
      mark && mark(startTag);
    }
    if ((format2 = resolveValue2(message3, key)) === null) {
      format2 = message3[key];
    }
    if (false) {
      const end = window.performance.now();
      const emitter = context.__v_emitter;
      if (emitter && start2 && format2) {
        emitter.emit("message-resolve", {
          type: "message-resolve",
          key,
          message: format2,
          time: end - start2,
          groupId: `${type}:${key}`
        });
      }
      if (startTag && endTag && mark && measure) {
        mark(endTag);
        measure("intlify message resolve", startTag, endTag);
      }
    }
    if (isString$1(format2) || isMessageAST(format2) || isMessageFunction(format2)) {
      break;
    }
    if (!isImplicitFallback(targetLocale, locales)) {
      const missingRet = handleMissing(
        context,
        // eslint-disable-line @typescript-eslint/no-explicit-any
        key,
        targetLocale,
        missingWarn,
        type
      );
      if (missingRet !== key) {
        format2 = missingRet;
      }
    }
    from = to;
  }
  return [format2, targetLocale, message3];
}
__name(resolveMessageFormat, "resolveMessageFormat");
function compileMessageFormat(context, key, targetLocale, format2, cacheBaseKey, onError) {
  const { messageCompiler, warnHtmlMessage } = context;
  if (isMessageFunction(format2)) {
    const msg2 = format2;
    msg2.locale = msg2.locale || targetLocale;
    msg2.key = msg2.key || key;
    return msg2;
  }
  if (messageCompiler == null) {
    const msg2 = /* @__PURE__ */ __name(() => format2, "msg2");
    msg2.locale = targetLocale;
    msg2.key = key;
    return msg2;
  }
  let start2 = null;
  let startTag;
  let endTag;
  if (false) {
    start2 = window.performance.now();
    startTag = "intlify-message-compilation-start";
    endTag = "intlify-message-compilation-end";
    mark && mark(startTag);
  }
  const msg = messageCompiler(format2, getCompileContext(context, targetLocale, cacheBaseKey, format2, warnHtmlMessage, onError));
  if (false) {
    const end = window.performance.now();
    const emitter = context.__v_emitter;
    if (emitter && start2) {
      emitter.emit("message-compilation", {
        type: "message-compilation",
        message: format2,
        time: end - start2,
        groupId: `${"translate"}:${key}`
      });
    }
    if (startTag && endTag && mark && measure) {
      mark(endTag);
      measure("intlify message compilation", startTag, endTag);
    }
  }
  msg.locale = targetLocale;
  msg.key = key;
  msg.source = format2;
  return msg;
}
__name(compileMessageFormat, "compileMessageFormat");
function evaluateMessage(context, msg, msgCtx) {
  let start2 = null;
  let startTag;
  let endTag;
  if (false) {
    start2 = window.performance.now();
    startTag = "intlify-message-evaluation-start";
    endTag = "intlify-message-evaluation-end";
    mark && mark(startTag);
  }
  const messaged = msg(msgCtx);
  if (false) {
    const end = window.performance.now();
    const emitter = context.__v_emitter;
    if (emitter && start2) {
      emitter.emit("message-evaluation", {
        type: "message-evaluation",
        value: messaged,
        time: end - start2,
        groupId: `${"translate"}:${msg.key}`
      });
    }
    if (startTag && endTag && mark && measure) {
      mark(endTag);
      measure("intlify message evaluation", startTag, endTag);
    }
  }
  return messaged;
}
__name(evaluateMessage, "evaluateMessage");
function parseTranslateArgs(...args) {
  const [arg1, arg2, arg3] = args;
  const options3 = {};
  if (!isString$1(arg1) && !isNumber(arg1) && !isMessageFunction(arg1) && !isMessageAST(arg1)) {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  const key = isNumber(arg1) ? String(arg1) : isMessageFunction(arg1) ? arg1 : arg1;
  if (isNumber(arg2)) {
    options3.plural = arg2;
  } else if (isString$1(arg2)) {
    options3.default = arg2;
  } else if (isPlainObject(arg2) && !isEmptyObject(arg2)) {
    options3.named = arg2;
  } else if (isArray(arg2)) {
    options3.list = arg2;
  }
  if (isNumber(arg3)) {
    options3.plural = arg3;
  } else if (isString$1(arg3)) {
    options3.default = arg3;
  } else if (isPlainObject(arg3)) {
    assign$1(options3, arg3);
  }
  return [key, options3];
}
__name(parseTranslateArgs, "parseTranslateArgs");
function getCompileContext(context, locale2, key, source, warnHtmlMessage, onError) {
  return {
    locale: locale2,
    key,
    warnHtmlMessage,
    onError: /* @__PURE__ */ __name((err) => {
      onError && onError(err);
      if (false) {
        const _source = getSourceForCodeFrame(source);
        const message3 = `Message compilation error: ${err.message}`;
        const codeFrame = err.location && _source && generateCodeFrame(_source, err.location.start.offset, err.location.end.offset);
        const emitter = context.__v_emitter;
        if (emitter && _source) {
          emitter.emit("compile-error", {
            message: _source,
            error: err.message,
            start: err.location && err.location.start.offset,
            end: err.location && err.location.end.offset,
            groupId: `${"translate"}:${key}`
          });
        }
        console.error(codeFrame ? `${message3}
${codeFrame}` : message3);
      } else {
        throw err;
      }
    }, "onError"),
    onCacheKey: /* @__PURE__ */ __name((source2) => generateFormatCacheKey(locale2, key, source2), "onCacheKey")
  };
}
__name(getCompileContext, "getCompileContext");
function getSourceForCodeFrame(source) {
  if (isString$1(source)) {
    return source;
  } else {
    if (source.loc && source.loc.source) {
      return source.loc.source;
    }
  }
}
__name(getSourceForCodeFrame, "getSourceForCodeFrame");
function getMessageContextOptions(context, locale2, message3, options3) {
  const { modifiers, pluralRules, messageResolver: resolveValue2, fallbackLocale, fallbackWarn, missingWarn, fallbackContext } = context;
  const resolveMessage = /* @__PURE__ */ __name((key) => {
    let val = resolveValue2(message3, key);
    if (val == null && fallbackContext) {
      const [, , message22] = resolveMessageFormat(fallbackContext, key, locale2, fallbackLocale, fallbackWarn, missingWarn);
      val = resolveValue2(message22, key);
    }
    if (isString$1(val) || isMessageAST(val)) {
      let occurred = false;
      const onError = /* @__PURE__ */ __name(() => {
        occurred = true;
      }, "onError");
      const msg = compileMessageFormat(context, key, locale2, val, key, onError);
      return !occurred ? msg : NOOP_MESSAGE_FUNCTION;
    } else if (isMessageFunction(val)) {
      return val;
    } else {
      return NOOP_MESSAGE_FUNCTION;
    }
  }, "resolveMessage");
  const ctxOptions = {
    locale: locale2,
    modifiers,
    pluralRules,
    messages: resolveMessage
  };
  if (context.processor) {
    ctxOptions.processor = context.processor;
  }
  if (options3.list) {
    ctxOptions.list = options3.list;
  }
  if (options3.named) {
    ctxOptions.named = options3.named;
  }
  if (isNumber(options3.plural)) {
    ctxOptions.pluralIndex = options3.plural;
  }
  return ctxOptions;
}
__name(getMessageContextOptions, "getMessageContextOptions");
const intlDefined = typeof Intl !== "undefined";
const Availabilities = {
  dateTimeFormat: intlDefined && typeof Intl.DateTimeFormat !== "undefined",
  numberFormat: intlDefined && typeof Intl.NumberFormat !== "undefined"
};
function datetime(context, ...args) {
  const { datetimeFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
  const { __datetimeFormatters } = context;
  if (false) {
    onWarn(getWarnMessage$1(CoreWarnCodes.CANNOT_FORMAT_DATE));
    return MISSING_RESOLVE_VALUE;
  }
  const [key, value3, options3, overrides] = parseDateTimeArgs(...args);
  const missingWarn = isBoolean(options3.missingWarn) ? options3.missingWarn : context.missingWarn;
  const fallbackWarn = isBoolean(options3.fallbackWarn) ? options3.fallbackWarn : context.fallbackWarn;
  const part = !!options3.part;
  const locale2 = getLocale(context, options3);
  const locales = localeFallbacker(
    context,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    fallbackLocale,
    locale2
  );
  if (!isString$1(key) || key === "") {
    return new Intl.DateTimeFormat(locale2, overrides).format(value3);
  }
  let datetimeFormat = {};
  let targetLocale;
  let format2 = null;
  let from = locale2;
  let to = null;
  const type = "datetime format";
  for (let i2 = 0; i2 < locales.length; i2++) {
    targetLocale = to = locales[i2];
    if (false) {
      onWarn(getWarnMessage$1(CoreWarnCodes.FALLBACK_TO_DATE_FORMAT, {
        key,
        target: targetLocale
      }));
    }
    if (false) {
      const emitter = context.__v_emitter;
      if (emitter) {
        emitter.emit("fallback", {
          type,
          key,
          from,
          to,
          groupId: `${type}:${key}`
        });
      }
    }
    datetimeFormat = datetimeFormats[targetLocale] || {};
    format2 = datetimeFormat[key];
    if (isPlainObject(format2))
      break;
    handleMissing(context, key, targetLocale, missingWarn, type);
    from = to;
  }
  if (!isPlainObject(format2) || !isString$1(targetLocale)) {
    return unresolving ? NOT_REOSLVED : key;
  }
  let id2 = `${targetLocale}__${key}`;
  if (!isEmptyObject(overrides)) {
    id2 = `${id2}__${JSON.stringify(overrides)}`;
  }
  let formatter = __datetimeFormatters.get(id2);
  if (!formatter) {
    formatter = new Intl.DateTimeFormat(targetLocale, assign$1({}, format2, overrides));
    __datetimeFormatters.set(id2, formatter);
  }
  return !part ? formatter.format(value3) : formatter.formatToParts(value3);
}
__name(datetime, "datetime");
const DATETIME_FORMAT_OPTIONS_KEYS = [
  "localeMatcher",
  "weekday",
  "era",
  "year",
  "month",
  "day",
  "hour",
  "minute",
  "second",
  "timeZoneName",
  "formatMatcher",
  "hour12",
  "timeZone",
  "dateStyle",
  "timeStyle",
  "calendar",
  "dayPeriod",
  "numberingSystem",
  "hourCycle",
  "fractionalSecondDigits"
];
function parseDateTimeArgs(...args) {
  const [arg1, arg2, arg3, arg4] = args;
  const options3 = {};
  let overrides = {};
  let value3;
  if (isString$1(arg1)) {
    const matches2 = arg1.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
    if (!matches2) {
      throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
    }
    const dateTime = matches2[3] ? matches2[3].trim().startsWith("T") ? `${matches2[1].trim()}${matches2[3].trim()}` : `${matches2[1].trim()}T${matches2[3].trim()}` : matches2[1].trim();
    value3 = new Date(dateTime);
    try {
      value3.toISOString();
    } catch (e) {
      throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
    }
  } else if (isDate(arg1)) {
    if (isNaN(arg1.getTime())) {
      throw createCoreError(CoreErrorCodes.INVALID_DATE_ARGUMENT);
    }
    value3 = arg1;
  } else if (isNumber(arg1)) {
    value3 = arg1;
  } else {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  if (isString$1(arg2)) {
    options3.key = arg2;
  } else if (isPlainObject(arg2)) {
    Object.keys(arg2).forEach((key) => {
      if (DATETIME_FORMAT_OPTIONS_KEYS.includes(key)) {
        overrides[key] = arg2[key];
      } else {
        options3[key] = arg2[key];
      }
    });
  }
  if (isString$1(arg3)) {
    options3.locale = arg3;
  } else if (isPlainObject(arg3)) {
    overrides = arg3;
  }
  if (isPlainObject(arg4)) {
    overrides = arg4;
  }
  return [options3.key || "", value3, options3, overrides];
}
__name(parseDateTimeArgs, "parseDateTimeArgs");
function clearDateTimeFormat(ctx, locale2, format2) {
  const context = ctx;
  for (const key in format2) {
    const id2 = `${locale2}__${key}`;
    if (!context.__datetimeFormatters.has(id2)) {
      continue;
    }
    context.__datetimeFormatters.delete(id2);
  }
}
__name(clearDateTimeFormat, "clearDateTimeFormat");
function number(context, ...args) {
  const { numberFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
  const { __numberFormatters } = context;
  if (false) {
    onWarn(getWarnMessage$1(CoreWarnCodes.CANNOT_FORMAT_NUMBER));
    return MISSING_RESOLVE_VALUE;
  }
  const [key, value3, options3, overrides] = parseNumberArgs(...args);
  const missingWarn = isBoolean(options3.missingWarn) ? options3.missingWarn : context.missingWarn;
  const fallbackWarn = isBoolean(options3.fallbackWarn) ? options3.fallbackWarn : context.fallbackWarn;
  const part = !!options3.part;
  const locale2 = getLocale(context, options3);
  const locales = localeFallbacker(
    context,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    fallbackLocale,
    locale2
  );
  if (!isString$1(key) || key === "") {
    return new Intl.NumberFormat(locale2, overrides).format(value3);
  }
  let numberFormat = {};
  let targetLocale;
  let format2 = null;
  let from = locale2;
  let to = null;
  const type = "number format";
  for (let i2 = 0; i2 < locales.length; i2++) {
    targetLocale = to = locales[i2];
    if (false) {
      onWarn(getWarnMessage$1(CoreWarnCodes.FALLBACK_TO_NUMBER_FORMAT, {
        key,
        target: targetLocale
      }));
    }
    if (false) {
      const emitter = context.__v_emitter;
      if (emitter) {
        emitter.emit("fallback", {
          type,
          key,
          from,
          to,
          groupId: `${type}:${key}`
        });
      }
    }
    numberFormat = numberFormats[targetLocale] || {};
    format2 = numberFormat[key];
    if (isPlainObject(format2))
      break;
    handleMissing(context, key, targetLocale, missingWarn, type);
    from = to;
  }
  if (!isPlainObject(format2) || !isString$1(targetLocale)) {
    return unresolving ? NOT_REOSLVED : key;
  }
  let id2 = `${targetLocale}__${key}`;
  if (!isEmptyObject(overrides)) {
    id2 = `${id2}__${JSON.stringify(overrides)}`;
  }
  let formatter = __numberFormatters.get(id2);
  if (!formatter) {
    formatter = new Intl.NumberFormat(targetLocale, assign$1({}, format2, overrides));
    __numberFormatters.set(id2, formatter);
  }
  return !part ? formatter.format(value3) : formatter.formatToParts(value3);
}
__name(number, "number");
const NUMBER_FORMAT_OPTIONS_KEYS = [
  "localeMatcher",
  "style",
  "currency",
  "currencyDisplay",
  "currencySign",
  "useGrouping",
  "minimumIntegerDigits",
  "minimumFractionDigits",
  "maximumFractionDigits",
  "minimumSignificantDigits",
  "maximumSignificantDigits",
  "compactDisplay",
  "notation",
  "signDisplay",
  "unit",
  "unitDisplay",
  "roundingMode",
  "roundingPriority",
  "roundingIncrement",
  "trailingZeroDisplay"
];
function parseNumberArgs(...args) {
  const [arg1, arg2, arg3, arg4] = args;
  const options3 = {};
  let overrides = {};
  if (!isNumber(arg1)) {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  const value3 = arg1;
  if (isString$1(arg2)) {
    options3.key = arg2;
  } else if (isPlainObject(arg2)) {
    Object.keys(arg2).forEach((key) => {
      if (NUMBER_FORMAT_OPTIONS_KEYS.includes(key)) {
        overrides[key] = arg2[key];
      } else {
        options3[key] = arg2[key];
      }
    });
  }
  if (isString$1(arg3)) {
    options3.locale = arg3;
  } else if (isPlainObject(arg3)) {
    overrides = arg3;
  }
  if (isPlainObject(arg4)) {
    overrides = arg4;
  }
  return [options3.key || "", value3, options3, overrides];
}
__name(parseNumberArgs, "parseNumberArgs");
function clearNumberFormat(ctx, locale2, format2) {
  const context = ctx;
  for (const key in format2) {
    const id2 = `${locale2}__${key}`;
    if (!context.__numberFormatters.has(id2)) {
      continue;
    }
    context.__numberFormatters.delete(id2);
  }
}
__name(clearNumberFormat, "clearNumberFormat");
{
  initFeatureFlags$1();
}
/*!
  * vue-i18n v9.13.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
const VERSION = "9.13.1";
function initFeatureFlags() {
  if (typeof __VUE_I18N_FULL_INSTALL__ !== "boolean") {
    getGlobalThis().__VUE_I18N_FULL_INSTALL__ = true;
  }
  if (typeof __VUE_I18N_LEGACY_API__ !== "boolean") {
    getGlobalThis().__VUE_I18N_LEGACY_API__ = true;
  }
  if (typeof __INTLIFY_JIT_COMPILATION__ !== "boolean") {
    getGlobalThis().__INTLIFY_JIT_COMPILATION__ = false;
  }
  if (typeof __INTLIFY_DROP_MESSAGE_COMPILER__ !== "boolean") {
    getGlobalThis().__INTLIFY_DROP_MESSAGE_COMPILER__ = false;
  }
  if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
    getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
  }
}
__name(initFeatureFlags, "initFeatureFlags");
const code$1 = CoreWarnCodes.__EXTEND_POINT__;
const inc$1 = incrementer(code$1);
const I18nWarnCodes = {
  FALLBACK_TO_ROOT: code$1,
  // 9
  NOT_SUPPORTED_PRESERVE: inc$1(),
  // 10
  NOT_SUPPORTED_FORMATTER: inc$1(),
  // 11
  NOT_SUPPORTED_PRESERVE_DIRECTIVE: inc$1(),
  // 12
  NOT_SUPPORTED_GET_CHOICE_INDEX: inc$1(),
  // 13
  COMPONENT_NAME_LEGACY_COMPATIBLE: inc$1(),
  // 14
  NOT_FOUND_PARENT_SCOPE: inc$1(),
  // 15
  IGNORE_OBJ_FLATTEN: inc$1(),
  // 16
  NOTICE_DROP_ALLOW_COMPOSITION: inc$1(),
  // 17
  NOTICE_DROP_TRANSLATE_EXIST_COMPATIBLE_FLAG: inc$1()
  // 18
};
const warnMessages = {
  [I18nWarnCodes.FALLBACK_TO_ROOT]: `Fall back to {type} '{key}' with root locale.`,
  [I18nWarnCodes.NOT_SUPPORTED_PRESERVE]: `Not supported 'preserve'.`,
  [I18nWarnCodes.NOT_SUPPORTED_FORMATTER]: `Not supported 'formatter'.`,
  [I18nWarnCodes.NOT_SUPPORTED_PRESERVE_DIRECTIVE]: `Not supported 'preserveDirectiveContent'.`,
  [I18nWarnCodes.NOT_SUPPORTED_GET_CHOICE_INDEX]: `Not supported 'getChoiceIndex'.`,
  [I18nWarnCodes.COMPONENT_NAME_LEGACY_COMPATIBLE]: `Component name legacy compatible: '{name}' -> 'i18n'`,
  [I18nWarnCodes.NOT_FOUND_PARENT_SCOPE]: `Not found parent scope. use the global scope.`,
  [I18nWarnCodes.IGNORE_OBJ_FLATTEN]: `Ignore object flatten: '{key}' key has an string value`,
  [I18nWarnCodes.NOTICE_DROP_ALLOW_COMPOSITION]: `'allowComposition' option will be dropped in the next major version. For more information, please see  https://tinyurl.com/2p97mcze`,
  [I18nWarnCodes.NOTICE_DROP_TRANSLATE_EXIST_COMPATIBLE_FLAG]: `'translateExistCompatible' option will be dropped in the next major version.`
};
function getWarnMessage(code2, ...args) {
  return format$2(warnMessages[code2], ...args);
}
__name(getWarnMessage, "getWarnMessage");
const code = CoreErrorCodes.__EXTEND_POINT__;
const inc = incrementer(code);
const I18nErrorCodes = {
  // composer module errors
  UNEXPECTED_RETURN_TYPE: code,
  // 24
  // legacy module errors
  INVALID_ARGUMENT: inc(),
  // 25
  // i18n module errors
  MUST_BE_CALL_SETUP_TOP: inc(),
  // 26
  NOT_INSTALLED: inc(),
  // 27
  NOT_AVAILABLE_IN_LEGACY_MODE: inc(),
  // 28
  // directive module errors
  REQUIRED_VALUE: inc(),
  // 29
  INVALID_VALUE: inc(),
  // 30
  // vue-devtools errors
  CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: inc(),
  // 31
  NOT_INSTALLED_WITH_PROVIDE: inc(),
  // 32
  // unexpected error
  UNEXPECTED_ERROR: inc(),
  // 33
  // not compatible legacy vue-i18n constructor
  NOT_COMPATIBLE_LEGACY_VUE_I18N: inc(),
  // 34
  // bridge support vue 2.x only
  BRIDGE_SUPPORT_VUE_2_ONLY: inc(),
  // 35
  // need to define `i18n` option in `allowComposition: true` and `useScope: 'local' at `useI18n``
  MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION: inc(),
  // 36
  // Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly
  NOT_AVAILABLE_COMPOSITION_IN_LEGACY: inc(),
  // 37
  // for enhancement
  __EXTEND_POINT__: inc()
  // 38
};
function createI18nError(code2, ...args) {
  return createCompileError(code2, null, false ? { messages: errorMessages, args } : void 0);
}
__name(createI18nError, "createI18nError");
const errorMessages = {
  [I18nErrorCodes.UNEXPECTED_RETURN_TYPE]: "Unexpected return type in composer",
  [I18nErrorCodes.INVALID_ARGUMENT]: "Invalid argument",
  [I18nErrorCodes.MUST_BE_CALL_SETUP_TOP]: "Must be called at the top of a `setup` function",
  [I18nErrorCodes.NOT_INSTALLED]: "Need to install with `app.use` function",
  [I18nErrorCodes.UNEXPECTED_ERROR]: "Unexpected error",
  [I18nErrorCodes.NOT_AVAILABLE_IN_LEGACY_MODE]: "Not available in legacy mode",
  [I18nErrorCodes.REQUIRED_VALUE]: `Required in value: {0}`,
  [I18nErrorCodes.INVALID_VALUE]: `Invalid value`,
  [I18nErrorCodes.CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN]: `Cannot setup vue-devtools plugin`,
  [I18nErrorCodes.NOT_INSTALLED_WITH_PROVIDE]: "Need to install with `provide` function",
  [I18nErrorCodes.NOT_COMPATIBLE_LEGACY_VUE_I18N]: "Not compatible legacy VueI18n.",
  [I18nErrorCodes.BRIDGE_SUPPORT_VUE_2_ONLY]: "vue-i18n-bridge support Vue 2.x only",
  [I18nErrorCodes.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION]: "Must define i18n option or custom block in Composition API with using local scope in Legacy API mode",
  [I18nErrorCodes.NOT_AVAILABLE_COMPOSITION_IN_LEGACY]: "Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly"
};
const TranslateVNodeSymbol = /* @__PURE__ */ makeSymbol("__translateVNode");
const DatetimePartsSymbol = /* @__PURE__ */ makeSymbol("__datetimeParts");
const NumberPartsSymbol = /* @__PURE__ */ makeSymbol("__numberParts");
const EnableEmitter = /* @__PURE__ */ makeSymbol("__enableEmitter");
const DisableEmitter = /* @__PURE__ */ makeSymbol("__disableEmitter");
const SetPluralRulesSymbol = makeSymbol("__setPluralRules");
makeSymbol("__intlifyMeta");
const InejctWithOptionSymbol = /* @__PURE__ */ makeSymbol("__injectWithOption");
const DisposeSymbol = /* @__PURE__ */ makeSymbol("__dispose");
const __VUE_I18N_BRIDGE__ = "__VUE_I18N_BRIDGE__";
function handleFlatJson(obj) {
  if (!isObject$1(obj)) {
    return obj;
  }
  for (const key in obj) {
    if (!hasOwn(obj, key)) {
      continue;
    }
    if (!key.includes(".")) {
      if (isObject$1(obj[key])) {
        handleFlatJson(obj[key]);
      }
    } else {
      const subKeys = key.split(".");
      const lastIndex = subKeys.length - 1;
      let currentObj = obj;
      let hasStringValue = false;
      for (let i2 = 0; i2 < lastIndex; i2++) {
        if (!(subKeys[i2] in currentObj)) {
          currentObj[subKeys[i2]] = {};
        }
        if (!isObject$1(currentObj[subKeys[i2]])) {
          hasStringValue = true;
          break;
        }
        currentObj = currentObj[subKeys[i2]];
      }
      if (!hasStringValue) {
        currentObj[subKeys[lastIndex]] = obj[key];
        delete obj[key];
      }
      if (isObject$1(currentObj[subKeys[lastIndex]])) {
        handleFlatJson(currentObj[subKeys[lastIndex]]);
      }
    }
  }
  return obj;
}
__name(handleFlatJson, "handleFlatJson");
function getLocaleMessages(locale2, options3) {
  const { messages: messages2, __i18n, messageResolver, flatJson } = options3;
  const ret = isPlainObject(messages2) ? messages2 : isArray(__i18n) ? {} : { [locale2]: {} };
  if (isArray(__i18n)) {
    __i18n.forEach((custom2) => {
      if ("locale" in custom2 && "resource" in custom2) {
        const { locale: locale22, resource } = custom2;
        if (locale22) {
          ret[locale22] = ret[locale22] || {};
          deepCopy(resource, ret[locale22]);
        } else {
          deepCopy(resource, ret);
        }
      } else {
        isString$1(custom2) && deepCopy(JSON.parse(custom2), ret);
      }
    });
  }
  if (messageResolver == null && flatJson) {
    for (const key in ret) {
      if (hasOwn(ret, key)) {
        handleFlatJson(ret[key]);
      }
    }
  }
  return ret;
}
__name(getLocaleMessages, "getLocaleMessages");
function getComponentOptions(instance) {
  return instance.type;
}
__name(getComponentOptions, "getComponentOptions");
function adjustI18nResources(gl, options3, componentOptions) {
  let messages2 = isObject$1(options3.messages) ? options3.messages : {};
  if ("__i18nGlobal" in componentOptions) {
    messages2 = getLocaleMessages(gl.locale.value, {
      messages: messages2,
      __i18n: componentOptions.__i18nGlobal
    });
  }
  const locales = Object.keys(messages2);
  if (locales.length) {
    locales.forEach((locale2) => {
      gl.mergeLocaleMessage(locale2, messages2[locale2]);
    });
  }
  {
    if (isObject$1(options3.datetimeFormats)) {
      const locales2 = Object.keys(options3.datetimeFormats);
      if (locales2.length) {
        locales2.forEach((locale2) => {
          gl.mergeDateTimeFormat(locale2, options3.datetimeFormats[locale2]);
        });
      }
    }
    if (isObject$1(options3.numberFormats)) {
      const locales2 = Object.keys(options3.numberFormats);
      if (locales2.length) {
        locales2.forEach((locale2) => {
          gl.mergeNumberFormat(locale2, options3.numberFormats[locale2]);
        });
      }
    }
  }
}
__name(adjustI18nResources, "adjustI18nResources");
function createTextNode(key) {
  return createVNode(Text, null, key, 0);
}
__name(createTextNode, "createTextNode");
const DEVTOOLS_META = "__INTLIFY_META__";
const NOOP_RETURN_ARRAY = /* @__PURE__ */ __name(() => [], "NOOP_RETURN_ARRAY");
const NOOP_RETURN_FALSE = /* @__PURE__ */ __name(() => false, "NOOP_RETURN_FALSE");
let composerID = 0;
function defineCoreMissingHandler(missing) {
  return (ctx, locale2, key, type) => {
    return missing(locale2, key, getCurrentInstance() || void 0, type);
  };
}
__name(defineCoreMissingHandler, "defineCoreMissingHandler");
const getMetaInfo = /* @__PURE__ */ __name(/* @__NO_SIDE_EFFECTS__ */ () => {
  const instance = getCurrentInstance();
  let meta = null;
  return instance && (meta = getComponentOptions(instance)[DEVTOOLS_META]) ? { [DEVTOOLS_META]: meta } : null;
}, "getMetaInfo");
function createComposer(options3 = {}, VueI18nLegacy) {
  const { __root, __injectWithOption } = options3;
  const _isGlobal = __root === void 0;
  const flatJson = options3.flatJson;
  const _ref = inBrowser ? ref : shallowRef;
  const translateExistCompatible = !!options3.translateExistCompatible;
  if (false) {
    if (translateExistCompatible && true) {
      warnOnce(getWarnMessage(I18nWarnCodes.NOTICE_DROP_TRANSLATE_EXIST_COMPATIBLE_FLAG));
    }
  }
  let _inheritLocale = isBoolean(options3.inheritLocale) ? options3.inheritLocale : true;
  const _locale = _ref(
    // prettier-ignore
    __root && _inheritLocale ? __root.locale.value : isString$1(options3.locale) ? options3.locale : DEFAULT_LOCALE
  );
  const _fallbackLocale = _ref(
    // prettier-ignore
    __root && _inheritLocale ? __root.fallbackLocale.value : isString$1(options3.fallbackLocale) || isArray(options3.fallbackLocale) || isPlainObject(options3.fallbackLocale) || options3.fallbackLocale === false ? options3.fallbackLocale : _locale.value
  );
  const _messages = _ref(getLocaleMessages(_locale.value, options3));
  const _datetimeFormats = _ref(isPlainObject(options3.datetimeFormats) ? options3.datetimeFormats : { [_locale.value]: {} });
  const _numberFormats = _ref(isPlainObject(options3.numberFormats) ? options3.numberFormats : { [_locale.value]: {} });
  let _missingWarn = __root ? __root.missingWarn : isBoolean(options3.missingWarn) || isRegExp(options3.missingWarn) ? options3.missingWarn : true;
  let _fallbackWarn = __root ? __root.fallbackWarn : isBoolean(options3.fallbackWarn) || isRegExp(options3.fallbackWarn) ? options3.fallbackWarn : true;
  let _fallbackRoot = __root ? __root.fallbackRoot : isBoolean(options3.fallbackRoot) ? options3.fallbackRoot : true;
  let _fallbackFormat = !!options3.fallbackFormat;
  let _missing = isFunction$1(options3.missing) ? options3.missing : null;
  let _runtimeMissing = isFunction$1(options3.missing) ? defineCoreMissingHandler(options3.missing) : null;
  let _postTranslation = isFunction$1(options3.postTranslation) ? options3.postTranslation : null;
  let _warnHtmlMessage = __root ? __root.warnHtmlMessage : isBoolean(options3.warnHtmlMessage) ? options3.warnHtmlMessage : true;
  let _escapeParameter = !!options3.escapeParameter;
  const _modifiers = __root ? __root.modifiers : isPlainObject(options3.modifiers) ? options3.modifiers : {};
  let _pluralRules = options3.pluralRules || __root && __root.pluralRules;
  let _context;
  const getCoreContext = /* @__PURE__ */ __name(() => {
    _isGlobal && setFallbackContext(null);
    const ctxOptions = {
      version: VERSION,
      locale: _locale.value,
      fallbackLocale: _fallbackLocale.value,
      messages: _messages.value,
      modifiers: _modifiers,
      pluralRules: _pluralRules,
      missing: _runtimeMissing === null ? void 0 : _runtimeMissing,
      missingWarn: _missingWarn,
      fallbackWarn: _fallbackWarn,
      fallbackFormat: _fallbackFormat,
      unresolving: true,
      postTranslation: _postTranslation === null ? void 0 : _postTranslation,
      warnHtmlMessage: _warnHtmlMessage,
      escapeParameter: _escapeParameter,
      messageResolver: options3.messageResolver,
      messageCompiler: options3.messageCompiler,
      __meta: { framework: "vue" }
    };
    {
      ctxOptions.datetimeFormats = _datetimeFormats.value;
      ctxOptions.numberFormats = _numberFormats.value;
      ctxOptions.__datetimeFormatters = isPlainObject(_context) ? _context.__datetimeFormatters : void 0;
      ctxOptions.__numberFormatters = isPlainObject(_context) ? _context.__numberFormatters : void 0;
    }
    if (false) {
      ctxOptions.__v_emitter = isPlainObject(_context) ? _context.__v_emitter : void 0;
    }
    const ctx = createCoreContext(ctxOptions);
    _isGlobal && setFallbackContext(ctx);
    return ctx;
  }, "getCoreContext");
  _context = getCoreContext();
  updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
  function trackReactivityValues() {
    return [
      _locale.value,
      _fallbackLocale.value,
      _messages.value,
      _datetimeFormats.value,
      _numberFormats.value
    ];
  }
  __name(trackReactivityValues, "trackReactivityValues");
  const locale2 = computed({
    get: /* @__PURE__ */ __name(() => _locale.value, "get"),
    set: /* @__PURE__ */ __name((val) => {
      _locale.value = val;
      _context.locale = _locale.value;
    }, "set")
  });
  const fallbackLocale = computed({
    get: /* @__PURE__ */ __name(() => _fallbackLocale.value, "get"),
    set: /* @__PURE__ */ __name((val) => {
      _fallbackLocale.value = val;
      _context.fallbackLocale = _fallbackLocale.value;
      updateFallbackLocale(_context, _locale.value, val);
    }, "set")
  });
  const messages2 = computed(() => _messages.value);
  const datetimeFormats = /* @__PURE__ */ computed(() => _datetimeFormats.value);
  const numberFormats = /* @__PURE__ */ computed(() => _numberFormats.value);
  function getPostTranslationHandler() {
    return isFunction$1(_postTranslation) ? _postTranslation : null;
  }
  __name(getPostTranslationHandler, "getPostTranslationHandler");
  function setPostTranslationHandler(handler6) {
    _postTranslation = handler6;
    _context.postTranslation = handler6;
  }
  __name(setPostTranslationHandler, "setPostTranslationHandler");
  function getMissingHandler() {
    return _missing;
  }
  __name(getMissingHandler, "getMissingHandler");
  function setMissingHandler(handler6) {
    if (handler6 !== null) {
      _runtimeMissing = defineCoreMissingHandler(handler6);
    }
    _missing = handler6;
    _context.missing = _runtimeMissing;
  }
  __name(setMissingHandler, "setMissingHandler");
  function isResolvedTranslateMessage(type, arg) {
    return type !== "translate" || !arg.resolvedMessage;
  }
  __name(isResolvedTranslateMessage, "isResolvedTranslateMessage");
  const wrapWithDeps = /* @__PURE__ */ __name((fn, argumentParser, warnType, fallbackSuccess, fallbackFail, successCondition) => {
    trackReactivityValues();
    let ret;
    try {
      if (__INTLIFY_PROD_DEVTOOLS__) {
        /* @__PURE__ */ setAdditionalMeta(/* @__PURE__ */ getMetaInfo());
      }
      if (!_isGlobal) {
        _context.fallbackContext = __root ? getFallbackContext() : void 0;
      }
      ret = fn(_context);
    } finally {
      if (__INTLIFY_PROD_DEVTOOLS__) {
        /* @__PURE__ */ setAdditionalMeta(null);
      }
      if (!_isGlobal) {
        _context.fallbackContext = void 0;
      }
    }
    if (warnType !== "translate exists" && // for not `te` (e.g `t`)
    isNumber(ret) && ret === NOT_REOSLVED || warnType === "translate exists" && !ret) {
      const [key, arg2] = argumentParser();
      if (false) {
        if (_fallbackRoot && (isTranslateFallbackWarn(_fallbackWarn, key) || isTranslateMissingWarn(_missingWarn, key))) {
          warn(getWarnMessage(I18nWarnCodes.FALLBACK_TO_ROOT, {
            key,
            type: warnType
          }));
        }
        if (false) {
          const { __v_emitter: emitter } = _context;
          if (emitter && _fallbackRoot) {
            emitter.emit("fallback", {
              type: warnType,
              key,
              to: "global",
              groupId: `${warnType}:${key}`
            });
          }
        }
      }
      return __root && _fallbackRoot ? fallbackSuccess(__root) : fallbackFail(key);
    } else if (successCondition(ret)) {
      return ret;
    } else {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_RETURN_TYPE);
    }
  }, "wrapWithDeps");
  function t(...args) {
    return wrapWithDeps((context) => Reflect.apply(translate, null, [context, ...args]), () => parseTranslateArgs(...args), "translate", (root26) => Reflect.apply(root26.t, root26, [...args]), (key) => key, (val) => isString$1(val));
  }
  __name(t, "t");
  function rt(...args) {
    const [arg1, arg2, arg3] = args;
    if (arg3 && !isObject$1(arg3)) {
      throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
    }
    return t(...[arg1, arg2, assign$1({ resolvedMessage: true }, arg3 || {})]);
  }
  __name(rt, "rt");
  function d(...args) {
    return wrapWithDeps((context) => Reflect.apply(datetime, null, [context, ...args]), () => parseDateTimeArgs(...args), "datetime format", (root26) => Reflect.apply(root26.d, root26, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString$1(val));
  }
  __name(d, "d");
  function n(...args) {
    return wrapWithDeps((context) => Reflect.apply(number, null, [context, ...args]), () => parseNumberArgs(...args), "number format", (root26) => Reflect.apply(root26.n, root26, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString$1(val));
  }
  __name(n, "n");
  function normalize(values2) {
    return values2.map((val) => isString$1(val) || isNumber(val) || isBoolean(val) ? createTextNode(String(val)) : val);
  }
  __name(normalize, "normalize");
  const interpolate = /* @__PURE__ */ __name((val) => val, "interpolate");
  const processor = {
    normalize,
    interpolate,
    type: "vnode"
  };
  function translateVNode(...args) {
    return wrapWithDeps(
      (context) => {
        let ret;
        const _context2 = context;
        try {
          _context2.processor = processor;
          ret = Reflect.apply(translate, null, [_context2, ...args]);
        } finally {
          _context2.processor = null;
        }
        return ret;
      },
      () => parseTranslateArgs(...args),
      "translate",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (root26) => root26[TranslateVNodeSymbol](...args),
      (key) => [createTextNode(key)],
      (val) => isArray(val)
    );
  }
  __name(translateVNode, "translateVNode");
  function numberParts(...args) {
    return wrapWithDeps(
      (context) => Reflect.apply(number, null, [context, ...args]),
      () => parseNumberArgs(...args),
      "number format",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (root26) => root26[NumberPartsSymbol](...args),
      NOOP_RETURN_ARRAY,
      (val) => isString$1(val) || isArray(val)
    );
  }
  __name(numberParts, "numberParts");
  function datetimeParts(...args) {
    return wrapWithDeps(
      (context) => Reflect.apply(datetime, null, [context, ...args]),
      () => parseDateTimeArgs(...args),
      "datetime format",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (root26) => root26[DatetimePartsSymbol](...args),
      NOOP_RETURN_ARRAY,
      (val) => isString$1(val) || isArray(val)
    );
  }
  __name(datetimeParts, "datetimeParts");
  function setPluralRules(rules) {
    _pluralRules = rules;
    _context.pluralRules = _pluralRules;
  }
  __name(setPluralRules, "setPluralRules");
  function te(key, locale22) {
    return wrapWithDeps(() => {
      if (!key) {
        return false;
      }
      const targetLocale = isString$1(locale22) ? locale22 : _locale.value;
      const message3 = getLocaleMessage(targetLocale);
      const resolved = _context.messageResolver(message3, key);
      return !translateExistCompatible ? isMessageAST(resolved) || isMessageFunction(resolved) || isString$1(resolved) : resolved != null;
    }, () => [key], "translate exists", (root26) => {
      return Reflect.apply(root26.te, root26, [key, locale22]);
    }, NOOP_RETURN_FALSE, (val) => isBoolean(val));
  }
  __name(te, "te");
  function resolveMessages(key) {
    let messages22 = null;
    const locales = fallbackWithLocaleChain(_context, _fallbackLocale.value, _locale.value);
    for (let i2 = 0; i2 < locales.length; i2++) {
      const targetLocaleMessages = _messages.value[locales[i2]] || {};
      const messageValue = _context.messageResolver(targetLocaleMessages, key);
      if (messageValue != null) {
        messages22 = messageValue;
        break;
      }
    }
    return messages22;
  }
  __name(resolveMessages, "resolveMessages");
  function tm(key) {
    const messages22 = resolveMessages(key);
    return messages22 != null ? messages22 : __root ? __root.tm(key) || {} : {};
  }
  __name(tm, "tm");
  function getLocaleMessage(locale22) {
    return _messages.value[locale22] || {};
  }
  __name(getLocaleMessage, "getLocaleMessage");
  function setLocaleMessage(locale22, message3) {
    if (flatJson) {
      const _message = { [locale22]: message3 };
      for (const key in _message) {
        if (hasOwn(_message, key)) {
          handleFlatJson(_message[key]);
        }
      }
      message3 = _message[locale22];
    }
    _messages.value[locale22] = message3;
    _context.messages = _messages.value;
  }
  __name(setLocaleMessage, "setLocaleMessage");
  function mergeLocaleMessage(locale22, message3) {
    _messages.value[locale22] = _messages.value[locale22] || {};
    const _message = { [locale22]: message3 };
    if (flatJson) {
      for (const key in _message) {
        if (hasOwn(_message, key)) {
          handleFlatJson(_message[key]);
        }
      }
    }
    message3 = _message[locale22];
    deepCopy(message3, _messages.value[locale22]);
    _context.messages = _messages.value;
  }
  __name(mergeLocaleMessage, "mergeLocaleMessage");
  function getDateTimeFormat(locale22) {
    return _datetimeFormats.value[locale22] || {};
  }
  __name(getDateTimeFormat, "getDateTimeFormat");
  function setDateTimeFormat(locale22, format2) {
    _datetimeFormats.value[locale22] = format2;
    _context.datetimeFormats = _datetimeFormats.value;
    clearDateTimeFormat(_context, locale22, format2);
  }
  __name(setDateTimeFormat, "setDateTimeFormat");
  function mergeDateTimeFormat(locale22, format2) {
    _datetimeFormats.value[locale22] = assign$1(_datetimeFormats.value[locale22] || {}, format2);
    _context.datetimeFormats = _datetimeFormats.value;
    clearDateTimeFormat(_context, locale22, format2);
  }
  __name(mergeDateTimeFormat, "mergeDateTimeFormat");
  function getNumberFormat(locale22) {
    return _numberFormats.value[locale22] || {};
  }
  __name(getNumberFormat, "getNumberFormat");
  function setNumberFormat(locale22, format2) {
    _numberFormats.value[locale22] = format2;
    _context.numberFormats = _numberFormats.value;
    clearNumberFormat(_context, locale22, format2);
  }
  __name(setNumberFormat, "setNumberFormat");
  function mergeNumberFormat(locale22, format2) {
    _numberFormats.value[locale22] = assign$1(_numberFormats.value[locale22] || {}, format2);
    _context.numberFormats = _numberFormats.value;
    clearNumberFormat(_context, locale22, format2);
  }
  __name(mergeNumberFormat, "mergeNumberFormat");
  composerID++;
  if (__root && inBrowser) {
    watch(__root.locale, (val) => {
      if (_inheritLocale) {
        _locale.value = val;
        _context.locale = val;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    });
    watch(__root.fallbackLocale, (val) => {
      if (_inheritLocale) {
        _fallbackLocale.value = val;
        _context.fallbackLocale = val;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    });
  }
  const composer = {
    id: composerID,
    locale: locale2,
    fallbackLocale,
    get inheritLocale() {
      return _inheritLocale;
    },
    set inheritLocale(val) {
      _inheritLocale = val;
      if (val && __root) {
        _locale.value = __root.locale.value;
        _fallbackLocale.value = __root.fallbackLocale.value;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    },
    get availableLocales() {
      return Object.keys(_messages.value).sort();
    },
    messages: messages2,
    get modifiers() {
      return _modifiers;
    },
    get pluralRules() {
      return _pluralRules || {};
    },
    get isGlobal() {
      return _isGlobal;
    },
    get missingWarn() {
      return _missingWarn;
    },
    set missingWarn(val) {
      _missingWarn = val;
      _context.missingWarn = _missingWarn;
    },
    get fallbackWarn() {
      return _fallbackWarn;
    },
    set fallbackWarn(val) {
      _fallbackWarn = val;
      _context.fallbackWarn = _fallbackWarn;
    },
    get fallbackRoot() {
      return _fallbackRoot;
    },
    set fallbackRoot(val) {
      _fallbackRoot = val;
    },
    get fallbackFormat() {
      return _fallbackFormat;
    },
    set fallbackFormat(val) {
      _fallbackFormat = val;
      _context.fallbackFormat = _fallbackFormat;
    },
    get warnHtmlMessage() {
      return _warnHtmlMessage;
    },
    set warnHtmlMessage(val) {
      _warnHtmlMessage = val;
      _context.warnHtmlMessage = val;
    },
    get escapeParameter() {
      return _escapeParameter;
    },
    set escapeParameter(val) {
      _escapeParameter = val;
      _context.escapeParameter = val;
    },
    t,
    getLocaleMessage,
    setLocaleMessage,
    mergeLocaleMessage,
    getPostTranslationHandler,
    setPostTranslationHandler,
    getMissingHandler,
    setMissingHandler,
    [SetPluralRulesSymbol]: setPluralRules
  };
  {
    composer.datetimeFormats = datetimeFormats;
    composer.numberFormats = numberFormats;
    composer.rt = rt;
    composer.te = te;
    composer.tm = tm;
    composer.d = d;
    composer.n = n;
    composer.getDateTimeFormat = getDateTimeFormat;
    composer.setDateTimeFormat = setDateTimeFormat;
    composer.mergeDateTimeFormat = mergeDateTimeFormat;
    composer.getNumberFormat = getNumberFormat;
    composer.setNumberFormat = setNumberFormat;
    composer.mergeNumberFormat = mergeNumberFormat;
    composer[InejctWithOptionSymbol] = __injectWithOption;
    composer[TranslateVNodeSymbol] = translateVNode;
    composer[DatetimePartsSymbol] = datetimeParts;
    composer[NumberPartsSymbol] = numberParts;
  }
  if (false) {
    composer[EnableEmitter] = (emitter) => {
      _context.__v_emitter = emitter;
    };
    composer[DisableEmitter] = () => {
      _context.__v_emitter = void 0;
    };
  }
  return composer;
}
__name(createComposer, "createComposer");
function convertComposerOptions(options3) {
  const locale2 = isString$1(options3.locale) ? options3.locale : DEFAULT_LOCALE;
  const fallbackLocale = isString$1(options3.fallbackLocale) || isArray(options3.fallbackLocale) || isPlainObject(options3.fallbackLocale) || options3.fallbackLocale === false ? options3.fallbackLocale : locale2;
  const missing = isFunction$1(options3.missing) ? options3.missing : void 0;
  const missingWarn = isBoolean(options3.silentTranslationWarn) || isRegExp(options3.silentTranslationWarn) ? !options3.silentTranslationWarn : true;
  const fallbackWarn = isBoolean(options3.silentFallbackWarn) || isRegExp(options3.silentFallbackWarn) ? !options3.silentFallbackWarn : true;
  const fallbackRoot = isBoolean(options3.fallbackRoot) ? options3.fallbackRoot : true;
  const fallbackFormat = !!options3.formatFallbackMessages;
  const modifiers = isPlainObject(options3.modifiers) ? options3.modifiers : {};
  const pluralizationRules = options3.pluralizationRules;
  const postTranslation = isFunction$1(options3.postTranslation) ? options3.postTranslation : void 0;
  const warnHtmlMessage = isString$1(options3.warnHtmlInMessage) ? options3.warnHtmlInMessage !== "off" : true;
  const escapeParameter = !!options3.escapeParameterHtml;
  const inheritLocale = isBoolean(options3.sync) ? options3.sync : true;
  if (false) {
    warn(getWarnMessage(I18nWarnCodes.NOT_SUPPORTED_FORMATTER));
  }
  if (false) {
    warn(getWarnMessage(I18nWarnCodes.NOT_SUPPORTED_PRESERVE_DIRECTIVE));
  }
  let messages2 = options3.messages;
  if (isPlainObject(options3.sharedMessages)) {
    const sharedMessages = options3.sharedMessages;
    const locales = Object.keys(sharedMessages);
    messages2 = locales.reduce((messages22, locale22) => {
      const message3 = messages22[locale22] || (messages22[locale22] = {});
      assign$1(message3, sharedMessages[locale22]);
      return messages22;
    }, messages2 || {});
  }
  const { __i18n, __root, __injectWithOption } = options3;
  const datetimeFormats = options3.datetimeFormats;
  const numberFormats = options3.numberFormats;
  const flatJson = options3.flatJson;
  const translateExistCompatible = options3.translateExistCompatible;
  return {
    locale: locale2,
    fallbackLocale,
    messages: messages2,
    flatJson,
    datetimeFormats,
    numberFormats,
    missing,
    missingWarn,
    fallbackWarn,
    fallbackRoot,
    fallbackFormat,
    modifiers,
    pluralRules: pluralizationRules,
    postTranslation,
    warnHtmlMessage,
    escapeParameter,
    messageResolver: options3.messageResolver,
    inheritLocale,
    translateExistCompatible,
    __i18n,
    __root,
    __injectWithOption
  };
}
__name(convertComposerOptions, "convertComposerOptions");
function createVueI18n(options3 = {}, VueI18nLegacy) {
  {
    const composer = createComposer(convertComposerOptions(options3));
    const { __extender } = options3;
    const vueI18n = {
      // id
      id: composer.id,
      // locale
      get locale() {
        return composer.locale.value;
      },
      set locale(val) {
        composer.locale.value = val;
      },
      // fallbackLocale
      get fallbackLocale() {
        return composer.fallbackLocale.value;
      },
      set fallbackLocale(val) {
        composer.fallbackLocale.value = val;
      },
      // messages
      get messages() {
        return composer.messages.value;
      },
      // datetimeFormats
      get datetimeFormats() {
        return composer.datetimeFormats.value;
      },
      // numberFormats
      get numberFormats() {
        return composer.numberFormats.value;
      },
      // availableLocales
      get availableLocales() {
        return composer.availableLocales;
      },
      // formatter
      get formatter() {
        return {
          interpolate() {
            return [];
          }
        };
      },
      set formatter(val) {
      },
      // missing
      get missing() {
        return composer.getMissingHandler();
      },
      set missing(handler6) {
        composer.setMissingHandler(handler6);
      },
      // silentTranslationWarn
      get silentTranslationWarn() {
        return isBoolean(composer.missingWarn) ? !composer.missingWarn : composer.missingWarn;
      },
      set silentTranslationWarn(val) {
        composer.missingWarn = isBoolean(val) ? !val : val;
      },
      // silentFallbackWarn
      get silentFallbackWarn() {
        return isBoolean(composer.fallbackWarn) ? !composer.fallbackWarn : composer.fallbackWarn;
      },
      set silentFallbackWarn(val) {
        composer.fallbackWarn = isBoolean(val) ? !val : val;
      },
      // modifiers
      get modifiers() {
        return composer.modifiers;
      },
      // formatFallbackMessages
      get formatFallbackMessages() {
        return composer.fallbackFormat;
      },
      set formatFallbackMessages(val) {
        composer.fallbackFormat = val;
      },
      // postTranslation
      get postTranslation() {
        return composer.getPostTranslationHandler();
      },
      set postTranslation(handler6) {
        composer.setPostTranslationHandler(handler6);
      },
      // sync
      get sync() {
        return composer.inheritLocale;
      },
      set sync(val) {
        composer.inheritLocale = val;
      },
      // warnInHtmlMessage
      get warnHtmlInMessage() {
        return composer.warnHtmlMessage ? "warn" : "off";
      },
      set warnHtmlInMessage(val) {
        composer.warnHtmlMessage = val !== "off";
      },
      // escapeParameterHtml
      get escapeParameterHtml() {
        return composer.escapeParameter;
      },
      set escapeParameterHtml(val) {
        composer.escapeParameter = val;
      },
      // preserveDirectiveContent
      get preserveDirectiveContent() {
        return true;
      },
      set preserveDirectiveContent(val) {
      },
      // pluralizationRules
      get pluralizationRules() {
        return composer.pluralRules || {};
      },
      // for internal
      __composer: composer,
      // t
      t(...args) {
        const [arg1, arg2, arg3] = args;
        const options22 = {};
        let list = null;
        let named = null;
        if (!isString$1(arg1)) {
          throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
        }
        const key = arg1;
        if (isString$1(arg2)) {
          options22.locale = arg2;
        } else if (isArray(arg2)) {
          list = arg2;
        } else if (isPlainObject(arg2)) {
          named = arg2;
        }
        if (isArray(arg3)) {
          list = arg3;
        } else if (isPlainObject(arg3)) {
          named = arg3;
        }
        return Reflect.apply(composer.t, composer, [
          key,
          list || named || {},
          options22
        ]);
      },
      rt(...args) {
        return Reflect.apply(composer.rt, composer, [...args]);
      },
      // tc
      tc(...args) {
        const [arg1, arg2, arg3] = args;
        const options22 = { plural: 1 };
        let list = null;
        let named = null;
        if (!isString$1(arg1)) {
          throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
        }
        const key = arg1;
        if (isString$1(arg2)) {
          options22.locale = arg2;
        } else if (isNumber(arg2)) {
          options22.plural = arg2;
        } else if (isArray(arg2)) {
          list = arg2;
        } else if (isPlainObject(arg2)) {
          named = arg2;
        }
        if (isString$1(arg3)) {
          options22.locale = arg3;
        } else if (isArray(arg3)) {
          list = arg3;
        } else if (isPlainObject(arg3)) {
          named = arg3;
        }
        return Reflect.apply(composer.t, composer, [
          key,
          list || named || {},
          options22
        ]);
      },
      // te
      te(key, locale2) {
        return composer.te(key, locale2);
      },
      // tm
      tm(key) {
        return composer.tm(key);
      },
      // getLocaleMessage
      getLocaleMessage(locale2) {
        return composer.getLocaleMessage(locale2);
      },
      // setLocaleMessage
      setLocaleMessage(locale2, message3) {
        composer.setLocaleMessage(locale2, message3);
      },
      // mergeLocaleMessage
      mergeLocaleMessage(locale2, message3) {
        composer.mergeLocaleMessage(locale2, message3);
      },
      // d
      d(...args) {
        return Reflect.apply(composer.d, composer, [...args]);
      },
      // getDateTimeFormat
      getDateTimeFormat(locale2) {
        return composer.getDateTimeFormat(locale2);
      },
      // setDateTimeFormat
      setDateTimeFormat(locale2, format2) {
        composer.setDateTimeFormat(locale2, format2);
      },
      // mergeDateTimeFormat
      mergeDateTimeFormat(locale2, format2) {
        composer.mergeDateTimeFormat(locale2, format2);
      },
      // n
      n(...args) {
        return Reflect.apply(composer.n, composer, [...args]);
      },
      // getNumberFormat
      getNumberFormat(locale2) {
        return composer.getNumberFormat(locale2);
      },
      // setNumberFormat
      setNumberFormat(locale2, format2) {
        composer.setNumberFormat(locale2, format2);
      },
      // mergeNumberFormat
      mergeNumberFormat(locale2, format2) {
        composer.mergeNumberFormat(locale2, format2);
      },
      // getChoiceIndex
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      getChoiceIndex(choice, choicesLength) {
        return -1;
      }
    };
    vueI18n.__extender = __extender;
    if (false) {
      vueI18n.__enableEmitter = (emitter) => {
        const __composer = composer;
        __composer[EnableEmitter] && __composer[EnableEmitter](emitter);
      };
      vueI18n.__disableEmitter = () => {
        const __composer = composer;
        __composer[DisableEmitter] && __composer[DisableEmitter]();
      };
    }
    return vueI18n;
  }
}
__name(createVueI18n, "createVueI18n");
const baseFormatProps = {
  tag: {
    type: [String, Object]
  },
  locale: {
    type: String
  },
  scope: {
    type: String,
    // NOTE: avoid https://github.com/microsoft/rushstack/issues/1050
    validator: /* @__PURE__ */ __name((val) => val === "parent" || val === "global", "validator"),
    default: "parent"
    /* ComponentI18nScope */
  },
  i18n: {
    type: Object
  }
};
function getInterpolateArg({ slots }, keys2) {
  if (keys2.length === 1 && keys2[0] === "default") {
    const ret = slots.default ? slots.default() : [];
    return ret.reduce((slot, current) => {
      return [
        ...slot,
        // prettier-ignore
        ...current.type === Fragment ? current.children : [current]
      ];
    }, []);
  } else {
    return keys2.reduce((arg, key) => {
      const slot = slots[key];
      if (slot) {
        arg[key] = slot();
      }
      return arg;
    }, {});
  }
}
__name(getInterpolateArg, "getInterpolateArg");
function getFragmentableTag(tag) {
  return Fragment;
}
__name(getFragmentableTag, "getFragmentableTag");
const TranslationImpl = /* @__PURE__ */ defineComponent({
  /* eslint-disable */
  name: "i18n-t",
  props: assign$1({
    keypath: {
      type: String,
      required: true
    },
    plural: {
      type: [Number, String],
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      validator: /* @__PURE__ */ __name((val) => isNumber(val) || !isNaN(val), "validator")
    }
  }, baseFormatProps),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props, context) {
    const { slots, attrs: attrs3 } = context;
    const i18n2 = props.i18n || useI18n({
      useScope: props.scope,
      __useComponent: true
    });
    return () => {
      const keys2 = Object.keys(slots).filter((key) => key !== "_");
      const options3 = {};
      if (props.locale) {
        options3.locale = props.locale;
      }
      if (props.plural !== void 0) {
        options3.plural = isString$1(props.plural) ? +props.plural : props.plural;
      }
      const arg = getInterpolateArg(context, keys2);
      const children = i18n2[TranslateVNodeSymbol](props.keypath, arg, options3);
      const assignedAttrs = assign$1({}, attrs3);
      const tag = isString$1(props.tag) || isObject$1(props.tag) ? props.tag : getFragmentableTag();
      return h(tag, assignedAttrs, children);
    };
  }
});
const Translation = TranslationImpl;
const I18nT = Translation;
function isVNode(target) {
  return isArray(target) && !isString$1(target[0]);
}
__name(isVNode, "isVNode");
function renderFormatter(props, context, slotKeys, partFormatter) {
  const { slots, attrs: attrs3 } = context;
  return () => {
    const options3 = { part: true };
    let overrides = {};
    if (props.locale) {
      options3.locale = props.locale;
    }
    if (isString$1(props.format)) {
      options3.key = props.format;
    } else if (isObject$1(props.format)) {
      if (isString$1(props.format.key)) {
        options3.key = props.format.key;
      }
      overrides = Object.keys(props.format).reduce((options22, prop2) => {
        return slotKeys.includes(prop2) ? assign$1({}, options22, { [prop2]: props.format[prop2] }) : options22;
      }, {});
    }
    const parts2 = partFormatter(...[props.value, options3, overrides]);
    let children = [options3.key];
    if (isArray(parts2)) {
      children = parts2.map((part, index2) => {
        const slot = slots[part.type];
        const node3 = slot ? slot({ [part.type]: part.value, index: index2, parts: parts2 }) : [part.value];
        if (isVNode(node3)) {
          node3[0].key = `${part.type}-${index2}`;
        }
        return node3;
      });
    } else if (isString$1(parts2)) {
      children = [parts2];
    }
    const assignedAttrs = assign$1({}, attrs3);
    const tag = isString$1(props.tag) || isObject$1(props.tag) ? props.tag : getFragmentableTag();
    return h(tag, assignedAttrs, children);
  };
}
__name(renderFormatter, "renderFormatter");
const NumberFormatImpl = /* @__PURE__ */ defineComponent({
  /* eslint-disable */
  name: "i18n-n",
  props: assign$1({
    value: {
      type: Number,
      required: true
    },
    format: {
      type: [String, Object]
    }
  }, baseFormatProps),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props, context) {
    const i18n2 = props.i18n || useI18n({
      useScope: props.scope,
      __useComponent: true
    });
    return renderFormatter(props, context, NUMBER_FORMAT_OPTIONS_KEYS, (...args) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      i18n2[NumberPartsSymbol](...args)
    ));
  }
});
const NumberFormat = NumberFormatImpl;
const I18nN = NumberFormat;
const DatetimeFormatImpl = /* @__PURE__ */ defineComponent({
  /* eslint-disable */
  name: "i18n-d",
  props: assign$1({
    value: {
      type: [Number, Date],
      required: true
    },
    format: {
      type: [String, Object]
    }
  }, baseFormatProps),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props, context) {
    const i18n2 = props.i18n || useI18n({
      useScope: props.scope,
      __useComponent: true
    });
    return renderFormatter(props, context, DATETIME_FORMAT_OPTIONS_KEYS, (...args) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      i18n2[DatetimePartsSymbol](...args)
    ));
  }
});
const DatetimeFormat = DatetimeFormatImpl;
const I18nD = DatetimeFormat;
function getComposer$2(i18n2, instance) {
  const i18nInternal = i18n2;
  if (i18n2.mode === "composition") {
    return i18nInternal.__getInstance(instance) || i18n2.global;
  } else {
    const vueI18n = i18nInternal.__getInstance(instance);
    return vueI18n != null ? vueI18n.__composer : i18n2.global.__composer;
  }
}
__name(getComposer$2, "getComposer$2");
function vTDirective(i18n2) {
  const _process = /* @__PURE__ */ __name((binding) => {
    const { instance, modifiers, value: value3 } = binding;
    if (!instance || !instance.$) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    const composer = getComposer$2(i18n2, instance.$);
    if (false) {
      warn(getWarnMessage(I18nWarnCodes.NOT_SUPPORTED_PRESERVE));
    }
    const parsedValue = parseValue(value3);
    return [
      Reflect.apply(composer.t, composer, [...makeParams(parsedValue)]),
      composer
    ];
  }, "_process");
  const register3 = /* @__PURE__ */ __name((el, binding) => {
    const [textContent, composer] = _process(binding);
    if (inBrowser && i18n2.global === composer) {
      el.__i18nWatcher = watch(composer.locale, () => {
        binding.instance && binding.instance.$forceUpdate();
      });
    }
    el.__composer = composer;
    el.textContent = textContent;
  }, "register");
  const unregister = /* @__PURE__ */ __name((el) => {
    if (inBrowser && el.__i18nWatcher) {
      el.__i18nWatcher();
      el.__i18nWatcher = void 0;
      delete el.__i18nWatcher;
    }
    if (el.__composer) {
      el.__composer = void 0;
      delete el.__composer;
    }
  }, "unregister");
  const update2 = /* @__PURE__ */ __name((el, { value: value3 }) => {
    if (el.__composer) {
      const composer = el.__composer;
      const parsedValue = parseValue(value3);
      el.textContent = Reflect.apply(composer.t, composer, [
        ...makeParams(parsedValue)
      ]);
    }
  }, "update");
  const getSSRProps = /* @__PURE__ */ __name((binding) => {
    const [textContent] = _process(binding);
    return { textContent };
  }, "getSSRProps");
  return {
    created: register3,
    unmounted: unregister,
    beforeUpdate: update2,
    getSSRProps
  };
}
__name(vTDirective, "vTDirective");
function parseValue(value3) {
  if (isString$1(value3)) {
    return { path: value3 };
  } else if (isPlainObject(value3)) {
    if (!("path" in value3)) {
      throw createI18nError(I18nErrorCodes.REQUIRED_VALUE, "path");
    }
    return value3;
  } else {
    throw createI18nError(I18nErrorCodes.INVALID_VALUE);
  }
}
__name(parseValue, "parseValue");
function makeParams(value3) {
  const { path, locale: locale2, args, choice, plural } = value3;
  const options3 = {};
  const named = args || {};
  if (isString$1(locale2)) {
    options3.locale = locale2;
  }
  if (isNumber(choice)) {
    options3.plural = choice;
  }
  if (isNumber(plural)) {
    options3.plural = plural;
  }
  return [path, named, options3];
}
__name(makeParams, "makeParams");
function apply(app2, i18n2, ...options3) {
  const pluginOptions = isPlainObject(options3[0]) ? options3[0] : {};
  const useI18nComponentName = !!pluginOptions.useI18nComponentName;
  const globalInstall = isBoolean(pluginOptions.globalInstall) ? pluginOptions.globalInstall : true;
  if (false) {
    warn(getWarnMessage(I18nWarnCodes.COMPONENT_NAME_LEGACY_COMPATIBLE, {
      name: Translation.name
    }));
  }
  if (globalInstall) {
    [!useI18nComponentName ? Translation.name : "i18n", "I18nT"].forEach((name) => app2.component(name, Translation));
    [NumberFormat.name, "I18nN"].forEach((name) => app2.component(name, NumberFormat));
    [DatetimeFormat.name, "I18nD"].forEach((name) => app2.component(name, DatetimeFormat));
  }
  {
    app2.directive("t", vTDirective(i18n2));
  }
}
__name(apply, "apply");
const VueDevToolsLabels = {
  [
    "vue-devtools-plugin-vue-i18n"
    /* VueDevToolsIDs.PLUGIN */
  ]: "Vue I18n devtools",
  [
    "vue-i18n-resource-inspector"
    /* VueDevToolsIDs.CUSTOM_INSPECTOR */
  ]: "I18n Resources",
  [
    "vue-i18n-timeline"
    /* VueDevToolsIDs.TIMELINE */
  ]: "Vue I18n"
};
const VueDevToolsPlaceholders = {
  [
    "vue-i18n-resource-inspector"
    /* VueDevToolsIDs.CUSTOM_INSPECTOR */
  ]: "Search for scopes ..."
};
const VueDevToolsTimelineColors = {
  [
    "vue-i18n-timeline"
    /* VueDevToolsIDs.TIMELINE */
  ]: 16764185
};
const VUE_I18N_COMPONENT_TYPES = "vue-i18n: composer properties";
let devtoolsApi;
async function enableDevTools(app2, i18n2) {
  return new Promise((resolve8, reject2) => {
    try {
      setupDevtoolsPlugin({
        id: "vue-devtools-plugin-vue-i18n",
        label: VueDevToolsLabels[
          "vue-devtools-plugin-vue-i18n"
          /* VueDevToolsIDs.PLUGIN */
        ],
        packageName: "vue-i18n",
        homepage: "https://vue-i18n.intlify.dev",
        logo: "https://vue-i18n.intlify.dev/vue-i18n-devtools-logo.png",
        componentStateTypes: [VUE_I18N_COMPONENT_TYPES],
        app: app2
        // eslint-disable-line @typescript-eslint/no-explicit-any
      }, (api2) => {
        devtoolsApi = api2;
        api2.on.visitComponentTree(({ componentInstance, treeNode }) => {
          updateComponentTreeTags(componentInstance, treeNode, i18n2);
        });
        api2.on.inspectComponent(({ componentInstance, instanceData }) => {
          if (componentInstance.vnode.el && componentInstance.vnode.el.__VUE_I18N__ && instanceData) {
            if (i18n2.mode === "legacy") {
              if (componentInstance.vnode.el.__VUE_I18N__ !== i18n2.global.__composer) {
                inspectComposer(instanceData, componentInstance.vnode.el.__VUE_I18N__);
              }
            } else {
              inspectComposer(instanceData, componentInstance.vnode.el.__VUE_I18N__);
            }
          }
        });
        api2.addInspector({
          id: "vue-i18n-resource-inspector",
          label: VueDevToolsLabels[
            "vue-i18n-resource-inspector"
            /* VueDevToolsIDs.CUSTOM_INSPECTOR */
          ],
          icon: "language",
          treeFilterPlaceholder: VueDevToolsPlaceholders[
            "vue-i18n-resource-inspector"
            /* VueDevToolsIDs.CUSTOM_INSPECTOR */
          ]
        });
        api2.on.getInspectorTree((payload) => {
          if (payload.app === app2 && payload.inspectorId === "vue-i18n-resource-inspector") {
            registerScope(payload, i18n2);
          }
        });
        const roots = /* @__PURE__ */ new Map();
        api2.on.getInspectorState(async (payload) => {
          if (payload.app === app2 && payload.inspectorId === "vue-i18n-resource-inspector") {
            api2.unhighlightElement();
            inspectScope(payload, i18n2);
            if (payload.nodeId === "global") {
              if (!roots.has(payload.app)) {
                const [root26] = await api2.getComponentInstances(payload.app);
                roots.set(payload.app, root26);
              }
              api2.highlightElement(roots.get(payload.app));
            } else {
              const instance = getComponentInstance(payload.nodeId, i18n2);
              instance && api2.highlightElement(instance);
            }
          }
        });
        api2.on.editInspectorState((payload) => {
          if (payload.app === app2 && payload.inspectorId === "vue-i18n-resource-inspector") {
            editScope(payload, i18n2);
          }
        });
        api2.addTimelineLayer({
          id: "vue-i18n-timeline",
          label: VueDevToolsLabels[
            "vue-i18n-timeline"
            /* VueDevToolsIDs.TIMELINE */
          ],
          color: VueDevToolsTimelineColors[
            "vue-i18n-timeline"
            /* VueDevToolsIDs.TIMELINE */
          ]
        });
        resolve8(true);
      });
    } catch (e) {
      console.error(e);
      reject2(false);
    }
  });
}
__name(enableDevTools, "enableDevTools");
function getI18nScopeLable(instance) {
  return instance.type.name || instance.type.displayName || instance.type.__file || "Anonymous";
}
__name(getI18nScopeLable, "getI18nScopeLable");
function updateComponentTreeTags(instance, treeNode, i18n2) {
  const global2 = i18n2.mode === "composition" ? i18n2.global : i18n2.global.__composer;
  if (instance && instance.vnode.el && instance.vnode.el.__VUE_I18N__) {
    if (instance.vnode.el.__VUE_I18N__ !== global2) {
      const tag = {
        label: `i18n (${getI18nScopeLable(instance)} Scope)`,
        textColor: 0,
        backgroundColor: 16764185
      };
      treeNode.tags.push(tag);
    }
  }
}
__name(updateComponentTreeTags, "updateComponentTreeTags");
function inspectComposer(instanceData, composer) {
  const type = VUE_I18N_COMPONENT_TYPES;
  instanceData.state.push({
    type,
    key: "locale",
    editable: true,
    value: composer.locale.value
  });
  instanceData.state.push({
    type,
    key: "availableLocales",
    editable: false,
    value: composer.availableLocales
  });
  instanceData.state.push({
    type,
    key: "fallbackLocale",
    editable: true,
    value: composer.fallbackLocale.value
  });
  instanceData.state.push({
    type,
    key: "inheritLocale",
    editable: true,
    value: composer.inheritLocale
  });
  instanceData.state.push({
    type,
    key: "messages",
    editable: false,
    value: getLocaleMessageValue(composer.messages.value)
  });
  {
    instanceData.state.push({
      type,
      key: "datetimeFormats",
      editable: false,
      value: composer.datetimeFormats.value
    });
    instanceData.state.push({
      type,
      key: "numberFormats",
      editable: false,
      value: composer.numberFormats.value
    });
  }
}
__name(inspectComposer, "inspectComposer");
function getLocaleMessageValue(messages2) {
  const value3 = {};
  Object.keys(messages2).forEach((key) => {
    const v2 = messages2[key];
    if (isFunction$1(v2) && "source" in v2) {
      value3[key] = getMessageFunctionDetails(v2);
    } else if (isMessageAST(v2) && v2.loc && v2.loc.source) {
      value3[key] = v2.loc.source;
    } else if (isObject$1(v2)) {
      value3[key] = getLocaleMessageValue(v2);
    } else {
      value3[key] = v2;
    }
  });
  return value3;
}
__name(getLocaleMessageValue, "getLocaleMessageValue");
const ESC = {
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "&": "&amp;"
};
function escape$1(s) {
  return s.replace(/[<>"&]/g, escapeChar);
}
__name(escape$1, "escape$1");
function escapeChar(a) {
  return ESC[a] || a;
}
__name(escapeChar, "escapeChar");
function getMessageFunctionDetails(func) {
  const argString = func.source ? `("${escape$1(func.source)}")` : `(?)`;
  return {
    _custom: {
      type: "function",
      display: `<span></span> ${argString}`
    }
  };
}
__name(getMessageFunctionDetails, "getMessageFunctionDetails");
function registerScope(payload, i18n2) {
  payload.rootNodes.push({
    id: "global",
    label: "Global Scope"
  });
  const global2 = i18n2.mode === "composition" ? i18n2.global : i18n2.global.__composer;
  for (const [keyInstance, instance] of i18n2.__instances) {
    const composer = i18n2.mode === "composition" ? instance : instance.__composer;
    if (global2 === composer) {
      continue;
    }
    payload.rootNodes.push({
      id: composer.id.toString(),
      label: `${getI18nScopeLable(keyInstance)} Scope`
    });
  }
}
__name(registerScope, "registerScope");
function getComponentInstance(nodeId, i18n2) {
  let instance = null;
  if (nodeId !== "global") {
    for (const [component, composer] of i18n2.__instances.entries()) {
      if (composer.id.toString() === nodeId) {
        instance = component;
        break;
      }
    }
  }
  return instance;
}
__name(getComponentInstance, "getComponentInstance");
function getComposer$1(nodeId, i18n2) {
  if (nodeId === "global") {
    return i18n2.mode === "composition" ? i18n2.global : i18n2.global.__composer;
  } else {
    const instance = Array.from(i18n2.__instances.values()).find((item2) => item2.id.toString() === nodeId);
    if (instance) {
      return i18n2.mode === "composition" ? instance : instance.__composer;
    } else {
      return null;
    }
  }
}
__name(getComposer$1, "getComposer$1");
function inspectScope(payload, i18n2) {
  const composer = getComposer$1(payload.nodeId, i18n2);
  if (composer) {
    payload.state = makeScopeInspectState(composer);
  }
  return null;
}
__name(inspectScope, "inspectScope");
function makeScopeInspectState(composer) {
  const state = {};
  const localeType = "Locale related info";
  const localeStates = [
    {
      type: localeType,
      key: "locale",
      editable: true,
      value: composer.locale.value
    },
    {
      type: localeType,
      key: "fallbackLocale",
      editable: true,
      value: composer.fallbackLocale.value
    },
    {
      type: localeType,
      key: "availableLocales",
      editable: false,
      value: composer.availableLocales
    },
    {
      type: localeType,
      key: "inheritLocale",
      editable: true,
      value: composer.inheritLocale
    }
  ];
  state[localeType] = localeStates;
  const localeMessagesType = "Locale messages info";
  const localeMessagesStates = [
    {
      type: localeMessagesType,
      key: "messages",
      editable: false,
      value: getLocaleMessageValue(composer.messages.value)
    }
  ];
  state[localeMessagesType] = localeMessagesStates;
  {
    const datetimeFormatsType = "Datetime formats info";
    const datetimeFormatsStates = [
      {
        type: datetimeFormatsType,
        key: "datetimeFormats",
        editable: false,
        value: composer.datetimeFormats.value
      }
    ];
    state[datetimeFormatsType] = datetimeFormatsStates;
    const numberFormatsType = "Datetime formats info";
    const numberFormatsStates = [
      {
        type: numberFormatsType,
        key: "numberFormats",
        editable: false,
        value: composer.numberFormats.value
      }
    ];
    state[numberFormatsType] = numberFormatsStates;
  }
  return state;
}
__name(makeScopeInspectState, "makeScopeInspectState");
function addTimelineEvent(event2, payload) {
  if (devtoolsApi) {
    let groupId;
    if (payload && "groupId" in payload) {
      groupId = payload.groupId;
      delete payload.groupId;
    }
    devtoolsApi.addTimelineEvent({
      layerId: "vue-i18n-timeline",
      event: {
        title: event2,
        groupId,
        time: Date.now(),
        meta: {},
        data: payload || {},
        logType: event2 === "compile-error" ? "error" : event2 === "fallback" || event2 === "missing" ? "warning" : "default"
      }
    });
  }
}
__name(addTimelineEvent, "addTimelineEvent");
function editScope(payload, i18n2) {
  const composer = getComposer$1(payload.nodeId, i18n2);
  if (composer) {
    const [field] = payload.path;
    if (field === "locale" && isString$1(payload.state.value)) {
      composer.locale.value = payload.state.value;
    } else if (field === "fallbackLocale" && (isString$1(payload.state.value) || isArray(payload.state.value) || isObject$1(payload.state.value))) {
      composer.fallbackLocale.value = payload.state.value;
    } else if (field === "inheritLocale" && isBoolean(payload.state.value)) {
      composer.inheritLocale = payload.state.value;
    }
  }
}
__name(editScope, "editScope");
function defineMixin(vuei18n, composer, i18n2) {
  return {
    beforeCreate() {
      const instance = getCurrentInstance();
      if (!instance) {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
      }
      const options3 = this.$options;
      if (options3.i18n) {
        const optionsI18n = options3.i18n;
        if (options3.__i18n) {
          optionsI18n.__i18n = options3.__i18n;
        }
        optionsI18n.__root = composer;
        if (this === this.$root) {
          this.$i18n = mergeToGlobal(vuei18n, optionsI18n);
        } else {
          optionsI18n.__injectWithOption = true;
          optionsI18n.__extender = i18n2.__vueI18nExtend;
          this.$i18n = createVueI18n(optionsI18n);
          const _vueI18n = this.$i18n;
          if (_vueI18n.__extender) {
            _vueI18n.__disposer = _vueI18n.__extender(this.$i18n);
          }
        }
      } else if (options3.__i18n) {
        if (this === this.$root) {
          this.$i18n = mergeToGlobal(vuei18n, options3);
        } else {
          this.$i18n = createVueI18n({
            __i18n: options3.__i18n,
            __injectWithOption: true,
            __extender: i18n2.__vueI18nExtend,
            __root: composer
          });
          const _vueI18n = this.$i18n;
          if (_vueI18n.__extender) {
            _vueI18n.__disposer = _vueI18n.__extender(this.$i18n);
          }
        }
      } else {
        this.$i18n = vuei18n;
      }
      if (options3.__i18nGlobal) {
        adjustI18nResources(composer, options3, options3);
      }
      this.$t = (...args) => this.$i18n.t(...args);
      this.$rt = (...args) => this.$i18n.rt(...args);
      this.$tc = (...args) => this.$i18n.tc(...args);
      this.$te = (key, locale2) => this.$i18n.te(key, locale2);
      this.$d = (...args) => this.$i18n.d(...args);
      this.$n = (...args) => this.$i18n.n(...args);
      this.$tm = (key) => this.$i18n.tm(key);
      i18n2.__setInstance(instance, this.$i18n);
    },
    mounted() {
      if (false) {
        const _vueI18n = this.$i18n;
        this.$el.__VUE_I18N__ = _vueI18n.__composer;
        const emitter = this.__v_emitter = createEmitter();
        _vueI18n.__enableEmitter && _vueI18n.__enableEmitter(emitter);
        emitter.on("*", addTimelineEvent);
      }
    },
    unmounted() {
      const instance = getCurrentInstance();
      if (!instance) {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
      }
      const _vueI18n = this.$i18n;
      if (false) {
        if (this.__v_emitter) {
          this.__v_emitter.off("*", addTimelineEvent);
          delete this.__v_emitter;
        }
        if (this.$i18n) {
          _vueI18n.__disableEmitter && _vueI18n.__disableEmitter();
          delete this.$el.__VUE_I18N__;
        }
      }
      delete this.$t;
      delete this.$rt;
      delete this.$tc;
      delete this.$te;
      delete this.$d;
      delete this.$n;
      delete this.$tm;
      if (_vueI18n.__disposer) {
        _vueI18n.__disposer();
        delete _vueI18n.__disposer;
        delete _vueI18n.__extender;
      }
      i18n2.__deleteInstance(instance);
      delete this.$i18n;
    }
  };
}
__name(defineMixin, "defineMixin");
function mergeToGlobal(g, options3) {
  g.locale = options3.locale || g.locale;
  g.fallbackLocale = options3.fallbackLocale || g.fallbackLocale;
  g.missing = options3.missing || g.missing;
  g.silentTranslationWarn = options3.silentTranslationWarn || g.silentFallbackWarn;
  g.silentFallbackWarn = options3.silentFallbackWarn || g.silentFallbackWarn;
  g.formatFallbackMessages = options3.formatFallbackMessages || g.formatFallbackMessages;
  g.postTranslation = options3.postTranslation || g.postTranslation;
  g.warnHtmlInMessage = options3.warnHtmlInMessage || g.warnHtmlInMessage;
  g.escapeParameterHtml = options3.escapeParameterHtml || g.escapeParameterHtml;
  g.sync = options3.sync || g.sync;
  g.__composer[SetPluralRulesSymbol](options3.pluralizationRules || g.pluralizationRules);
  const messages2 = getLocaleMessages(g.locale, {
    messages: options3.messages,
    __i18n: options3.__i18n
  });
  Object.keys(messages2).forEach((locale2) => g.mergeLocaleMessage(locale2, messages2[locale2]));
  if (options3.datetimeFormats) {
    Object.keys(options3.datetimeFormats).forEach((locale2) => g.mergeDateTimeFormat(locale2, options3.datetimeFormats[locale2]));
  }
  if (options3.numberFormats) {
    Object.keys(options3.numberFormats).forEach((locale2) => g.mergeNumberFormat(locale2, options3.numberFormats[locale2]));
  }
  return g;
}
__name(mergeToGlobal, "mergeToGlobal");
const I18nInjectionKey = /* @__PURE__ */ makeSymbol("global-vue-i18n");
function createI18n(options3 = {}, VueI18nLegacy) {
  const __legacyMode = __VUE_I18N_LEGACY_API__ && isBoolean(options3.legacy) ? options3.legacy : __VUE_I18N_LEGACY_API__;
  const __globalInjection = isBoolean(options3.globalInjection) ? options3.globalInjection : true;
  const __allowComposition = __VUE_I18N_LEGACY_API__ && __legacyMode ? !!options3.allowComposition : true;
  const __instances = /* @__PURE__ */ new Map();
  const [globalScope, __global] = createGlobal(options3, __legacyMode);
  const symbol = /* @__PURE__ */ makeSymbol(false ? "vue-i18n" : "");
  if (false) {
    if (__legacyMode && __allowComposition && true) {
      warn(getWarnMessage(I18nWarnCodes.NOTICE_DROP_ALLOW_COMPOSITION));
    }
  }
  function __getInstance(component) {
    return __instances.get(component) || null;
  }
  __name(__getInstance, "__getInstance");
  function __setInstance(component, instance) {
    __instances.set(component, instance);
  }
  __name(__setInstance, "__setInstance");
  function __deleteInstance(component) {
    __instances.delete(component);
  }
  __name(__deleteInstance, "__deleteInstance");
  {
    const i18n2 = {
      // mode
      get mode() {
        return __VUE_I18N_LEGACY_API__ && __legacyMode ? "legacy" : "composition";
      },
      // allowComposition
      get allowComposition() {
        return __allowComposition;
      },
      // install plugin
      async install(app2, ...options22) {
        if (false) {
          app2.__VUE_I18N__ = i18n2;
        }
        app2.__VUE_I18N_SYMBOL__ = symbol;
        app2.provide(app2.__VUE_I18N_SYMBOL__, i18n2);
        if (isPlainObject(options22[0])) {
          const opts = options22[0];
          i18n2.__composerExtend = opts.__composerExtend;
          i18n2.__vueI18nExtend = opts.__vueI18nExtend;
        }
        let globalReleaseHandler = null;
        if (!__legacyMode && __globalInjection) {
          globalReleaseHandler = injectGlobalFields(app2, i18n2.global);
        }
        if (__VUE_I18N_FULL_INSTALL__) {
          apply(app2, i18n2, ...options22);
        }
        if (__VUE_I18N_LEGACY_API__ && __legacyMode) {
          app2.mixin(defineMixin(__global, __global.__composer, i18n2));
        }
        const unmountApp = app2.unmount;
        app2.unmount = () => {
          globalReleaseHandler && globalReleaseHandler();
          i18n2.dispose();
          unmountApp();
        };
        if (false) {
          const ret = await enableDevTools(app2, i18n2);
          if (!ret) {
            throw createI18nError(I18nErrorCodes.CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN);
          }
          const emitter = createEmitter();
          if (__legacyMode) {
            const _vueI18n = __global;
            _vueI18n.__enableEmitter && _vueI18n.__enableEmitter(emitter);
          } else {
            const _composer = __global;
            _composer[EnableEmitter] && _composer[EnableEmitter](emitter);
          }
          emitter.on("*", addTimelineEvent);
        }
      },
      // global accessor
      get global() {
        return __global;
      },
      dispose() {
        globalScope.stop();
      },
      // @internal
      __instances,
      // @internal
      __getInstance,
      // @internal
      __setInstance,
      // @internal
      __deleteInstance
    };
    return i18n2;
  }
}
__name(createI18n, "createI18n");
function useI18n(options3 = {}) {
  const instance = getCurrentInstance();
  if (instance == null) {
    throw createI18nError(I18nErrorCodes.MUST_BE_CALL_SETUP_TOP);
  }
  if (!instance.isCE && instance.appContext.app != null && !instance.appContext.app.__VUE_I18N_SYMBOL__) {
    throw createI18nError(I18nErrorCodes.NOT_INSTALLED);
  }
  const i18n2 = getI18nInstance(instance);
  const gl = getGlobalComposer(i18n2);
  const componentOptions = getComponentOptions(instance);
  const scope = getScope(options3, componentOptions);
  if (__VUE_I18N_LEGACY_API__) {
    if (i18n2.mode === "legacy" && !options3.__useComponent) {
      if (!i18n2.allowComposition) {
        throw createI18nError(I18nErrorCodes.NOT_AVAILABLE_IN_LEGACY_MODE);
      }
      return useI18nForLegacy(instance, scope, gl, options3);
    }
  }
  if (scope === "global") {
    adjustI18nResources(gl, options3, componentOptions);
    return gl;
  }
  if (scope === "parent") {
    let composer2 = getComposer(i18n2, instance, options3.__useComponent);
    if (composer2 == null) {
      if (false) {
        warn(getWarnMessage(I18nWarnCodes.NOT_FOUND_PARENT_SCOPE));
      }
      composer2 = gl;
    }
    return composer2;
  }
  const i18nInternal = i18n2;
  let composer = i18nInternal.__getInstance(instance);
  if (composer == null) {
    const composerOptions = assign$1({}, options3);
    if ("__i18n" in componentOptions) {
      composerOptions.__i18n = componentOptions.__i18n;
    }
    if (gl) {
      composerOptions.__root = gl;
    }
    composer = createComposer(composerOptions);
    if (i18nInternal.__composerExtend) {
      composer[DisposeSymbol] = i18nInternal.__composerExtend(composer);
    }
    setupLifeCycle(i18nInternal, instance, composer);
    i18nInternal.__setInstance(instance, composer);
  }
  return composer;
}
__name(useI18n, "useI18n");
const castToVueI18n = /* @__PURE__ */ __name(/* @__NO_SIDE_EFFECTS__ */ (i18n2) => {
  if (!(__VUE_I18N_BRIDGE__ in i18n2)) {
    throw createI18nError(I18nErrorCodes.NOT_COMPATIBLE_LEGACY_VUE_I18N);
  }
  return i18n2;
}, "castToVueI18n");
function createGlobal(options3, legacyMode, VueI18nLegacy) {
  const scope = effectScope();
  {
    const obj = __VUE_I18N_LEGACY_API__ && legacyMode ? scope.run(() => createVueI18n(options3)) : scope.run(() => createComposer(options3));
    if (obj == null) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    return [scope, obj];
  }
}
__name(createGlobal, "createGlobal");
function getI18nInstance(instance) {
  {
    const i18n2 = inject(!instance.isCE ? instance.appContext.app.__VUE_I18N_SYMBOL__ : I18nInjectionKey);
    if (!i18n2) {
      throw createI18nError(!instance.isCE ? I18nErrorCodes.UNEXPECTED_ERROR : I18nErrorCodes.NOT_INSTALLED_WITH_PROVIDE);
    }
    return i18n2;
  }
}
__name(getI18nInstance, "getI18nInstance");
function getScope(options3, componentOptions) {
  return isEmptyObject(options3) ? "__i18n" in componentOptions ? "local" : "global" : !options3.useScope ? "local" : options3.useScope;
}
__name(getScope, "getScope");
function getGlobalComposer(i18n2) {
  return i18n2.mode === "composition" ? i18n2.global : i18n2.global.__composer;
}
__name(getGlobalComposer, "getGlobalComposer");
function getComposer(i18n2, target, useComponent = false) {
  let composer = null;
  const root26 = target.root;
  let current = getParentComponentInstance(target, useComponent);
  while (current != null) {
    const i18nInternal = i18n2;
    if (i18n2.mode === "composition") {
      composer = i18nInternal.__getInstance(current);
    } else {
      if (__VUE_I18N_LEGACY_API__) {
        const vueI18n = i18nInternal.__getInstance(current);
        if (vueI18n != null) {
          composer = vueI18n.__composer;
          if (useComponent && composer && !composer[InejctWithOptionSymbol]) {
            composer = null;
          }
        }
      }
    }
    if (composer != null) {
      break;
    }
    if (root26 === current) {
      break;
    }
    current = current.parent;
  }
  return composer;
}
__name(getComposer, "getComposer");
function getParentComponentInstance(target, useComponent = false) {
  if (target == null) {
    return null;
  }
  {
    return !useComponent ? target.parent : target.vnode.ctx || target.parent;
  }
}
__name(getParentComponentInstance, "getParentComponentInstance");
function setupLifeCycle(i18n2, target, composer) {
  let emitter = null;
  {
    onMounted(() => {
      if (false) {
        target.vnode.el.__VUE_I18N__ = composer;
        emitter = createEmitter();
        const _composer = composer;
        _composer[EnableEmitter] && _composer[EnableEmitter](emitter);
        emitter.on("*", addTimelineEvent);
      }
    }, target);
    onUnmounted(() => {
      const _composer = composer;
      if (false) {
        emitter && emitter.off("*", addTimelineEvent);
        _composer[DisableEmitter] && _composer[DisableEmitter]();
        delete target.vnode.el.__VUE_I18N__;
      }
      i18n2.__deleteInstance(target);
      const dispose = _composer[DisposeSymbol];
      if (dispose) {
        dispose();
        delete _composer[DisposeSymbol];
      }
    }, target);
  }
}
__name(setupLifeCycle, "setupLifeCycle");
function useI18nForLegacy(instance, scope, root26, options3 = {}) {
  const isLocalScope = scope === "local";
  const _composer = shallowRef(null);
  if (isLocalScope && instance.proxy && !(instance.proxy.$options.i18n || instance.proxy.$options.__i18n)) {
    throw createI18nError(I18nErrorCodes.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION);
  }
  const _inheritLocale = isBoolean(options3.inheritLocale) ? options3.inheritLocale : !isString$1(options3.locale);
  const _locale = ref(
    // prettier-ignore
    !isLocalScope || _inheritLocale ? root26.locale.value : isString$1(options3.locale) ? options3.locale : DEFAULT_LOCALE
  );
  const _fallbackLocale = ref(
    // prettier-ignore
    !isLocalScope || _inheritLocale ? root26.fallbackLocale.value : isString$1(options3.fallbackLocale) || isArray(options3.fallbackLocale) || isPlainObject(options3.fallbackLocale) || options3.fallbackLocale === false ? options3.fallbackLocale : _locale.value
  );
  const _messages = ref(getLocaleMessages(_locale.value, options3));
  const _datetimeFormats = ref(isPlainObject(options3.datetimeFormats) ? options3.datetimeFormats : { [_locale.value]: {} });
  const _numberFormats = ref(isPlainObject(options3.numberFormats) ? options3.numberFormats : { [_locale.value]: {} });
  const _missingWarn = isLocalScope ? root26.missingWarn : isBoolean(options3.missingWarn) || isRegExp(options3.missingWarn) ? options3.missingWarn : true;
  const _fallbackWarn = isLocalScope ? root26.fallbackWarn : isBoolean(options3.fallbackWarn) || isRegExp(options3.fallbackWarn) ? options3.fallbackWarn : true;
  const _fallbackRoot = isLocalScope ? root26.fallbackRoot : isBoolean(options3.fallbackRoot) ? options3.fallbackRoot : true;
  const _fallbackFormat = !!options3.fallbackFormat;
  const _missing = isFunction$1(options3.missing) ? options3.missing : null;
  const _postTranslation = isFunction$1(options3.postTranslation) ? options3.postTranslation : null;
  const _warnHtmlMessage = isLocalScope ? root26.warnHtmlMessage : isBoolean(options3.warnHtmlMessage) ? options3.warnHtmlMessage : true;
  const _escapeParameter = !!options3.escapeParameter;
  const _modifiers = isLocalScope ? root26.modifiers : isPlainObject(options3.modifiers) ? options3.modifiers : {};
  const _pluralRules = options3.pluralRules || isLocalScope && root26.pluralRules;
  function trackReactivityValues() {
    return [
      _locale.value,
      _fallbackLocale.value,
      _messages.value,
      _datetimeFormats.value,
      _numberFormats.value
    ];
  }
  __name(trackReactivityValues, "trackReactivityValues");
  const locale2 = computed({
    get: /* @__PURE__ */ __name(() => {
      return _composer.value ? _composer.value.locale.value : _locale.value;
    }, "get"),
    set: /* @__PURE__ */ __name((val) => {
      if (_composer.value) {
        _composer.value.locale.value = val;
      }
      _locale.value = val;
    }, "set")
  });
  const fallbackLocale = computed({
    get: /* @__PURE__ */ __name(() => {
      return _composer.value ? _composer.value.fallbackLocale.value : _fallbackLocale.value;
    }, "get"),
    set: /* @__PURE__ */ __name((val) => {
      if (_composer.value) {
        _composer.value.fallbackLocale.value = val;
      }
      _fallbackLocale.value = val;
    }, "set")
  });
  const messages2 = computed(() => {
    if (_composer.value) {
      return _composer.value.messages.value;
    } else {
      return _messages.value;
    }
  });
  const datetimeFormats = computed(() => _datetimeFormats.value);
  const numberFormats = computed(() => _numberFormats.value);
  function getPostTranslationHandler() {
    return _composer.value ? _composer.value.getPostTranslationHandler() : _postTranslation;
  }
  __name(getPostTranslationHandler, "getPostTranslationHandler");
  function setPostTranslationHandler(handler6) {
    if (_composer.value) {
      _composer.value.setPostTranslationHandler(handler6);
    }
  }
  __name(setPostTranslationHandler, "setPostTranslationHandler");
  function getMissingHandler() {
    return _composer.value ? _composer.value.getMissingHandler() : _missing;
  }
  __name(getMissingHandler, "getMissingHandler");
  function setMissingHandler(handler6) {
    if (_composer.value) {
      _composer.value.setMissingHandler(handler6);
    }
  }
  __name(setMissingHandler, "setMissingHandler");
  function warpWithDeps(fn) {
    trackReactivityValues();
    return fn();
  }
  __name(warpWithDeps, "warpWithDeps");
  function t(...args) {
    return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.t, null, [...args])) : warpWithDeps(() => "");
  }
  __name(t, "t");
  function rt(...args) {
    return _composer.value ? Reflect.apply(_composer.value.rt, null, [...args]) : "";
  }
  __name(rt, "rt");
  function d(...args) {
    return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.d, null, [...args])) : warpWithDeps(() => "");
  }
  __name(d, "d");
  function n(...args) {
    return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.n, null, [...args])) : warpWithDeps(() => "");
  }
  __name(n, "n");
  function tm(key) {
    return _composer.value ? _composer.value.tm(key) : {};
  }
  __name(tm, "tm");
  function te(key, locale22) {
    return _composer.value ? _composer.value.te(key, locale22) : false;
  }
  __name(te, "te");
  function getLocaleMessage(locale22) {
    return _composer.value ? _composer.value.getLocaleMessage(locale22) : {};
  }
  __name(getLocaleMessage, "getLocaleMessage");
  function setLocaleMessage(locale22, message3) {
    if (_composer.value) {
      _composer.value.setLocaleMessage(locale22, message3);
      _messages.value[locale22] = message3;
    }
  }
  __name(setLocaleMessage, "setLocaleMessage");
  function mergeLocaleMessage(locale22, message3) {
    if (_composer.value) {
      _composer.value.mergeLocaleMessage(locale22, message3);
    }
  }
  __name(mergeLocaleMessage, "mergeLocaleMessage");
  function getDateTimeFormat(locale22) {
    return _composer.value ? _composer.value.getDateTimeFormat(locale22) : {};
  }
  __name(getDateTimeFormat, "getDateTimeFormat");
  function setDateTimeFormat(locale22, format2) {
    if (_composer.value) {
      _composer.value.setDateTimeFormat(locale22, format2);
      _datetimeFormats.value[locale22] = format2;
    }
  }
  __name(setDateTimeFormat, "setDateTimeFormat");
  function mergeDateTimeFormat(locale22, format2) {
    if (_composer.value) {
      _composer.value.mergeDateTimeFormat(locale22, format2);
    }
  }
  __name(mergeDateTimeFormat, "mergeDateTimeFormat");
  function getNumberFormat(locale22) {
    return _composer.value ? _composer.value.getNumberFormat(locale22) : {};
  }
  __name(getNumberFormat, "getNumberFormat");
  function setNumberFormat(locale22, format2) {
    if (_composer.value) {
      _composer.value.setNumberFormat(locale22, format2);
      _numberFormats.value[locale22] = format2;
    }
  }
  __name(setNumberFormat, "setNumberFormat");
  function mergeNumberFormat(locale22, format2) {
    if (_composer.value) {
      _composer.value.mergeNumberFormat(locale22, format2);
    }
  }
  __name(mergeNumberFormat, "mergeNumberFormat");
  const wrapper = {
    get id() {
      return _composer.value ? _composer.value.id : -1;
    },
    locale: locale2,
    fallbackLocale,
    messages: messages2,
    datetimeFormats,
    numberFormats,
    get inheritLocale() {
      return _composer.value ? _composer.value.inheritLocale : _inheritLocale;
    },
    set inheritLocale(val) {
      if (_composer.value) {
        _composer.value.inheritLocale = val;
      }
    },
    get availableLocales() {
      return _composer.value ? _composer.value.availableLocales : Object.keys(_messages.value);
    },
    get modifiers() {
      return _composer.value ? _composer.value.modifiers : _modifiers;
    },
    get pluralRules() {
      return _composer.value ? _composer.value.pluralRules : _pluralRules;
    },
    get isGlobal() {
      return _composer.value ? _composer.value.isGlobal : false;
    },
    get missingWarn() {
      return _composer.value ? _composer.value.missingWarn : _missingWarn;
    },
    set missingWarn(val) {
      if (_composer.value) {
        _composer.value.missingWarn = val;
      }
    },
    get fallbackWarn() {
      return _composer.value ? _composer.value.fallbackWarn : _fallbackWarn;
    },
    set fallbackWarn(val) {
      if (_composer.value) {
        _composer.value.missingWarn = val;
      }
    },
    get fallbackRoot() {
      return _composer.value ? _composer.value.fallbackRoot : _fallbackRoot;
    },
    set fallbackRoot(val) {
      if (_composer.value) {
        _composer.value.fallbackRoot = val;
      }
    },
    get fallbackFormat() {
      return _composer.value ? _composer.value.fallbackFormat : _fallbackFormat;
    },
    set fallbackFormat(val) {
      if (_composer.value) {
        _composer.value.fallbackFormat = val;
      }
    },
    get warnHtmlMessage() {
      return _composer.value ? _composer.value.warnHtmlMessage : _warnHtmlMessage;
    },
    set warnHtmlMessage(val) {
      if (_composer.value) {
        _composer.value.warnHtmlMessage = val;
      }
    },
    get escapeParameter() {
      return _composer.value ? _composer.value.escapeParameter : _escapeParameter;
    },
    set escapeParameter(val) {
      if (_composer.value) {
        _composer.value.escapeParameter = val;
      }
    },
    t,
    getPostTranslationHandler,
    setPostTranslationHandler,
    getMissingHandler,
    setMissingHandler,
    rt,
    d,
    n,
    tm,
    te,
    getLocaleMessage,
    setLocaleMessage,
    mergeLocaleMessage,
    getDateTimeFormat,
    setDateTimeFormat,
    mergeDateTimeFormat,
    getNumberFormat,
    setNumberFormat,
    mergeNumberFormat
  };
  function sync(composer) {
    composer.locale.value = _locale.value;
    composer.fallbackLocale.value = _fallbackLocale.value;
    Object.keys(_messages.value).forEach((locale22) => {
      composer.mergeLocaleMessage(locale22, _messages.value[locale22]);
    });
    Object.keys(_datetimeFormats.value).forEach((locale22) => {
      composer.mergeDateTimeFormat(locale22, _datetimeFormats.value[locale22]);
    });
    Object.keys(_numberFormats.value).forEach((locale22) => {
      composer.mergeNumberFormat(locale22, _numberFormats.value[locale22]);
    });
    composer.escapeParameter = _escapeParameter;
    composer.fallbackFormat = _fallbackFormat;
    composer.fallbackRoot = _fallbackRoot;
    composer.fallbackWarn = _fallbackWarn;
    composer.missingWarn = _missingWarn;
    composer.warnHtmlMessage = _warnHtmlMessage;
  }
  __name(sync, "sync");
  onBeforeMount(() => {
    if (instance.proxy == null || instance.proxy.$i18n == null) {
      throw createI18nError(I18nErrorCodes.NOT_AVAILABLE_COMPOSITION_IN_LEGACY);
    }
    const composer = _composer.value = instance.proxy.$i18n.__composer;
    if (scope === "global") {
      _locale.value = composer.locale.value;
      _fallbackLocale.value = composer.fallbackLocale.value;
      _messages.value = composer.messages.value;
      _datetimeFormats.value = composer.datetimeFormats.value;
      _numberFormats.value = composer.numberFormats.value;
    } else if (isLocalScope) {
      sync(composer);
    }
  });
  return wrapper;
}
__name(useI18nForLegacy, "useI18nForLegacy");
const globalExportProps = [
  "locale",
  "fallbackLocale",
  "availableLocales"
];
const globalExportMethods = ["t", "rt", "d", "n", "tm", "te"];
function injectGlobalFields(app2, composer) {
  const i18n2 = /* @__PURE__ */ Object.create(null);
  globalExportProps.forEach((prop2) => {
    const desc = Object.getOwnPropertyDescriptor(composer, prop2);
    if (!desc) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    const wrap = isRef(desc.value) ? {
      get() {
        return desc.value.value;
      },
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      set(val) {
        desc.value.value = val;
      }
    } : {
      get() {
        return desc.get && desc.get();
      }
    };
    Object.defineProperty(i18n2, prop2, wrap);
  });
  app2.config.globalProperties.$i18n = i18n2;
  globalExportMethods.forEach((method) => {
    const desc = Object.getOwnPropertyDescriptor(composer, method);
    if (!desc || !desc.value) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    Object.defineProperty(app2.config.globalProperties, `$${method}`, desc);
  });
  const dispose = /* @__PURE__ */ __name(() => {
    delete app2.config.globalProperties.$i18n;
    globalExportMethods.forEach((method) => {
      delete app2.config.globalProperties[`$${method}`];
    });
  }, "dispose");
  return dispose;
}
__name(injectGlobalFields, "injectGlobalFields");
{
  initFeatureFlags();
}
if (__INTLIFY_JIT_COMPILATION__) {
  registerMessageCompiler(compile);
} else {
  registerMessageCompiler(compileToFunction);
}
registerMessageResolver(resolveValue);
registerLocaleFallbacker(fallbackWithLocaleChain);
if (__INTLIFY_PROD_DEVTOOLS__) {
  const target = getGlobalThis();
  target.__INTLIFY__ = true;
  setDevToolsHook(target.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
}
if (false) ;
const _withScopeId$8 = /* @__PURE__ */ __name((n) => (pushScopeId("data-v-d28bffc4"), n = n(), popScopeId(), n), "_withScopeId$8");
const _hoisted_1$p = { class: "comfy-vue-node-search-container" };
const _hoisted_2$i = {
  key: 0,
  class: "comfy-vue-node-preview-container"
};
const _hoisted_3$a = /* @__PURE__ */ _withScopeId$8(() => /* @__PURE__ */ createBaseVNode("h3", null, "Add node filter condition", -1));
const _hoisted_4$6 = { class: "_dialog-body" };
const _hoisted_5$4 = { class: "option-container" };
const _hoisted_6$3 = { class: "option-display-name" };
const _hoisted_7$2 = ["innerHTML"];
const _hoisted_8$1 = /* @__PURE__ */ _withScopeId$8(() => /* @__PURE__ */ createBaseVNode("span", null, "", -1));
const _hoisted_9$1 = ["innerHTML"];
const _hoisted_10$1 = {
  key: 0,
  class: "option-category"
};
const _hoisted_11$1 = { class: "option-badges" };
const _sfc_main$k = /* @__PURE__ */ defineComponent({
  __name: "NodeSearchBox",
  props: {
    filters: {},
    searchLimit: { default: 64 }
  },
  emits: ["addFilter", "removeFilter", "addNode"],
  setup(__props, { emit: __emit }) {
    const settingStore = useSettingStore();
    const { t } = useI18n();
    const enableNodePreview = computed(
      () => settingStore.get("Comfy.NodeSearchBoxImpl.NodePreview")
    );
    const showCategory = computed(
      () => settingStore.get("Comfy.NodeSearchBoxImpl.ShowCategory")
    );
    const showIdName = computed(
      () => settingStore.get("Comfy.NodeSearchBoxImpl.ShowIdName")
    );
    const props = __props;
    const nodeSearchFilterVisible = ref(false);
    const inputId = `comfy-vue-node-search-box-input-${Math.random()}`;
    const suggestions2 = ref([]);
    const hoveredSuggestion = ref(null);
    const currentQuery = ref("");
    const placeholder = computed(() => {
      return props.filters.length === 0 ? t("searchNodes") + "..." : "";
    });
    const search3 = /* @__PURE__ */ __name((query) => {
      currentQuery.value = query;
      suggestions2.value = [
        ...useNodeDefStore().nodeSearchService.searchNode(query, props.filters, {
          limit: props.searchLimit
        })
      ];
    }, "search");
    const highlightQuery = /* @__PURE__ */ __name((text, query) => {
      if (!query) return text;
      const regex = new RegExp(`(${query})`, "gi");
      return text.replace(regex, '<span class="highlight">$1</span>');
    }, "highlightQuery");
    const emit2 = __emit;
    const reFocusInput = /* @__PURE__ */ __name(() => {
      const inputElement = document.getElementById(inputId);
      if (inputElement) {
        inputElement.blur();
        inputElement.focus();
      }
    }, "reFocusInput");
    onMounted(reFocusInput);
    const onAddFilter = /* @__PURE__ */ __name((filterAndValue) => {
      nodeSearchFilterVisible.value = false;
      emit2("addFilter", filterAndValue);
      reFocusInput();
    }, "onAddFilter");
    const onRemoveFilter = /* @__PURE__ */ __name((event2, filterAndValue) => {
      event2.stopPropagation();
      event2.preventDefault();
      emit2("removeFilter", filterAndValue);
      reFocusInput();
    }, "onRemoveFilter");
    const setHoverSuggestion = /* @__PURE__ */ __name((index2) => {
      if (index2 === -1) {
        hoveredSuggestion.value = null;
        return;
      }
      const value3 = suggestions2.value[index2];
      hoveredSuggestion.value = value3;
    }, "setHoverSuggestion");
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$p, [
        enableNodePreview.value ? (openBlock(), createElementBlock("div", _hoisted_2$i, [
          hoveredSuggestion.value ? (openBlock(), createBlock(NodePreview, {
            nodeDef: hoveredSuggestion.value,
            key: hoveredSuggestion.value?.name || ""
          }, null, 8, ["nodeDef"])) : createCommentVNode("", true)
        ])) : createCommentVNode("", true),
        createVNode(unref(script$J), {
          icon: "pi pi-filter",
          severity: "secondary",
          class: "_filter-button",
          onClick: _cache[0] || (_cache[0] = ($event) => nodeSearchFilterVisible.value = true)
        }),
        createVNode(unref(script$k), {
          visible: nodeSearchFilterVisible.value,
          "onUpdate:visible": _cache[1] || (_cache[1] = ($event) => nodeSearchFilterVisible.value = $event),
          class: "_dialog"
        }, {
          header: withCtx(() => [
            _hoisted_3$a
          ]),
          default: withCtx(() => [
            createBaseVNode("div", _hoisted_4$6, [
              createVNode(NodeSearchFilter, { onAddFilter })
            ])
          ]),
          _: 1
        }, 8, ["visible"]),
        createVNode(_sfc_main$o, {
          "model-value": props.filters,
          class: "comfy-vue-node-search-box",
          scrollHeight: "40vh",
          placeholder: placeholder.value,
          "input-id": inputId,
          "append-to": "self",
          suggestions: suggestions2.value,
          "min-length": 0,
          delay: 100,
          onComplete: _cache[2] || (_cache[2] = ($event) => search3($event.query)),
          onOptionSelect: _cache[3] || (_cache[3] = ($event) => emit2("addNode", $event.value)),
          onFocusedOptionChanged: _cache[4] || (_cache[4] = ($event) => setHoverSuggestion($event)),
          "complete-on-focus": "",
          "auto-option-focus": "",
          "force-selection": "",
          multiple: ""
        }, {
          option: withCtx(({ option: option4 }) => [
            createBaseVNode("div", _hoisted_5$4, [
              createBaseVNode("div", _hoisted_6$3, [
                createBaseVNode("div", null, [
                  createBaseVNode("span", {
                    innerHTML: highlightQuery(option4.display_name, currentQuery.value)
                  }, null, 8, _hoisted_7$2),
                  _hoisted_8$1,
                  showIdName.value ? (openBlock(), createBlock(unref(script$w), {
                    key: 0,
                    severity: "secondary"
                  }, {
                    default: withCtx(() => [
                      createBaseVNode("span", {
                        innerHTML: highlightQuery(option4.name, currentQuery.value)
                      }, null, 8, _hoisted_9$1)
                    ]),
                    _: 2
                  }, 1024)) : createCommentVNode("", true)
                ]),
                showCategory.value ? (openBlock(), createElementBlock("div", _hoisted_10$1, toDisplayString$1(option4.category.replaceAll("/", " > ")), 1)) : createCommentVNode("", true)
              ]),
              createBaseVNode("div", _hoisted_11$1, [
                option4.experimental ? (openBlock(), createBlock(unref(script$w), {
                  key: 0,
                  value: _ctx.$t("experimental"),
                  severity: "primary"
                }, null, 8, ["value"])) : createCommentVNode("", true),
                option4.deprecated ? (openBlock(), createBlock(unref(script$w), {
                  key: 1,
                  value: _ctx.$t("deprecated"),
                  severity: "danger"
                }, null, 8, ["value"])) : createCommentVNode("", true),
                option4.python_module !== void 0 ? (openBlock(), createBlock(NodeSourceChip, {
                  key: 2,
                  python_module: option4.python_module
                }, null, 8, ["python_module"])) : createCommentVNode("", true)
              ])
            ])
          ]),
          chip: withCtx(({ value: value3 }) => [
            createVNode(SearchFilterChip, {
              onRemove: /* @__PURE__ */ __name(($event) => onRemoveFilter($event, value3), "onRemove"),
              text: value3[1],
              badge: value3[0].invokeSequence.toUpperCase(),
              "badge-class": value3[0].invokeSequence + "-badge"
            }, null, 8, ["onRemove", "text", "badge", "badge-class"])
          ]),
          _: 1
        }, 8, ["model-value", "placeholder", "suggestions"])
      ]);
    };
  }
});
const NodeSearchBox = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["__scopeId", "data-v-d28bffc4"]]);
class ConnectingLinkImpl {
  static {
    __name(this, "ConnectingLinkImpl");
  }
  node;
  slot;
  input;
  output;
  pos;
  constructor(node3, slot, input, output, pos2) {
    this.node = node3;
    this.slot = slot;
    this.input = input;
    this.output = output;
    this.pos = pos2;
  }
  static createFromPlainObject(obj) {
    return new ConnectingLinkImpl(
      obj.node,
      obj.slot,
      obj.input,
      obj.output,
      obj.pos
    );
  }
  get type() {
    const result = this.input ? this.input.type : this.output.type;
    return result === -1 ? null : result;
  }
  /**
   * Which slot type is release and need to be reconnected.
   * - 'output' means we need a new node's outputs slot to connect with this link
   */
  get releaseSlotType() {
    return this.output ? "input" : "output";
  }
  connectTo(newNode) {
    const newNodeSlots = this.releaseSlotType === "output" ? newNode.outputs : newNode.inputs;
    if (!newNodeSlots) return;
    const newNodeSlot = newNodeSlots.findIndex(
      (slot) => slot.type === this.type || slot.type === "*" || this.type === "*"
    );
    if (newNodeSlot === -1) {
      console.warn(
        `Could not find slot with type ${this.type} on node ${newNode.title}. This should never happen`
      );
      return;
    }
    if (this.releaseSlotType === "input") {
      this.node.connect(this.slot, newNode, newNodeSlot);
    } else {
      newNode.connect(newNodeSlot, this.node, this.slot);
    }
  }
}
const _sfc_main$j = /* @__PURE__ */ defineComponent({
  __name: "NodeSearchBoxPopover",
  setup(__props) {
    const settingStore = useSettingStore();
    const visible = ref(false);
    const dismissable = ref(true);
    const triggerEvent2 = ref(null);
    const getNewNodeLocation = /* @__PURE__ */ __name(() => {
      if (triggerEvent2.value === null) {
        return [100, 100];
      }
      const originalEvent = triggerEvent2.value.detail.originalEvent;
      return [originalEvent.canvasX, originalEvent.canvasY];
    }, "getNewNodeLocation");
    const nodeFilters = ref([]);
    const addFilter = /* @__PURE__ */ __name((filter4) => {
      nodeFilters.value.push(filter4);
    }, "addFilter");
    const removeFilter = /* @__PURE__ */ __name((filter4) => {
      nodeFilters.value = nodeFilters.value.filter((f) => f !== filter4);
    }, "removeFilter");
    const clearFilters = /* @__PURE__ */ __name(() => {
      nodeFilters.value = [];
    }, "clearFilters");
    const closeDialog = /* @__PURE__ */ __name(() => {
      visible.value = false;
    }, "closeDialog");
    const addNode = /* @__PURE__ */ __name((nodeDef) => {
      const node3 = app$1.addNodeOnGraph(nodeDef, { pos: getNewNodeLocation() });
      const eventDetail = triggerEvent2.value.detail;
      if (eventDetail.subType === "empty-release") {
        eventDetail.linkReleaseContext.links.forEach((link) => {
          ConnectingLinkImpl.createFromPlainObject(link).connectTo(node3);
        });
      }
      window.setTimeout(() => {
        closeDialog();
      }, 100);
    }, "addNode");
    const newSearchBoxEnabled = computed(
      () => settingStore.get("Comfy.NodeSearchBoxImpl") === "default"
    );
    const showSearchBox = /* @__PURE__ */ __name((e) => {
      if (newSearchBoxEnabled.value) {
        showNewSearchBox(e);
      } else {
        canvasStore.canvas.showSearchBox(e.detail.originalEvent);
      }
    }, "showSearchBox");
    const nodeDefStore = useNodeDefStore();
    const showNewSearchBox = /* @__PURE__ */ __name((e) => {
      if (e.detail.linkReleaseContext) {
        const links = e.detail.linkReleaseContext.links;
        if (links.length === 0) {
          console.warn("Empty release with no links! This should never happen");
          return;
        }
        const firstLink = ConnectingLinkImpl.createFromPlainObject(links[0]);
        const filter4 = nodeDefStore.nodeSearchService.getFilterById(
          firstLink.releaseSlotType
        );
        const dataType = firstLink.type;
        addFilter([filter4, dataType]);
      }
      visible.value = true;
      triggerEvent2.value = e;
      dismissable.value = false;
      setTimeout(() => {
        dismissable.value = true;
      }, 300);
    }, "showNewSearchBox");
    const showContextMenu = /* @__PURE__ */ __name((e) => {
      const links = e.detail.linkReleaseContext.links;
      if (links.length === 0) {
        console.warn("Empty release with no links! This should never happen");
        return;
      }
      const firstLink = ConnectingLinkImpl.createFromPlainObject(links[0]);
      const mouseEvent = e.detail.originalEvent;
      const commonOptions = {
        e: mouseEvent,
        allow_searchbox: true,
        showSearchBox: /* @__PURE__ */ __name(() => showSearchBox(e), "showSearchBox")
      };
      const connectionOptions = firstLink.output ? { nodeFrom: firstLink.node, slotFrom: firstLink.output } : { nodeTo: firstLink.node, slotTo: firstLink.input };
      canvasStore.canvas.showConnectionMenu({
        ...connectionOptions,
        ...commonOptions
      });
    }, "showContextMenu");
    const canvasStore = useCanvasStore();
    watchEffect(() => {
      if (canvasStore.canvas) {
        LiteGraph.release_link_on_empty_shows_menu = false;
        canvasStore.canvas.allow_searchbox = false;
      }
    });
    const canvasEventHandler = /* @__PURE__ */ __name((e) => {
      if (e.detail.subType === "empty-double-click") {
        showSearchBox(e);
      } else if (e.detail.subType === "empty-release") {
        handleCanvasEmptyRelease(e);
      } else if (e.detail.subType === "group-double-click") {
        const group = e.detail.group;
        const [x2, y2] = group.pos;
        const relativeY = e.detail.originalEvent.canvasY - y2;
        if (relativeY > group.titleHeight) {
          showSearchBox(e);
        }
      }
    }, "canvasEventHandler");
    const linkReleaseAction = computed(() => {
      return settingStore.get("Comfy.LinkRelease.Action");
    });
    const linkReleaseActionShift = computed(() => {
      return settingStore.get("Comfy.LinkRelease.ActionShift");
    });
    const handleCanvasEmptyRelease = /* @__PURE__ */ __name((e) => {
      const originalEvent = e.detail.originalEvent;
      const shiftPressed = originalEvent.shiftKey;
      const action = shiftPressed ? linkReleaseActionShift.value : linkReleaseAction.value;
      switch (action) {
        case LinkReleaseTriggerAction.SEARCH_BOX:
          showSearchBox(e);
          break;
        case LinkReleaseTriggerAction.CONTEXT_MENU:
          showContextMenu(e);
          break;
        case LinkReleaseTriggerAction.NO_ACTION:
        default:
          break;
      }
    }, "handleCanvasEmptyRelease");
    onMounted(() => {
      document.addEventListener("litegraph:canvas", canvasEventHandler);
    });
    onUnmounted(() => {
      document.removeEventListener("litegraph:canvas", canvasEventHandler);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createVNode(unref(script$k), {
          visible: visible.value,
          "onUpdate:visible": _cache[0] || (_cache[0] = ($event) => visible.value = $event),
          modal: "",
          "dismissable-mask": dismissable.value,
          onHide: clearFilters,
          pt: {
            root: { class: "invisible-dialog-root" },
            mask: { class: "node-search-box-dialog-mask" },
            transition: {
              enterFromClass: "opacity-0 scale-75",
              // 100ms is the duration of the transition in the dialog component
              enterActiveClass: "transition-all duration-100 ease-out",
              leaveActiveClass: "transition-all duration-100 ease-in",
              leaveToClass: "opacity-0 scale-75"
            }
          }
        }, {
          container: withCtx(() => [
            createVNode(NodeSearchBox, {
              filters: nodeFilters.value,
              onAddFilter: addFilter,
              onRemoveFilter: removeFilter,
              onAddNode: addNode
            }, null, 8, ["filters"])
          ]),
          _: 1
        }, 8, ["visible", "dismissable-mask"])
      ]);
    };
  }
});
const _sfc_main$i = /* @__PURE__ */ defineComponent({
  __name: "NodeTooltip",
  setup(__props) {
    let idleTimeout;
    const nodeDefStore = useNodeDefStore();
    const settingStore = useSettingStore();
    const tooltipRef = ref();
    const tooltipText = ref("");
    const left = ref();
    const top = ref();
    const getHoveredWidget = /* @__PURE__ */ __name(() => {
      const node3 = app$1.canvas.node_over;
      if (!node3.widgets) return;
      const graphPos = app$1.canvas.graph_mouse;
      const x2 = graphPos[0] - node3.pos[0];
      const y2 = graphPos[1] - node3.pos[1];
      for (const w2 of node3.widgets) {
        let widgetWidth, widgetHeight;
        if (w2.computeSize) {
          ;
          [widgetWidth, widgetHeight] = w2.computeSize(node3.size[0]);
        } else {
          widgetWidth = w2.width || node3.size[0];
          widgetHeight = LiteGraph.NODE_WIDGET_HEIGHT;
        }
        if (w2.last_y !== void 0 && x2 >= 6 && x2 <= widgetWidth - 12 && y2 >= w2.last_y && y2 <= w2.last_y + widgetHeight) {
          return w2;
        }
      }
    }, "getHoveredWidget");
    const hideTooltip = /* @__PURE__ */ __name(() => tooltipText.value = null, "hideTooltip");
    const showTooltip = /* @__PURE__ */ __name(async (tooltip) => {
      if (!tooltip) return;
      left.value = app$1.canvas.mouse[0] + "px";
      top.value = app$1.canvas.mouse[1] + "px";
      tooltipText.value = tooltip;
      await nextTick();
      const rect = tooltipRef.value.getBoundingClientRect();
      if (rect.right > window.innerWidth) {
        left.value = app$1.canvas.mouse[0] - rect.width + "px";
      }
      if (rect.top < 0) {
        top.value = app$1.canvas.mouse[1] + rect.height + "px";
      }
    }, "showTooltip");
    const onIdle = /* @__PURE__ */ __name(() => {
      const { canvas } = app$1;
      const node3 = canvas.node_over;
      if (!node3) return;
      const ctor = node3.constructor;
      const nodeDef = nodeDefStore.nodeDefsByName[node3.type];
      if (ctor.title_mode !== LiteGraph.NO_TITLE && canvas.graph_mouse[1] < node3.pos[1]) {
        return showTooltip(nodeDef.description);
      }
      if (node3.flags?.collapsed) return;
      const inputSlot = canvas.isOverNodeInput(
        node3,
        canvas.graph_mouse[0],
        canvas.graph_mouse[1],
        [0, 0]
      );
      if (inputSlot !== -1) {
        const inputName = node3.inputs[inputSlot].name;
        return showTooltip(nodeDef.input.getInput(inputName)?.tooltip);
      }
      const outputSlot = canvas.isOverNodeOutput(
        node3,
        canvas.graph_mouse[0],
        canvas.graph_mouse[1],
        [0, 0]
      );
      if (outputSlot !== -1) {
        return showTooltip(nodeDef.output.all?.[outputSlot].tooltip);
      }
      const widget = getHoveredWidget();
      if (widget && !widget.element) {
        return showTooltip(
          widget.tooltip ?? nodeDef.input.getInput(widget.name)?.tooltip
        );
      }
    }, "onIdle");
    const onMouseMove = /* @__PURE__ */ __name((e) => {
      hideTooltip();
      clearTimeout(idleTimeout);
      if (e.target.nodeName !== "CANVAS") return;
      idleTimeout = window.setTimeout(onIdle, 500);
    }, "onMouseMove");
    watch(
      () => settingStore.get("Comfy.EnableTooltips"),
      (enabled) => {
        if (enabled) {
          window.addEventListener("mousemove", onMouseMove);
          window.addEventListener("click", hideTooltip);
        } else {
          window.removeEventListener("mousemove", onMouseMove);
          window.removeEventListener("click", hideTooltip);
        }
      },
      { immediate: true }
    );
    onBeforeUnmount(() => {
      window.removeEventListener("mousemove", onMouseMove);
      window.removeEventListener("click", hideTooltip);
    });
    return (_ctx, _cache) => {
      return tooltipText.value ? (openBlock(), createElementBlock("div", {
        key: 0,
        ref_key: "tooltipRef",
        ref: tooltipRef,
        class: "node-tooltip",
        style: normalizeStyle({ left: left.value, top: top.value })
      }, toDisplayString$1(tooltipText.value), 5)) : createCommentVNode("", true);
    };
  }
});
const NodeTooltip = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["__scopeId", "data-v-e0597bf9"]]);
function _arrayWithHoles(r) {
  if (Array.isArray(r)) return r;
}
__name(_arrayWithHoles, "_arrayWithHoles");
function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i2, u, a = [], f = true, o = false;
    try {
      if (i2 = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = false;
      } else for (; !(f = (e = i2.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
__name(_iterableToArrayLimit, "_iterableToArrayLimit");
function _arrayLikeToArray$7(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
__name(_arrayLikeToArray$7, "_arrayLikeToArray$7");
function _unsupportedIterableToArray$7(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$7(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$7(r, a) : void 0;
  }
}
__name(_unsupportedIterableToArray$7, "_unsupportedIterableToArray$7");
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableRest, "_nonIterableRest");
function _slicedToArray(r, e) {
  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray$7(r, e) || _nonIterableRest();
}
__name(_slicedToArray, "_slicedToArray");
var dist = {};
var bind$1 = {};
"use strict";
Object.defineProperty(bind$1, "__esModule", { value: true });
var bind_2 = bind$1.bind = void 0;
function bind(target, _a) {
  var type = _a.type, listener = _a.listener, options3 = _a.options;
  target.addEventListener(type, listener, options3);
  return /* @__PURE__ */ __name(function unbind2() {
    target.removeEventListener(type, listener, options3);
  }, "unbind");
}
__name(bind, "bind");
bind_2 = bind$1.bind = bind;
var bindAll$1 = {};
"use strict";
var __assign = commonjsGlobal && commonjsGlobal.__assign || function() {
  __assign = Object.assign || function(t) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2))
        t[p2] = s[p2];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
Object.defineProperty(bindAll$1, "__esModule", { value: true });
var bindAll_2 = bindAll$1.bindAll = void 0;
var bind_1 = bind$1;
function toOptions(value3) {
  if (typeof value3 === "undefined") {
    return void 0;
  }
  if (typeof value3 === "boolean") {
    return {
      capture: value3
    };
  }
  return value3;
}
__name(toOptions, "toOptions");
function getBinding(original, sharedOptions) {
  if (sharedOptions == null) {
    return original;
  }
  var binding = __assign(__assign({}, original), { options: __assign(__assign({}, toOptions(sharedOptions)), toOptions(original.options)) });
  return binding;
}
__name(getBinding, "getBinding");
function bindAll(target, bindings, sharedOptions) {
  var unbinds = bindings.map(function(original) {
    var binding = getBinding(original, sharedOptions);
    return (0, bind_1.bind)(target, binding);
  });
  return /* @__PURE__ */ __name(function unbindAll() {
    unbinds.forEach(function(unbind2) {
      return unbind2();
    });
  }, "unbindAll");
}
__name(bindAll, "bindAll");
bindAll_2 = bindAll$1.bindAll = bindAll;
(function(exports) {
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bindAll = exports.bind = void 0;
  var bind_12 = bind$1;
  Object.defineProperty(exports, "bind", { enumerable: true, get: /* @__PURE__ */ __name(function() {
    return bind_12.bind;
  }, "get") });
  var bind_all_1 = bindAll$1;
  Object.defineProperty(exports, "bindAll", { enumerable: true, get: /* @__PURE__ */ __name(function() {
    return bind_all_1.bindAll;
  }, "get") });
})(dist);
const index = /* @__PURE__ */ getDefaultExportFromCjs(dist);
var honeyPotDataAttribute = "data-pdnd-honey-pot";
function isHoneyPotElement(target) {
  return target instanceof Element && target.hasAttribute(honeyPotDataAttribute);
}
__name(isHoneyPotElement, "isHoneyPotElement");
function getElementFromPointWithoutHoneypot(client) {
  var _document$elementsFro = document.elementsFromPoint(client.x, client.y), _document$elementsFro2 = _slicedToArray(_document$elementsFro, 2), top = _document$elementsFro2[0], second = _document$elementsFro2[1];
  if (!top) {
    return null;
  }
  if (isHoneyPotElement(top)) {
    return second !== null && second !== void 0 ? second : null;
  }
  return top;
}
__name(getElementFromPointWithoutHoneypot, "getElementFromPointWithoutHoneypot");
function _typeof$5(o) {
  "@babel/helpers - typeof";
  return _typeof$5 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$5(o);
}
__name(_typeof$5, "_typeof$5");
function toPrimitive(t, r) {
  if ("object" != _typeof$5(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$5(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(toPrimitive, "toPrimitive");
function toPropertyKey(t) {
  var i2 = toPrimitive(t, "string");
  return "symbol" == _typeof$5(i2) ? i2 : i2 + "";
}
__name(toPropertyKey, "toPropertyKey");
function _defineProperty$5(e, r, t) {
  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[r] = t, e;
}
__name(_defineProperty$5, "_defineProperty$5");
var maxZIndex = 2147483647;
function ownKeys$6(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
__name(ownKeys$6, "ownKeys$6");
function _objectSpread$6(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$6(Object(t), true).forEach(function(r2) {
      _defineProperty$5(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$6(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
__name(_objectSpread$6, "_objectSpread$6");
var honeyPotSize = 2;
var halfHoneyPotSize = honeyPotSize / 2;
function floorToClosestPixel(point) {
  return {
    x: Math.floor(point.x),
    y: Math.floor(point.y)
  };
}
__name(floorToClosestPixel, "floorToClosestPixel");
function pullBackByHalfHoneyPotSize(point) {
  return {
    x: point.x - halfHoneyPotSize,
    y: point.y - halfHoneyPotSize
  };
}
__name(pullBackByHalfHoneyPotSize, "pullBackByHalfHoneyPotSize");
function preventGoingBackwardsOffScreen(point) {
  return {
    x: Math.max(point.x, 0),
    y: Math.max(point.y, 0)
  };
}
__name(preventGoingBackwardsOffScreen, "preventGoingBackwardsOffScreen");
function preventGoingForwardsOffScreen(point) {
  return {
    x: Math.min(point.x, window.innerWidth - honeyPotSize),
    y: Math.min(point.y, window.innerHeight - honeyPotSize)
  };
}
__name(preventGoingForwardsOffScreen, "preventGoingForwardsOffScreen");
function getHoneyPotRectFor(_ref) {
  var client = _ref.client;
  var point = preventGoingForwardsOffScreen(preventGoingBackwardsOffScreen(pullBackByHalfHoneyPotSize(floorToClosestPixel(client))));
  return DOMRect.fromRect({
    x: point.x,
    y: point.y,
    width: honeyPotSize,
    height: honeyPotSize
  });
}
__name(getHoneyPotRectFor, "getHoneyPotRectFor");
function getRectStyles(_ref2) {
  var clientRect = _ref2.clientRect;
  return {
    left: "".concat(clientRect.left, "px"),
    top: "".concat(clientRect.top, "px"),
    width: "".concat(clientRect.width, "px"),
    height: "".concat(clientRect.height, "px")
  };
}
__name(getRectStyles, "getRectStyles");
function isWithin(_ref3) {
  var client = _ref3.client, clientRect = _ref3.clientRect;
  return (
    // is within horizontal bounds
    client.x >= clientRect.x && client.x <= clientRect.x + clientRect.width && // is within vertical bounds
    client.y >= clientRect.y && client.y <= clientRect.y + clientRect.height
  );
}
__name(isWithin, "isWithin");
function mountHoneyPot(_ref4) {
  var initial = _ref4.initial;
  var element = document.createElement("div");
  element.setAttribute(honeyPotDataAttribute, "true");
  var clientRect = getHoneyPotRectFor({
    client: initial
  });
  Object.assign(element.style, _objectSpread$6(_objectSpread$6({
    // Setting a background color explicitly to avoid any inherited styles.
    // Looks like this could be `opacity: 0`, but worried that _might_
    // cause the element to be ignored on some platforms.
    // When debugging, set backgroundColor to something like "red".
    backgroundColor: "transparent",
    position: "fixed",
    // Being explicit to avoid inheriting styles
    padding: 0,
    margin: 0,
    boxSizing: "border-box"
  }, getRectStyles({
    clientRect
  })), {}, {
    // We want this element to absorb pointer events,
    // it's kind of the whole point 
    pointerEvents: "auto",
    // Want to make sure the honey pot is top of everything else.
    // Don't need to worry about native drag previews, as they will
    // have been rendered (and removed) before the honey pot is rendered
    zIndex: maxZIndex
  }));
  document.body.appendChild(element);
  var unbindPointerMove = dist.bind(window, {
    type: "pointermove",
    listener: /* @__PURE__ */ __name(function listener(event2) {
      var client = {
        x: event2.clientX,
        y: event2.clientY
      };
      clientRect = getHoneyPotRectFor({
        client
      });
      Object.assign(element.style, getRectStyles({
        clientRect
      }));
    }, "listener"),
    // using capture so we are less likely to be impacted by event stopping
    options: {
      capture: true
    }
  });
  return /* @__PURE__ */ __name(function finish(_ref5) {
    var current = _ref5.current;
    unbindPointerMove();
    if (isWithin({
      client: current,
      clientRect
    })) {
      element.remove();
      return;
    }
    function cleanup() {
      unbindPostDragEvents();
      element.remove();
    }
    __name(cleanup, "cleanup");
    var unbindPostDragEvents = dist.bindAll(window, [
      {
        type: "pointerdown",
        listener: cleanup
      },
      {
        type: "pointermove",
        listener: cleanup
      },
      {
        type: "focusin",
        listener: cleanup
      },
      {
        type: "focusout",
        listener: cleanup
      },
      // a 'pointerdown' should happen before 'dragstart', but just being super safe
      {
        type: "dragstart",
        listener: cleanup
      },
      // if the user has dragged something out of the window
      // and then is dragging something back into the window
      // the first events we will see are "dragenter" (and then "dragover").
      // So if we see any of these we need to clear the post drag fix.
      {
        type: "dragenter",
        listener: cleanup
      },
      {
        type: "dragover",
        listener: cleanup
      }
      // Not adding a "wheel" event listener, as "wheel" by itself does not
      // resolve the bug.
    ], {
      // Using `capture` so less likely to be impacted by other code stopping events
      capture: true
    });
  }, "finish");
}
__name(mountHoneyPot, "mountHoneyPot");
function makeHoneyPotFix() {
  var latestPointerMove = null;
  function bindEvents3() {
    latestPointerMove = null;
    return dist.bind(window, {
      type: "pointermove",
      listener: /* @__PURE__ */ __name(function listener(event2) {
        latestPointerMove = {
          x: event2.clientX,
          y: event2.clientY
        };
      }, "listener"),
      // listening for pointer move in capture phase
      // so we are less likely to be impacted by events being stopped.
      options: {
        capture: true
      }
    });
  }
  __name(bindEvents3, "bindEvents");
  function getOnPostDispatch() {
    var finish = null;
    return /* @__PURE__ */ __name(function onPostEvent(_ref6) {
      var eventName = _ref6.eventName, payload = _ref6.payload;
      if (eventName === "onDragStart") {
        var _latestPointerMove;
        var input = payload.location.initial.input;
        var initial = (_latestPointerMove = latestPointerMove) !== null && _latestPointerMove !== void 0 ? _latestPointerMove : {
          x: input.clientX,
          y: input.clientY
        };
        finish = mountHoneyPot({
          initial
        });
      }
      if (eventName === "onDrop") {
        var _finish;
        var _input = payload.location.current.input;
        (_finish = finish) === null || _finish === void 0 || _finish({
          current: {
            x: _input.clientX,
            y: _input.clientY
          }
        });
        finish = null;
        latestPointerMove = null;
      }
    }, "onPostEvent");
  }
  __name(getOnPostDispatch, "getOnPostDispatch");
  return {
    bindEvents: bindEvents3,
    getOnPostDispatch
  };
}
__name(makeHoneyPotFix, "makeHoneyPotFix");
function _arrayWithoutHoles$5(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$7(r);
}
__name(_arrayWithoutHoles$5, "_arrayWithoutHoles$5");
function _iterableToArray$5(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
__name(_iterableToArray$5, "_iterableToArray$5");
function _nonIterableSpread$5() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableSpread$5, "_nonIterableSpread$5");
function _toConsumableArray$5(r) {
  return _arrayWithoutHoles$5(r) || _iterableToArray$5(r) || _unsupportedIterableToArray$7(r) || _nonIterableSpread$5();
}
__name(_toConsumableArray$5, "_toConsumableArray$5");
function once(fn) {
  var cache2 = null;
  return /* @__PURE__ */ __name(function wrapped() {
    if (!cache2) {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var result = fn.apply(this, args);
      cache2 = {
        result
      };
    }
    return cache2.result;
  }, "wrapped");
}
__name(once, "once");
var isFirefox = once(/* @__PURE__ */ __name(function isFirefox2() {
  if (false) {
    return false;
  }
  return navigator.userAgent.includes("Firefox");
}, "isFirefox2"));
var isSafari = once(/* @__PURE__ */ __name(function isSafari2() {
  if (false) {
    return false;
  }
  var _navigator2 = navigator, userAgent = _navigator2.userAgent;
  return userAgent.includes("AppleWebKit") && !userAgent.includes("Chrome");
}, "isSafari2"));
var symbols = {
  isLeavingWindow: Symbol("leaving"),
  isEnteringWindow: Symbol("entering")
};
function isEnteringWindowInSafari(_ref) {
  var dragEnter = _ref.dragEnter;
  if (!isSafari()) {
    return false;
  }
  return dragEnter.hasOwnProperty(symbols.isEnteringWindow);
}
__name(isEnteringWindowInSafari, "isEnteringWindowInSafari");
function isLeavingWindowInSafari(_ref2) {
  var dragLeave = _ref2.dragLeave;
  if (!isSafari()) {
    return false;
  }
  return dragLeave.hasOwnProperty(symbols.isLeavingWindow);
}
__name(isLeavingWindowInSafari, "isLeavingWindowInSafari");
(/* @__PURE__ */ __name(function fixSafari() {
  if (typeof window === "undefined") {
    return;
  }
  if (false) {
    return;
  }
  if (!isSafari()) {
    return;
  }
  function getInitialState() {
    return {
      enterCount: 0,
      isOverWindow: false
    };
  }
  __name(getInitialState, "getInitialState");
  var state = getInitialState();
  function resetState() {
    state = getInitialState();
  }
  __name(resetState, "resetState");
  dist.bindAll(
    window,
    [{
      type: "dragstart",
      listener: /* @__PURE__ */ __name(function listener() {
        state.enterCount = 0;
        state.isOverWindow = true;
      }, "listener")
    }, {
      type: "drop",
      listener: resetState
    }, {
      type: "dragend",
      listener: resetState
    }, {
      type: "dragenter",
      listener: /* @__PURE__ */ __name(function listener(event2) {
        if (!state.isOverWindow && state.enterCount === 0) {
          event2[symbols.isEnteringWindow] = true;
        }
        state.isOverWindow = true;
        state.enterCount++;
      }, "listener")
    }, {
      type: "dragleave",
      listener: /* @__PURE__ */ __name(function listener(event2) {
        state.enterCount--;
        if (state.isOverWindow && state.enterCount === 0) {
          event2[symbols.isLeavingWindow] = true;
          state.isOverWindow = false;
        }
      }, "listener")
    }],
    // using `capture: true` so that adding event listeners
    // in bubble phase will have the correct symbols
    {
      capture: true
    }
  );
}, "fixSafari"))();
function isNodeLike(target) {
  return "nodeName" in target;
}
__name(isNodeLike, "isNodeLike");
function isFromAnotherWindow(eventTarget) {
  return isNodeLike(eventTarget) && eventTarget.ownerDocument !== document;
}
__name(isFromAnotherWindow, "isFromAnotherWindow");
function isLeavingWindow(_ref) {
  var dragLeave = _ref.dragLeave;
  var type = dragLeave.type, relatedTarget = dragLeave.relatedTarget;
  if (type !== "dragleave") {
    return false;
  }
  if (isSafari()) {
    return isLeavingWindowInSafari({
      dragLeave
    });
  }
  if (relatedTarget == null) {
    return true;
  }
  if (isFirefox()) {
    return isFromAnotherWindow(relatedTarget);
  }
  return relatedTarget instanceof HTMLIFrameElement;
}
__name(isLeavingWindow, "isLeavingWindow");
function getBindingsForBrokenDrags(_ref) {
  var onDragEnd3 = _ref.onDragEnd;
  return [
    // ## Detecting drag ending for removed draggables
    //
    // If a draggable element is removed during a drag and the user drops:
    // 1. if over a valid drop target: we get a "drop" event to know the drag is finished
    // 2. if not over a valid drop target (or cancelled): we get nothing
    // The "dragend" event will not fire on the source draggable if it has been
    // removed from the DOM.
    // So we need to figure out if a drag operation has finished by looking at other events
    // We can do this by looking at other events
    // ### First detection: "pointermove" events
    // 1. "pointermove" events cannot fire during a drag and drop operation
    // according to the spec. So if we get a "pointermove" it means that
    // the drag and drop operations has finished. So if we get a "pointermove"
    // we know that the drag is over
    // 2.  Drag and drop operations are _supposed_ to suppress
    // other pointer events. However, firefox will allow a few
    // pointer event to get through after a drag starts.
    // The most I've seen is 3
    {
      type: "pointermove",
      listener: /* @__PURE__ */ function() {
        var callCount = 0;
        return /* @__PURE__ */ __name(function listener() {
          if (callCount < 20) {
            callCount++;
            return;
          }
          onDragEnd3();
        }, "listener");
      }()
    },
    // ### Second detection: "pointerdown" events
    // If we receive this event then we know that a drag operation has finished
    // and potentially another one is about to start.
    // Note: `pointerdown` fires on all browsers / platforms before "dragstart"
    {
      type: "pointerdown",
      listener: onDragEnd3
    }
  ];
}
__name(getBindingsForBrokenDrags, "getBindingsForBrokenDrags");
function getInput(event2) {
  return {
    altKey: event2.altKey,
    button: event2.button,
    buttons: event2.buttons,
    ctrlKey: event2.ctrlKey,
    metaKey: event2.metaKey,
    shiftKey: event2.shiftKey,
    clientX: event2.clientX,
    clientY: event2.clientY,
    pageX: event2.pageX,
    pageY: event2.pageY
  };
}
__name(getInput, "getInput");
var rafSchd = /* @__PURE__ */ __name(function rafSchd2(fn) {
  var lastArgs = [];
  var frameId = null;
  var wrapperFn = /* @__PURE__ */ __name(function wrapperFn2() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    lastArgs = args;
    if (frameId) {
      return;
    }
    frameId = requestAnimationFrame(function() {
      frameId = null;
      fn.apply(void 0, lastArgs);
    });
  }, "wrapperFn");
  wrapperFn.cancel = function() {
    if (!frameId) {
      return;
    }
    cancelAnimationFrame(frameId);
    frameId = null;
  };
  return wrapperFn;
}, "rafSchd");
var scheduleOnDrag = rafSchd(function(fn) {
  return fn();
});
var dragStart = /* @__PURE__ */ function() {
  var scheduled = null;
  function schedule(fn) {
    var frameId = requestAnimationFrame(function() {
      scheduled = null;
      fn();
    });
    scheduled = {
      frameId,
      fn
    };
  }
  __name(schedule, "schedule");
  function flush() {
    if (scheduled) {
      cancelAnimationFrame(scheduled.frameId);
      scheduled.fn();
      scheduled = null;
    }
  }
  __name(flush, "flush");
  return {
    schedule,
    flush
  };
}();
function makeDispatch(_ref) {
  var source = _ref.source, initial = _ref.initial, dispatchEvent = _ref.dispatchEvent;
  var previous = {
    dropTargets: []
  };
  function safeDispatch(args) {
    dispatchEvent(args);
    previous = {
      dropTargets: args.payload.location.current.dropTargets
    };
  }
  __name(safeDispatch, "safeDispatch");
  var dispatch = {
    start: /* @__PURE__ */ __name(function start2(_ref2) {
      var nativeSetDragImage = _ref2.nativeSetDragImage;
      var location2 = {
        current: initial,
        previous,
        initial
      };
      safeDispatch({
        eventName: "onGenerateDragPreview",
        payload: {
          source,
          location: location2,
          nativeSetDragImage
        }
      });
      dragStart.schedule(function() {
        safeDispatch({
          eventName: "onDragStart",
          payload: {
            source,
            location: location2
          }
        });
      });
    }, "start"),
    dragUpdate: /* @__PURE__ */ __name(function dragUpdate(_ref3) {
      var current = _ref3.current;
      dragStart.flush();
      scheduleOnDrag.cancel();
      safeDispatch({
        eventName: "onDropTargetChange",
        payload: {
          source,
          location: {
            initial,
            previous,
            current
          }
        }
      });
    }, "dragUpdate"),
    drag: /* @__PURE__ */ __name(function drag(_ref4) {
      var current = _ref4.current;
      scheduleOnDrag(function() {
        dragStart.flush();
        var location2 = {
          initial,
          previous,
          current
        };
        safeDispatch({
          eventName: "onDrag",
          payload: {
            source,
            location: location2
          }
        });
      });
    }, "drag"),
    drop: /* @__PURE__ */ __name(function drop(_ref5) {
      var current = _ref5.current, updatedSourcePayload = _ref5.updatedSourcePayload;
      dragStart.flush();
      scheduleOnDrag.cancel();
      safeDispatch({
        eventName: "onDrop",
        payload: {
          source: updatedSourcePayload !== null && updatedSourcePayload !== void 0 ? updatedSourcePayload : source,
          location: {
            current,
            previous,
            initial
          }
        }
      });
    }, "drop")
  };
  return dispatch;
}
__name(makeDispatch, "makeDispatch");
var globalState = {
  isActive: false
};
function canStart() {
  return !globalState.isActive;
}
__name(canStart, "canStart");
function getNativeSetDragImage(event2) {
  if (event2.dataTransfer) {
    return event2.dataTransfer.setDragImage.bind(event2.dataTransfer);
  }
  return null;
}
__name(getNativeSetDragImage, "getNativeSetDragImage");
function hasHierarchyChanged(_ref) {
  var current = _ref.current, next2 = _ref.next;
  if (current.length !== next2.length) {
    return true;
  }
  for (var i2 = 0; i2 < current.length; i2++) {
    if (current[i2].element !== next2[i2].element) {
      return true;
    }
  }
  return false;
}
__name(hasHierarchyChanged, "hasHierarchyChanged");
function start(_ref2) {
  var event2 = _ref2.event, dragType = _ref2.dragType, getDropTargetsOver = _ref2.getDropTargetsOver, dispatchEvent = _ref2.dispatchEvent;
  if (!canStart()) {
    return;
  }
  var initial = getStartLocation({
    event: event2,
    dragType,
    getDropTargetsOver
  });
  globalState.isActive = true;
  var state = {
    current: initial
  };
  setDropEffectOnEvent({
    event: event2,
    current: initial.dropTargets
  });
  var dispatch = makeDispatch({
    source: dragType.payload,
    dispatchEvent,
    initial
  });
  function updateState(next2) {
    var hasChanged2 = hasHierarchyChanged({
      current: state.current.dropTargets,
      next: next2.dropTargets
    });
    state.current = next2;
    if (hasChanged2) {
      dispatch.dragUpdate({
        current: state.current
      });
    }
  }
  __name(updateState, "updateState");
  function onUpdateEvent(event3) {
    var input = getInput(event3);
    var target = isHoneyPotElement(event3.target) ? getElementFromPointWithoutHoneypot({
      x: input.clientX,
      y: input.clientY
    }) : event3.target;
    var nextDropTargets = getDropTargetsOver({
      target,
      input,
      source: dragType.payload,
      current: state.current.dropTargets
    });
    if (nextDropTargets.length) {
      event3.preventDefault();
      setDropEffectOnEvent({
        event: event3,
        current: nextDropTargets
      });
    }
    updateState({
      dropTargets: nextDropTargets,
      input
    });
  }
  __name(onUpdateEvent, "onUpdateEvent");
  function cancel() {
    if (state.current.dropTargets.length) {
      updateState({
        dropTargets: [],
        input: state.current.input
      });
    }
    dispatch.drop({
      current: state.current,
      updatedSourcePayload: null
    });
    finish();
  }
  __name(cancel, "cancel");
  function finish() {
    globalState.isActive = false;
    unbindEvents3();
  }
  __name(finish, "finish");
  var unbindEvents3 = dist.bindAll(
    window,
    [{
      //  Note: we are repurposing the `dragover` event as our `drag` event
      // this is because firefox does not publish pointer coordinates during
      // a `drag` event, but does for every other type of drag event
      // `dragover` fires on all elements that are being dragged over
      // Because we are binding to `window` - our `dragover` is effectively the same as a `drag`
      // 
      type: "dragover",
      listener: /* @__PURE__ */ __name(function listener(event3) {
        onUpdateEvent(event3);
        dispatch.drag({
          current: state.current
        });
      }, "listener")
    }, {
      type: "dragenter",
      listener: onUpdateEvent
    }, {
      type: "dragleave",
      listener: /* @__PURE__ */ __name(function listener(event3) {
        if (!isLeavingWindow({
          dragLeave: event3
        })) {
          return;
        }
        updateState({
          input: state.current.input,
          dropTargets: []
        });
        if (dragType.startedFrom === "external") {
          cancel();
        }
      }, "listener")
    }, {
      // A "drop" can only happen if the browser allowed the drop
      type: "drop",
      listener: /* @__PURE__ */ __name(function listener(event3) {
        state.current = {
          dropTargets: state.current.dropTargets,
          input: getInput(event3)
        };
        if (!state.current.dropTargets.length) {
          cancel();
          return;
        }
        event3.preventDefault();
        setDropEffectOnEvent({
          event: event3,
          current: state.current.dropTargets
        });
        dispatch.drop({
          current: state.current,
          // When dropping something native, we need to extract the latest
          // `.items` from the "drop" event as it is now accessible
          updatedSourcePayload: dragType.type === "external" ? dragType.getDropPayload(event3) : null
        });
        finish();
      }, "listener")
    }, {
      // "dragend" fires when on the drag source (eg a draggable element)
      // when the drag is finished.
      // "dragend" will fire after "drop" (if there was a successful drop)
      // "dragend" does not fire if the draggable source has been removed during the drag
      // or for external drag sources (eg files)
      // This "dragend" listener will not fire if there was a successful drop
      // as we will have already removed the event listener
      type: "dragend",
      listener: /* @__PURE__ */ __name(function listener(event3) {
        state.current = {
          dropTargets: state.current.dropTargets,
          input: getInput(event3)
        };
        cancel();
      }, "listener")
    }].concat(_toConsumableArray$5(getBindingsForBrokenDrags({
      onDragEnd: cancel
    }))),
    // Once we have started a managed drag operation it is important that we see / own all drag events
    // We got one adoption bug pop up where some code was stopping (`event.stopPropagation()`)
    // all "drop" events in the bubble phase on the `document.body`.
    // This meant that we never saw the "drop" event.
    {
      capture: true
    }
  );
  dispatch.start({
    nativeSetDragImage: getNativeSetDragImage(event2)
  });
}
__name(start, "start");
function setDropEffectOnEvent(_ref3) {
  var _current$;
  var event2 = _ref3.event, current = _ref3.current;
  var innerMost = (_current$ = current[0]) === null || _current$ === void 0 ? void 0 : _current$.dropEffect;
  if (innerMost != null && event2.dataTransfer) {
    event2.dataTransfer.dropEffect = innerMost;
  }
}
__name(setDropEffectOnEvent, "setDropEffectOnEvent");
function getStartLocation(_ref4) {
  var event2 = _ref4.event, dragType = _ref4.dragType, getDropTargetsOver = _ref4.getDropTargetsOver;
  var input = getInput(event2);
  if (dragType.startedFrom === "external") {
    return {
      input,
      dropTargets: []
    };
  }
  var dropTargets = getDropTargetsOver({
    input,
    source: dragType.payload,
    target: event2.target,
    current: []
  });
  return {
    input,
    dropTargets
  };
}
__name(getStartLocation, "getStartLocation");
var lifecycle = {
  canStart,
  start
};
var ledger = /* @__PURE__ */ new Map();
function registerUsage(_ref) {
  var typeKey = _ref.typeKey, mount2 = _ref.mount;
  var entry = ledger.get(typeKey);
  if (entry) {
    entry.usageCount++;
    return entry;
  }
  var initial = {
    typeKey,
    unmount: mount2(),
    usageCount: 1
  };
  ledger.set(typeKey, initial);
  return initial;
}
__name(registerUsage, "registerUsage");
function register(args) {
  var entry = registerUsage(args);
  return /* @__PURE__ */ __name(function unregister() {
    entry.usageCount--;
    if (entry.usageCount > 0) {
      return;
    }
    entry.unmount();
    ledger.delete(args.typeKey);
  }, "unregister");
}
__name(register, "register");
function combine() {
  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
    fns[_key] = arguments[_key];
  }
  return /* @__PURE__ */ __name(function cleanup() {
    fns.forEach(function(fn) {
      return fn();
    });
  }, "cleanup");
}
__name(combine, "combine");
function addAttribute(element, _ref) {
  var attribute = _ref.attribute, value3 = _ref.value;
  element.setAttribute(attribute, value3);
  return function() {
    return element.removeAttribute(attribute);
  };
}
__name(addAttribute, "addAttribute");
function ownKeys$5(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
__name(ownKeys$5, "ownKeys$5");
function _objectSpread$5(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$5(Object(t), true).forEach(function(r2) {
      _defineProperty$5(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$5(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
__name(_objectSpread$5, "_objectSpread$5");
function _createForOfIteratorHelper$3(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$6(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i2 = 0;
      var F = /* @__PURE__ */ __name(function F2() {
      }, "F2");
      return { s: F, n: /* @__PURE__ */ __name(function n() {
        if (i2 >= o.length) return { done: true };
        return { done: false, value: o[i2++] };
      }, "n"), e: /* @__PURE__ */ __name(function e(_e) {
        throw _e;
      }, "e"), f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: /* @__PURE__ */ __name(function s() {
    it = it.call(o);
  }, "s"), n: /* @__PURE__ */ __name(function n() {
    var step2 = it.next();
    normalCompletion = step2.done;
    return step2;
  }, "n"), e: /* @__PURE__ */ __name(function e(_e2) {
    didErr = true;
    err = _e2;
  }, "e"), f: /* @__PURE__ */ __name(function f() {
    try {
      if (!normalCompletion && it.return != null) it.return();
    } finally {
      if (didErr) throw err;
    }
  }, "f") };
}
__name(_createForOfIteratorHelper$3, "_createForOfIteratorHelper$3");
function _unsupportedIterableToArray$6(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$6(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$6(o, minLen);
}
__name(_unsupportedIterableToArray$6, "_unsupportedIterableToArray$6");
function _arrayLikeToArray$6(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) arr2[i2] = arr[i2];
  return arr2;
}
__name(_arrayLikeToArray$6, "_arrayLikeToArray$6");
function copyReverse(array) {
  return array.slice(0).reverse();
}
__name(copyReverse, "copyReverse");
function makeDropTarget(_ref) {
  var typeKey = _ref.typeKey, defaultDropEffect = _ref.defaultDropEffect;
  var registry = /* @__PURE__ */ new WeakMap();
  var dropTargetDataAtt = "data-drop-target-for-".concat(typeKey);
  var dropTargetSelector = "[".concat(dropTargetDataAtt, "]");
  function addToRegistry2(args) {
    registry.set(args.element, args);
    return function() {
      return registry.delete(args.element);
    };
  }
  __name(addToRegistry2, "addToRegistry");
  function dropTargetForConsumers(args) {
    if (false) {
      var existing = registry.get(args.element);
      if (existing) {
        console.warn("You have already registered a [".concat(typeKey, "] dropTarget on the same element"), {
          existing,
          proposed: args
        });
      }
      if (args.element instanceof HTMLIFrameElement) {
        console.warn("\n            We recommend not registering <iframe> elements as drop targets\n            as it can result in some strange browser event ordering.\n          ".replace(/\s{2,}/g, " ").trim());
      }
    }
    return combine(addAttribute(args.element, {
      attribute: dropTargetDataAtt,
      value: "true"
    }), addToRegistry2(args));
  }
  __name(dropTargetForConsumers, "dropTargetForConsumers");
  function getActualDropTargets(_ref2) {
    var _args$getData, _args$getData2, _args$getDropEffect, _args$getDropEffect2;
    var source = _ref2.source, target = _ref2.target, input = _ref2.input, _ref2$result = _ref2.result, result = _ref2$result === void 0 ? [] : _ref2$result;
    if (target == null) {
      return result;
    }
    if (!(target instanceof Element)) {
      if (target instanceof Node) {
        return getActualDropTargets({
          source,
          target: target.parentElement,
          input,
          result
        });
      }
      return result;
    }
    var closest = target.closest(dropTargetSelector);
    if (closest == null) {
      return result;
    }
    var args = registry.get(closest);
    if (args == null) {
      return result;
    }
    var feedback = {
      input,
      source,
      element: args.element
    };
    if (args.canDrop && !args.canDrop(feedback)) {
      return getActualDropTargets({
        source,
        target: args.element.parentElement,
        input,
        result
      });
    }
    var data24 = (_args$getData = (_args$getData2 = args.getData) === null || _args$getData2 === void 0 ? void 0 : _args$getData2.call(args, feedback)) !== null && _args$getData !== void 0 ? _args$getData : {};
    var dropEffect = (_args$getDropEffect = (_args$getDropEffect2 = args.getDropEffect) === null || _args$getDropEffect2 === void 0 ? void 0 : _args$getDropEffect2.call(args, feedback)) !== null && _args$getDropEffect !== void 0 ? _args$getDropEffect : defaultDropEffect;
    var record = {
      data: data24,
      element: args.element,
      dropEffect,
      // we are collecting _actual_ drop targets, so these are
      // being applied _not_ due to stickiness
      isActiveDueToStickiness: false
    };
    return getActualDropTargets({
      source,
      target: args.element.parentElement,
      input,
      // Using bubble ordering. Same ordering as `event.getPath()`
      result: [].concat(_toConsumableArray$5(result), [record])
    });
  }
  __name(getActualDropTargets, "getActualDropTargets");
  function notifyCurrent(_ref3) {
    var eventName = _ref3.eventName, payload = _ref3.payload;
    var _iterator = _createForOfIteratorHelper$3(payload.location.current.dropTargets), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var _entry$eventName;
        var record = _step.value;
        var entry = registry.get(record.element);
        var _args = _objectSpread$5(_objectSpread$5({}, payload), {}, {
          self: record
        });
        entry === null || entry === void 0 || (_entry$eventName = entry[eventName]) === null || _entry$eventName === void 0 || _entry$eventName.call(
          entry,
          // I cannot seem to get the types right here.
          // TS doesn't seem to like that one event can need `nativeSetDragImage`
          // @ts-expect-error
          _args
        );
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  __name(notifyCurrent, "notifyCurrent");
  var actions = {
    onGenerateDragPreview: notifyCurrent,
    onDrag: notifyCurrent,
    onDragStart: notifyCurrent,
    onDrop: notifyCurrent,
    onDropTargetChange: /* @__PURE__ */ __name(function onDropTargetChange(_ref4) {
      var payload = _ref4.payload;
      var isCurrent = new Set(payload.location.current.dropTargets.map(function(record2) {
        return record2.element;
      }));
      var visited = /* @__PURE__ */ new Set();
      var _iterator2 = _createForOfIteratorHelper$3(payload.location.previous.dropTargets), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var _entry$onDropTargetCh;
          var record = _step2.value;
          visited.add(record.element);
          var entry = registry.get(record.element);
          var isOver = isCurrent.has(record.element);
          var _args2 = _objectSpread$5(_objectSpread$5({}, payload), {}, {
            self: record
          });
          entry === null || entry === void 0 || (_entry$onDropTargetCh = entry.onDropTargetChange) === null || _entry$onDropTargetCh === void 0 || _entry$onDropTargetCh.call(entry, _args2);
          if (!isOver) {
            var _entry$onDragLeave;
            entry === null || entry === void 0 || (_entry$onDragLeave = entry.onDragLeave) === null || _entry$onDragLeave === void 0 || _entry$onDragLeave.call(entry, _args2);
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      var _iterator3 = _createForOfIteratorHelper$3(payload.location.current.dropTargets), _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
          var _entry$onDropTargetCh2, _entry$onDragEnter;
          var _record = _step3.value;
          if (visited.has(_record.element)) {
            continue;
          }
          var _args3 = _objectSpread$5(_objectSpread$5({}, payload), {}, {
            self: _record
          });
          var _entry = registry.get(_record.element);
          _entry === null || _entry === void 0 || (_entry$onDropTargetCh2 = _entry.onDropTargetChange) === null || _entry$onDropTargetCh2 === void 0 || _entry$onDropTargetCh2.call(_entry, _args3);
          _entry === null || _entry === void 0 || (_entry$onDragEnter = _entry.onDragEnter) === null || _entry$onDragEnter === void 0 || _entry$onDragEnter.call(_entry, _args3);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    }, "onDropTargetChange")
  };
  function dispatchEvent(args) {
    actions[args.eventName](args);
  }
  __name(dispatchEvent, "dispatchEvent");
  function getIsOver(_ref5) {
    var source = _ref5.source, target = _ref5.target, input = _ref5.input, current = _ref5.current;
    var actual = getActualDropTargets({
      source,
      target,
      input
    });
    if (actual.length >= current.length) {
      return actual;
    }
    var lastCaptureOrdered = copyReverse(current);
    var actualCaptureOrdered = copyReverse(actual);
    var resultCaptureOrdered = [];
    for (var index2 = 0; index2 < lastCaptureOrdered.length; index2++) {
      var _argsForLast$getIsSti;
      var last = lastCaptureOrdered[index2];
      var fresh = actualCaptureOrdered[index2];
      if (fresh != null) {
        resultCaptureOrdered.push(fresh);
        continue;
      }
      var parent = resultCaptureOrdered[index2 - 1];
      var lastParent = lastCaptureOrdered[index2 - 1];
      if ((parent === null || parent === void 0 ? void 0 : parent.element) !== (lastParent === null || lastParent === void 0 ? void 0 : lastParent.element)) {
        break;
      }
      var argsForLast = registry.get(last.element);
      if (!argsForLast) {
        break;
      }
      var feedback = {
        input,
        source,
        element: argsForLast.element
      };
      if (argsForLast.canDrop && !argsForLast.canDrop(feedback)) {
        break;
      }
      if (!((_argsForLast$getIsSti = argsForLast.getIsSticky) !== null && _argsForLast$getIsSti !== void 0 && _argsForLast$getIsSti.call(argsForLast, feedback))) {
        break;
      }
      resultCaptureOrdered.push(_objectSpread$5(_objectSpread$5({}, last), {}, {
        // making it clear to consumers this drop target is active due to stickiness
        isActiveDueToStickiness: true
      }));
    }
    return copyReverse(resultCaptureOrdered);
  }
  __name(getIsOver, "getIsOver");
  return {
    dropTargetForConsumers,
    getIsOver,
    dispatchEvent
  };
}
__name(makeDropTarget, "makeDropTarget");
function _createForOfIteratorHelper$2(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$5(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i2 = 0;
      var F = /* @__PURE__ */ __name(function F2() {
      }, "F");
      return { s: F, n: /* @__PURE__ */ __name(function n() {
        if (i2 >= o.length) return { done: true };
        return { done: false, value: o[i2++] };
      }, "n"), e: /* @__PURE__ */ __name(function e(_e) {
        throw _e;
      }, "e"), f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: /* @__PURE__ */ __name(function s() {
    it = it.call(o);
  }, "s"), n: /* @__PURE__ */ __name(function n() {
    var step2 = it.next();
    normalCompletion = step2.done;
    return step2;
  }, "n"), e: /* @__PURE__ */ __name(function e(_e2) {
    didErr = true;
    err = _e2;
  }, "e"), f: /* @__PURE__ */ __name(function f() {
    try {
      if (!normalCompletion && it.return != null) it.return();
    } finally {
      if (didErr) throw err;
    }
  }, "f") };
}
__name(_createForOfIteratorHelper$2, "_createForOfIteratorHelper$2");
function _unsupportedIterableToArray$5(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$5(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$5(o, minLen);
}
__name(_unsupportedIterableToArray$5, "_unsupportedIterableToArray$5");
function _arrayLikeToArray$5(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) arr2[i2] = arr[i2];
  return arr2;
}
__name(_arrayLikeToArray$5, "_arrayLikeToArray$5");
function ownKeys$4(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
__name(ownKeys$4, "ownKeys$4");
function _objectSpread$4(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$4(Object(t), true).forEach(function(r2) {
      _defineProperty$5(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$4(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
__name(_objectSpread$4, "_objectSpread$4");
function makeMonitor() {
  var registry = /* @__PURE__ */ new Set();
  var dragging = null;
  function tryAddToActive(monitor) {
    if (!dragging) {
      return;
    }
    if (!monitor.canMonitor || monitor.canMonitor(dragging.canMonitorArgs)) {
      dragging.active.add(monitor);
    }
  }
  __name(tryAddToActive, "tryAddToActive");
  function monitorForConsumers(args) {
    var entry = _objectSpread$4({}, args);
    registry.add(entry);
    tryAddToActive(entry);
    return /* @__PURE__ */ __name(function cleanup() {
      registry.delete(entry);
      if (dragging) {
        dragging.active.delete(entry);
      }
    }, "cleanup");
  }
  __name(monitorForConsumers, "monitorForConsumers");
  function dispatchEvent(_ref) {
    var eventName = _ref.eventName, payload = _ref.payload;
    if (eventName === "onGenerateDragPreview") {
      dragging = {
        canMonitorArgs: {
          initial: payload.location.initial,
          source: payload.source
        },
        active: /* @__PURE__ */ new Set()
      };
      var _iterator = _createForOfIteratorHelper$2(registry), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var monitor = _step.value;
          tryAddToActive(monitor);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    if (!dragging) {
      return;
    }
    var active3 = Array.from(dragging.active);
    for (var _i = 0, _active = active3; _i < _active.length; _i++) {
      var _monitor = _active[_i];
      if (dragging.active.has(_monitor)) {
        var _monitor$eventName;
        (_monitor$eventName = _monitor[eventName]) === null || _monitor$eventName === void 0 || _monitor$eventName.call(_monitor, payload);
      }
    }
    if (eventName === "onDrop") {
      dragging.active.clear();
      dragging = null;
    }
  }
  __name(dispatchEvent, "dispatchEvent");
  return {
    dispatchEvent,
    monitorForConsumers
  };
}
__name(makeMonitor, "makeMonitor");
function makeAdapter(_ref) {
  var typeKey = _ref.typeKey, mount2 = _ref.mount, dispatchEventToSource2 = _ref.dispatchEventToSource, onPostDispatch = _ref.onPostDispatch, defaultDropEffect = _ref.defaultDropEffect;
  var monitorAPI = makeMonitor();
  var dropTargetAPI = makeDropTarget({
    typeKey,
    defaultDropEffect
  });
  function dispatchEvent(args) {
    dispatchEventToSource2 === null || dispatchEventToSource2 === void 0 || dispatchEventToSource2(args);
    dropTargetAPI.dispatchEvent(args);
    monitorAPI.dispatchEvent(args);
    onPostDispatch === null || onPostDispatch === void 0 || onPostDispatch(args);
  }
  __name(dispatchEvent, "dispatchEvent");
  function start2(_ref2) {
    var event2 = _ref2.event, dragType = _ref2.dragType;
    lifecycle.start({
      event: event2,
      dragType,
      getDropTargetsOver: dropTargetAPI.getIsOver,
      dispatchEvent
    });
  }
  __name(start2, "start");
  function registerUsage2() {
    function mountAdapter() {
      var api2 = {
        canStart: lifecycle.canStart,
        start: start2
      };
      return mount2(api2);
    }
    __name(mountAdapter, "mountAdapter");
    return register({
      typeKey,
      mount: mountAdapter
    });
  }
  __name(registerUsage2, "registerUsage");
  return {
    registerUsage: registerUsage2,
    dropTarget: dropTargetAPI.dropTargetForConsumers,
    monitor: monitorAPI.monitorForConsumers
  };
}
__name(makeAdapter, "makeAdapter");
var isAndroid = once(/* @__PURE__ */ __name(function isAndroid2() {
  return navigator.userAgent.toLocaleLowerCase().includes("android");
}, "isAndroid"));
var androidFallbackText = "pdnd:android-fallback";
var textMediaType = "text/plain";
var urlMediaType = "text/uri-list";
var elementAdapterNativeDataKey = "application/vnd.pdnd";
var draggableRegistry = /* @__PURE__ */ new WeakMap();
function addToRegistry(args) {
  draggableRegistry.set(args.element, args);
  return /* @__PURE__ */ __name(function cleanup() {
    draggableRegistry.delete(args.element);
  }, "cleanup");
}
__name(addToRegistry, "addToRegistry");
var honeyPotFix = makeHoneyPotFix();
var adapter = makeAdapter({
  typeKey: "element",
  defaultDropEffect: "move",
  mount: /* @__PURE__ */ __name(function mount(api2) {
    return combine(honeyPotFix.bindEvents(), dist.bind(document, {
      type: "dragstart",
      listener: /* @__PURE__ */ __name(function listener(event2) {
        var _entry$dragHandle, _entry$getInitialData, _entry$getInitialData2, _entry$dragHandle2, _entry$getInitialData3, _entry$getInitialData4;
        if (!api2.canStart(event2)) {
          return;
        }
        if (event2.defaultPrevented) {
          return;
        }
        if (!event2.dataTransfer) {
          if (false) {
            console.warn("\n              It appears as though you have are not testing DragEvents correctly.\n\n              - If you are unit testing, ensure you have polyfilled DragEvent.\n              - If you are browser testing, ensure you are dispatching drag events correctly.\n\n              Please see our testing guides for more information:\n              https://atlassian.design/components/pragmatic-drag-and-drop/core-package/testing\n            ".replace(/ {2}/g, ""));
          }
          return;
        }
        var target = event2.target;
        if (!(target instanceof HTMLElement)) {
          return null;
        }
        var entry = draggableRegistry.get(target);
        if (!entry) {
          return null;
        }
        var input = getInput(event2);
        var feedback = {
          element: entry.element,
          dragHandle: (_entry$dragHandle = entry.dragHandle) !== null && _entry$dragHandle !== void 0 ? _entry$dragHandle : null,
          input
        };
        if (entry.canDrag && !entry.canDrag(feedback)) {
          event2.preventDefault();
          return null;
        }
        if (entry.dragHandle) {
          var over = getElementFromPointWithoutHoneypot({
            x: input.clientX,
            y: input.clientY
          });
          if (!entry.dragHandle.contains(over)) {
            event2.preventDefault();
            return null;
          }
        }
        var nativeData = (_entry$getInitialData = (_entry$getInitialData2 = entry.getInitialDataForExternal) === null || _entry$getInitialData2 === void 0 ? void 0 : _entry$getInitialData2.call(entry, feedback)) !== null && _entry$getInitialData !== void 0 ? _entry$getInitialData : null;
        if (nativeData) {
          for (var _i = 0, _Object$entries = Object.entries(nativeData); _i < _Object$entries.length; _i++) {
            var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2), key = _Object$entries$_i[0], data24 = _Object$entries$_i[1];
            event2.dataTransfer.setData(key, data24 !== null && data24 !== void 0 ? data24 : "");
          }
        }
        var types = event2.dataTransfer.types;
        if (isAndroid() && !types.includes(textMediaType) && !types.includes(urlMediaType)) {
          event2.dataTransfer.setData(textMediaType, androidFallbackText);
        }
        event2.dataTransfer.setData(elementAdapterNativeDataKey, "");
        var payload = {
          element: entry.element,
          dragHandle: (_entry$dragHandle2 = entry.dragHandle) !== null && _entry$dragHandle2 !== void 0 ? _entry$dragHandle2 : null,
          data: (_entry$getInitialData3 = (_entry$getInitialData4 = entry.getInitialData) === null || _entry$getInitialData4 === void 0 ? void 0 : _entry$getInitialData4.call(entry, feedback)) !== null && _entry$getInitialData3 !== void 0 ? _entry$getInitialData3 : {}
        };
        var dragType = {
          type: "element",
          payload,
          startedFrom: "internal"
        };
        api2.start({
          event: event2,
          dragType
        });
      }, "listener")
    }));
  }, "mount"),
  dispatchEventToSource: /* @__PURE__ */ __name(function dispatchEventToSource(_ref) {
    var _draggableRegistry$ge, _draggableRegistry$ge2;
    var eventName = _ref.eventName, payload = _ref.payload;
    (_draggableRegistry$ge = draggableRegistry.get(payload.source.element)) === null || _draggableRegistry$ge === void 0 || (_draggableRegistry$ge2 = _draggableRegistry$ge[eventName]) === null || _draggableRegistry$ge2 === void 0 || _draggableRegistry$ge2.call(
      _draggableRegistry$ge,
      // I cannot seem to get the types right here.
      // TS doesn't seem to like that one event can need `nativeSetDragImage`
      // @ts-expect-error
      payload
    );
  }, "dispatchEventToSource"),
  onPostDispatch: honeyPotFix.getOnPostDispatch()
});
var dropTargetForElements = adapter.dropTarget;
var monitorForElements = adapter.monitor;
function draggable(args) {
  if (false) {
    if (args.dragHandle && !args.element.contains(args.dragHandle)) {
      console.warn("Drag handle element must be contained in draggable element", {
        element: args.element,
        dragHandle: args.dragHandle
      });
    }
  }
  if (false) {
    var existing = draggableRegistry.get(args.element);
    if (existing) {
      console.warn("You have already registered a `draggable` on the same element", {
        existing,
        proposed: args
      });
    }
  }
  return combine(
    // making the draggable register the adapter rather than drop targets
    // this is because you *must* have a draggable element to start a drag
    // but you _might_ not have any drop targets immediately
    // (You might create drop targets async)
    adapter.registerUsage(),
    addToRegistry(args),
    addAttribute(args.element, {
      attribute: "draggable",
      value: "true"
    })
  );
}
__name(draggable, "draggable");
const BOOKMARK_SETTING_ID = "Comfy.NodeLibrary.Bookmarks.V2";
const useNodeBookmarkStore = defineStore("nodeBookmark", () => {
  const settingStore = useSettingStore();
  const nodeDefStore = useNodeDefStore();
  const migrateLegacyBookmarks = /* @__PURE__ */ __name(() => {
    settingStore.get("Comfy.NodeLibrary.Bookmarks").forEach((bookmark) => {
      if (bookmark.endsWith("/")) {
        addBookmark(bookmark);
        return;
      }
      const category = bookmark.split("/").slice(0, -1).join("/");
      const displayName = bookmark.split("/").pop();
      const nodeDef = nodeDefStore.nodeDefsByDisplayName[displayName];
      if (!nodeDef) return;
      addBookmark(`${category === "" ? "" : category + "/"}${nodeDef.name}`);
    });
    settingStore.set("Comfy.NodeLibrary.Bookmarks", []);
  }, "migrateLegacyBookmarks");
  const bookmarks = computed(
    () => settingStore.get(BOOKMARK_SETTING_ID)
  );
  const bookmarksSet = computed(() => new Set(bookmarks.value));
  const bookmarkedRoot = computed(
    () => buildBookmarkTree(bookmarks.value)
  );
  const isBookmarked = /* @__PURE__ */ __name((node3) => bookmarksSet.value.has(node3.nodePath) || bookmarksSet.value.has(node3.name), "isBookmarked");
  const toggleBookmark = /* @__PURE__ */ __name((node3) => {
    if (isBookmarked(node3)) {
      deleteBookmark(node3.nodePath);
      deleteBookmark(node3.name);
    } else {
      addBookmark(node3.name);
    }
  }, "toggleBookmark");
  const buildBookmarkTree = /* @__PURE__ */ __name((bookmarks2) => {
    const bookmarkNodes = bookmarks2.map((bookmark) => {
      if (bookmark.endsWith("/")) return createDummyFolderNodeDef(bookmark);
      const parts2 = bookmark.split("/");
      const name = parts2.pop();
      const category = parts2.join("/");
      const srcNodeDef = nodeDefStore.nodeDefsByName[name];
      if (!srcNodeDef) {
        return null;
      }
      const nodeDef = _.clone(srcNodeDef);
      nodeDef.category = category;
      return nodeDef;
    }).filter((nodeDef) => nodeDef !== null);
    return buildNodeDefTree(bookmarkNodes);
  }, "buildBookmarkTree");
  const addBookmark = /* @__PURE__ */ __name((nodePath) => {
    settingStore.set(BOOKMARK_SETTING_ID, [...bookmarks.value, nodePath]);
  }, "addBookmark");
  const deleteBookmark = /* @__PURE__ */ __name((nodePath) => {
    settingStore.set(
      BOOKMARK_SETTING_ID,
      bookmarks.value.filter((b) => b !== nodePath)
    );
  }, "deleteBookmark");
  const addNewBookmarkFolder = /* @__PURE__ */ __name((parent) => {
    const parentPath = parent ? parent.nodePath : "";
    let newFolderPath = parentPath + "New Folder/";
    let suffix2 = 1;
    while (bookmarks.value.some((b) => b.startsWith(newFolderPath))) {
      newFolderPath = parentPath + `New Folder ${suffix2}/`;
      suffix2++;
    }
    addBookmark(newFolderPath);
    return newFolderPath;
  }, "addNewBookmarkFolder");
  const renameBookmarkFolder = /* @__PURE__ */ __name((folderNode, newName) => {
    if (!folderNode.isDummyFolder) {
      throw new Error("Cannot rename non-folder node");
    }
    const newNodePath = folderNode.category.split("/").slice(0, -1).concat(newName).join("/") + "/";
    if (newNodePath === folderNode.nodePath) {
      return;
    }
    if (bookmarks.value.some((b) => b.startsWith(newNodePath))) {
      throw new Error(`Folder name "${newNodePath}" already exists`);
    }
    settingStore.set(
      BOOKMARK_SETTING_ID,
      bookmarks.value.map(
        (b) => b.startsWith(folderNode.nodePath) ? b.replace(folderNode.nodePath, newNodePath) : b
      )
    );
    renameBookmarkCustomization(folderNode.nodePath, newNodePath);
  }, "renameBookmarkFolder");
  const deleteBookmarkFolder = /* @__PURE__ */ __name((folderNode) => {
    if (!folderNode.isDummyFolder) {
      throw new Error("Cannot delete non-folder node");
    }
    settingStore.set(
      BOOKMARK_SETTING_ID,
      bookmarks.value.filter(
        (b) => b !== folderNode.nodePath && !b.startsWith(folderNode.nodePath)
      )
    );
    deleteBookmarkCustomization(folderNode.nodePath);
  }, "deleteBookmarkFolder");
  const bookmarksCustomization = computed(() => settingStore.get("Comfy.NodeLibrary.BookmarksCustomization"));
  const updateBookmarkCustomization = /* @__PURE__ */ __name((nodePath, customization) => {
    const currentCustomization = bookmarksCustomization.value[nodePath] || {};
    const newCustomization = { ...currentCustomization, ...customization };
    if (newCustomization.icon === defaultBookmarkIcon) {
      delete newCustomization.icon;
    }
    if (newCustomization.color === defaultBookmarkColor) {
      delete newCustomization.color;
    }
    if (Object.keys(newCustomization).length === 0) {
      deleteBookmarkCustomization(nodePath);
    } else {
      settingStore.set("Comfy.NodeLibrary.BookmarksCustomization", {
        ...bookmarksCustomization.value,
        [nodePath]: newCustomization
      });
    }
  }, "updateBookmarkCustomization");
  const deleteBookmarkCustomization = /* @__PURE__ */ __name((nodePath) => {
    settingStore.set("Comfy.NodeLibrary.BookmarksCustomization", {
      ...bookmarksCustomization.value,
      [nodePath]: void 0
    });
  }, "deleteBookmarkCustomization");
  const renameBookmarkCustomization = /* @__PURE__ */ __name((oldNodePath, newNodePath) => {
    const updatedCustomization = { ...bookmarksCustomization.value };
    if (updatedCustomization[oldNodePath]) {
      updatedCustomization[newNodePath] = updatedCustomization[oldNodePath];
      delete updatedCustomization[oldNodePath];
    }
    settingStore.set(
      "Comfy.NodeLibrary.BookmarksCustomization",
      updatedCustomization
    );
  }, "renameBookmarkCustomization");
  const defaultBookmarkIcon = "pi-bookmark-fill";
  const defaultBookmarkColor = "#a1a1aa";
  return {
    bookmarks,
    bookmarkedRoot,
    isBookmarked,
    toggleBookmark,
    addBookmark,
    addNewBookmarkFolder,
    renameBookmarkFolder,
    deleteBookmarkFolder,
    bookmarksCustomization,
    updateBookmarkCustomization,
    deleteBookmarkCustomization,
    renameBookmarkCustomization,
    defaultBookmarkIcon,
    defaultBookmarkColor,
    migrateLegacyBookmarks
  };
});
const _sfc_main$h = /* @__PURE__ */ defineComponent({
  __name: "GraphCanvas",
  emits: ["ready"],
  setup(__props, { emit: __emit }) {
    const emit2 = __emit;
    const canvasRef = ref(null);
    const settingStore = useSettingStore();
    const nodeDefStore = useNodeDefStore();
    const workspaceStore = useWorkspaceStore();
    const canvasStore = useCanvasStore();
    const betaMenuEnabled = computed(
      () => settingStore.get("Comfy.UseNewMenu") !== "Disabled"
    );
    watchEffect(() => {
      const canvasInfoEnabled = settingStore.get("Comfy.Graph.CanvasInfo");
      if (canvasStore.canvas) {
        canvasStore.canvas.show_info = canvasInfoEnabled;
      }
    });
    watchEffect(() => {
      const zoomSpeed = settingStore.get("Comfy.Graph.ZoomSpeed");
      if (canvasStore.canvas) {
        canvasStore.canvas.zoom_speed = zoomSpeed;
      }
    });
    watchEffect(() => {
      nodeDefStore.showDeprecated = settingStore.get("Comfy.Node.ShowDeprecated");
    });
    watchEffect(() => {
      nodeDefStore.showExperimental = settingStore.get(
        "Comfy.Node.ShowExperimental"
      );
    });
    watchEffect(() => {
      const spellcheckEnabled = settingStore.get("Comfy.TextareaWidget.Spellcheck");
      const textareas = document.querySelectorAll("textarea.comfy-multiline-input");
      textareas.forEach((textarea) => {
        textarea.spellcheck = spellcheckEnabled;
        textarea.focus();
        textarea.blur();
      });
    });
    let dropTargetCleanup = /* @__PURE__ */ __name(() => {
    }, "dropTargetCleanup");
    onMounted(async () => {
      window["LiteGraph"] = LiteGraph;
      window["LGraph"] = LGraph;
      window["LLink"] = LLink;
      window["LGraphNode"] = LGraphNode;
      window["LGraphGroup"] = LGraphGroup;
      window["DragAndScale"] = DragAndScale;
      window["LGraphCanvas"] = LGraphCanvas;
      window["ContextMenu"] = ContextMenu;
      app$1.vueAppReady = true;
      workspaceStore.spinner = true;
      await app$1.setup(canvasRef.value);
      canvasStore.canvas = app$1.canvas;
      workspaceStore.spinner = false;
      window["app"] = app$1;
      window["graph"] = app$1.graph;
      dropTargetCleanup = dropTargetForElements({
        element: canvasRef.value,
        onDrop: /* @__PURE__ */ __name((event2) => {
          const loc = event2.location.current.input;
          const dndData = event2.source.data;
          if (dndData.type === "tree-explorer-node") {
            const node3 = dndData.data;
            if (node3.data instanceof ComfyNodeDefImpl) {
              const nodeDef = node3.data;
              const pos2 = app$1.clientPosToCanvasPos([
                loc.clientX - 20,
                loc.clientY
              ]);
              app$1.addNodeOnGraph(nodeDef, { pos: pos2 });
            }
          }
        }, "onDrop")
      });
      useNodeBookmarkStore().migrateLegacyBookmarks();
      useNodeDefStore().nodeSearchService.endsWithFilterStartSequence("");
      emit2("ready");
    });
    onUnmounted(() => {
      dropTargetCleanup();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        (openBlock(), createBlock(Teleport, { to: ".graph-canvas-container" }, [
          betaMenuEnabled.value ? (openBlock(), createBlock(LiteGraphCanvasSplitterOverlay, { key: 0 }, {
            "side-bar-panel": withCtx(() => [
              createVNode(SideToolbar)
            ]),
            _: 1
          })) : createCommentVNode("", true),
          createVNode(TitleEditor),
          createBaseVNode("canvas", {
            ref_key: "canvasRef",
            ref: canvasRef,
            id: "graph-canvas",
            tabindex: "1"
          }, null, 512)
        ])),
        createVNode(_sfc_main$j),
        createVNode(NodeTooltip)
      ], 64);
    };
  }
});
var theme$8 = /* @__PURE__ */ __name(function theme29(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-confirmpopup {\n    position: absolute;\n    margin-top: ".concat(dt3("confirmpopup.gutter"), ";\n    top: 0;\n    left: 0;\n    background: ").concat(dt3("confirmpopup.background"), ";\n    color: ").concat(dt3("confirmpopup.color"), ";\n    border: 1px solid ").concat(dt3("confirmpopup.border.color"), ";\n    border-radius: ").concat(dt3("confirmpopup.border.radius"), ";\n    box-shadow: ").concat(dt3("confirmpopup.shadow"), ";\n}\n\n.p-confirmpopup-content {\n    display: flex;\n    align-items: center;\n    padding: ").concat(dt3("confirmpopup.content.padding"), ";\n    gap: ").concat(dt3("confirmpopup.content.gap"), ";\n}\n\n.p-confirmpopup-icon {\n    font-size: ").concat(dt3("confirmpopup.icon.size"), ";\n    width: ").concat(dt3("confirmpopup.icon.size"), ";\n    height: ").concat(dt3("confirmpopup.icon.size"), ";\n    color: ").concat(dt3("confirmpopup.icon.color"), ";\n}\n\n.p-confirmpopup-footer {\n    display: flex;\n    justify-content: flex-end;\n    gap: ").concat(dt3("confirmpopup.footer.gap"), ";\n    padding: ").concat(dt3("confirmpopup.footer.padding"), ";\n}\n\n.p-confirmpopup-footer button {\n    width: auto;\n}\n\n.p-confirmpopup-footer button:last-child {\n    margin: 0;\n}\n\n.p-confirmpopup-flipped {\n    margin-top: calc(").concat(dt3("confirmpopup.gutter"), " * -1);\n    margin-bottom: ").concat(dt3("confirmpopup.gutter"), ";\n}\n\n.p-confirmpopup-enter-from {\n    opacity: 0;\n    transform: scaleY(0.8);\n}\n\n.p-confirmpopup-leave-to {\n    opacity: 0;\n}\n\n.p-confirmpopup-enter-active {\n    transition: transform 0.12s cubic-bezier(0, 0, 0.2, 1), opacity 0.12s cubic-bezier(0, 0, 0.2, 1);\n}\n\n.p-confirmpopup-leave-active {\n    transition: opacity 0.1s linear;\n}\n\n.p-confirmpopup:after,\n.p-confirmpopup:before {\n    bottom: 100%;\n    left: ").concat(dt3("confirmpopup.arrow.offset"), ';\n    content: " ";\n    height: 0;\n    width: 0;\n    position: absolute;\n    pointer-events: none;\n}\n\n.p-confirmpopup:after {\n    border-width: calc(').concat(dt3("confirmpopup.gutter"), " - 2px);\n    margin-left: calc(-1 * (").concat(dt3("confirmpopup.gutter"), " - 2px));\n    border-style: solid;\n    border-color: transparent;\n    border-bottom-color: ").concat(dt3("confirmpopup.background"), ";\n}\n\n.p-confirmpopup:before {\n    border-width: ").concat(dt3("confirmpopup.gutter"), ";\n    margin-left: calc(-1 * ").concat(dt3("confirmpopup.gutter"), ");\n    border-style: solid;\n    border-color: transparent;\n    border-bottom-color: ").concat(dt3("confirmpopup.border.color"), ";\n}\n\n.p-confirmpopup-flipped:after,\n.p-confirmpopup-flipped:before {\n    bottom: auto;\n    top: 100%;\n}\n\n.p-confirmpopup-flipped:after {\n    border-bottom-color: transparent;\n    border-top-color: ").concat(dt3("confirmpopup.background"), ";\n}\n\n.p-confirmpopup-flipped:before {\n    border-bottom-color: transparent;\n    border-top-color: ").concat(dt3("confirmpopup.border.color"), ";\n}\n");
}, "theme");
var classes$8 = {
  root: "p-confirmpopup p-component",
  content: "p-confirmpopup-content",
  icon: "p-confirmpopup-icon",
  message: "p-confirmpopup-message",
  footer: "p-confirmpopup-footer",
  pcRejectButton: "p-confirmpopup-reject-button",
  pcAcceptButton: "p-confirmpopup-accept-button"
};
var ConfirmPopupStyle = BaseStyle.extend({
  name: "confirmpopup",
  theme: theme$8,
  classes: classes$8
});
var script$1$8 = {
  name: "BaseConfirmPopup",
  "extends": script$X,
  props: {
    group: String
  },
  style: ConfirmPopupStyle,
  provide: /* @__PURE__ */ __name(function provide32() {
    return {
      $pcConfirmPopup: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$h = {
  name: "ConfirmPopup",
  "extends": script$1$8,
  inheritAttrs: false,
  data: /* @__PURE__ */ __name(function data14() {
    return {
      visible: false,
      confirmation: null,
      autoFocusAccept: null,
      autoFocusReject: null
    };
  }, "data"),
  target: null,
  outsideClickListener: null,
  scrollHandler: null,
  resizeListener: null,
  container: null,
  confirmListener: null,
  closeListener: null,
  mounted: /* @__PURE__ */ __name(function mounted13() {
    var _this = this;
    this.confirmListener = function(options3) {
      if (!options3) {
        return;
      }
      if (options3.group === _this.group) {
        _this.confirmation = options3;
        _this.target = options3.target;
        if (_this.confirmation.onShow) {
          _this.confirmation.onShow();
        }
        _this.visible = true;
      }
    };
    this.closeListener = function() {
      _this.visible = false;
      _this.confirmation = null;
    };
    ConfirmationEventBus.on("confirm", this.confirmListener);
    ConfirmationEventBus.on("close", this.closeListener);
  }, "mounted"),
  beforeUnmount: /* @__PURE__ */ __name(function beforeUnmount8() {
    ConfirmationEventBus.off("confirm", this.confirmListener);
    ConfirmationEventBus.off("close", this.closeListener);
    this.unbindOutsideClickListener();
    if (this.scrollHandler) {
      this.scrollHandler.destroy();
      this.scrollHandler = null;
    }
    this.unbindResizeListener();
    if (this.container) {
      ZIndex.clear(this.container);
      this.container = null;
    }
    this.target = null;
    this.confirmation = null;
  }, "beforeUnmount"),
  methods: {
    accept: /* @__PURE__ */ __name(function accept() {
      if (this.confirmation.accept) {
        this.confirmation.accept();
      }
      this.visible = false;
    }, "accept"),
    reject: /* @__PURE__ */ __name(function reject() {
      if (this.confirmation.reject) {
        this.confirmation.reject();
      }
      this.visible = false;
    }, "reject"),
    onHide: /* @__PURE__ */ __name(function onHide() {
      if (this.confirmation.onHide) {
        this.confirmation.onHide();
      }
      this.visible = false;
    }, "onHide"),
    onAcceptKeydown: /* @__PURE__ */ __name(function onAcceptKeydown(event2) {
      if (event2.code === "Space" || event2.code === "Enter" || event2.code === "NumpadEnter") {
        this.accept();
        focus(this.target);
        event2.preventDefault();
      }
    }, "onAcceptKeydown"),
    onRejectKeydown: /* @__PURE__ */ __name(function onRejectKeydown(event2) {
      if (event2.code === "Space" || event2.code === "Enter" || event2.code === "NumpadEnter") {
        this.reject();
        focus(this.target);
        event2.preventDefault();
      }
    }, "onRejectKeydown"),
    onEnter: /* @__PURE__ */ __name(function onEnter2(el) {
      this.autoFocusAccept = this.confirmation.defaultFocus === void 0 || this.confirmation.defaultFocus === "accept" ? true : false;
      this.autoFocusReject = this.confirmation.defaultFocus === "reject" ? true : false;
      this.bindOutsideClickListener();
      this.bindScrollListener();
      this.bindResizeListener();
      ZIndex.set("overlay", el, this.$primevue.config.zIndex.overlay);
    }, "onEnter"),
    onAfterEnter: /* @__PURE__ */ __name(function onAfterEnter() {
      this.focus();
    }, "onAfterEnter"),
    onLeave: /* @__PURE__ */ __name(function onLeave2() {
      this.autoFocusAccept = null;
      this.autoFocusReject = null;
      this.unbindOutsideClickListener();
      this.unbindScrollListener();
      this.unbindResizeListener();
    }, "onLeave"),
    onAfterLeave: /* @__PURE__ */ __name(function onAfterLeave2(el) {
      ZIndex.clear(el);
    }, "onAfterLeave"),
    alignOverlay: /* @__PURE__ */ __name(function alignOverlay4() {
      absolutePosition(this.container, this.target, false);
      var containerOffset = getOffset(this.container);
      var targetOffset = getOffset(this.target);
      var arrowLeft = 0;
      if (containerOffset.left < targetOffset.left) {
        arrowLeft = targetOffset.left - containerOffset.left;
      }
      this.container.style.setProperty($dt("overlay.arrow.left").name, "".concat(arrowLeft, "px"));
      if (containerOffset.top < targetOffset.top) {
        this.container.setAttribute("data-p-confirmpopup-flipped", "true");
        !this.isUnstyled && addClass(this.container, "p-confirmpopup-flipped");
      }
    }, "alignOverlay"),
    bindOutsideClickListener: /* @__PURE__ */ __name(function bindOutsideClickListener3() {
      var _this2 = this;
      if (!this.outsideClickListener) {
        this.outsideClickListener = function(event2) {
          if (_this2.visible && _this2.container && !_this2.container.contains(event2.target) && !_this2.isTargetClicked(event2)) {
            if (_this2.confirmation.onHide) {
              _this2.confirmation.onHide();
            }
            _this2.visible = false;
          } else {
            _this2.alignOverlay();
          }
        };
        document.addEventListener("click", this.outsideClickListener);
      }
    }, "bindOutsideClickListener"),
    unbindOutsideClickListener: /* @__PURE__ */ __name(function unbindOutsideClickListener3() {
      if (this.outsideClickListener) {
        document.removeEventListener("click", this.outsideClickListener);
        this.outsideClickListener = null;
      }
    }, "unbindOutsideClickListener"),
    bindScrollListener: /* @__PURE__ */ __name(function bindScrollListener4() {
      var _this3 = this;
      if (!this.scrollHandler) {
        this.scrollHandler = new ConnectedOverlayScrollHandler(this.target, function() {
          if (_this3.visible) {
            _this3.visible = false;
          }
        });
      }
      this.scrollHandler.bindScrollListener();
    }, "bindScrollListener"),
    unbindScrollListener: /* @__PURE__ */ __name(function unbindScrollListener4() {
      if (this.scrollHandler) {
        this.scrollHandler.unbindScrollListener();
      }
    }, "unbindScrollListener"),
    bindResizeListener: /* @__PURE__ */ __name(function bindResizeListener4() {
      var _this4 = this;
      if (!this.resizeListener) {
        this.resizeListener = function() {
          if (_this4.visible && !isTouchDevice()) {
            _this4.visible = false;
          }
        };
        window.addEventListener("resize", this.resizeListener);
      }
    }, "bindResizeListener"),
    unbindResizeListener: /* @__PURE__ */ __name(function unbindResizeListener4() {
      if (this.resizeListener) {
        window.removeEventListener("resize", this.resizeListener);
        this.resizeListener = null;
      }
    }, "unbindResizeListener"),
    focus: /* @__PURE__ */ __name(function focus2() {
      var focusTarget = this.container.querySelector("[autofocus]");
      if (focusTarget) {
        focusTarget.focus({
          preventScroll: true
        });
      }
    }, "focus"),
    isTargetClicked: /* @__PURE__ */ __name(function isTargetClicked(event2) {
      return this.target && (this.target === event2.target || this.target.contains(event2.target));
    }, "isTargetClicked"),
    containerRef: /* @__PURE__ */ __name(function containerRef2(el) {
      this.container = el;
    }, "containerRef"),
    onOverlayClick: /* @__PURE__ */ __name(function onOverlayClick3(event2) {
      OverlayEventBus.emit("overlay-click", {
        originalEvent: event2,
        target: this.target
      });
    }, "onOverlayClick"),
    onOverlayKeydown: /* @__PURE__ */ __name(function onOverlayKeydown(event2) {
      if (event2.code === "Escape") {
        ConfirmationEventBus.emit("close", this.closeListener);
        focus(this.target);
      }
    }, "onOverlayKeydown"),
    getCXOptions: /* @__PURE__ */ __name(function getCXOptions(icon2, iconProps) {
      return {
        contenxt: {
          icon: icon2,
          iconClass: iconProps["class"]
        }
      };
    }, "getCXOptions")
  },
  computed: {
    message: /* @__PURE__ */ __name(function message() {
      return this.confirmation ? this.confirmation.message : null;
    }, "message"),
    acceptLabel: /* @__PURE__ */ __name(function acceptLabel() {
      if (this.confirmation) {
        var confirmation = this.confirmation;
        return confirmation.acceptLabel ? confirmation.acceptLabel : confirmation.acceptProps ? confirmation.acceptProps.label || this.$primevue.config.locale.accept : null;
      }
      return null;
    }, "acceptLabel"),
    rejectLabel: /* @__PURE__ */ __name(function rejectLabel() {
      if (this.confirmation) {
        var confirmation = this.confirmation;
        return confirmation.rejectLabel ? confirmation.rejectLabel : confirmation.rejectProps ? confirmation.rejectProps.label || this.$primevue.config.locale.reject : null;
      }
      return null;
    }, "rejectLabel"),
    acceptIcon: /* @__PURE__ */ __name(function acceptIcon() {
      var _this$confirmation;
      return this.confirmation ? this.confirmation.acceptIcon : (_this$confirmation = this.confirmation) !== null && _this$confirmation !== void 0 && _this$confirmation.acceptProps ? this.confirmation.acceptProps.icon : null;
    }, "acceptIcon"),
    rejectIcon: /* @__PURE__ */ __name(function rejectIcon() {
      var _this$confirmation2;
      return this.confirmation ? this.confirmation.rejectIcon : (_this$confirmation2 = this.confirmation) !== null && _this$confirmation2 !== void 0 && _this$confirmation2.rejectProps ? this.confirmation.rejectProps.icon : null;
    }, "rejectIcon")
  },
  components: {
    Button: script$J,
    Portal: script$z
  },
  directives: {
    focustrap: FocusTrap
  }
};
var _hoisted_1$o = ["aria-modal"];
function render$g(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_Button = resolveComponent("Button");
  var _component_Portal = resolveComponent("Portal");
  var _directive_focustrap = resolveDirective("focustrap");
  return openBlock(), createBlock(_component_Portal, null, {
    "default": withCtx(function() {
      return [createVNode(Transition, mergeProps({
        name: "p-confirmpopup",
        onEnter: $options.onEnter,
        onAfterEnter: $options.onAfterEnter,
        onLeave: $options.onLeave,
        onAfterLeave: $options.onAfterLeave
      }, _ctx.ptm("transition")), {
        "default": withCtx(function() {
          var _$data$confirmation$r, _$data$confirmation$r2, _$data$confirmation$a;
          return [$data.visible ? withDirectives((openBlock(), createElementBlock("div", mergeProps({
            key: 0,
            ref: $options.containerRef,
            role: "alertdialog",
            "class": _ctx.cx("root"),
            "aria-modal": $data.visible,
            onClick: _cache[2] || (_cache[2] = function() {
              return $options.onOverlayClick && $options.onOverlayClick.apply($options, arguments);
            }),
            onKeydown: _cache[3] || (_cache[3] = function() {
              return $options.onOverlayKeydown && $options.onOverlayKeydown.apply($options, arguments);
            })
          }, _ctx.ptmi("root")), [_ctx.$slots.container ? renderSlot(_ctx.$slots, "container", {
            key: 0,
            message: $data.confirmation,
            acceptCallback: $options.accept,
            rejectCallback: $options.reject
          }) : (openBlock(), createElementBlock(Fragment, {
            key: 1
          }, [!_ctx.$slots.message ? (openBlock(), createElementBlock("div", mergeProps({
            key: 0,
            "class": _ctx.cx("content")
          }, _ctx.ptm("content")), [renderSlot(_ctx.$slots, "icon", {}, function() {
            return [_ctx.$slots.icon ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.$slots.icon), {
              key: 0,
              "class": normalizeClass(_ctx.cx("icon"))
            }, null, 8, ["class"])) : $data.confirmation.icon ? (openBlock(), createElementBlock("span", mergeProps({
              key: 1,
              "class": [$data.confirmation.icon, _ctx.cx("icon")]
            }, _ctx.ptm("icon")), null, 16)) : createCommentVNode("", true)];
          }), createBaseVNode("span", mergeProps({
            "class": _ctx.cx("message")
          }, _ctx.ptm("message")), toDisplayString$1($data.confirmation.message), 17)], 16)) : (openBlock(), createBlock(resolveDynamicComponent(_ctx.$slots.message), {
            key: 1,
            message: $data.confirmation
          }, null, 8, ["message"])), createBaseVNode("div", mergeProps({
            "class": _ctx.cx("footer")
          }, _ctx.ptm("footer")), [createVNode(_component_Button, mergeProps({
            "class": [_ctx.cx("pcRejectButton"), $data.confirmation.rejectClass],
            autofocus: $data.autoFocusReject,
            unstyled: _ctx.unstyled,
            size: ((_$data$confirmation$r = $data.confirmation.rejectProps) === null || _$data$confirmation$r === void 0 ? void 0 : _$data$confirmation$r.size) || "small",
            text: ((_$data$confirmation$r2 = $data.confirmation.rejectProps) === null || _$data$confirmation$r2 === void 0 ? void 0 : _$data$confirmation$r2.text) || false,
            onClick: _cache[0] || (_cache[0] = function($event) {
              return $options.reject();
            }),
            onKeydown: $options.onRejectKeydown
          }, $data.confirmation.rejectProps, {
            label: $options.rejectLabel,
            pt: _ctx.ptm("pcRejectButton")
          }), createSlots({
            _: 2
          }, [$options.rejectIcon || _ctx.$slots.rejecticon ? {
            name: "icon",
            fn: withCtx(function(iconProps) {
              return [renderSlot(_ctx.$slots, "rejecticon", {}, function() {
                return [createBaseVNode("span", mergeProps({
                  "class": [$options.rejectIcon, iconProps["class"]]
                }, _ctx.ptm("pcRejectButton")["icon"], {
                  "data-pc-section": "rejectbuttonicon"
                }), null, 16)];
              })];
            }),
            key: "0"
          } : void 0]), 1040, ["class", "autofocus", "unstyled", "size", "text", "onKeydown", "label", "pt"]), createVNode(_component_Button, mergeProps({
            "class": [_ctx.cx("pcAcceptButton"), $data.confirmation.acceptClass],
            autofocus: $data.autoFocusAccept,
            unstyled: _ctx.unstyled,
            size: ((_$data$confirmation$a = $data.confirmation.acceptProps) === null || _$data$confirmation$a === void 0 ? void 0 : _$data$confirmation$a.size) || "small",
            onClick: _cache[1] || (_cache[1] = function($event) {
              return $options.accept();
            }),
            onKeydown: $options.onAcceptKeydown
          }, $data.confirmation.acceptProps, {
            label: $options.acceptLabel,
            pt: _ctx.ptm("pcAcceptButton")
          }), createSlots({
            _: 2
          }, [$options.acceptIcon || _ctx.$slots.accepticon ? {
            name: "icon",
            fn: withCtx(function(iconProps) {
              return [renderSlot(_ctx.$slots, "accepticon", {}, function() {
                return [createBaseVNode("span", mergeProps({
                  "class": [$options.acceptIcon, iconProps["class"]]
                }, _ctx.ptm("pcAcceptButton")["icon"], {
                  "data-pc-section": "acceptbuttonicon"
                }), null, 16)];
              })];
            }),
            key: "0"
          } : void 0]), 1040, ["class", "autofocus", "unstyled", "size", "onKeydown", "label", "pt"])], 16)], 64))], 16, _hoisted_1$o)), [[_directive_focustrap]]) : createCommentVNode("", true)];
        }),
        _: 3
      }, 16, ["onEnter", "onAfterEnter", "onLeave", "onAfterLeave"])];
    }),
    _: 3
  });
}
__name(render$g, "render$g");
script$h.render = render$g;
var theme$7 = /* @__PURE__ */ __name(function theme30(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-contextmenu {\n    background: ".concat(dt3("contextmenu.background"), ";\n    color: ").concat(dt3("contextmenu.color"), ";\n    border: 1px solid ").concat(dt3("contextmenu.border.color"), ";\n    border-radius: ").concat(dt3("contextmenu.border.radius"), ";\n    box-shadow: ").concat(dt3("contextmenu.shadow"), ";\n    min-width: 12.5rem;\n}\n\n.p-contextmenu-root-list,\n.p-contextmenu-submenu {\n    margin: 0;\n    padding: ").concat(dt3("contextmenu.list.padding"), ";\n    list-style: none;\n    outline: 0 none;\n    display: flex;\n    flex-direction: column;\n    gap: ").concat(dt3("contextmenu.list.gap"), ";\n}\n\n.p-contextmenu-submenu {\n    position: absolute;\n    display: flex;\n    flex-direction: column;\n    min-width: 100%;\n    z-index: 1;\n    background: ").concat(dt3("contextmenu.background"), ";\n    color: ").concat(dt3("contextmenu.color"), ";\n    border: 1px solid ").concat(dt3("contextmenu.border.color"), ";\n    border-radius: ").concat(dt3("contextmenu.border.radius"), ";\n    box-shadow: ").concat(dt3("contextmenu.shadow"), ";\n}\n\n.p-contextmenu-item {\n    position: relative;\n}\n\n.p-contextmenu-item-content {\n    transition: background ").concat(dt3("contextmenu.transition.duration"), ", color ").concat(dt3("contextmenu.transition.duration"), ";\n    border-radius: ").concat(dt3("contextmenu.item.border.radius"), ";\n    color: ").concat(dt3("contextmenu.item.color"), ";\n}\n\n.p-contextmenu-item-link {\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    text-decoration: none;\n    overflow: hidden;\n    position: relative;\n    color: inherit;\n    padding: ").concat(dt3("contextmenu.item.padding"), ";\n    gap: ").concat(dt3("contextmenu.item.gap"), ";\n    user-select: none;\n}\n\n.p-contextmenu-item-label {\n    line-height: 1;\n}\n\n.p-contextmenu-item-icon {\n    color: ").concat(dt3("contextmenu.item.icon.color"), ";\n}\n\n.p-contextmenu-submenu-icon {\n    color: ").concat(dt3("contextmenu.submenu.icon.color"), ";\n    margin-left: auto;\n    font-size: ").concat(dt3("contextmenu.submenu.icon.size"), ";\n    width: ").concat(dt3("contextmenu.submenu.icon.size"), ";\n    height: ").concat(dt3("contextmenu.submenu.icon.size"), ";\n}\n\n.p-contextmenu-item.p-focus > .p-contextmenu-item-content {\n    color: ").concat(dt3("contextmenu.item.focus.color"), ";\n    background: ").concat(dt3("contextmenu.item.focus.background"), ";\n}\n\n.p-contextmenu-item.p-focus > .p-contextmenu-item-content .p-contextmenu-item-icon {\n    color: ").concat(dt3("contextmenu.item.icon.focus.color"), ";\n}\n\n.p-contextmenu-item.p-focus > .p-contextmenu-item-content .p-contextmenu-submenu-icon {\n    color: ").concat(dt3("contextmenu.submenu.icon.focus.color"), ";\n}\n\n.p-contextmenu-item:not(.p-disabled) > .p-contextmenu-item-content:hover {\n    color: ").concat(dt3("contextmenu.item.focus.color"), ";\n    background: ").concat(dt3("contextmenu.item.focus.background"), ";\n}\n\n.p-contextmenu-item:not(.p-disabled) > .p-contextmenu-item-content:hover .p-contextmenu-item-icon {\n    color: ").concat(dt3("contextmenu.item.icon.focus.color"), ";\n}\n\n.p-contextmenu-item:not(.p-disabled) > .p-contextmenu-item-content:hover .p-contextmenu-submenu-icon {\n    color: ").concat(dt3("contextmenu.submenu.icon.focus.color"), ";\n}\n\n.p-contextmenu-item-active > .p-contextmenu-item-content {\n    color: ").concat(dt3("contextmenu.item.active.color"), ";\n    background: ").concat(dt3("contextmenu.item.active.background"), ";\n}\n\n.p-contextmenu-item-active > .p-contextmenu-item-content .p-contextmenu-item-icon {\n    color: ").concat(dt3("contextmenu.item.icon.active.color"), ";\n}\n\n.p-contextmenu-item-active > .p-contextmenu-item-content .p-contextmenu-submenu-icon {\n    color: ").concat(dt3("contextmenu.submenu.icon.active.color"), ";\n}\n\n.p-contextmenu-separator {\n    border-top: 1px solid  ").concat(dt3("contextmenu.separator.border.color"), ";\n}\n\n.p-contextmenu-enter-from,\n.p-contextmenu-leave-active {\n    opacity: 0;\n}\n\n.p-contextmenu-enter-active {\n    transition: opacity 250ms;\n}\n");
}, "theme");
var classes$7 = {
  root: "p-contextmenu p-component",
  rootList: "p-contextmenu-root-list",
  item: /* @__PURE__ */ __name(function item(_ref2) {
    var instance = _ref2.instance, processedItem = _ref2.processedItem;
    return ["p-contextmenu-item", {
      "p-contextmenu-item-active": instance.isItemActive(processedItem),
      "p-focus": instance.isItemFocused(processedItem),
      "p-disabled": instance.isItemDisabled(processedItem)
    }];
  }, "item"),
  itemContent: "p-contextmenu-item-content",
  itemLink: "p-contextmenu-item-link",
  itemIcon: "p-contextmenu-item-icon",
  itemLabel: "p-contextmenu-item-label",
  submenuIcon: "p-contextmenu-submenu-icon",
  submenu: "p-contextmenu-submenu",
  separator: "p-contextmenu-separator"
};
var ContextMenuStyle = BaseStyle.extend({
  name: "contextmenu",
  theme: theme$7,
  classes: classes$7
});
var script$g = {
  name: "AngleRightIcon",
  "extends": script$U
};
var _hoisted_1$n = /* @__PURE__ */ createBaseVNode("path", {
  d: "M5.25 11.1728C5.14929 11.1694 5.05033 11.1455 4.9592 11.1025C4.86806 11.0595 4.78666 10.9984 4.72 10.9228C4.57955 10.7822 4.50066 10.5916 4.50066 10.3928C4.50066 10.1941 4.57955 10.0035 4.72 9.86283L7.72 6.86283L4.72 3.86283C4.66067 3.71882 4.64765 3.55991 4.68275 3.40816C4.71785 3.25642 4.79932 3.11936 4.91585 3.01602C5.03238 2.91268 5.17819 2.84819 5.33305 2.83149C5.4879 2.81479 5.64411 2.84671 5.78 2.92283L9.28 6.42283C9.42045 6.56346 9.49934 6.75408 9.49934 6.95283C9.49934 7.15158 9.42045 7.34221 9.28 7.48283L5.78 10.9228C5.71333 10.9984 5.63193 11.0595 5.5408 11.1025C5.44966 11.1455 5.35071 11.1694 5.25 11.1728Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$h = [_hoisted_1$n];
function render$f(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$h, 16);
}
__name(render$f, "render$f");
script$g.render = render$f;
var script$2$3 = {
  name: "BaseContextMenu",
  "extends": script$X,
  props: {
    model: {
      type: Array,
      "default": null
    },
    appendTo: {
      type: [String, Object],
      "default": "body"
    },
    autoZIndex: {
      type: Boolean,
      "default": true
    },
    baseZIndex: {
      type: Number,
      "default": 0
    },
    global: {
      type: Boolean,
      "default": false
    },
    tabindex: {
      type: Number,
      "default": 0
    },
    ariaLabelledby: {
      type: String,
      "default": null
    },
    ariaLabel: {
      type: String,
      "default": null
    }
  },
  style: ContextMenuStyle,
  provide: /* @__PURE__ */ __name(function provide33() {
    return {
      $pcContextMenu: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$1$7 = {
  name: "ContextMenuSub",
  hostName: "ContextMenu",
  "extends": script$X,
  emits: ["item-click", "item-mouseenter", "item-mousemove"],
  props: {
    items: {
      type: Array,
      "default": null
    },
    menuId: {
      type: String,
      "default": null
    },
    focusedItemId: {
      type: String,
      "default": null
    },
    root: {
      type: Boolean,
      "default": false
    },
    visible: {
      type: Boolean,
      "default": false
    },
    level: {
      type: Number,
      "default": 0
    },
    templates: {
      type: Object,
      "default": null
    },
    activeItemPath: {
      type: Object,
      "default": null
    },
    tabindex: {
      type: Number,
      "default": 0
    }
  },
  methods: {
    getItemId: /* @__PURE__ */ __name(function getItemId(processedItem) {
      return "".concat(this.menuId, "_").concat(processedItem.key);
    }, "getItemId"),
    getItemKey: /* @__PURE__ */ __name(function getItemKey(processedItem) {
      return this.getItemId(processedItem);
    }, "getItemKey"),
    getItemProp: /* @__PURE__ */ __name(function getItemProp(processedItem, name, params) {
      return processedItem && processedItem.item ? resolve(processedItem.item[name], params) : void 0;
    }, "getItemProp"),
    getItemLabel: /* @__PURE__ */ __name(function getItemLabel(processedItem) {
      return this.getItemProp(processedItem, "label");
    }, "getItemLabel"),
    getItemLabelId: /* @__PURE__ */ __name(function getItemLabelId(processedItem) {
      return "".concat(this.menuId, "_").concat(processedItem.key, "_label");
    }, "getItemLabelId"),
    getPTOptions: /* @__PURE__ */ __name(function getPTOptions10(key, processedItem, index2) {
      return this.ptm(key, {
        context: {
          item: processedItem,
          active: this.isItemActive(processedItem),
          focused: this.isItemFocused(processedItem),
          disabled: this.isItemDisabled(processedItem),
          index: index2
        }
      });
    }, "getPTOptions"),
    isItemActive: /* @__PURE__ */ __name(function isItemActive(processedItem) {
      return this.activeItemPath.some(function(path) {
        return path.key === processedItem.key;
      });
    }, "isItemActive"),
    isItemVisible: /* @__PURE__ */ __name(function isItemVisible(processedItem) {
      return this.getItemProp(processedItem, "visible") !== false;
    }, "isItemVisible"),
    isItemDisabled: /* @__PURE__ */ __name(function isItemDisabled(processedItem) {
      return this.getItemProp(processedItem, "disabled");
    }, "isItemDisabled"),
    isItemFocused: /* @__PURE__ */ __name(function isItemFocused(processedItem) {
      return this.focusedItemId === this.getItemId(processedItem);
    }, "isItemFocused"),
    isItemGroup: /* @__PURE__ */ __name(function isItemGroup(processedItem) {
      return isNotEmpty(processedItem.items);
    }, "isItemGroup"),
    onItemClick: /* @__PURE__ */ __name(function onItemClick(event2, processedItem) {
      this.getItemProp(processedItem, "command", {
        originalEvent: event2,
        item: processedItem.item
      });
      this.$emit("item-click", {
        originalEvent: event2,
        processedItem,
        isFocus: true
      });
    }, "onItemClick"),
    onItemMouseEnter: /* @__PURE__ */ __name(function onItemMouseEnter(event2, processedItem) {
      this.$emit("item-mouseenter", {
        originalEvent: event2,
        processedItem
      });
    }, "onItemMouseEnter"),
    onItemMouseMove: /* @__PURE__ */ __name(function onItemMouseMove(event2, processedItem) {
      this.$emit("item-mousemove", {
        originalEvent: event2,
        processedItem,
        isFocus: true
      });
    }, "onItemMouseMove"),
    getAriaSetSize: /* @__PURE__ */ __name(function getAriaSetSize() {
      var _this = this;
      return this.items.filter(function(processedItem) {
        return _this.isItemVisible(processedItem) && !_this.getItemProp(processedItem, "separator");
      }).length;
    }, "getAriaSetSize"),
    getAriaPosInset: /* @__PURE__ */ __name(function getAriaPosInset4(index2) {
      var _this2 = this;
      return index2 - this.items.slice(0, index2).filter(function(processedItem) {
        return _this2.isItemVisible(processedItem) && _this2.getItemProp(processedItem, "separator");
      }).length + 1;
    }, "getAriaPosInset"),
    onEnter: /* @__PURE__ */ __name(function onEnter3() {
      nestedPosition(this.$refs.container, this.level);
    }, "onEnter"),
    getMenuItemProps: /* @__PURE__ */ __name(function getMenuItemProps(processedItem, index2) {
      return {
        action: mergeProps({
          "class": this.cx("itemLink"),
          tabindex: -1,
          "aria-hidden": true
        }, this.getPTOptions("itemLink", processedItem, index2)),
        icon: mergeProps({
          "class": [this.cx("itemIcon"), this.getItemProp(processedItem, "icon")]
        }, this.getPTOptions("itemIcon", processedItem, index2)),
        label: mergeProps({
          "class": this.cx("itemLabel")
        }, this.getPTOptions("itemLabel", processedItem, index2)),
        submenuicon: mergeProps({
          "class": this.cx("submenuIcon")
        }, this.getPTOptions("submenuicon", processedItem, index2))
      };
    }, "getMenuItemProps")
  },
  components: {
    AngleRightIcon: script$g
  },
  directives: {
    ripple: Ripple
  }
};
var _hoisted_1$m = ["tabindex"];
var _hoisted_2$g = ["id", "aria-label", "aria-disabled", "aria-expanded", "aria-haspopup", "aria-level", "aria-setsize", "aria-posinset", "data-p-active", "data-p-focused", "data-p-disabled"];
var _hoisted_3$9 = ["onClick", "onMouseenter", "onMousemove"];
var _hoisted_4$5 = ["href", "target"];
var _hoisted_5$3 = ["id"];
var _hoisted_6$2 = ["id"];
function render$1$3(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_AngleRightIcon = resolveComponent("AngleRightIcon");
  var _component_ContextMenuSub = resolveComponent("ContextMenuSub", true);
  var _directive_ripple = resolveDirective("ripple");
  return openBlock(), createBlock(Transition, mergeProps({
    name: "p-contextmenusub",
    onEnter: $options.onEnter
  }, _ctx.ptm("menu.transition")), {
    "default": withCtx(function() {
      return [($props.root ? true : $props.visible) ? (openBlock(), createElementBlock("ul", mergeProps({
        key: 0,
        ref: "container",
        tabindex: $props.tabindex
      }, _ctx.ptm("rootList")), [(openBlock(true), createElementBlock(Fragment, null, renderList($props.items, function(processedItem, index2) {
        return openBlock(), createElementBlock(Fragment, {
          key: $options.getItemKey(processedItem)
        }, [$options.isItemVisible(processedItem) && !$options.getItemProp(processedItem, "separator") ? (openBlock(), createElementBlock("li", mergeProps({
          key: 0,
          id: $options.getItemId(processedItem),
          style: $options.getItemProp(processedItem, "style"),
          "class": [_ctx.cx("item", {
            processedItem
          }), $options.getItemProp(processedItem, "class")],
          role: "menuitem",
          "aria-label": $options.getItemLabel(processedItem),
          "aria-disabled": $options.isItemDisabled(processedItem) || void 0,
          "aria-expanded": $options.isItemGroup(processedItem) ? $options.isItemActive(processedItem) : void 0,
          "aria-haspopup": $options.isItemGroup(processedItem) && !$options.getItemProp(processedItem, "to") ? "menu" : void 0,
          "aria-level": $props.level + 1,
          "aria-setsize": $options.getAriaSetSize(),
          "aria-posinset": $options.getAriaPosInset(index2),
          ref_for: true
        }, $options.getPTOptions("item", processedItem, index2), {
          "data-p-active": $options.isItemActive(processedItem),
          "data-p-focused": $options.isItemFocused(processedItem),
          "data-p-disabled": $options.isItemDisabled(processedItem)
        }), [createBaseVNode("div", mergeProps({
          "class": _ctx.cx("itemContent"),
          onClick: /* @__PURE__ */ __name(function onClick3($event) {
            return $options.onItemClick($event, processedItem);
          }, "onClick"),
          onMouseenter: /* @__PURE__ */ __name(function onMouseenter($event) {
            return $options.onItemMouseEnter($event, processedItem);
          }, "onMouseenter"),
          onMousemove: /* @__PURE__ */ __name(function onMousemove($event) {
            return $options.onItemMouseMove($event, processedItem);
          }, "onMousemove"),
          ref_for: true
        }, $options.getPTOptions("itemContent", processedItem, index2)), [!$props.templates.item ? withDirectives((openBlock(), createElementBlock("a", mergeProps({
          key: 0,
          href: $options.getItemProp(processedItem, "url"),
          "class": _ctx.cx("itemLink"),
          target: $options.getItemProp(processedItem, "target"),
          tabindex: "-1",
          "aria-hidden": "true",
          ref_for: true
        }, $options.getPTOptions("itemLink", processedItem, index2)), [$props.templates.itemicon ? (openBlock(), createBlock(resolveDynamicComponent($props.templates.itemicon), {
          key: 0,
          item: processedItem.item,
          "class": normalizeClass(_ctx.cx("itemIcon"))
        }, null, 8, ["item", "class"])) : $options.getItemProp(processedItem, "icon") ? (openBlock(), createElementBlock("span", mergeProps({
          key: 1,
          "class": [_ctx.cx("itemIcon"), $options.getItemProp(processedItem, "icon")],
          ref_for: true
        }, $options.getPTOptions("itemIcon", processedItem, index2)), null, 16)) : createCommentVNode("", true), createBaseVNode("span", mergeProps({
          id: $options.getItemLabelId(processedItem),
          "class": _ctx.cx("itemLabel"),
          ref_for: true
        }, $options.getPTOptions("itemLabel", processedItem, index2)), toDisplayString$1($options.getItemLabel(processedItem)), 17, _hoisted_5$3), $options.getItemProp(processedItem, "items") ? (openBlock(), createElementBlock(Fragment, {
          key: 2
        }, [$props.templates.submenuicon ? (openBlock(), createBlock(resolveDynamicComponent($props.templates.submenuicon), {
          key: 0,
          active: $options.isItemActive(processedItem),
          "class": normalizeClass(_ctx.cx("submenuIcon"))
        }, null, 8, ["active", "class"])) : (openBlock(), createBlock(_component_AngleRightIcon, mergeProps({
          key: 1,
          "class": _ctx.cx("submenuIcon"),
          ref_for: true
        }, $options.getPTOptions("submenuicon", processedItem, index2)), null, 16, ["class"]))], 64)) : createCommentVNode("", true)], 16, _hoisted_4$5)), [[_directive_ripple]]) : (openBlock(), createBlock(resolveDynamicComponent($props.templates.item), {
          key: 1,
          item: processedItem.item,
          hasSubmenu: $options.getItemProp(processedItem, "items"),
          label: $options.getItemLabel(processedItem),
          props: $options.getMenuItemProps(processedItem, index2)
        }, null, 8, ["item", "hasSubmenu", "label", "props"]))], 16, _hoisted_3$9), $options.isItemVisible(processedItem) && $options.isItemGroup(processedItem) ? (openBlock(), createBlock(_component_ContextMenuSub, mergeProps({
          key: 0,
          id: $options.getItemId(processedItem) + "_list",
          role: "menu",
          "class": _ctx.cx("submenu"),
          menuId: $props.menuId,
          focusedItemId: $props.focusedItemId,
          items: processedItem.items,
          templates: $props.templates,
          activeItemPath: $props.activeItemPath,
          level: $props.level + 1,
          visible: $options.isItemActive(processedItem) && $options.isItemGroup(processedItem),
          pt: _ctx.pt,
          unstyled: _ctx.unstyled,
          onItemClick: _cache[0] || (_cache[0] = function($event) {
            return _ctx.$emit("item-click", $event);
          }),
          onItemMouseenter: _cache[1] || (_cache[1] = function($event) {
            return _ctx.$emit("item-mouseenter", $event);
          }),
          onItemMousemove: _cache[2] || (_cache[2] = function($event) {
            return _ctx.$emit("item-mousemove", $event);
          }),
          "aria-labelledby": $options.getItemLabelId(processedItem),
          ref_for: true
        }, _ctx.ptm("submenu")), null, 16, ["id", "class", "menuId", "focusedItemId", "items", "templates", "activeItemPath", "level", "visible", "pt", "unstyled", "aria-labelledby"])) : createCommentVNode("", true)], 16, _hoisted_2$g)) : createCommentVNode("", true), $options.isItemVisible(processedItem) && $options.getItemProp(processedItem, "separator") ? (openBlock(), createElementBlock("li", mergeProps({
          key: 1,
          id: $options.getItemId(processedItem),
          style: $options.getItemProp(processedItem, "style"),
          "class": [_ctx.cx("separator"), $options.getItemProp(processedItem, "class")],
          role: "separator",
          ref_for: true
        }, _ctx.ptm("separator")), null, 16, _hoisted_6$2)) : createCommentVNode("", true)], 64);
      }), 128))], 16, _hoisted_1$m)) : createCommentVNode("", true)];
    }),
    _: 1
  }, 16, ["onEnter"]);
}
__name(render$1$3, "render$1$3");
script$1$7.render = render$1$3;
var script$f = {
  name: "ContextMenu",
  "extends": script$2$3,
  inheritAttrs: false,
  emits: ["focus", "blur", "show", "hide", "before-show", "before-hide"],
  target: null,
  outsideClickListener: null,
  resizeListener: null,
  documentContextMenuListener: null,
  pageX: null,
  pageY: null,
  container: null,
  list: null,
  data: /* @__PURE__ */ __name(function data15() {
    return {
      id: this.$attrs.id,
      focused: false,
      focusedItemInfo: {
        index: -1,
        level: 0,
        parentKey: ""
      },
      activeItemPath: [],
      visible: false,
      submenuVisible: false
    };
  }, "data"),
  watch: {
    "$attrs.id": /* @__PURE__ */ __name(function $attrsId7(newValue) {
      this.id = newValue || UniqueComponentId();
    }, "$attrsId"),
    activeItemPath: /* @__PURE__ */ __name(function activeItemPath(newPath) {
      if (isNotEmpty(newPath)) {
        this.bindOutsideClickListener();
        this.bindResizeListener();
      } else if (!this.visible) {
        this.unbindOutsideClickListener();
        this.unbindResizeListener();
      }
    }, "activeItemPath")
  },
  mounted: /* @__PURE__ */ __name(function mounted14() {
    this.id = this.id || UniqueComponentId();
    if (this.global) {
      this.bindDocumentContextMenuListener();
    }
  }, "mounted"),
  beforeUnmount: /* @__PURE__ */ __name(function beforeUnmount9() {
    this.unbindResizeListener();
    this.unbindOutsideClickListener();
    this.unbindDocumentContextMenuListener();
    if (this.container && this.autoZIndex) {
      ZIndex.clear(this.container);
    }
    this.target = null;
    this.container = null;
  }, "beforeUnmount"),
  methods: {
    getItemProp: /* @__PURE__ */ __name(function getItemProp2(item2, name) {
      return item2 ? resolve(item2[name]) : void 0;
    }, "getItemProp"),
    getItemLabel: /* @__PURE__ */ __name(function getItemLabel2(item2) {
      return this.getItemProp(item2, "label");
    }, "getItemLabel"),
    isItemDisabled: /* @__PURE__ */ __name(function isItemDisabled2(item2) {
      return this.getItemProp(item2, "disabled");
    }, "isItemDisabled"),
    isItemVisible: /* @__PURE__ */ __name(function isItemVisible2(item2) {
      return this.getItemProp(item2, "visible") !== false;
    }, "isItemVisible"),
    isItemGroup: /* @__PURE__ */ __name(function isItemGroup2(item2) {
      return isNotEmpty(this.getItemProp(item2, "items"));
    }, "isItemGroup"),
    isItemSeparator: /* @__PURE__ */ __name(function isItemSeparator(item2) {
      return this.getItemProp(item2, "separator");
    }, "isItemSeparator"),
    getProccessedItemLabel: /* @__PURE__ */ __name(function getProccessedItemLabel(processedItem) {
      return processedItem ? this.getItemLabel(processedItem.item) : void 0;
    }, "getProccessedItemLabel"),
    isProccessedItemGroup: /* @__PURE__ */ __name(function isProccessedItemGroup(processedItem) {
      return processedItem && isNotEmpty(processedItem.items);
    }, "isProccessedItemGroup"),
    toggle: /* @__PURE__ */ __name(function toggle(event2) {
      this.visible ? this.hide() : this.show(event2);
    }, "toggle"),
    show: /* @__PURE__ */ __name(function show4(event2) {
      this.$emit("before-show");
      this.activeItemPath = [];
      this.focusedItemInfo = {
        index: -1,
        level: 0,
        parentKey: ""
      };
      focus(this.list);
      this.pageX = event2.pageX;
      this.pageY = event2.pageY;
      this.visible ? this.position() : this.visible = true;
      event2.stopPropagation();
      event2.preventDefault();
    }, "show"),
    hide: /* @__PURE__ */ __name(function hide4() {
      this.$emit("before-hide");
      this.visible = false;
      this.activeItemPath = [];
      this.focusedItemInfo = {
        index: -1,
        level: 0,
        parentKey: ""
      };
    }, "hide"),
    onFocus: /* @__PURE__ */ __name(function onFocus6(event2) {
      this.focused = true;
      this.focusedItemInfo = this.focusedItemInfo.index !== -1 ? this.focusedItemInfo : {
        index: -1,
        level: 0,
        parentKey: ""
      };
      this.$emit("focus", event2);
    }, "onFocus"),
    onBlur: /* @__PURE__ */ __name(function onBlur6(event2) {
      this.focused = false;
      this.focusedItemInfo = {
        index: -1,
        level: 0,
        parentKey: ""
      };
      this.searchValue = "";
      this.$emit("blur", event2);
    }, "onBlur"),
    onKeyDown: /* @__PURE__ */ __name(function onKeyDown7(event2) {
      var metaKey = event2.metaKey || event2.ctrlKey;
      switch (event2.code) {
        case "ArrowDown":
          this.onArrowDownKey(event2);
          break;
        case "ArrowUp":
          this.onArrowUpKey(event2);
          break;
        case "ArrowLeft":
          this.onArrowLeftKey(event2);
          break;
        case "ArrowRight":
          this.onArrowRightKey(event2);
          break;
        case "Home":
          this.onHomeKey(event2);
          break;
        case "End":
          this.onEndKey(event2);
          break;
        case "Space":
          this.onSpaceKey(event2);
          break;
        case "Enter":
        case "NumpadEnter":
          this.onEnterKey(event2);
          break;
        case "Escape":
          this.onEscapeKey(event2);
          break;
        case "Tab":
          this.onTabKey(event2);
          break;
        case "PageDown":
        case "PageUp":
        case "Backspace":
        case "ShiftLeft":
        case "ShiftRight":
          break;
        default:
          if (!metaKey && isPrintableCharacter(event2.key)) {
            this.searchItems(event2, event2.key);
          }
          break;
      }
    }, "onKeyDown"),
    onItemChange: /* @__PURE__ */ __name(function onItemChange(event2) {
      var processedItem = event2.processedItem, isFocus = event2.isFocus;
      if (isEmpty(processedItem)) return;
      var index2 = processedItem.index, key = processedItem.key, level = processedItem.level, parentKey = processedItem.parentKey, items2 = processedItem.items;
      var grouped = isNotEmpty(items2);
      var activeItemPath2 = this.activeItemPath.filter(function(p2) {
        return p2.parentKey !== parentKey && p2.parentKey !== key;
      });
      if (grouped) {
        activeItemPath2.push(processedItem);
        this.submenuVisible = true;
      }
      this.focusedItemInfo = {
        index: index2,
        level,
        parentKey
      };
      this.activeItemPath = activeItemPath2;
      isFocus && focus(this.list);
    }, "onItemChange"),
    onItemClick: /* @__PURE__ */ __name(function onItemClick2(event2) {
      var processedItem = event2.processedItem;
      var grouped = this.isProccessedItemGroup(processedItem);
      var selected2 = this.isSelected(processedItem);
      if (selected2) {
        var index2 = processedItem.index, key = processedItem.key, level = processedItem.level, parentKey = processedItem.parentKey;
        this.activeItemPath = this.activeItemPath.filter(function(p2) {
          return key !== p2.key && key.startsWith(p2.key);
        });
        this.focusedItemInfo = {
          index: index2,
          level,
          parentKey
        };
        focus(this.list);
      } else {
        grouped ? this.onItemChange(event2) : this.hide();
      }
    }, "onItemClick"),
    onItemMouseEnter: /* @__PURE__ */ __name(function onItemMouseEnter2(event2) {
      this.onItemChange(event2);
    }, "onItemMouseEnter"),
    onItemMouseMove: /* @__PURE__ */ __name(function onItemMouseMove2(event2) {
      if (this.focused) {
        this.changeFocusedItemIndex(event2, event2.processedItem.index);
      }
    }, "onItemMouseMove"),
    onArrowDownKey: /* @__PURE__ */ __name(function onArrowDownKey4(event2) {
      var itemIndex = this.focusedItemInfo.index !== -1 ? this.findNextItemIndex(this.focusedItemInfo.index) : this.findFirstFocusedItemIndex();
      this.changeFocusedItemIndex(event2, itemIndex);
      event2.preventDefault();
    }, "onArrowDownKey"),
    onArrowUpKey: /* @__PURE__ */ __name(function onArrowUpKey4(event2) {
      if (event2.altKey) {
        if (this.focusedItemInfo.index !== -1) {
          var processedItem = this.visibleItems[this.focusedItemInfo.index];
          var grouped = this.isProccessedItemGroup(processedItem);
          !grouped && this.onItemChange({
            originalEvent: event2,
            processedItem
          });
        }
        this.popup && this.hide();
        event2.preventDefault();
      } else {
        var itemIndex = this.focusedItemInfo.index !== -1 ? this.findPrevItemIndex(this.focusedItemInfo.index) : this.findLastFocusedItemIndex();
        this.changeFocusedItemIndex(event2, itemIndex);
        event2.preventDefault();
      }
    }, "onArrowUpKey"),
    onArrowLeftKey: /* @__PURE__ */ __name(function onArrowLeftKey4(event2) {
      var _this = this;
      var processedItem = this.visibleItems[this.focusedItemInfo.index];
      var parentItem = this.activeItemPath.find(function(p2) {
        return p2.key === processedItem.parentKey;
      });
      var root26 = isEmpty(processedItem.parent);
      if (!root26) {
        this.focusedItemInfo = {
          index: -1,
          parentKey: parentItem ? parentItem.parentKey : ""
        };
        this.searchValue = "";
        this.onArrowDownKey(event2);
      }
      this.activeItemPath = this.activeItemPath.filter(function(p2) {
        return p2.parentKey !== _this.focusedItemInfo.parentKey;
      });
      event2.preventDefault();
    }, "onArrowLeftKey"),
    onArrowRightKey: /* @__PURE__ */ __name(function onArrowRightKey2(event2) {
      var processedItem = this.visibleItems[this.focusedItemInfo.index];
      var grouped = this.isProccessedItemGroup(processedItem);
      if (grouped) {
        this.onItemChange({
          originalEvent: event2,
          processedItem
        });
        this.focusedItemInfo = {
          index: -1,
          parentKey: processedItem.key
        };
        this.searchValue = "";
        this.onArrowDownKey(event2);
      }
      event2.preventDefault();
    }, "onArrowRightKey"),
    onHomeKey: /* @__PURE__ */ __name(function onHomeKey4(event2) {
      this.changeFocusedItemIndex(event2, this.findFirstItemIndex());
      event2.preventDefault();
    }, "onHomeKey"),
    onEndKey: /* @__PURE__ */ __name(function onEndKey4(event2) {
      this.changeFocusedItemIndex(event2, this.findLastItemIndex());
      event2.preventDefault();
    }, "onEndKey"),
    onEnterKey: /* @__PURE__ */ __name(function onEnterKey4(event2) {
      if (this.focusedItemInfo.index !== -1) {
        var element = findSingle(this.list, 'li[id="'.concat("".concat(this.focusedItemIdx), '"]'));
        var anchorElement = element && findSingle(element, 'a[data-pc-section="itemlink"]');
        anchorElement ? anchorElement.click() : element && element.click();
        var processedItem = this.visibleItems[this.focusedItemInfo.index];
        var grouped = this.isProccessedItemGroup(processedItem);
        !grouped && (this.focusedItemInfo.index = this.findFirstFocusedItemIndex());
      }
      event2.preventDefault();
    }, "onEnterKey"),
    onSpaceKey: /* @__PURE__ */ __name(function onSpaceKey3(event2) {
      this.onEnterKey(event2);
    }, "onSpaceKey"),
    onEscapeKey: /* @__PURE__ */ __name(function onEscapeKey3(event2) {
      this.hide();
      !this.popup && (this.focusedItemInfo.index = this.findFirstFocusedItemIndex());
      event2.preventDefault();
    }, "onEscapeKey"),
    onTabKey: /* @__PURE__ */ __name(function onTabKey3(event2) {
      if (this.focusedItemInfo.index !== -1) {
        var processedItem = this.visibleItems[this.focusedItemInfo.index];
        var grouped = this.isProccessedItemGroup(processedItem);
        !grouped && this.onItemChange({
          originalEvent: event2,
          processedItem
        });
      }
      this.hide();
    }, "onTabKey"),
    onEnter: /* @__PURE__ */ __name(function onEnter4(el) {
      addStyle(el, {
        position: "absolute"
      });
      this.position();
      if (this.autoZIndex) {
        ZIndex.set("menu", el, this.baseZIndex + this.$primevue.config.zIndex.menu);
      }
    }, "onEnter"),
    onAfterEnter: /* @__PURE__ */ __name(function onAfterEnter2() {
      this.bindOutsideClickListener();
      this.bindResizeListener();
      this.$emit("show");
      focus(this.list);
    }, "onAfterEnter"),
    onLeave: /* @__PURE__ */ __name(function onLeave3() {
      this.$emit("hide");
      this.container = null;
    }, "onLeave"),
    onAfterLeave: /* @__PURE__ */ __name(function onAfterLeave3(el) {
      if (this.autoZIndex) {
        ZIndex.clear(el);
      }
      this.unbindOutsideClickListener();
      this.unbindResizeListener();
    }, "onAfterLeave"),
    position: /* @__PURE__ */ __name(function position() {
      var left = this.pageX + 1;
      var top = this.pageY + 1;
      var width2 = this.container.offsetParent ? this.container.offsetWidth : getHiddenElementOuterWidth(this.container);
      var height = this.container.offsetParent ? this.container.offsetHeight : getHiddenElementOuterHeight(this.container);
      var viewport = getViewport();
      if (left + width2 - document.body.scrollLeft > viewport.width) {
        left -= width2;
      }
      if (top + height - document.body.scrollTop > viewport.height) {
        top -= height;
      }
      if (left < document.body.scrollLeft) {
        left = document.body.scrollLeft;
      }
      if (top < document.body.scrollTop) {
        top = document.body.scrollTop;
      }
      this.container.style.left = left + "px";
      this.container.style.top = top + "px";
    }, "position"),
    bindOutsideClickListener: /* @__PURE__ */ __name(function bindOutsideClickListener4() {
      var _this2 = this;
      if (!this.outsideClickListener) {
        this.outsideClickListener = function(event2) {
          var isOutsideContainer = _this2.container && !_this2.container.contains(event2.target);
          var isOutsideTarget = _this2.visible ? !(_this2.target && (_this2.target === event2.target || _this2.target.contains(event2.target))) : true;
          if (isOutsideContainer && isOutsideTarget) {
            _this2.hide();
          }
        };
        document.addEventListener("click", this.outsideClickListener);
      }
    }, "bindOutsideClickListener"),
    unbindOutsideClickListener: /* @__PURE__ */ __name(function unbindOutsideClickListener4() {
      if (this.outsideClickListener) {
        document.removeEventListener("click", this.outsideClickListener);
        this.outsideClickListener = null;
      }
    }, "unbindOutsideClickListener"),
    bindResizeListener: /* @__PURE__ */ __name(function bindResizeListener5() {
      var _this3 = this;
      if (!this.resizeListener) {
        this.resizeListener = function() {
          if (_this3.visible && !isTouchDevice()) {
            _this3.hide();
          }
        };
        window.addEventListener("resize", this.resizeListener);
      }
    }, "bindResizeListener"),
    unbindResizeListener: /* @__PURE__ */ __name(function unbindResizeListener5() {
      if (this.resizeListener) {
        window.removeEventListener("resize", this.resizeListener);
        this.resizeListener = null;
      }
    }, "unbindResizeListener"),
    bindDocumentContextMenuListener: /* @__PURE__ */ __name(function bindDocumentContextMenuListener() {
      var _this4 = this;
      if (!this.documentContextMenuListener) {
        this.documentContextMenuListener = function(event2) {
          event2.button === 2 && _this4.show(event2);
        };
        document.addEventListener("contextmenu", this.documentContextMenuListener);
      }
    }, "bindDocumentContextMenuListener"),
    unbindDocumentContextMenuListener: /* @__PURE__ */ __name(function unbindDocumentContextMenuListener() {
      if (this.documentContextMenuListener) {
        document.removeEventListener("contextmenu", this.documentContextMenuListener);
        this.documentContextMenuListener = null;
      }
    }, "unbindDocumentContextMenuListener"),
    isItemMatched: /* @__PURE__ */ __name(function isItemMatched(processedItem) {
      var _this$getProccessedIt;
      return this.isValidItem(processedItem) && ((_this$getProccessedIt = this.getProccessedItemLabel(processedItem)) === null || _this$getProccessedIt === void 0 ? void 0 : _this$getProccessedIt.toLocaleLowerCase().startsWith(this.searchValue.toLocaleLowerCase()));
    }, "isItemMatched"),
    isValidItem: /* @__PURE__ */ __name(function isValidItem(processedItem) {
      return !!processedItem && !this.isItemDisabled(processedItem.item) && !this.isItemSeparator(processedItem.item) && this.isItemVisible(processedItem.item);
    }, "isValidItem"),
    isValidSelectedItem: /* @__PURE__ */ __name(function isValidSelectedItem(processedItem) {
      return this.isValidItem(processedItem) && this.isSelected(processedItem);
    }, "isValidSelectedItem"),
    isSelected: /* @__PURE__ */ __name(function isSelected5(processedItem) {
      return this.activeItemPath.some(function(p2) {
        return p2.key === processedItem.key;
      });
    }, "isSelected"),
    findFirstItemIndex: /* @__PURE__ */ __name(function findFirstItemIndex() {
      var _this5 = this;
      return this.visibleItems.findIndex(function(processedItem) {
        return _this5.isValidItem(processedItem);
      });
    }, "findFirstItemIndex"),
    findLastItemIndex: /* @__PURE__ */ __name(function findLastItemIndex() {
      var _this6 = this;
      return findLastIndex(this.visibleItems, function(processedItem) {
        return _this6.isValidItem(processedItem);
      });
    }, "findLastItemIndex"),
    findNextItemIndex: /* @__PURE__ */ __name(function findNextItemIndex(index2) {
      var _this7 = this;
      var matchedItemIndex = index2 < this.visibleItems.length - 1 ? this.visibleItems.slice(index2 + 1).findIndex(function(processedItem) {
        return _this7.isValidItem(processedItem);
      }) : -1;
      return matchedItemIndex > -1 ? matchedItemIndex + index2 + 1 : index2;
    }, "findNextItemIndex"),
    findPrevItemIndex: /* @__PURE__ */ __name(function findPrevItemIndex(index2) {
      var _this8 = this;
      var matchedItemIndex = index2 > 0 ? findLastIndex(this.visibleItems.slice(0, index2), function(processedItem) {
        return _this8.isValidItem(processedItem);
      }) : -1;
      return matchedItemIndex > -1 ? matchedItemIndex : index2;
    }, "findPrevItemIndex"),
    findSelectedItemIndex: /* @__PURE__ */ __name(function findSelectedItemIndex() {
      var _this9 = this;
      return this.visibleItems.findIndex(function(processedItem) {
        return _this9.isValidSelectedItem(processedItem);
      });
    }, "findSelectedItemIndex"),
    findFirstFocusedItemIndex: /* @__PURE__ */ __name(function findFirstFocusedItemIndex() {
      var selectedIndex = this.findSelectedItemIndex();
      return selectedIndex < 0 ? this.findFirstItemIndex() : selectedIndex;
    }, "findFirstFocusedItemIndex"),
    findLastFocusedItemIndex: /* @__PURE__ */ __name(function findLastFocusedItemIndex() {
      var selectedIndex = this.findSelectedItemIndex();
      return selectedIndex < 0 ? this.findLastItemIndex() : selectedIndex;
    }, "findLastFocusedItemIndex"),
    searchItems: /* @__PURE__ */ __name(function searchItems(event2, _char) {
      var _this10 = this;
      this.searchValue = (this.searchValue || "") + _char;
      var itemIndex = -1;
      var matched = false;
      if (this.focusedItemInfo.index !== -1) {
        itemIndex = this.visibleItems.slice(this.focusedItemInfo.index).findIndex(function(processedItem) {
          return _this10.isItemMatched(processedItem);
        });
        itemIndex = itemIndex === -1 ? this.visibleItems.slice(0, this.focusedItemInfo.index).findIndex(function(processedItem) {
          return _this10.isItemMatched(processedItem);
        }) : itemIndex + this.focusedItemInfo.index;
      } else {
        itemIndex = this.visibleItems.findIndex(function(processedItem) {
          return _this10.isItemMatched(processedItem);
        });
      }
      if (itemIndex !== -1) {
        matched = true;
      }
      if (itemIndex === -1 && this.focusedItemInfo.index === -1) {
        itemIndex = this.findFirstFocusedItemIndex();
      }
      if (itemIndex !== -1) {
        this.changeFocusedItemIndex(event2, itemIndex);
      }
      if (this.searchTimeout) {
        clearTimeout(this.searchTimeout);
      }
      this.searchTimeout = setTimeout(function() {
        _this10.searchValue = "";
        _this10.searchTimeout = null;
      }, 500);
      return matched;
    }, "searchItems"),
    changeFocusedItemIndex: /* @__PURE__ */ __name(function changeFocusedItemIndex(event2, index2) {
      if (this.focusedItemInfo.index !== index2) {
        this.focusedItemInfo.index = index2;
        this.scrollInView();
      }
    }, "changeFocusedItemIndex"),
    scrollInView: /* @__PURE__ */ __name(function scrollInView6() {
      var index2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : -1;
      var id2 = index2 !== -1 ? "".concat(this.id, "_").concat(index2) : this.focusedItemIdx;
      var element = findSingle(this.list, 'li[id="'.concat(id2, '"]'));
      if (element) {
        element.scrollIntoView && element.scrollIntoView({
          block: "nearest",
          inline: "start"
        });
      }
    }, "scrollInView"),
    createProcessedItems: /* @__PURE__ */ __name(function createProcessedItems(items2) {
      var _this11 = this;
      var level = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var parent = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var parentKey = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "";
      var processedItems2 = [];
      items2 && items2.forEach(function(item2, index2) {
        var key = (parentKey !== "" ? parentKey + "_" : "") + index2;
        var newItem = {
          item: item2,
          index: index2,
          level,
          key,
          parent,
          parentKey
        };
        newItem["items"] = _this11.createProcessedItems(item2.items, level + 1, newItem, key);
        processedItems2.push(newItem);
      });
      return processedItems2;
    }, "createProcessedItems"),
    containerRef: /* @__PURE__ */ __name(function containerRef3(el) {
      this.container = el;
    }, "containerRef"),
    listRef: /* @__PURE__ */ __name(function listRef4(el) {
      this.list = el ? el.$el : void 0;
    }, "listRef")
  },
  computed: {
    processedItems: /* @__PURE__ */ __name(function processedItems() {
      return this.createProcessedItems(this.model || []);
    }, "processedItems"),
    visibleItems: /* @__PURE__ */ __name(function visibleItems() {
      var _this12 = this;
      var processedItem = this.activeItemPath.find(function(p2) {
        return p2.key === _this12.focusedItemInfo.parentKey;
      });
      return processedItem ? processedItem.items : this.processedItems;
    }, "visibleItems"),
    focusedItemIdx: /* @__PURE__ */ __name(function focusedItemIdx() {
      return this.focusedItemInfo.index !== -1 ? "".concat(this.id).concat(isNotEmpty(this.focusedItemInfo.parentKey) ? "_" + this.focusedItemInfo.parentKey : "", "_").concat(this.focusedItemInfo.index) : null;
    }, "focusedItemIdx")
  },
  components: {
    ContextMenuSub: script$1$7,
    Portal: script$z
  }
};
function render$e(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_ContextMenuSub = resolveComponent("ContextMenuSub");
  var _component_Portal = resolveComponent("Portal");
  return openBlock(), createBlock(_component_Portal, {
    appendTo: _ctx.appendTo
  }, {
    "default": withCtx(function() {
      return [createVNode(Transition, mergeProps({
        name: "p-contextmenu",
        onEnter: $options.onEnter,
        onAfterEnter: $options.onAfterEnter,
        onLeave: $options.onLeave,
        onAfterLeave: $options.onAfterLeave
      }, _ctx.ptm("transition")), {
        "default": withCtx(function() {
          return [$data.visible ? (openBlock(), createElementBlock("div", mergeProps({
            key: 0,
            ref: $options.containerRef,
            "class": _ctx.cx("root")
          }, _ctx.ptmi("root")), [createVNode(_component_ContextMenuSub, {
            ref: $options.listRef,
            id: $data.id + "_list",
            "class": normalizeClass(_ctx.cx("rootList")),
            role: "menubar",
            root: true,
            tabindex: _ctx.tabindex,
            "aria-orientation": "vertical",
            "aria-activedescendant": $data.focused ? $options.focusedItemIdx : void 0,
            menuId: $data.id,
            focusedItemId: $data.focused ? $options.focusedItemIdx : void 0,
            items: $options.processedItems,
            templates: _ctx.$slots,
            activeItemPath: $data.activeItemPath,
            "aria-labelledby": _ctx.ariaLabelledby,
            "aria-label": _ctx.ariaLabel,
            level: 0,
            visible: $data.submenuVisible,
            pt: _ctx.pt,
            unstyled: _ctx.unstyled,
            onFocus: $options.onFocus,
            onBlur: $options.onBlur,
            onKeydown: $options.onKeyDown,
            onItemClick: $options.onItemClick,
            onItemMouseenter: $options.onItemMouseEnter,
            onItemMousemove: $options.onItemMouseMove
          }, null, 8, ["id", "class", "tabindex", "aria-activedescendant", "menuId", "focusedItemId", "items", "templates", "activeItemPath", "aria-labelledby", "aria-label", "visible", "pt", "unstyled", "onFocus", "onBlur", "onKeydown", "onItemClick", "onItemMouseenter", "onItemMousemove"])], 16)) : createCommentVNode("", true)];
        }),
        _: 1
      }, 16, ["onEnter", "onAfterEnter", "onLeave", "onAfterLeave"])];
    }),
    _: 1
  }, 8, ["appendTo"]);
}
__name(render$e, "render$e");
script$f.render = render$e;
const _withScopeId$7 = /* @__PURE__ */ __name((n) => (pushScopeId("data-v-9bc23daf"), n = n(), popScopeId(), n), "_withScopeId$7");
const _hoisted_1$l = ["src", "data-test"];
const _hoisted_2$f = ["src"];
const _hoisted_3$8 = {
  key: 1,
  class: "broken-image-placeholder"
};
const _hoisted_4$4 = /* @__PURE__ */ _withScopeId$7(() => /* @__PURE__ */ createBaseVNode("i", { class: "pi pi-image" }, null, -1));
const _sfc_main$g = /* @__PURE__ */ defineComponent({
  __name: "ComfyImage",
  props: {
    src: {},
    class: {},
    contain: { type: Boolean, default: false }
  },
  setup(__props) {
    const props = __props;
    const imageBroken = ref(false);
    const handleImageError = /* @__PURE__ */ __name((e) => {
      imageBroken.value = true;
    }, "handleImageError");
    const classArray = computed(() => {
      if (Array.isArray(props.class)) {
        return props.class;
      } else if (typeof props.class === "string") {
        return props.class.split(" ");
      } else if (typeof props.class === "object") {
        return Object.keys(props.class).filter((key) => props.class[key]);
      }
      return [];
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        !imageBroken.value ? (openBlock(), createElementBlock("span", {
          key: 0,
          class: normalizeClass(["comfy-image-wrap", [{ contain: _ctx.contain }]])
        }, [
          _ctx.contain ? (openBlock(), createElementBlock("img", {
            key: 0,
            src: _ctx.src,
            onError: handleImageError,
            "data-test": _ctx.src,
            class: "comfy-image-blur",
            style: normalizeStyle({ "background-image": `url(${_ctx.src})` })
          }, null, 44, _hoisted_1$l)) : createCommentVNode("", true),
          createBaseVNode("img", {
            src: _ctx.src,
            onError: handleImageError,
            class: normalizeClass(["comfy-image-main", [...classArray.value]])
          }, null, 42, _hoisted_2$f)
        ], 2)) : createCommentVNode("", true),
        imageBroken.value ? (openBlock(), createElementBlock("div", _hoisted_3$8, [
          _hoisted_4$4,
          createBaseVNode("span", null, toDisplayString$1(_ctx.$t("imageFailedToLoad")), 1)
        ])) : createCommentVNode("", true)
      ], 64);
    };
  }
});
const ComfyImage = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["__scopeId", "data-v-9bc23daf"]]);
const _withScopeId$6 = /* @__PURE__ */ __name((n) => (pushScopeId("data-v-d9c060ae"), n = n(), popScopeId(), n), "_withScopeId$6");
const _hoisted_1$k = { class: "image-preview-mask" };
const _hoisted_2$e = {
  key: 1,
  class: "task-result-preview"
};
const _hoisted_3$7 = /* @__PURE__ */ _withScopeId$6(() => /* @__PURE__ */ createBaseVNode("i", { class: "pi pi-file" }, null, -1));
const _sfc_main$f = /* @__PURE__ */ defineComponent({
  __name: "ResultItem",
  props: {
    result: {}
  },
  emits: ["preview"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const resultContainer = ref(null);
    const settingStore = useSettingStore();
    const imageFit = computed(
      () => settingStore.get("Comfy.Queue.ImageFit")
    );
    onMounted(() => {
      if (props.result.mediaType === "images") {
        resultContainer.value?.querySelectorAll("img").forEach((img) => {
          img.draggable = true;
        });
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "result-container",
        ref_key: "resultContainer",
        ref: resultContainer
      }, [
        _ctx.result.mediaType === "images" || _ctx.result.mediaType === "gifs" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createVNode(ComfyImage, {
            src: _ctx.result.url,
            class: "task-output-image",
            contain: imageFit.value === "contain"
          }, null, 8, ["src", "contain"]),
          createBaseVNode("div", _hoisted_1$k, [
            createVNode(unref(script$J), {
              icon: "pi pi-eye",
              severity: "secondary",
              onClick: _cache[0] || (_cache[0] = ($event) => emit2("preview", _ctx.result)),
              rounded: ""
            })
          ])
        ], 64)) : (openBlock(), createElementBlock("div", _hoisted_2$e, [
          _hoisted_3$7,
          createBaseVNode("span", null, toDisplayString$1(_ctx.result.mediaType), 1)
        ]))
      ], 512);
    };
  }
});
const ResultItem = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["__scopeId", "data-v-d9c060ae"]]);
var TaskItemDisplayStatus = /* @__PURE__ */ ((TaskItemDisplayStatus2) => {
  TaskItemDisplayStatus2["Running"] = "Running";
  TaskItemDisplayStatus2["Pending"] = "Pending";
  TaskItemDisplayStatus2["Completed"] = "Completed";
  TaskItemDisplayStatus2["Failed"] = "Failed";
  TaskItemDisplayStatus2["Cancelled"] = "Cancelled";
  return TaskItemDisplayStatus2;
})(TaskItemDisplayStatus || {});
class ResultItemImpl {
  static {
    __name(this, "ResultItemImpl");
  }
  filename;
  subfolder;
  type;
  nodeId;
  // 'audio' | 'images' | ...
  mediaType;
  get url() {
    return api.apiURL(`/view?filename=${encodeURIComponent(this.filename)}&type=${this.type}&
					subfolder=${encodeURIComponent(this.subfolder || "")}`);
  }
  get urlWithTimestamp() {
    return `${this.url}&t=${+/* @__PURE__ */ new Date()}`;
  }
  get supportsPreview() {
    return ["images", "gifs"].includes(this.mediaType);
  }
}
class TaskItemImpl {
  static {
    __name(this, "TaskItemImpl");
  }
  taskType;
  prompt;
  status;
  outputs;
  flatOutputs;
  constructor(taskType, prompt2, status, outputs, flatOutputs) {
    this.taskType = taskType;
    this.prompt = prompt2;
    this.status = status;
    this.outputs = outputs;
    this.flatOutputs = flatOutputs ?? this.calculateFlatOutputs();
  }
  calculateFlatOutputs() {
    if (!this.outputs) {
      return [];
    }
    return Object.entries(this.outputs).flatMap(
      ([nodeId, nodeOutputs]) => Object.entries(nodeOutputs).flatMap(
        ([mediaType, items2]) => items2.map(
          (item2) => plainToClass(ResultItemImpl, {
            ...item2,
            nodeId,
            mediaType
          })
        )
      )
    );
  }
  get previewOutput() {
    return this.flatOutputs.find(
      // Prefer saved media files over the temp previews
      (output) => output.type === "output" && output.supportsPreview
    ) ?? this.flatOutputs.find((output) => output.supportsPreview);
  }
  get apiTaskType() {
    switch (this.taskType) {
      case "Running":
      case "Pending":
        return "queue";
      case "History":
        return "history";
    }
  }
  get key() {
    return this.promptId + this.displayStatus;
  }
  get queueIndex() {
    return this.prompt[0];
  }
  get promptId() {
    return this.prompt[1];
  }
  get promptInputs() {
    return this.prompt[2];
  }
  get extraData() {
    return this.prompt[3];
  }
  get outputsToExecute() {
    return this.prompt[4];
  }
  get extraPngInfo() {
    return this.extraData.extra_pnginfo;
  }
  get clientId() {
    return this.extraData.client_id;
  }
  get workflow() {
    return this.extraPngInfo.workflow;
  }
  get messages() {
    return this.status?.messages || [];
  }
  get interrupted() {
    return _.some(
      this.messages,
      (message3) => message3[0] === "execution_interrupted"
    );
  }
  get isHistory() {
    return this.taskType === "History";
  }
  get isRunning() {
    return this.taskType === "Running";
  }
  get displayStatus() {
    switch (this.taskType) {
      case "Running":
        return "Running";
      case "Pending":
        return "Pending";
      case "History":
        if (this.interrupted) return "Cancelled";
        switch (this.status.status_str) {
          case "success":
            return "Completed";
          case "error":
            return "Failed";
        }
    }
  }
  get executionStartTimestamp() {
    const message3 = this.messages.find(
      (message22) => message22[0] === "execution_start"
    );
    return message3 ? message3[1].timestamp : void 0;
  }
  get executionEndTimestamp() {
    const messages2 = this.messages.filter(
      (message3) => [
        "execution_success",
        "execution_interrupted",
        "execution_error"
      ].includes(message3[0])
    );
    if (!messages2.length) {
      return void 0;
    }
    return _.max(messages2.map((message3) => message3[1].timestamp));
  }
  get executionTime() {
    if (!this.executionStartTimestamp || !this.executionEndTimestamp) {
      return void 0;
    }
    return this.executionEndTimestamp - this.executionStartTimestamp;
  }
  get executionTimeInSeconds() {
    return this.executionTime !== void 0 ? this.executionTime / 1e3 : void 0;
  }
  async loadWorkflow() {
    await app$1.loadGraphData(toRaw(this.workflow));
    if (this.outputs) {
      app$1.nodeOutputs = toRaw(this.outputs);
    }
  }
  flatten() {
    if (this.displayStatus !== "Completed") {
      return [this];
    }
    return this.flatOutputs.map(
      (output, i2) => new TaskItemImpl(
        this.taskType,
        [
          this.queueIndex,
          `${this.promptId}-${i2}`,
          this.promptInputs,
          this.extraData,
          this.outputsToExecute
        ],
        this.status,
        {
          [output.nodeId]: {
            [output.mediaType]: [output]
          }
        },
        [output]
      )
    );
  }
}
const useQueueStore = defineStore("queue", {
  state: /* @__PURE__ */ __name(() => ({
    runningTasks: [],
    pendingTasks: [],
    historyTasks: [],
    maxHistoryItems: 64,
    isLoading: false
  }), "state"),
  getters: {
    tasks(state) {
      return [
        ...state.pendingTasks,
        ...state.runningTasks,
        ...state.historyTasks
      ];
    },
    flatTasks() {
      return this.tasks.flatMap((task) => task.flatten());
    },
    lastHistoryQueueIndex(state) {
      return state.historyTasks.length ? state.historyTasks[0].queueIndex : -1;
    }
  },
  actions: {
    // Fetch the queue data from the API
    async update() {
      this.isLoading = true;
      try {
        const [queue2, history] = await Promise.all([
          api.getQueue(),
          api.getHistory(this.maxHistoryItems)
        ]);
        const toClassAll = /* @__PURE__ */ __name((tasks) => tasks.map(
          (task) => new TaskItemImpl(
            task.taskType,
            task.prompt,
            task["status"],
            task["outputs"] || {}
          )
        ).sort((a, b) => b.queueIndex - a.queueIndex), "toClassAll");
        this.runningTasks = toClassAll(queue2.Running);
        this.pendingTasks = toClassAll(queue2.Pending);
        const allIndex = new Set(
          history.History.map((item2) => item2.prompt[0])
        );
        const newHistoryItems = toClassAll(
          history.History.filter(
            (item2) => item2.prompt[0] > this.lastHistoryQueueIndex
          )
        );
        const existingHistoryItems = this.historyTasks.filter(
          (item2) => allIndex.has(item2.queueIndex)
        );
        this.historyTasks = [...newHistoryItems, ...existingHistoryItems].slice(0, this.maxHistoryItems).sort((a, b) => b.queueIndex - a.queueIndex);
      } finally {
        this.isLoading = false;
      }
    },
    async clear() {
      await Promise.all(
        ["queue", "history"].map((type) => api.clearItems(type))
      );
      await this.update();
    },
    async delete(task) {
      await api.deleteItem(task.apiTaskType, task.promptId);
      await this.update();
    }
  }
});
const useQueuePendingTaskCountStore = defineStore(
  "queuePendingTaskCount",
  {
    state: /* @__PURE__ */ __name(() => ({
      count: 0
    }), "state"),
    actions: {
      update(e) {
        this.count = e.detail?.exec_info?.queue_remaining || 0;
      }
    }
  }
);
const _withScopeId$5 = /* @__PURE__ */ __name((n) => (pushScopeId("data-v-11ef4cfe"), n = n(), popScopeId(), n), "_withScopeId$5");
const _hoisted_1$j = { class: "task-result-preview" };
const _hoisted_2$d = {
  key: 1,
  class: "pi pi-spin pi-spinner"
};
const _hoisted_3$6 = { key: 2 };
const _hoisted_4$3 = {
  key: 3,
  class: "pi pi-exclamation-triangle"
};
const _hoisted_5$2 = {
  key: 4,
  class: "pi pi-exclamation-circle"
};
const _hoisted_6$1 = { class: "task-item-details" };
const _hoisted_7$1 = { class: "tag-wrapper status-tag-group" };
const _hoisted_8 = ["innerHTML"];
const _hoisted_9 = {
  key: 0,
  class: "task-time"
};
const _hoisted_10 = {
  key: 1,
  class: "task-prompt-id"
};
const _hoisted_11 = { class: "tag-wrapper" };
const _hoisted_12 = { style: { "font-weight": "bold" } };
const _sfc_main$e = /* @__PURE__ */ defineComponent({
  __name: "TaskItem",
  props: {
    task: {},
    isFlatTask: { type: Boolean }
  },
  emits: ["contextmenu", "preview", "task-output-length-clicked"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const flatOutputs = props.task.flatOutputs;
    const coverResult = flatOutputs.length ? props.task.previewOutput || flatOutputs[0] : null;
    const node3 = flatOutputs.length ? props.task.workflow.nodes.find(
      (n) => n.id == coverResult.nodeId
    ) ?? null : null;
    const emit2 = __emit;
    const handleContextMenu = /* @__PURE__ */ __name((e) => {
      emit2("contextmenu", { task: props.task, event: e, node: node3 });
    }, "handleContextMenu");
    const handlePreview = /* @__PURE__ */ __name(() => {
      emit2("preview", props.task);
    }, "handlePreview");
    const handleOutputLengthClick = /* @__PURE__ */ __name(() => {
      emit2("task-output-length-clicked", props.task);
    }, "handleOutputLengthClick");
    const taskTagSeverity = /* @__PURE__ */ __name((status) => {
      switch (status) {
        case TaskItemDisplayStatus.Pending:
          return "secondary";
        case TaskItemDisplayStatus.Running:
          return "info";
        case TaskItemDisplayStatus.Completed:
          return "success";
        case TaskItemDisplayStatus.Failed:
          return "danger";
        case TaskItemDisplayStatus.Cancelled:
          return "warn";
      }
    }, "taskTagSeverity");
    const taskStatusText = /* @__PURE__ */ __name((status) => {
      switch (status) {
        case TaskItemDisplayStatus.Pending:
          return "Pending";
        case TaskItemDisplayStatus.Running:
          return "Running";
        case TaskItemDisplayStatus.Completed:
          return '<i class="pi pi-check" style="font-weight: bold"></i>';
        case TaskItemDisplayStatus.Failed:
          return "Failed";
        case TaskItemDisplayStatus.Cancelled:
          return "Cancelled";
      }
    }, "taskStatusText");
    const formatTime = /* @__PURE__ */ __name((time) => {
      if (time === void 0) {
        return "";
      }
      return `${time.toFixed(2)}s`;
    }, "formatTime");
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "task-item",
        onContextmenu: handleContextMenu
      }, [
        createBaseVNode("div", _hoisted_1$j, [
          _ctx.task.displayStatus === unref(TaskItemDisplayStatus).Completed ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            unref(flatOutputs).length ? (openBlock(), createBlock(ResultItem, {
              key: 0,
              result: unref(coverResult),
              onPreview: handlePreview
            }, null, 8, ["result"])) : createCommentVNode("", true)
          ], 64)) : _ctx.task.displayStatus === unref(TaskItemDisplayStatus).Running ? (openBlock(), createElementBlock("i", _hoisted_2$d)) : _ctx.task.displayStatus === unref(TaskItemDisplayStatus).Pending ? (openBlock(), createElementBlock("span", _hoisted_3$6, "...")) : _ctx.task.displayStatus === unref(TaskItemDisplayStatus).Cancelled ? (openBlock(), createElementBlock("i", _hoisted_4$3)) : _ctx.task.displayStatus === unref(TaskItemDisplayStatus).Failed ? (openBlock(), createElementBlock("i", _hoisted_5$2)) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_6$1, [
          createBaseVNode("div", _hoisted_7$1, [
            _ctx.isFlatTask && _ctx.task.isHistory ? (openBlock(), createBlock(unref(script$w), {
              key: 0,
              class: "node-name-tag"
            }, {
              default: withCtx(() => [
                createVNode(unref(script$J), {
                  class: "task-node-link",
                  label: `${unref(node3)?.type} (#${unref(node3)?.id})`,
                  link: "",
                  size: "small",
                  onClick: _cache[0] || (_cache[0] = ($event) => unref(app$1).goToNode(unref(node3)?.id))
                }, null, 8, ["label"])
              ]),
              _: 1
            })) : createCommentVNode("", true),
            createVNode(unref(script$w), {
              severity: taskTagSeverity(_ctx.task.displayStatus)
            }, {
              default: withCtx(() => [
                createBaseVNode("span", {
                  innerHTML: taskStatusText(_ctx.task.displayStatus)
                }, null, 8, _hoisted_8),
                _ctx.task.isHistory ? (openBlock(), createElementBlock("span", _hoisted_9, toDisplayString$1(formatTime(_ctx.task.executionTimeInSeconds)), 1)) : createCommentVNode("", true),
                _ctx.isFlatTask ? (openBlock(), createElementBlock("span", _hoisted_10, toDisplayString$1(_ctx.task.promptId.split("-")[0]), 1)) : createCommentVNode("", true)
              ]),
              _: 1
            }, 8, ["severity"])
          ]),
          createBaseVNode("div", _hoisted_11, [
            _ctx.task.isHistory && unref(flatOutputs).length > 1 ? (openBlock(), createBlock(unref(script$J), {
              key: 0,
              outlined: "",
              onClick: handleOutputLengthClick
            }, {
              default: withCtx(() => [
                createBaseVNode("span", _hoisted_12, toDisplayString$1(unref(flatOutputs).length), 1)
              ]),
              _: 1
            })) : createCommentVNode("", true)
          ])
        ])
      ], 32);
    };
  }
});
const TaskItem = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["__scopeId", "data-v-11ef4cfe"]]);
var theme$6 = /* @__PURE__ */ __name(function theme31(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-galleria {\n    overflow: hidden;\n    border-style: solid;\n    border-width: ".concat(dt3("galleria.border.width"), ";\n    border-color: ").concat(dt3("galleria.border.color"), ";\n    border-radius: ").concat(dt3("galleria.border.radius"), ";\n}\n\n.p-galleria-content {\n    display: flex;\n    flex-direction: column;\n}\n\n.p-galleria-items-container {\n    display: flex;\n    flex-direction: column;\n    position: relative;\n}\n\n.p-galleria-items {\n    position: relative;\n    display: flex;\n    height: 100%;\n}\n\n.p-galleria-nav-button {\n    position: absolute;\n    top: 50%;\n    display: inline-flex;\n    justify-content: center;\n    align-items: center;\n    overflow: hidden;\n    background: ").concat(dt3("galleria.nav.button.background"), ";\n    color: ").concat(dt3("galleria.nav.button.color"), ";\n    width: ").concat(dt3("galleria.nav.button.size"), ";\n    height: ").concat(dt3("galleria.nav.button.size"), ";\n    transition: background ").concat(dt3("galleria.transition.duration"), ", color ").concat(dt3("galleria.transition.duration"), ", outline-color ").concat(dt3("galleria.transition.duration"), ", box-shadow ").concat(dt3("galleria.transition.duration"), ";\n    margin: calc(-1 * calc(").concat(dt3("galleria.nav.button.size"), ") / 2) ").concat(dt3("galleria.nav.button.gutter"), " 0 ").concat(dt3("galleria.nav.button.gutter"), ";\n    padding: 0;\n    user-select: none;\n    border: 0 none;\n    cursor: pointer;\n    outline-color: transparent;\n}\n\n.p-galleria-nav-button:not(.p-disabled):hover {\n    background: ").concat(dt3("galleria.nav.button.hover.background"), ";\n    color: ").concat(dt3("galleria.nav.button.hover.color"), ";\n}\n\n.p-galleria-nav-button:not(.p-disabled):focus-visible {\n    box-shadow: ").concat(dt3("galleria.nav.button.focus.ring.shadow"), ";\n    outline: ").concat(dt3("galleria.nav.button.focus.ring.width"), " ").concat(dt3("galleria.nav.button.focus.ring.style"), " ").concat(dt3("galleria.nav.button.focus.ring.color"), ";\n    outline-offset: ").concat(dt3("galleria.nav.button.focus.ring.offset"), ";\n}\n\n.p-galleria-next-icon,\n.p-galleria-prev-icon {\n    font-size: ").concat(dt3("galleria.nav.icon.size"), ";\n    width: ").concat(dt3("galleria.nav.icon.size"), ";\n    height: ").concat(dt3("galleria.nav.icon.size"), ";\n}\n\n.p-galleria-prev-button {\n    border-radius: ").concat(dt3("galleria.nav.button.prev.border.radius"), ";\n    left: 0;\n}\n\n.p-galleria-next-button {\n    border-radius: ").concat(dt3("galleria.nav.button.next.border.radius"), ";\n    right: 0;\n}\n\n.p-galleria-item {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    height: 100%;\n    width: 100%;\n}\n\n.p-galleria-hover-navigators .p-galleria-nav-button {\n    pointer-events: none;\n    opacity: 0;\n    transition: opacity ").concat(dt3("galleria.transition.duration"), " ease-in-out;\n}\n\n.p-galleria-hover-navigators .p-galleria-items-container:hover .p-galleria-nav-button {\n    pointer-events: all;\n    opacity: 1;\n}\n\n.p-galleria-hover-navigators .p-galleria-items-container:hover .p-galleria-nav-button.p-disabled {\n    pointer-events: none;\n}\n\n.p-galleria-caption {\n    position: absolute;\n    bottom: 0;\n    left: 0;\n    width: 100%;\n    background: ").concat(dt3("galleria.caption.background"), ";\n    color: ").concat(dt3("galleria.caption.color"), ";\n    padding: ").concat(dt3("galleria.caption.padding"), ";\n}\n\n.p-galleria-thumbnails {\n    display: flex;\n    flex-direction: column;\n    overflow: auto;\n    flex-shrink: 0;\n}\n\n.p-galleria-thumbnail-nav-button {\n    align-self: center;\n    flex: 0 0 auto;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    overflow: hidden;\n    position: relative;\n    margin: 0 ").concat(dt3("galleria.thumbnail.nav.button.gutter"), ";\n    padding: 0;\n    border: none;\n    user-select: none;\n    cursor: pointer;\n    background: transparent;\n    color: ").concat(dt3("galleria.thumbnail.nav.button.color"), ";\n    width: ").concat(dt3("galleria.thumbnail.nav.button.size"), ";\n    height: ").concat(dt3("galleria.thumbnail.nav.button.size"), ";\n    transition: background ").concat(dt3("galleria.transition.duration"), ", color ").concat(dt3("galleria.transition.duration"), ", outline-color ").concat(dt3("galleria.transition.duration"), ";\n    outline-color: transparent;\n    border-radius: ").concat(dt3("galleria.thumbnail.nav.button.border.radius"), ";\n}\n\n.p-galleria-thumbnail-nav-button:hover {\n    background: ").concat(dt3("galleria.thumbnail.nav.button.hover.background"), ";\n    color: ").concat(dt3("galleria.thumbnail.nav.button.hover.color"), ";\n}\n\n.p-galleria-thumbnail-nav-button:focus-visible {\n    box-shadow: ").concat(dt3("galleria.thumbnail.nav.button.focus.ring.shadow"), ";\n    outline: ").concat(dt3("galleria.thumbnail.nav.button.focus.ring.width"), " ").concat(dt3("galleria.thumbnail.nav.button.focus.ring.style"), " ").concat(dt3("galleria.thumbnail.nav.button.focus.ring.color"), ";\n    outline-offset: ").concat(dt3("galleria.thumbnail.nav.button.focus.ring.offset"), ";\n}\n\n.p-galleria-thumbnail-nav-button .p-galleria-thumbnail-next-icon,\n.p-galleria-thumbnail-nav-button .p-galleria-thumbnail-prev-icon {\n    font-size: ").concat(dt3("galleria.thumbnail.nav.button.icon.size"), ";\n    width: ").concat(dt3("galleria.thumbnail.nav.button.icon.size"), ";\n    height: ").concat(dt3("galleria.thumbnail.nav.button.icon.size"), ";\n}\n\n.p-galleria-thumbnails-content {\n    display: flex;\n    flex-direction: row;\n    background: ").concat(dt3("galleria.thumbnails.content.background"), ";\n    padding: ").concat(dt3("galleria.thumbnails.content.padding"), ";\n}\n\n.p-galleria-thumbnails-viewport {\n    overflow: hidden;\n    width: 100%;\n}\n\n.p-galleria-thumbnail-items {\n    display: flex;\n}\n\n.p-galleria-thumbnail-item {\n    overflow: auto;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    cursor: pointer;\n    opacity: 0.5;\n}\n\n.p-galleria-thumbnail {\n    outline-color: transparent;\n}\n\n.p-galleria-thumbnail-item:hover {\n    opacity: 1;\n    transition: opacity 0.3s;\n}\n\n.p-galleria-thumbnail-item-current {\n    opacity: 1;\n}\n\n.p-galleria-thumbnails-left .p-galleria-content,\n.p-galleria-thumbnails-right .p-galleria-content {\n    flex-direction: row;\n}\n\n.p-galleria-thumbnails-left .p-galleria-items-container,\n.p-galleria-thumbnails-right .p-galleria-items-container {\n    flex-direction: row;\n}\n\n.p-galleria-thumbnails-left .p-galleria-items-container,\n.p-galleria-thumbnails-top .p-galleria-items-container {\n    order: 2;\n}\n\n.p-galleria-thumbnails-left .p-galleria-thumbnails,\n.p-galleria-thumbnails-top .p-galleria-thumbnails {\n    order: 1;\n}\n\n.p-galleria-thumbnails-left .p-galleria-thumbnails-content,\n.p-galleria-thumbnails-right .p-galleria-thumbnails-content {\n    flex-direction: column;\n    flex-grow: 1;\n}\n\n.p-galleria-thumbnails-left .p-galleria-thumbnail-items,\n.p-galleria-thumbnails-right .p-galleria-thumbnail-items {\n    flex-direction: column;\n    height: 100%;\n}\n\n.p-galleria-indicator-list {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    padding: ").concat(dt3("galleria.indicator.list.padding"), ";\n    gap: ").concat(dt3("galleria.indicator.list.gap"), ";\n    margin: 0;\n    list-style: none;\n}\n\n.p-galleria-indicator-button {\n    display: inline-flex;\n    align-items: center;\n    background: ").concat(dt3("galleria.indicator.button.background"), ";\n    width: ").concat(dt3("galleria.indicator.button.width"), ";\n    height: ").concat(dt3("galleria.indicator.button.height"), ";\n    transition: background ").concat(dt3("galleria.transition.duration"), ", color ").concat(dt3("galleria.transition.duration"), ", outline-color ").concat(dt3("galleria.transition.duration"), ", box-shadow ").concat(dt3("galleria.transition.duration"), ";\n    outline-color: transparent;\n    border-radius: ").concat(dt3("galleria.indicator.button.border.radius"), ";\n    margin: 0;\n    padding: 0;\n    border: none;\n    user-select: none;\n    cursor: pointer;\n}\n\n.p-galleria-indicator-button:hover {\n    background: ").concat(dt3("galleria.indicator.button.hover.background"), ";\n}\n\n.p-galleria-indicator-button:focus-visible {\n    box-shadow: ").concat(dt3("galleria.indicator.button.focus.ring.shadow"), ";\n    outline: ").concat(dt3("galleria.indicator.button.focus.ring.width"), " ").concat(dt3("galleria.indicator.button.focus.ring.style"), " ").concat(dt3("galleria.indicator.button.focus.ring.color"), ";\n    outline-offset: ").concat(dt3("galleria.indicator.button.focus.ring.offset"), ";\n}\n\n.p-galleria-indicator-active .p-galleria-indicator-button {\n    background: ").concat(dt3("galleria.indicator.button.active.background"), ";\n}\n\n.p-galleria-indicators-left .p-galleria-items-container,\n.p-galleria-indicators-right .p-galleria-items-container {\n    flex-direction: row;\n    align-items: center;\n}\n\n.p-galleria-indicators-left .p-galleria-items,\n.p-galleria-indicators-top .p-galleria-items {\n    order: 2;\n}\n\n.p-galleria-indicators-left .p-galleria-indicator-list,\n.p-galleria-indicators-top .p-galleria-indicator-list {\n    order: 1;\n}\n\n.p-galleria-indicators-left .p-galleria-indicator-list,\n.p-galleria-indicators-right .p-galleria-indicator-list {\n    flex-direction: column;\n}\n\n.p-galleria-inset-indicators .p-galleria-indicator-list {\n    position: absolute;\n    display: flex;\n    z-index: 1;\n    background: ").concat(dt3("galleria.inset.indicator.list.background"), ";\n}\n\n.p-galleria-inset-indicators .p-galleria-indicator-button {\n    background: ").concat(dt3("galleria.inset.indicator.button.background"), ";\n}\n\n.p-galleria-inset-indicators .p-galleria-indicator-button:hover {\n    background: ").concat(dt3("galleria.inset.indicator.button.hover.background"), ";\n}\n\n.p-galleria-inset-indicators .p-galleria-indicator-active .p-galleria-indicator-button {\n    background: ").concat(dt3("galleria.inset.indicator.button.active.background"), ";\n}\n\n.p-galleria-inset-indicators.p-galleria-indicators-top .p-galleria-indicator-list {\n    top: 0;\n    left: 0;\n    width: 100%;\n    align-items: flex-start;\n}\n\n.p-galleria-inset-indicators.p-galleria-indicators-right .p-galleria-indicator-list {\n    right: 0;\n    top: 0;\n    height: 100%;\n    align-items: flex-end;\n}\n\n.p-galleria-inset-indicators.p-galleria-indicators-bottom .p-galleria-indicator-list {\n    bottom: 0;\n    left: 0;\n    width: 100%;\n    align-items: flex-end;\n}\n\n.p-galleria-inset-indicators.p-galleria-indicators-left .p-galleria-indicator-list {\n    left: 0;\n    top: 0;\n    height: 100%;\n    align-items: flex-start;\n}\n\n.p-galleria-mask {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.p-galleria-close-button {\n    position: absolute;\n    top: 0;\n    right: 0;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    overflow: hidden;\n    margin: ").concat(dt3("galleria.close.button.gutter"), ";\n    background: ").concat(dt3("galleria.close.button.background"), ";\n    color: ").concat(dt3("galleria.close.button.color"), ";\n    width: ").concat(dt3("galleria.close.button.size"), ";\n    height: ").concat(dt3("galleria.close.button.size"), ";\n    padding: 0;\n    border: none;\n    user-select: none;\n    cursor: pointer;\n    border-radius: ").concat(dt3("galleria.close.button.border.radius"), ";\n    outline-color: transparent;\n    transition: background ").concat(dt3("galleria.transition.duration"), ", color ").concat(dt3("galleria.transition.duration"), ", outline-color ").concat(dt3("galleria.transition.duration"), ";\n}\n\n.p-galleria-close-icon {\n    font-size: ").concat(dt3("galleria.close.button.icon.size"), ";\n    width: ").concat(dt3("galleria.close.button.icon.size"), ";\n    height: ").concat(dt3("galleria.close.button.icon.size"), ";\n}\n\n.p-galleria-close-button:hover {\n    background: ").concat(dt3("galleria.close.button.hover.background"), ";\n    color: ").concat(dt3("galleria.close.button.hover.color"), ";\n}\n\n.p-galleria-close-button:focus-visible {\n    box-shadow: ").concat(dt3("galleria.close.button.focus.ring.shadow"), ";\n    outline: ").concat(dt3("galleria.close.button.focus.ring.width"), " ").concat(dt3("galleria.close.button.focus.ring.style"), " ").concat(dt3("galleria.close.button.focus.ring.color"), ";\n    outline-offset: ").concat(dt3("galleria.close.button.focus.ring.offset"), ";\n}\n\n.p-galleria-mask .p-galleria-nav-button {\n    position: fixed;\n    top: 50%;\n}\n\n.p-galleria-enter-active {\n    transition: all 150ms cubic-bezier(0, 0, 0.2, 1);\n}\n\n.p-galleria-leave-active {\n    transition: all 150ms cubic-bezier(0.4, 0, 0.2, 1);\n}\n\n.p-galleria-enter-from,\n.p-galleria-leave-to {\n    opacity: 0;\n    transform: scale(0.7);\n}\n\n.p-galleria-enter-active .p-galleria-nav-button {\n    opacity: 0;\n}\n\n.p-items-hidden .p-galleria-thumbnail-item {\n    visibility: hidden;\n}\n\n.p-items-hidden .p-galleria-thumbnail-item.p-galleria-thumbnail-item-active {\n    visibility: visible;\n}\n");
}, "theme");
var classes$6 = {
  mask: "p-galleria-mask p-overlay-mask p-overlay-mask-enter",
  root: /* @__PURE__ */ __name(function root21(_ref2) {
    var instance = _ref2.instance;
    var thumbnailsPosClass = instance.$attrs.showThumbnails && instance.getPositionClass("p-galleria-thumbnails", instance.$attrs.thumbnailsPosition);
    var indicatorPosClass = instance.$attrs.showIndicators && instance.getPositionClass("p-galleria-indicators", instance.$attrs.indicatorsPosition);
    return ["p-galleria p-component", {
      "p-galleria-fullscreen": instance.$attrs.fullScreen,
      "p-galleria-inset-indicators": instance.$attrs.showIndicatorsOnItem,
      "p-galleria-hover-navigators": instance.$attrs.showItemNavigatorsOnHover && !instance.$attrs.fullScreen
    }, thumbnailsPosClass, indicatorPosClass];
  }, "root"),
  closeButton: "p-galleria-close-button",
  closeIcon: "p-galleria-close-icon",
  header: "p-galleria-header",
  content: "p-galleria-content",
  footer: "p-galleria-footer",
  itemsContainer: "p-galleria-items-container",
  items: "p-galleria-items",
  previousItemButton: /* @__PURE__ */ __name(function previousItemButton(_ref3) {
    var instance = _ref3.instance;
    return ["p-galleria-prev-button p-galleria-nav-button", {
      "p-disabled": instance.isNavBackwardDisabled()
    }];
  }, "previousItemButton"),
  previousItemIcon: "p-galleria-prev-icon",
  item: "p-galleria-item",
  nextItemButton: /* @__PURE__ */ __name(function nextItemButton(_ref4) {
    var instance = _ref4.instance;
    return ["p-galleria-next-button p-galleria-nav-button", {
      "p-disabled": instance.isNavForwardDisabled()
    }];
  }, "nextItemButton"),
  nextItemIcon: "p-galleria-next-icon",
  caption: "p-galleria-caption",
  indicatorList: "p-galleria-indicator-list",
  indicator: /* @__PURE__ */ __name(function indicator(_ref5) {
    var instance = _ref5.instance, index2 = _ref5.index;
    return ["p-galleria-indicator", {
      "p-galleria-indicator-active": instance.isIndicatorItemActive(index2)
    }];
  }, "indicator"),
  indicatorButton: "p-galleria-indicator-button",
  thumbnails: "p-galleria-thumbnails",
  thumbnailContent: "p-galleria-thumbnails-content",
  previousThumbnailButton: /* @__PURE__ */ __name(function previousThumbnailButton(_ref6) {
    var instance = _ref6.instance;
    return ["p-galleria-thumbnail-prev-button p-galleria-thumbnail-nav-button", {
      "p-disabled": instance.isNavBackwardDisabled()
    }];
  }, "previousThumbnailButton"),
  previousThumbnailIcon: "p-galleria-thumbnail-prev-icon",
  thumbnailsViewport: "p-galleria-thumbnails-viewport",
  thumbnailItems: "p-galleria-thumbnail-items",
  thumbnailItem: /* @__PURE__ */ __name(function thumbnailItem(_ref7) {
    var instance = _ref7.instance, index2 = _ref7.index, activeIndex2 = _ref7.activeIndex;
    return ["p-galleria-thumbnail-item", {
      "p-galleria-thumbnail-item-current": activeIndex2 === index2,
      "p-galleria-thumbnail-item-active": instance.isItemActive(index2),
      "p-galleria-thumbnail-item-start": instance.firstItemAciveIndex() === index2,
      "p-galleria-thumbnail-item-end": instance.lastItemActiveIndex() === index2
    }];
  }, "thumbnailItem"),
  thumbnail: "p-galleria-thumbnail",
  nextThumbnailButton: /* @__PURE__ */ __name(function nextThumbnailButton(_ref8) {
    var instance = _ref8.instance;
    return ["p-galleria-thumbnail-next-button  p-galleria-thumbnail-nav-button", {
      "p-disabled": instance.isNavForwardDisabled()
    }];
  }, "nextThumbnailButton"),
  nextThumbnailIcon: "p-galleria-thumbnail-next-icon"
};
var GalleriaStyle = BaseStyle.extend({
  name: "galleria",
  theme: theme$6,
  classes: classes$6
});
var script$e = {
  name: "ChevronLeftIcon",
  "extends": script$U
};
var _hoisted_1$i = /* @__PURE__ */ createBaseVNode("path", {
  d: "M9.61296 13C9.50997 13.0005 9.40792 12.9804 9.3128 12.9409C9.21767 12.9014 9.13139 12.8433 9.05902 12.7701L3.83313 7.54416C3.68634 7.39718 3.60388 7.19795 3.60388 6.99022C3.60388 6.78249 3.68634 6.58325 3.83313 6.43628L9.05902 1.21039C9.20762 1.07192 9.40416 0.996539 9.60724 1.00012C9.81032 1.00371 10.0041 1.08597 10.1477 1.22959C10.2913 1.37322 10.3736 1.56698 10.3772 1.77005C10.3808 1.97313 10.3054 2.16968 10.1669 2.31827L5.49496 6.99022L10.1669 11.6622C10.3137 11.8091 10.3962 12.0084 10.3962 12.2161C10.3962 12.4238 10.3137 12.6231 10.1669 12.7701C10.0945 12.8433 10.0083 12.9014 9.91313 12.9409C9.81801 12.9804 9.71596 13.0005 9.61296 13Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$c = [_hoisted_1$i];
function render$d(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$c, 16);
}
__name(render$d, "render$d");
script$e.render = render$d;
var script$d = {
  name: "ChevronRightIcon",
  "extends": script$U
};
var _hoisted_1$h = /* @__PURE__ */ createBaseVNode("path", {
  d: "M4.38708 13C4.28408 13.0005 4.18203 12.9804 4.08691 12.9409C3.99178 12.9014 3.9055 12.8433 3.83313 12.7701C3.68634 12.6231 3.60388 12.4238 3.60388 12.2161C3.60388 12.0084 3.68634 11.8091 3.83313 11.6622L8.50507 6.99022L3.83313 2.31827C3.69467 2.16968 3.61928 1.97313 3.62287 1.77005C3.62645 1.56698 3.70872 1.37322 3.85234 1.22959C3.99596 1.08597 4.18972 1.00371 4.3928 1.00012C4.59588 0.996539 4.79242 1.07192 4.94102 1.21039L10.1669 6.43628C10.3137 6.58325 10.3962 6.78249 10.3962 6.99022C10.3962 7.19795 10.3137 7.39718 10.1669 7.54416L4.94102 12.7701C4.86865 12.8433 4.78237 12.9014 4.68724 12.9409C4.59212 12.9804 4.49007 13.0005 4.38708 13Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$b = [_hoisted_1$h];
function render$c(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$b, 16);
}
__name(render$c, "render$c");
script$d.render = render$c;
var script$c = {
  name: "ChevronUpIcon",
  "extends": script$U
};
var _hoisted_1$g = /* @__PURE__ */ createBaseVNode("path", {
  d: "M12.2097 10.4113C12.1057 10.4118 12.0027 10.3915 11.9067 10.3516C11.8107 10.3118 11.7237 10.2532 11.6506 10.1792L6.93602 5.46461L2.22139 10.1476C2.07272 10.244 1.89599 10.2877 1.71953 10.2717C1.54307 10.2556 1.3771 10.1808 1.24822 10.0593C1.11933 9.93766 1.035 9.77633 1.00874 9.6011C0.982477 9.42587 1.0158 9.2469 1.10338 9.09287L6.37701 3.81923C6.52533 3.6711 6.72639 3.58789 6.93602 3.58789C7.14565 3.58789 7.3467 3.6711 7.49502 3.81923L12.7687 9.09287C12.9168 9.24119 13 9.44225 13 9.65187C13 9.8615 12.9168 10.0626 12.7687 10.2109C12.616 10.3487 12.4151 10.4207 12.2097 10.4113Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$a = [_hoisted_1$g];
function render$b(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$a, 16);
}
__name(render$b, "render$b");
script$c.render = render$b;
var script$4$1 = {
  name: "BaseGalleria",
  "extends": script$X,
  props: {
    id: {
      type: String,
      "default": null
    },
    value: {
      type: Array,
      "default": null
    },
    activeIndex: {
      type: Number,
      "default": 0
    },
    fullScreen: {
      type: Boolean,
      "default": false
    },
    visible: {
      type: Boolean,
      "default": false
    },
    numVisible: {
      type: Number,
      "default": 3
    },
    responsiveOptions: {
      type: Array,
      "default": null
    },
    showItemNavigators: {
      type: Boolean,
      "default": false
    },
    showThumbnailNavigators: {
      type: Boolean,
      "default": true
    },
    showItemNavigatorsOnHover: {
      type: Boolean,
      "default": false
    },
    changeItemOnIndicatorHover: {
      type: Boolean,
      "default": false
    },
    circular: {
      type: Boolean,
      "default": false
    },
    autoPlay: {
      type: Boolean,
      "default": false
    },
    transitionInterval: {
      type: Number,
      "default": 4e3
    },
    showThumbnails: {
      type: Boolean,
      "default": true
    },
    thumbnailsPosition: {
      type: String,
      "default": "bottom"
    },
    verticalThumbnailViewPortHeight: {
      type: String,
      "default": "300px"
    },
    showIndicators: {
      type: Boolean,
      "default": false
    },
    showIndicatorsOnItem: {
      type: Boolean,
      "default": false
    },
    indicatorsPosition: {
      type: String,
      "default": "bottom"
    },
    baseZIndex: {
      type: Number,
      "default": 0
    },
    maskClass: {
      type: String,
      "default": null
    },
    containerStyle: {
      type: null,
      "default": null
    },
    containerClass: {
      type: null,
      "default": null
    },
    containerProps: {
      type: null,
      "default": null
    },
    prevButtonProps: {
      type: null,
      "default": null
    },
    nextButtonProps: {
      type: null,
      "default": null
    },
    ariaLabel: {
      type: String,
      "default": null
    },
    ariaRoledescription: {
      type: String,
      "default": null
    }
  },
  style: GalleriaStyle,
  provide: /* @__PURE__ */ __name(function provide34() {
    return {
      $pcGalleria: this,
      $parentInstance: this
    };
  }, "provide")
};
function _toConsumableArray$1$1(r) {
  return _arrayWithoutHoles$1$1(r) || _iterableToArray$1$1(r) || _unsupportedIterableToArray$1$1(r) || _nonIterableSpread$1$1();
}
__name(_toConsumableArray$1$1, "_toConsumableArray$1$1");
function _nonIterableSpread$1$1() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableSpread$1$1, "_nonIterableSpread$1$1");
function _unsupportedIterableToArray$1$1(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$1$1(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$1$1(r, a) : void 0;
  }
}
__name(_unsupportedIterableToArray$1$1, "_unsupportedIterableToArray$1$1");
function _iterableToArray$1$1(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
__name(_iterableToArray$1$1, "_iterableToArray$1$1");
function _arrayWithoutHoles$1$1(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$1$1(r);
}
__name(_arrayWithoutHoles$1$1, "_arrayWithoutHoles$1$1");
function _arrayLikeToArray$1$1(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
__name(_arrayLikeToArray$1$1, "_arrayLikeToArray$1$1");
var script$3$1 = {
  name: "GalleriaItem",
  hostName: "Galleria",
  "extends": script$X,
  emits: ["start-slideshow", "stop-slideshow", "update:activeIndex"],
  props: {
    circular: {
      type: Boolean,
      "default": false
    },
    activeIndex: {
      type: Number,
      "default": 0
    },
    value: {
      type: Array,
      "default": null
    },
    showItemNavigators: {
      type: Boolean,
      "default": true
    },
    showIndicators: {
      type: Boolean,
      "default": true
    },
    slideShowActive: {
      type: Boolean,
      "default": true
    },
    changeItemOnIndicatorHover: {
      type: Boolean,
      "default": true
    },
    autoPlay: {
      type: Boolean,
      "default": false
    },
    templates: {
      type: null,
      "default": null
    },
    id: {
      type: String,
      "default": null
    }
  },
  mounted: /* @__PURE__ */ __name(function mounted15() {
    if (this.autoPlay) {
      this.$emit("start-slideshow");
    }
  }, "mounted"),
  methods: {
    getIndicatorPTOptions: /* @__PURE__ */ __name(function getIndicatorPTOptions(index2) {
      return {
        context: {
          highlighted: this.activeIndex === index2
        }
      };
    }, "getIndicatorPTOptions"),
    next: /* @__PURE__ */ __name(function next() {
      var nextItemIndex = this.activeIndex + 1;
      var activeIndex2 = this.circular && this.value.length - 1 === this.activeIndex ? 0 : nextItemIndex;
      this.$emit("update:activeIndex", activeIndex2);
    }, "next"),
    prev: /* @__PURE__ */ __name(function prev() {
      var prevItemIndex = this.activeIndex !== 0 ? this.activeIndex - 1 : 0;
      var activeIndex2 = this.circular && this.activeIndex === 0 ? this.value.length - 1 : prevItemIndex;
      this.$emit("update:activeIndex", activeIndex2);
    }, "prev"),
    stopSlideShow: /* @__PURE__ */ __name(function stopSlideShow() {
      if (this.slideShowActive && this.stopSlideShow) {
        this.$emit("stop-slideshow");
      }
    }, "stopSlideShow"),
    navBackward: /* @__PURE__ */ __name(function navBackward(e) {
      this.stopSlideShow();
      this.prev();
      if (e && e.cancelable) {
        e.preventDefault();
      }
    }, "navBackward"),
    navForward: /* @__PURE__ */ __name(function navForward(e) {
      this.stopSlideShow();
      this.next();
      if (e && e.cancelable) {
        e.preventDefault();
      }
    }, "navForward"),
    onIndicatorClick: /* @__PURE__ */ __name(function onIndicatorClick(index2) {
      this.stopSlideShow();
      this.$emit("update:activeIndex", index2);
    }, "onIndicatorClick"),
    onIndicatorMouseEnter: /* @__PURE__ */ __name(function onIndicatorMouseEnter(index2) {
      if (this.changeItemOnIndicatorHover) {
        this.stopSlideShow();
        this.$emit("update:activeIndex", index2);
      }
    }, "onIndicatorMouseEnter"),
    onIndicatorKeyDown: /* @__PURE__ */ __name(function onIndicatorKeyDown(event2, index2) {
      switch (event2.code) {
        case "Enter":
        case "NumpadEnter":
        case "Space":
          this.stopSlideShow();
          this.$emit("update:activeIndex", index2);
          event2.preventDefault();
          break;
        case "ArrowRight":
          this.onRightKey();
          break;
        case "ArrowLeft":
          this.onLeftKey();
          break;
        case "Home":
          this.onHomeKey();
          event2.preventDefault();
          break;
        case "End":
          this.onEndKey();
          event2.preventDefault();
          break;
        case "Tab":
          this.onTabKey();
          break;
        case "ArrowDown":
        case "ArrowUp":
        case "PageUp":
        case "PageDown":
          event2.preventDefault();
          break;
      }
    }, "onIndicatorKeyDown"),
    onRightKey: /* @__PURE__ */ __name(function onRightKey() {
      var indicators = _toConsumableArray$1$1(find(this.$refs.indicatorContent, '[data-pc-section="indicator"]'));
      var activeIndex2 = this.findFocusedIndicatorIndex();
      this.changedFocusedIndicator(activeIndex2, activeIndex2 + 1 === indicators.length ? indicators.length - 1 : activeIndex2 + 1);
    }, "onRightKey"),
    onLeftKey: /* @__PURE__ */ __name(function onLeftKey() {
      var activeIndex2 = this.findFocusedIndicatorIndex();
      this.changedFocusedIndicator(activeIndex2, activeIndex2 - 1 <= 0 ? 0 : activeIndex2 - 1);
    }, "onLeftKey"),
    onHomeKey: /* @__PURE__ */ __name(function onHomeKey5() {
      var activeIndex2 = this.findFocusedIndicatorIndex();
      this.changedFocusedIndicator(activeIndex2, 0);
    }, "onHomeKey"),
    onEndKey: /* @__PURE__ */ __name(function onEndKey5() {
      var indicators = _toConsumableArray$1$1(find(this.$refs.indicatorContent, '[data-pc-section="indicator"]'));
      var activeIndex2 = this.findFocusedIndicatorIndex();
      this.changedFocusedIndicator(activeIndex2, indicators.length - 1);
    }, "onEndKey"),
    onTabKey: /* @__PURE__ */ __name(function onTabKey4() {
      var indicators = _toConsumableArray$1$1(find(this.$refs.indicatorContent, '[data-pc-section="indicator"]'));
      var highlightedIndex = indicators.findIndex(function(ind) {
        return getAttribute(ind, "data-p-active") === true;
      });
      var activeIndicator = findSingle(this.$refs.indicatorContent, '[data-pc-section="indicator"] > button[tabindex="0"]');
      var activeIndex2 = indicators.findIndex(function(ind) {
        return ind === activeIndicator.parentElement;
      });
      indicators[activeIndex2].children[0].tabIndex = "-1";
      indicators[highlightedIndex].children[0].tabIndex = "0";
    }, "onTabKey"),
    findFocusedIndicatorIndex: /* @__PURE__ */ __name(function findFocusedIndicatorIndex() {
      var indicators = _toConsumableArray$1$1(find(this.$refs.indicatorContent, '[data-pc-section="indicator"]'));
      var activeIndicator = findSingle(this.$refs.indicatorContent, '[data-pc-section="indicator"] > button[tabindex="0"]');
      return indicators.findIndex(function(ind) {
        return ind === activeIndicator.parentElement;
      });
    }, "findFocusedIndicatorIndex"),
    changedFocusedIndicator: /* @__PURE__ */ __name(function changedFocusedIndicator(prevInd, nextInd) {
      var indicators = _toConsumableArray$1$1(find(this.$refs.indicatorContent, '[data-pc-section="indicator"]'));
      indicators[prevInd].children[0].tabIndex = "-1";
      indicators[nextInd].children[0].tabIndex = "0";
      indicators[nextInd].children[0].focus();
    }, "changedFocusedIndicator"),
    isIndicatorItemActive: /* @__PURE__ */ __name(function isIndicatorItemActive(index2) {
      return this.activeIndex === index2;
    }, "isIndicatorItemActive"),
    isNavBackwardDisabled: /* @__PURE__ */ __name(function isNavBackwardDisabled() {
      return !this.circular && this.activeIndex === 0;
    }, "isNavBackwardDisabled"),
    isNavForwardDisabled: /* @__PURE__ */ __name(function isNavForwardDisabled() {
      return !this.circular && this.activeIndex === this.value.length - 1;
    }, "isNavForwardDisabled"),
    ariaSlideNumber: /* @__PURE__ */ __name(function ariaSlideNumber(value3) {
      return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.slideNumber.replace(/{slideNumber}/g, value3) : void 0;
    }, "ariaSlideNumber"),
    ariaPageLabel: /* @__PURE__ */ __name(function ariaPageLabel(value3) {
      return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.pageLabel.replace(/{page}/g, value3) : void 0;
    }, "ariaPageLabel")
  },
  computed: {
    activeItem: /* @__PURE__ */ __name(function activeItem() {
      return this.value[this.activeIndex];
    }, "activeItem"),
    ariaSlideLabel: /* @__PURE__ */ __name(function ariaSlideLabel() {
      return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.slide : void 0;
    }, "ariaSlideLabel")
  },
  components: {
    ChevronLeftIcon: script$e,
    ChevronRightIcon: script$d
  },
  directives: {
    ripple: Ripple
  }
};
var _hoisted_1$3$1 = ["disabled"];
var _hoisted_2$2$1 = ["id", "aria-label", "aria-roledescription"];
var _hoisted_3$2$1 = ["disabled"];
var _hoisted_4$1$1 = ["aria-label", "aria-selected", "aria-controls", "onClick", "onMouseenter", "onKeydown", "data-p-active"];
var _hoisted_5$1 = ["tabindex"];
function render$3$1(_ctx, _cache, $props, $setup, $data, $options) {
  var _directive_ripple = resolveDirective("ripple");
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("itemsContainer")
  }, _ctx.ptm("itemsContainer")), [createBaseVNode("div", mergeProps({
    "class": _ctx.cx("items")
  }, _ctx.ptm("items")), [$props.showItemNavigators ? withDirectives((openBlock(), createElementBlock("button", mergeProps({
    key: 0,
    type: "button",
    "class": _ctx.cx("previousItemButton"),
    onClick: _cache[0] || (_cache[0] = function($event) {
      return $options.navBackward($event);
    }),
    disabled: $options.isNavBackwardDisabled()
  }, _ctx.ptm("previousItemButton"), {
    "data-pc-group-section": "itemnavigator"
  }), [(openBlock(), createBlock(resolveDynamicComponent($props.templates.previousitemicon || "ChevronLeftIcon"), mergeProps({
    "class": _ctx.cx("previousItemIcon")
  }, _ctx.ptm("previousItemIcon")), null, 16, ["class"]))], 16, _hoisted_1$3$1)), [[_directive_ripple]]) : createCommentVNode("", true), createBaseVNode("div", mergeProps({
    id: $props.id + "_item_" + $props.activeIndex,
    "class": _ctx.cx("item"),
    role: "group",
    "aria-label": $options.ariaSlideNumber($props.activeIndex + 1),
    "aria-roledescription": $options.ariaSlideLabel
  }, _ctx.ptm("item")), [$props.templates.item ? (openBlock(), createBlock(resolveDynamicComponent($props.templates.item), {
    key: 0,
    item: $options.activeItem
  }, null, 8, ["item"])) : createCommentVNode("", true)], 16, _hoisted_2$2$1), $props.showItemNavigators ? withDirectives((openBlock(), createElementBlock("button", mergeProps({
    key: 1,
    type: "button",
    "class": _ctx.cx("nextItemButton"),
    onClick: _cache[1] || (_cache[1] = function($event) {
      return $options.navForward($event);
    }),
    disabled: $options.isNavForwardDisabled()
  }, _ctx.ptm("nextItemButton"), {
    "data-pc-group-section": "itemnavigator"
  }), [(openBlock(), createBlock(resolveDynamicComponent($props.templates.nextitemicon || "ChevronRightIcon"), mergeProps({
    "class": _ctx.cx("nextItemIcon")
  }, _ctx.ptm("nextItemIcon")), null, 16, ["class"]))], 16, _hoisted_3$2$1)), [[_directive_ripple]]) : createCommentVNode("", true), $props.templates["caption"] ? (openBlock(), createElementBlock("div", mergeProps({
    key: 2,
    "class": _ctx.cx("caption")
  }, _ctx.ptm("caption")), [$props.templates.caption ? (openBlock(), createBlock(resolveDynamicComponent($props.templates.caption), {
    key: 0,
    item: $options.activeItem
  }, null, 8, ["item"])) : createCommentVNode("", true)], 16)) : createCommentVNode("", true)], 16), $props.showIndicators ? (openBlock(), createElementBlock("ul", mergeProps({
    key: 0,
    ref: "indicatorContent",
    "class": _ctx.cx("indicatorList")
  }, _ctx.ptm("indicatorList")), [(openBlock(true), createElementBlock(Fragment, null, renderList($props.value, function(item2, index2) {
    return openBlock(), createElementBlock("li", mergeProps({
      key: "p-galleria-indicator-".concat(index2),
      "class": _ctx.cx("indicator", {
        index: index2
      }),
      "aria-label": $options.ariaPageLabel(index2 + 1),
      "aria-selected": $props.activeIndex === index2,
      "aria-controls": $props.id + "_item_" + index2,
      onClick: /* @__PURE__ */ __name(function onClick3($event) {
        return $options.onIndicatorClick(index2);
      }, "onClick"),
      onMouseenter: /* @__PURE__ */ __name(function onMouseenter($event) {
        return $options.onIndicatorMouseEnter(index2);
      }, "onMouseenter"),
      onKeydown: /* @__PURE__ */ __name(function onKeydown3($event) {
        return $options.onIndicatorKeyDown($event, index2);
      }, "onKeydown"),
      ref_for: true
    }, _ctx.ptm("indicator", $options.getIndicatorPTOptions(index2)), {
      "data-p-active": $options.isIndicatorItemActive(index2)
    }), [!$props.templates["indicator"] ? (openBlock(), createElementBlock("button", mergeProps({
      key: 0,
      type: "button",
      tabindex: $props.activeIndex === index2 ? "0" : "-1",
      "class": _ctx.cx("indicatorButton"),
      ref_for: true
    }, _ctx.ptm("indicatorButton", $options.getIndicatorPTOptions(index2))), null, 16, _hoisted_5$1)) : createCommentVNode("", true), $props.templates.indicator ? (openBlock(), createBlock(resolveDynamicComponent($props.templates.indicator), {
      key: 1,
      index: index2
    }, null, 8, ["index"])) : createCommentVNode("", true)], 16, _hoisted_4$1$1);
  }), 128))], 16)) : createCommentVNode("", true)], 16);
}
__name(render$3$1, "render$3$1");
script$3$1.render = render$3$1;
function _toConsumableArray$4(r) {
  return _arrayWithoutHoles$4(r) || _iterableToArray$4(r) || _unsupportedIterableToArray$4(r) || _nonIterableSpread$4();
}
__name(_toConsumableArray$4, "_toConsumableArray$4");
function _nonIterableSpread$4() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableSpread$4, "_nonIterableSpread$4");
function _unsupportedIterableToArray$4(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$4(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$4(r, a) : void 0;
  }
}
__name(_unsupportedIterableToArray$4, "_unsupportedIterableToArray$4");
function _iterableToArray$4(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
__name(_iterableToArray$4, "_iterableToArray$4");
function _arrayWithoutHoles$4(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$4(r);
}
__name(_arrayWithoutHoles$4, "_arrayWithoutHoles$4");
function _arrayLikeToArray$4(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
__name(_arrayLikeToArray$4, "_arrayLikeToArray$4");
var script$2$2 = {
  name: "GalleriaThumbnails",
  hostName: "Galleria",
  "extends": script$X,
  emits: ["stop-slideshow", "update:activeIndex"],
  props: {
    containerId: {
      type: String,
      "default": null
    },
    value: {
      type: Array,
      "default": null
    },
    numVisible: {
      type: Number,
      "default": 3
    },
    activeIndex: {
      type: Number,
      "default": 0
    },
    isVertical: {
      type: Boolean,
      "default": false
    },
    slideShowActive: {
      type: Boolean,
      "default": false
    },
    circular: {
      type: Boolean,
      "default": false
    },
    responsiveOptions: {
      type: Array,
      "default": null
    },
    contentHeight: {
      type: String,
      "default": "300px"
    },
    showThumbnailNavigators: {
      type: Boolean,
      "default": true
    },
    templates: {
      type: null,
      "default": null
    },
    prevButtonProps: {
      type: null,
      "default": null
    },
    nextButtonProps: {
      type: null,
      "default": null
    }
  },
  startPos: null,
  thumbnailsStyle: null,
  sortedResponsiveOptions: null,
  data: /* @__PURE__ */ __name(function data16() {
    return {
      d_numVisible: this.numVisible,
      d_oldNumVisible: this.numVisible,
      d_activeIndex: this.activeIndex,
      d_oldActiveItemIndex: this.activeIndex,
      totalShiftedItems: 0,
      page: 0
    };
  }, "data"),
  watch: {
    numVisible: /* @__PURE__ */ __name(function numVisible(newValue, oldValue) {
      this.d_numVisible = newValue;
      this.d_oldNumVisible = oldValue;
    }, "numVisible"),
    activeIndex: /* @__PURE__ */ __name(function activeIndex(newValue, oldValue) {
      this.d_activeIndex = newValue;
      this.d_oldActiveItemIndex = oldValue;
    }, "activeIndex")
  },
  mounted: /* @__PURE__ */ __name(function mounted16() {
    this.createStyle();
    this.calculatePosition();
    if (this.responsiveOptions) {
      this.bindDocumentListeners();
    }
  }, "mounted"),
  updated: /* @__PURE__ */ __name(function updated9() {
    var totalShiftedItems = this.totalShiftedItems;
    if (this.d_oldNumVisible !== this.d_numVisible || this.d_oldActiveItemIndex !== this.d_activeIndex) {
      if (this.d_activeIndex <= this.getMedianItemIndex()) {
        totalShiftedItems = 0;
      } else if (this.value.length - this.d_numVisible + this.getMedianItemIndex() < this.d_activeIndex) {
        totalShiftedItems = this.d_numVisible - this.value.length;
      } else if (this.value.length - this.d_numVisible < this.d_activeIndex && this.d_numVisible % 2 === 0) {
        totalShiftedItems = this.d_activeIndex * -1 + this.getMedianItemIndex() + 1;
      } else {
        totalShiftedItems = this.d_activeIndex * -1 + this.getMedianItemIndex();
      }
      if (totalShiftedItems !== this.totalShiftedItems) {
        this.totalShiftedItems = totalShiftedItems;
      }
      this.$refs.itemsContainer.style.transform = this.isVertical ? "translate3d(0, ".concat(totalShiftedItems * (100 / this.d_numVisible), "%, 0)") : "translate3d(".concat(totalShiftedItems * (100 / this.d_numVisible), "%, 0, 0)");
      if (this.d_oldActiveItemIndex !== this.d_activeIndex) {
        document.body.setAttribute("data-p-items-hidden", "false");
        !this.isUnstyled && removeClass(this.$refs.itemsContainer, "p-items-hidden");
        this.$refs.itemsContainer.style.transition = "transform 500ms ease 0s";
      }
      this.d_oldActiveItemIndex = this.d_activeIndex;
      this.d_oldNumVisible = this.d_numVisible;
    }
  }, "updated"),
  beforeUnmount: /* @__PURE__ */ __name(function beforeUnmount10() {
    if (this.responsiveOptions) {
      this.unbindDocumentListeners();
    }
    if (this.thumbnailsStyle) {
      this.thumbnailsStyle.parentNode.removeChild(this.thumbnailsStyle);
    }
  }, "beforeUnmount"),
  methods: {
    step: /* @__PURE__ */ __name(function step(dir) {
      var totalShiftedItems = this.totalShiftedItems + dir;
      if (dir < 0 && -1 * totalShiftedItems + this.d_numVisible > this.value.length - 1) {
        totalShiftedItems = this.d_numVisible - this.value.length;
      } else if (dir > 0 && totalShiftedItems > 0) {
        totalShiftedItems = 0;
      }
      if (this.circular) {
        if (dir < 0 && this.value.length - 1 === this.d_activeIndex) {
          totalShiftedItems = 0;
        } else if (dir > 0 && this.d_activeIndex === 0) {
          totalShiftedItems = this.d_numVisible - this.value.length;
        }
      }
      if (this.$refs.itemsContainer) {
        document.body.setAttribute("data-p-items-hidden", "false");
        !this.isUnstyled && removeClass(this.$refs.itemsContainer, "p-items-hidden");
        this.$refs.itemsContainer.style.transform = this.isVertical ? "translate3d(0, ".concat(totalShiftedItems * (100 / this.d_numVisible), "%, 0)") : "translate3d(".concat(totalShiftedItems * (100 / this.d_numVisible), "%, 0, 0)");
        this.$refs.itemsContainer.style.transition = "transform 500ms ease 0s";
      }
      this.totalShiftedItems = totalShiftedItems;
    }, "step"),
    stopSlideShow: /* @__PURE__ */ __name(function stopSlideShow2() {
      if (this.slideShowActive && this.stopSlideShow) {
        this.$emit("stop-slideshow");
      }
    }, "stopSlideShow"),
    getMedianItemIndex: /* @__PURE__ */ __name(function getMedianItemIndex() {
      var index2 = Math.floor(this.d_numVisible / 2);
      return this.d_numVisible % 2 ? index2 : index2 - 1;
    }, "getMedianItemIndex"),
    navBackward: /* @__PURE__ */ __name(function navBackward2(e) {
      this.stopSlideShow();
      var prevItemIndex = this.d_activeIndex !== 0 ? this.d_activeIndex - 1 : 0;
      var diff = prevItemIndex + this.totalShiftedItems;
      if (this.d_numVisible - diff - 1 > this.getMedianItemIndex() && (-1 * this.totalShiftedItems !== 0 || this.circular)) {
        this.step(1);
      }
      var activeIndex2 = this.circular && this.d_activeIndex === 0 ? this.value.length - 1 : prevItemIndex;
      this.$emit("update:activeIndex", activeIndex2);
      if (e.cancelable) {
        e.preventDefault();
      }
    }, "navBackward"),
    navForward: /* @__PURE__ */ __name(function navForward2(e) {
      this.stopSlideShow();
      var nextItemIndex = this.d_activeIndex === this.value.length - 1 ? this.value.length - 1 : this.d_activeIndex + 1;
      if (nextItemIndex + this.totalShiftedItems > this.getMedianItemIndex() && (-1 * this.totalShiftedItems < this.getTotalPageNumber() - 1 || this.circular)) {
        this.step(-1);
      }
      var activeIndex2 = this.circular && this.value.length - 1 === this.d_activeIndex ? 0 : nextItemIndex;
      this.$emit("update:activeIndex", activeIndex2);
      if (e.cancelable) {
        e.preventDefault();
      }
    }, "navForward"),
    onItemClick: /* @__PURE__ */ __name(function onItemClick3(index2) {
      this.stopSlideShow();
      var selectedItemIndex = index2;
      if (selectedItemIndex !== this.d_activeIndex) {
        var diff = selectedItemIndex + this.totalShiftedItems;
        var dir = 0;
        if (selectedItemIndex < this.d_activeIndex) {
          dir = this.d_numVisible - diff - 1 - this.getMedianItemIndex();
          if (dir > 0 && -1 * this.totalShiftedItems !== 0) {
            this.step(dir);
          }
        } else {
          dir = this.getMedianItemIndex() - diff;
          if (dir < 0 && -1 * this.totalShiftedItems < this.getTotalPageNumber() - 1) {
            this.step(dir);
          }
        }
        this.$emit("update:activeIndex", selectedItemIndex);
      }
    }, "onItemClick"),
    onThumbnailKeydown: /* @__PURE__ */ __name(function onThumbnailKeydown(event2, index2) {
      if (event2.code === "Enter" || event2.code === "NumpadEnter" || event2.code === "Space") {
        this.onItemClick(index2);
        event2.preventDefault();
      }
      switch (event2.code) {
        case "ArrowRight":
          this.onRightKey();
          break;
        case "ArrowLeft":
          this.onLeftKey();
          break;
        case "Home":
          this.onHomeKey();
          event2.preventDefault();
          break;
        case "End":
          this.onEndKey();
          event2.preventDefault();
          break;
        case "ArrowUp":
        case "ArrowDown":
          event2.preventDefault();
          break;
        case "Tab":
          this.onTabKey();
          break;
      }
    }, "onThumbnailKeydown"),
    onRightKey: /* @__PURE__ */ __name(function onRightKey2() {
      var indicators = find(this.$refs.itemsContainer, '[data-pc-section="thumbnailitem"]');
      var activeIndex2 = this.findFocusedIndicatorIndex();
      this.changedFocusedIndicator(activeIndex2, activeIndex2 + 1 === indicators.length ? indicators.length - 1 : activeIndex2 + 1);
    }, "onRightKey"),
    onLeftKey: /* @__PURE__ */ __name(function onLeftKey2() {
      var activeIndex2 = this.findFocusedIndicatorIndex();
      this.changedFocusedIndicator(activeIndex2, activeIndex2 - 1 <= 0 ? 0 : activeIndex2 - 1);
    }, "onLeftKey"),
    onHomeKey: /* @__PURE__ */ __name(function onHomeKey6() {
      var activeIndex2 = this.findFocusedIndicatorIndex();
      this.changedFocusedIndicator(activeIndex2, 0);
    }, "onHomeKey"),
    onEndKey: /* @__PURE__ */ __name(function onEndKey6() {
      var indicators = find(this.$refs.itemsContainer, '[data-pc-section="thumbnailitem"]');
      var activeIndex2 = this.findFocusedIndicatorIndex();
      this.changedFocusedIndicator(activeIndex2, indicators.length - 1);
    }, "onEndKey"),
    onTabKey: /* @__PURE__ */ __name(function onTabKey5() {
      var indicators = _toConsumableArray$4(find(this.$refs.itemsContainer, '[data-pc-section="thumbnailitem"]'));
      var highlightedIndex = indicators.findIndex(function(ind) {
        return getAttribute(ind, "data-p-active") === true;
      });
      var activeIndicator = findSingle(this.$refs.itemsContainer, '[tabindex="0"]');
      var activeIndex2 = indicators.findIndex(function(ind) {
        return ind === activeIndicator.parentElement;
      });
      indicators[activeIndex2].children[0].tabIndex = "-1";
      indicators[highlightedIndex].children[0].tabIndex = "0";
    }, "onTabKey"),
    findFocusedIndicatorIndex: /* @__PURE__ */ __name(function findFocusedIndicatorIndex2() {
      var indicators = _toConsumableArray$4(find(this.$refs.itemsContainer, '[data-pc-section="thumbnailitem"]'));
      var activeIndicator = findSingle(this.$refs.itemsContainer, '[data-pc-section="thumbnailitem"] > [tabindex="0"]');
      return indicators.findIndex(function(ind) {
        return ind === activeIndicator.parentElement;
      });
    }, "findFocusedIndicatorIndex"),
    changedFocusedIndicator: /* @__PURE__ */ __name(function changedFocusedIndicator2(prevInd, nextInd) {
      var indicators = find(this.$refs.itemsContainer, '[data-pc-section="thumbnailitem"]');
      indicators[prevInd].children[0].tabIndex = "-1";
      indicators[nextInd].children[0].tabIndex = "0";
      indicators[nextInd].children[0].focus();
    }, "changedFocusedIndicator"),
    onTransitionEnd: /* @__PURE__ */ __name(function onTransitionEnd(e) {
      if (this.$refs.itemsContainer && e.propertyName === "transform") {
        document.body.setAttribute("data-p-items-hidden", "true");
        !this.isUnstyled && addClass(this.$refs.itemsContainer, "p-items-hidden");
        this.$refs.itemsContainer.style.transition = "";
      }
    }, "onTransitionEnd"),
    onTouchStart: /* @__PURE__ */ __name(function onTouchStart(e) {
      var touchobj = e.changedTouches[0];
      this.startPos = {
        x: touchobj.pageX,
        y: touchobj.pageY
      };
    }, "onTouchStart"),
    onTouchMove: /* @__PURE__ */ __name(function onTouchMove(e) {
      if (e.cancelable) {
        e.preventDefault();
      }
    }, "onTouchMove"),
    onTouchEnd: /* @__PURE__ */ __name(function onTouchEnd(e) {
      var touchobj = e.changedTouches[0];
      if (this.isVertical) {
        this.changePageOnTouch(e, touchobj.pageY - this.startPos.y);
      } else {
        this.changePageOnTouch(e, touchobj.pageX - this.startPos.x);
      }
    }, "onTouchEnd"),
    changePageOnTouch: /* @__PURE__ */ __name(function changePageOnTouch(e, diff) {
      if (diff < 0) {
        this.navForward(e);
      } else {
        this.navBackward(e);
      }
    }, "changePageOnTouch"),
    getTotalPageNumber: /* @__PURE__ */ __name(function getTotalPageNumber() {
      return this.value.length > this.d_numVisible ? this.value.length - this.d_numVisible + 1 : 0;
    }, "getTotalPageNumber"),
    createStyle: /* @__PURE__ */ __name(function createStyle2() {
      if (!this.thumbnailsStyle) {
        var _this$$primevue;
        this.thumbnailsStyle = document.createElement("style");
        this.thumbnailsStyle.type = "text/css";
        setAttribute(this.thumbnailsStyle, "nonce", (_this$$primevue = this.$primevue) === null || _this$$primevue === void 0 || (_this$$primevue = _this$$primevue.config) === null || _this$$primevue === void 0 || (_this$$primevue = _this$$primevue.csp) === null || _this$$primevue === void 0 ? void 0 : _this$$primevue.nonce);
        document.body.appendChild(this.thumbnailsStyle);
      }
      var innerHTML = "\n                #".concat(this.containerId, ' [data-pc-section="thumbnailitem"] {\n                    flex: 1 0 ').concat(100 / this.d_numVisible, "%\n                }\n            ");
      if (this.responsiveOptions && !this.isUnstyled) {
        this.sortedResponsiveOptions = _toConsumableArray$4(this.responsiveOptions);
        var comparer = localeComparator();
        this.sortedResponsiveOptions.sort(function(data1, data24) {
          var value1 = data1.breakpoint;
          var value22 = data24.breakpoint;
          return sort(value1, value22, -1, comparer);
        });
        for (var i2 = 0; i2 < this.sortedResponsiveOptions.length; i2++) {
          var res = this.sortedResponsiveOptions[i2];
          innerHTML += "\n                        @media screen and (max-width: ".concat(res.breakpoint, ") {\n                            #").concat(this.containerId, " .p-galleria-thumbnail-item {\n                                flex: 1 0 ").concat(100 / res.numVisible, "%\n                            }\n                        }\n                    ");
        }
      }
      this.thumbnailsStyle.innerHTML = innerHTML;
    }, "createStyle"),
    calculatePosition: /* @__PURE__ */ __name(function calculatePosition() {
      if (this.$refs.itemsContainer && this.sortedResponsiveOptions) {
        var windowWidth = window.innerWidth;
        var matchedResponsiveData = {
          numVisible: this.numVisible
        };
        for (var i2 = 0; i2 < this.sortedResponsiveOptions.length; i2++) {
          var res = this.sortedResponsiveOptions[i2];
          if (parseInt(res.breakpoint, 10) >= windowWidth) {
            matchedResponsiveData = res;
          }
        }
        if (this.d_numVisible !== matchedResponsiveData.numVisible) {
          this.d_numVisible = matchedResponsiveData.numVisible;
        }
      }
    }, "calculatePosition"),
    bindDocumentListeners: /* @__PURE__ */ __name(function bindDocumentListeners() {
      var _this = this;
      if (!this.documentResizeListener) {
        this.documentResizeListener = function() {
          _this.calculatePosition();
        };
        window.addEventListener("resize", this.documentResizeListener);
      }
    }, "bindDocumentListeners"),
    unbindDocumentListeners: /* @__PURE__ */ __name(function unbindDocumentListeners() {
      if (this.documentResizeListener) {
        window.removeEventListener("resize", this.documentResizeListener);
        this.documentResizeListener = null;
      }
    }, "unbindDocumentListeners"),
    isNavBackwardDisabled: /* @__PURE__ */ __name(function isNavBackwardDisabled2() {
      return !this.circular && this.d_activeIndex === 0 || this.value.length <= this.d_numVisible;
    }, "isNavBackwardDisabled"),
    isNavForwardDisabled: /* @__PURE__ */ __name(function isNavForwardDisabled2() {
      return !this.circular && this.d_activeIndex === this.value.length - 1 || this.value.length <= this.d_numVisible;
    }, "isNavForwardDisabled"),
    firstItemAciveIndex: /* @__PURE__ */ __name(function firstItemAciveIndex() {
      return this.totalShiftedItems * -1;
    }, "firstItemAciveIndex"),
    lastItemActiveIndex: /* @__PURE__ */ __name(function lastItemActiveIndex() {
      return this.firstItemAciveIndex() + this.d_numVisible - 1;
    }, "lastItemActiveIndex"),
    isItemActive: /* @__PURE__ */ __name(function isItemActive2(index2) {
      return this.firstItemAciveIndex() <= index2 && this.lastItemActiveIndex() >= index2;
    }, "isItemActive"),
    ariaPageLabel: /* @__PURE__ */ __name(function ariaPageLabel2(value3) {
      return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.pageLabel.replace(/{page}/g, value3) : void 0;
    }, "ariaPageLabel")
  },
  computed: {
    ariaPrevButtonLabel: /* @__PURE__ */ __name(function ariaPrevButtonLabel() {
      return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.prevPageLabel : void 0;
    }, "ariaPrevButtonLabel"),
    ariaNextButtonLabel: /* @__PURE__ */ __name(function ariaNextButtonLabel() {
      return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.nextPageLabel : void 0;
    }, "ariaNextButtonLabel")
  },
  components: {
    ChevronLeftIcon: script$e,
    ChevronRightIcon: script$d,
    ChevronUpIcon: script$c,
    ChevronDownIcon: script$B
  },
  directives: {
    ripple: Ripple
  }
};
function _typeof$2$1(o) {
  "@babel/helpers - typeof";
  return _typeof$2$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$2$1(o);
}
__name(_typeof$2$1, "_typeof$2$1");
function ownKeys$2$1(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
__name(ownKeys$2$1, "ownKeys$2$1");
function _objectSpread$2$1(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$2$1(Object(t), true).forEach(function(r2) {
      _defineProperty$2$1(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$2$1(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
__name(_objectSpread$2$1, "_objectSpread$2$1");
function _defineProperty$2$1(e, r, t) {
  return (r = _toPropertyKey$2$1(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty$2$1, "_defineProperty$2$1");
function _toPropertyKey$2$1(t) {
  var i2 = _toPrimitive$2$1(t, "string");
  return "symbol" == _typeof$2$1(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$2$1, "_toPropertyKey$2$1");
function _toPrimitive$2$1(t, r) {
  if ("object" != _typeof$2$1(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$2$1(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive$2$1, "_toPrimitive$2$1");
var _hoisted_1$2$1 = ["disabled", "aria-label"];
var _hoisted_2$1$1 = ["data-p-active", "aria-selected", "aria-controls", "onKeydown", "data-p-galleria-thumbnail-item-current", "data-p-galleria-thumbnail-item-active", "data-p-galleria-thumbnail-item-start", "data-p-galleria-thumbnail-item-end"];
var _hoisted_3$1$1 = ["tabindex", "aria-label", "aria-current", "onClick"];
var _hoisted_4$2 = ["disabled", "aria-label"];
function render$2$1(_ctx, _cache, $props, $setup, $data, $options) {
  var _directive_ripple = resolveDirective("ripple");
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("thumbnails")
  }, _ctx.ptm("thumbnails")), [createBaseVNode("div", mergeProps({
    "class": _ctx.cx("thumbnailContent")
  }, _ctx.ptm("thumbnailContent")), [$props.showThumbnailNavigators ? withDirectives((openBlock(), createElementBlock("button", mergeProps({
    key: 0,
    "class": _ctx.cx("previousThumbnailButton"),
    disabled: $options.isNavBackwardDisabled(),
    type: "button",
    "aria-label": $options.ariaPrevButtonLabel,
    onClick: _cache[0] || (_cache[0] = function($event) {
      return $options.navBackward($event);
    })
  }, _objectSpread$2$1(_objectSpread$2$1({}, $props.prevButtonProps), _ctx.ptm("previousThumbnailButton")), {
    "data-pc-group-section": "thumbnailnavigator"
  }), [(openBlock(), createBlock(resolveDynamicComponent($props.templates.previousthumbnailicon || ($props.isVertical ? "ChevronUpIcon" : "ChevronLeftIcon")), mergeProps({
    "class": _ctx.cx("previousThumbnailIcon")
  }, _ctx.ptm("previousThumbnailIcon")), null, 16, ["class"]))], 16, _hoisted_1$2$1)), [[_directive_ripple]]) : createCommentVNode("", true), createBaseVNode("div", mergeProps({
    "class": _ctx.cx("thumbnailsViewport"),
    style: {
      height: $props.isVertical ? $props.contentHeight : ""
    }
  }, _ctx.ptm("thumbnailsViewport")), [createBaseVNode("div", mergeProps({
    ref: "itemsContainer",
    "class": _ctx.cx("thumbnailItems"),
    role: "tablist",
    onTransitionend: _cache[1] || (_cache[1] = function($event) {
      return $options.onTransitionEnd($event);
    }),
    onTouchstart: _cache[2] || (_cache[2] = function($event) {
      return $options.onTouchStart($event);
    }),
    onTouchmove: _cache[3] || (_cache[3] = function($event) {
      return $options.onTouchMove($event);
    }),
    onTouchend: _cache[4] || (_cache[4] = function($event) {
      return $options.onTouchEnd($event);
    })
  }, _ctx.ptm("thumbnailItems")), [(openBlock(true), createElementBlock(Fragment, null, renderList($props.value, function(item2, index2) {
    return openBlock(), createElementBlock("div", mergeProps({
      key: "p-galleria-thumbnail-item-".concat(index2),
      "class": _ctx.cx("thumbnailItem", {
        index: index2,
        activeIndex: $props.activeIndex
      }),
      role: "tab",
      "data-p-active": $props.activeIndex === index2,
      "aria-selected": $props.activeIndex === index2,
      "aria-controls": $props.containerId + "_item_" + index2,
      onKeydown: /* @__PURE__ */ __name(function onKeydown3($event) {
        return $options.onThumbnailKeydown($event, index2);
      }, "onKeydown"),
      ref_for: true
    }, _ctx.ptm("thumbnailItem"), {
      "data-p-galleria-thumbnail-item-current": $props.activeIndex === index2,
      "data-p-galleria-thumbnail-item-active": $options.isItemActive(index2),
      "data-p-galleria-thumbnail-item-start": $options.firstItemAciveIndex() === index2,
      "data-p-galleria-thumbnail-item-end": $options.lastItemActiveIndex() === index2
    }), [createBaseVNode("div", mergeProps({
      "class": _ctx.cx("thumbnail"),
      tabindex: $props.activeIndex === index2 ? "0" : "-1",
      "aria-label": $options.ariaPageLabel(index2 + 1),
      "aria-current": $props.activeIndex === index2 ? "page" : void 0,
      onClick: /* @__PURE__ */ __name(function onClick3($event) {
        return $options.onItemClick(index2);
      }, "onClick"),
      ref_for: true
    }, _ctx.ptm("thumbnail")), [$props.templates.thumbnail ? (openBlock(), createBlock(resolveDynamicComponent($props.templates.thumbnail), {
      key: 0,
      item: item2
    }, null, 8, ["item"])) : createCommentVNode("", true)], 16, _hoisted_3$1$1)], 16, _hoisted_2$1$1);
  }), 128))], 16)], 16), $props.showThumbnailNavigators ? withDirectives((openBlock(), createElementBlock("button", mergeProps({
    key: 1,
    "class": _ctx.cx("nextThumbnailButton"),
    disabled: $options.isNavForwardDisabled(),
    type: "button",
    "aria-label": $options.ariaNextButtonLabel,
    onClick: _cache[5] || (_cache[5] = function($event) {
      return $options.navForward($event);
    })
  }, _objectSpread$2$1(_objectSpread$2$1({}, $props.nextButtonProps), _ctx.ptm("nextThumbnailButton")), {
    "data-pc-group-section": "thumbnailnavigator"
  }), [(openBlock(), createBlock(resolveDynamicComponent($props.templates.nextthumbnailicon || ($props.isVertical ? "ChevronDownIcon" : "ChevronRightIcon")), mergeProps({
    "class": _ctx.cx("nextThumbnailIcon")
  }, _ctx.ptm("nextThumbnailIcon")), null, 16, ["class"]))], 16, _hoisted_4$2)), [[_directive_ripple]]) : createCommentVNode("", true)], 16)], 16);
}
__name(render$2$1, "render$2$1");
script$2$2.render = render$2$1;
function _typeof$1$2(o) {
  "@babel/helpers - typeof";
  return _typeof$1$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$1$2(o);
}
__name(_typeof$1$2, "_typeof$1$2");
function ownKeys$1$2(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
__name(ownKeys$1$2, "ownKeys$1$2");
function _objectSpread$1$2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$1$2(Object(t), true).forEach(function(r2) {
      _defineProperty$1$2(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1$2(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
__name(_objectSpread$1$2, "_objectSpread$1$2");
function _defineProperty$1$2(e, r, t) {
  return (r = _toPropertyKey$1$2(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty$1$2, "_defineProperty$1$2");
function _toPropertyKey$1$2(t) {
  var i2 = _toPrimitive$1$2(t, "string");
  return "symbol" == _typeof$1$2(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$1$2, "_toPropertyKey$1$2");
function _toPrimitive$1$2(t, r) {
  if ("object" != _typeof$1$2(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$1$2(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive$1$2, "_toPrimitive$1$2");
var script$1$6 = {
  name: "GalleriaContent",
  hostName: "Galleria",
  "extends": script$X,
  inheritAttrs: false,
  interval: null,
  emits: ["activeitem-change", "mask-hide"],
  data: /* @__PURE__ */ __name(function data17() {
    return {
      id: this.$attrs.id || UniqueComponentId(),
      activeIndex: this.$attrs.activeIndex,
      numVisible: this.$attrs.numVisible,
      slideShowActive: false
    };
  }, "data"),
  watch: {
    "$attrs.id": /* @__PURE__ */ __name(function $attrsId8(newValue) {
      this.id = newValue || UniqueComponentId();
    }, "$attrsId"),
    "$attrs.value": /* @__PURE__ */ __name(function $attrsValue(newVal) {
      if (newVal && newVal.length < this.numVisible) {
        this.numVisible = newVal.length;
      }
    }, "$attrsValue"),
    "$attrs.activeIndex": /* @__PURE__ */ __name(function $attrsActiveIndex(newVal) {
      this.activeIndex = newVal;
    }, "$attrsActiveIndex"),
    "$attrs.numVisible": /* @__PURE__ */ __name(function $attrsNumVisible(newVal) {
      this.numVisible = newVal;
    }, "$attrsNumVisible"),
    "$attrs.autoPlay": /* @__PURE__ */ __name(function $attrsAutoPlay(newVal) {
      newVal ? this.startSlideShow() : this.stopSlideShow();
    }, "$attrsAutoPlay")
  },
  mounted: /* @__PURE__ */ __name(function mounted17() {
    this.id = this.id || UniqueComponentId();
  }, "mounted"),
  updated: /* @__PURE__ */ __name(function updated10() {
    this.$emit("activeitem-change", this.activeIndex);
  }, "updated"),
  beforeUnmount: /* @__PURE__ */ __name(function beforeUnmount11() {
    if (this.slideShowActive) {
      this.stopSlideShow();
    }
  }, "beforeUnmount"),
  methods: {
    getPTOptions: /* @__PURE__ */ __name(function getPTOptions11(key) {
      return this.ptm(key, {
        props: _objectSpread$1$2(_objectSpread$1$2({}, this.$attrs), {}, {
          pt: this.pt,
          unstyled: this.unstyled
        })
      });
    }, "getPTOptions"),
    isAutoPlayActive: /* @__PURE__ */ __name(function isAutoPlayActive() {
      return this.slideShowActive;
    }, "isAutoPlayActive"),
    startSlideShow: /* @__PURE__ */ __name(function startSlideShow() {
      var _this = this;
      this.interval = setInterval(function() {
        var activeIndex2 = _this.$attrs.circular && _this.$attrs.value.length - 1 === _this.activeIndex ? 0 : _this.activeIndex + 1;
        _this.activeIndex = activeIndex2;
      }, this.$attrs.transitionInterval);
      this.slideShowActive = true;
    }, "startSlideShow"),
    stopSlideShow: /* @__PURE__ */ __name(function stopSlideShow3() {
      if (this.interval) {
        clearInterval(this.interval);
      }
      this.slideShowActive = false;
    }, "stopSlideShow"),
    getPositionClass: /* @__PURE__ */ __name(function getPositionClass(preClassName, position2) {
      var positions = ["top", "left", "bottom", "right"];
      var pos2 = positions.find(function(item2) {
        return item2 === position2;
      });
      return pos2 ? "".concat(preClassName, "-").concat(pos2) : "";
    }, "getPositionClass"),
    isVertical: /* @__PURE__ */ __name(function isVertical3() {
      return this.$attrs.thumbnailsPosition === "left" || this.$attrs.thumbnailsPosition === "right";
    }, "isVertical")
  },
  computed: {
    closeAriaLabel: /* @__PURE__ */ __name(function closeAriaLabel2() {
      return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.close : void 0;
    }, "closeAriaLabel")
  },
  components: {
    GalleriaItem: script$3$1,
    GalleriaThumbnails: script$2$2,
    TimesIcon: script$A
  },
  directives: {
    ripple: Ripple
  }
};
function _typeof$4(o) {
  "@babel/helpers - typeof";
  return _typeof$4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$4(o);
}
__name(_typeof$4, "_typeof$4");
function ownKeys$3(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
__name(ownKeys$3, "ownKeys$3");
function _objectSpread$3(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$3(Object(t), true).forEach(function(r2) {
      _defineProperty$4(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$3(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
__name(_objectSpread$3, "_objectSpread$3");
function _defineProperty$4(e, r, t) {
  return (r = _toPropertyKey$4(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty$4, "_defineProperty$4");
function _toPropertyKey$4(t) {
  var i2 = _toPrimitive$4(t, "string");
  return "symbol" == _typeof$4(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$4, "_toPropertyKey$4");
function _toPrimitive$4(t, r) {
  if ("object" != _typeof$4(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$4(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive$4, "_toPrimitive$4");
var _hoisted_1$1$2 = ["id", "aria-label", "aria-roledescription"];
var _hoisted_2$9 = ["aria-label"];
var _hoisted_3$5 = ["aria-live"];
function render$1$2(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_GalleriaItem = resolveComponent("GalleriaItem");
  var _component_GalleriaThumbnails = resolveComponent("GalleriaThumbnails");
  var _directive_ripple = resolveDirective("ripple");
  return _ctx.$attrs.value && _ctx.$attrs.value.length > 0 ? (openBlock(), createElementBlock("div", mergeProps({
    key: 0,
    id: $data.id,
    role: "region",
    "class": [_ctx.cx("root"), _ctx.$attrs.containerClass],
    style: _ctx.$attrs.containerStyle,
    "aria-label": _ctx.$attrs.ariaLabel,
    "aria-roledescription": _ctx.$attrs.ariaRoledescription
  }, _objectSpread$3(_objectSpread$3({}, _ctx.$attrs.containerProps), $options.getPTOptions("root"))), [_ctx.$attrs.fullScreen ? withDirectives((openBlock(), createElementBlock("button", mergeProps({
    key: 0,
    autofocus: "",
    type: "button",
    "class": _ctx.cx("closeButton"),
    "aria-label": $options.closeAriaLabel,
    onClick: _cache[0] || (_cache[0] = function($event) {
      return _ctx.$emit("mask-hide");
    })
  }, $options.getPTOptions("closeButton")), [(openBlock(), createBlock(resolveDynamicComponent(_ctx.$attrs.templates["closeicon"] || "TimesIcon"), mergeProps({
    "class": _ctx.cx("closeIcon")
  }, $options.getPTOptions("closeIcon")), null, 16, ["class"]))], 16, _hoisted_2$9)), [[_directive_ripple]]) : createCommentVNode("", true), _ctx.$attrs.templates && _ctx.$attrs.templates["header"] ? (openBlock(), createElementBlock("div", mergeProps({
    key: 1,
    "class": _ctx.cx("header")
  }, $options.getPTOptions("header")), [(openBlock(), createBlock(resolveDynamicComponent(_ctx.$attrs.templates["header"])))], 16)) : createCommentVNode("", true), createBaseVNode("div", mergeProps({
    "class": _ctx.cx("content"),
    "aria-live": _ctx.$attrs.autoPlay ? "polite" : "off"
  }, $options.getPTOptions("content")), [createVNode(_component_GalleriaItem, {
    id: $data.id,
    activeIndex: $data.activeIndex,
    "onUpdate:activeIndex": _cache[1] || (_cache[1] = function($event) {
      return $data.activeIndex = $event;
    }),
    slideShowActive: $data.slideShowActive,
    "onUpdate:slideShowActive": _cache[2] || (_cache[2] = function($event) {
      return $data.slideShowActive = $event;
    }),
    value: _ctx.$attrs.value,
    circular: _ctx.$attrs.circular,
    templates: _ctx.$attrs.templates,
    showIndicators: _ctx.$attrs.showIndicators,
    changeItemOnIndicatorHover: _ctx.$attrs.changeItemOnIndicatorHover,
    showItemNavigators: _ctx.$attrs.showItemNavigators,
    autoPlay: _ctx.$attrs.autoPlay,
    onStartSlideshow: $options.startSlideShow,
    onStopSlideshow: $options.stopSlideShow,
    pt: _ctx.pt,
    unstyled: _ctx.unstyled
  }, null, 8, ["id", "activeIndex", "slideShowActive", "value", "circular", "templates", "showIndicators", "changeItemOnIndicatorHover", "showItemNavigators", "autoPlay", "onStartSlideshow", "onStopSlideshow", "pt", "unstyled"]), _ctx.$attrs.showThumbnails ? (openBlock(), createBlock(_component_GalleriaThumbnails, {
    key: 0,
    activeIndex: $data.activeIndex,
    "onUpdate:activeIndex": _cache[3] || (_cache[3] = function($event) {
      return $data.activeIndex = $event;
    }),
    slideShowActive: $data.slideShowActive,
    "onUpdate:slideShowActive": _cache[4] || (_cache[4] = function($event) {
      return $data.slideShowActive = $event;
    }),
    containerId: $data.id,
    value: _ctx.$attrs.value,
    templates: _ctx.$attrs.templates,
    numVisible: $data.numVisible,
    responsiveOptions: _ctx.$attrs.responsiveOptions,
    circular: _ctx.$attrs.circular,
    isVertical: $options.isVertical(),
    contentHeight: _ctx.$attrs.verticalThumbnailViewPortHeight,
    showThumbnailNavigators: _ctx.$attrs.showThumbnailNavigators,
    prevButtonProps: _ctx.$attrs.prevButtonProps,
    nextButtonProps: _ctx.$attrs.nextButtonProps,
    onStopSlideshow: $options.stopSlideShow,
    pt: _ctx.pt,
    unstyled: _ctx.unstyled
  }, null, 8, ["activeIndex", "slideShowActive", "containerId", "value", "templates", "numVisible", "responsiveOptions", "circular", "isVertical", "contentHeight", "showThumbnailNavigators", "prevButtonProps", "nextButtonProps", "onStopSlideshow", "pt", "unstyled"])) : createCommentVNode("", true)], 16, _hoisted_3$5), _ctx.$attrs.templates && _ctx.$attrs.templates["footer"] ? (openBlock(), createElementBlock("div", mergeProps({
    key: 2,
    "class": _ctx.cx("footer")
  }, $options.getPTOptions("footer")), [(openBlock(), createBlock(resolveDynamicComponent(_ctx.$attrs.templates["footer"])))], 16)) : createCommentVNode("", true)], 16, _hoisted_1$1$2)) : createCommentVNode("", true);
}
__name(render$1$2, "render$1$2");
script$1$6.render = render$1$2;
var script$b = {
  name: "Galleria",
  "extends": script$4$1,
  inheritAttrs: false,
  emits: ["update:activeIndex", "update:visible"],
  container: null,
  mask: null,
  data: /* @__PURE__ */ __name(function data18() {
    return {
      containerVisible: this.visible
    };
  }, "data"),
  updated: /* @__PURE__ */ __name(function updated11() {
    if (this.fullScreen && this.visible) {
      this.containerVisible = this.visible;
    }
  }, "updated"),
  beforeUnmount: /* @__PURE__ */ __name(function beforeUnmount12() {
    if (this.fullScreen) {
      unblockBodyScroll();
    }
    this.mask = null;
    if (this.container) {
      ZIndex.clear(this.container);
      this.container = null;
    }
  }, "beforeUnmount"),
  methods: {
    onBeforeEnter: /* @__PURE__ */ __name(function onBeforeEnter2(el) {
      ZIndex.set("modal", el, this.baseZIndex || this.$primevue.config.zIndex.modal);
    }, "onBeforeEnter"),
    onEnter: /* @__PURE__ */ __name(function onEnter5(el) {
      this.mask.style.zIndex = String(parseInt(el.style.zIndex, 10) - 1);
      blockBodyScroll();
      this.focus();
    }, "onEnter"),
    onBeforeLeave: /* @__PURE__ */ __name(function onBeforeLeave2() {
      !this.isUnstyled && addClass(this.mask, "p-overlay-mask-leave");
    }, "onBeforeLeave"),
    onAfterLeave: /* @__PURE__ */ __name(function onAfterLeave4(el) {
      ZIndex.clear(el);
      this.containerVisible = false;
      unblockBodyScroll();
    }, "onAfterLeave"),
    onActiveItemChange: /* @__PURE__ */ __name(function onActiveItemChange(index2) {
      if (this.activeIndex !== index2) {
        this.$emit("update:activeIndex", index2);
      }
    }, "onActiveItemChange"),
    maskHide: /* @__PURE__ */ __name(function maskHide() {
      this.$emit("update:visible", false);
    }, "maskHide"),
    containerRef: /* @__PURE__ */ __name(function containerRef4(el) {
      this.container = el;
    }, "containerRef"),
    maskRef: /* @__PURE__ */ __name(function maskRef2(el) {
      this.mask = el;
    }, "maskRef"),
    focus: /* @__PURE__ */ __name(function focus3() {
      var focusTarget = this.container.$el.querySelector("[autofocus]");
      if (focusTarget) {
        focusTarget.focus();
      }
    }, "focus")
  },
  components: {
    GalleriaContent: script$1$6,
    Portal: script$z
  },
  directives: {
    focustrap: FocusTrap
  }
};
var _hoisted_1$f = ["aria-modal"];
function render$a(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_GalleriaContent = resolveComponent("GalleriaContent");
  var _component_Portal = resolveComponent("Portal");
  var _directive_focustrap = resolveDirective("focustrap");
  return _ctx.fullScreen ? (openBlock(), createBlock(_component_Portal, {
    key: 0
  }, {
    "default": withCtx(function() {
      return [$data.containerVisible ? (openBlock(), createElementBlock("div", mergeProps({
        key: 0,
        ref: $options.maskRef,
        "class": [_ctx.cx("mask"), _ctx.maskClass],
        role: "dialog",
        "aria-modal": _ctx.fullScreen ? "true" : void 0
      }, _ctx.ptm("mask")), [createVNode(Transition, mergeProps({
        name: "p-galleria",
        onBeforeEnter: $options.onBeforeEnter,
        onEnter: $options.onEnter,
        onBeforeLeave: $options.onBeforeLeave,
        onAfterLeave: $options.onAfterLeave,
        appear: ""
      }, _ctx.ptm("transition")), {
        "default": withCtx(function() {
          return [_ctx.visible ? withDirectives((openBlock(), createBlock(_component_GalleriaContent, mergeProps({
            key: 0,
            ref: $options.containerRef,
            onMaskHide: $options.maskHide,
            templates: _ctx.$slots,
            onActiveitemChange: $options.onActiveItemChange,
            pt: _ctx.pt,
            unstyled: _ctx.unstyled
          }, _ctx.$props), null, 16, ["onMaskHide", "templates", "onActiveitemChange", "pt", "unstyled"])), [[_directive_focustrap]]) : createCommentVNode("", true)];
        }),
        _: 1
      }, 16, ["onBeforeEnter", "onEnter", "onBeforeLeave", "onAfterLeave"])], 16, _hoisted_1$f)) : createCommentVNode("", true)];
    }),
    _: 1
  })) : (openBlock(), createBlock(_component_GalleriaContent, mergeProps({
    key: 1,
    templates: _ctx.$slots,
    onActiveitemChange: $options.onActiveItemChange,
    pt: _ctx.pt,
    unstyled: _ctx.unstyled
  }, _ctx.$props), null, 16, ["templates", "onActiveitemChange", "pt", "unstyled"]));
}
__name(render$a, "render$a");
script$b.render = render$a;
const _sfc_main$d = /* @__PURE__ */ defineComponent({
  __name: "ResultGallery",
  props: {
    allGalleryItems: {},
    activeIndex: {}
  },
  emits: ["update:activeIndex"],
  setup(__props, { emit: __emit }) {
    const galleryVisible = ref(false);
    const emit2 = __emit;
    const props = __props;
    watch(
      () => props.activeIndex,
      (index2) => {
        if (index2 !== -1) {
          galleryVisible.value = true;
        }
      }
    );
    const handleVisibilityChange = /* @__PURE__ */ __name((visible) => {
      if (!visible) {
        emit2("update:activeIndex", -1);
      }
    }, "handleVisibilityChange");
    const handleActiveIndexChange = /* @__PURE__ */ __name((index2) => {
      emit2("update:activeIndex", index2);
    }, "handleActiveIndexChange");
    const handleKeyDown = /* @__PURE__ */ __name((event2) => {
      if (!galleryVisible.value) return;
      switch (event2.key) {
        case "ArrowLeft":
          navigateImage(-1);
          break;
        case "ArrowRight":
          navigateImage(1);
          break;
        case "Escape":
          galleryVisible.value = false;
          handleVisibilityChange(false);
          break;
      }
    }, "handleKeyDown");
    const navigateImage = /* @__PURE__ */ __name((direction) => {
      const newIndex = (props.activeIndex + direction + props.allGalleryItems.length) % props.allGalleryItems.length;
      emit2("update:activeIndex", newIndex);
    }, "navigateImage");
    onMounted(() => {
      window.addEventListener("keydown", handleKeyDown);
    });
    onUnmounted(() => {
      window.removeEventListener("keydown", handleKeyDown);
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(script$b), {
        visible: galleryVisible.value,
        "onUpdate:visible": [
          _cache[0] || (_cache[0] = ($event) => galleryVisible.value = $event),
          handleVisibilityChange
        ],
        activeIndex: _ctx.activeIndex,
        "onUpdate:activeIndex": handleActiveIndexChange,
        value: _ctx.allGalleryItems,
        showIndicators: false,
        changeItemOnIndicatorHover: "",
        showItemNavigators: "",
        fullScreen: "",
        circular: "",
        showThumbnails: false
      }, {
        item: withCtx(({ item: item2 }) => [
          (openBlock(), createBlock(ComfyImage, {
            key: item2.url,
            src: item2.url,
            contain: false,
            class: "galleria-image"
          }, null, 8, ["src"]))
        ]),
        _: 1
      }, 8, ["visible", "activeIndex", "value"]);
    };
  }
});
var theme$5 = /* @__PURE__ */ __name(function theme32(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-toolbar {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    flex-wrap: wrap;\n    padding: ".concat(dt3("toolbar.padding"), ";\n    background: ").concat(dt3("toolbar.background"), ";\n    border: 1px solid ").concat(dt3("toolbar.border.color"), ";\n    color: ").concat(dt3("toolbar.color"), ";\n    border-radius: ").concat(dt3("toolbar.border.radius"), ";\n    gap: ").concat(dt3("toolbar.gap"), ";\n}\n\n.p-toolbar-start,\n.p-toolbar-center,\n.p-toolbar-end {\n    display: flex;\n    align-items: center;\n}\n");
}, "theme");
var classes$5 = {
  root: "p-toolbar p-component",
  start: "p-toolbar-start",
  center: "p-toolbar-center",
  end: "p-toolbar-end"
};
var ToolbarStyle = BaseStyle.extend({
  name: "toolbar",
  theme: theme$5,
  classes: classes$5
});
var script$1$5 = {
  name: "BaseToolbar",
  "extends": script$X,
  props: {
    ariaLabelledby: {
      type: String,
      "default": null
    }
  },
  style: ToolbarStyle,
  provide: /* @__PURE__ */ __name(function provide35() {
    return {
      $pcToolbar: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$a = {
  name: "Toolbar",
  "extends": script$1$5,
  inheritAttrs: false
};
var _hoisted_1$e = ["aria-labelledby"];
function render$9(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("root"),
    role: "toolbar",
    "aria-labelledby": _ctx.ariaLabelledby
  }, _ctx.ptmi("root")), [createBaseVNode("div", mergeProps({
    "class": _ctx.cx("start")
  }, _ctx.ptm("start")), [renderSlot(_ctx.$slots, "start")], 16), createBaseVNode("div", mergeProps({
    "class": _ctx.cx("center")
  }, _ctx.ptm("center")), [renderSlot(_ctx.$slots, "center")], 16), createBaseVNode("div", mergeProps({
    "class": _ctx.cx("end")
  }, _ctx.ptm("end")), [renderSlot(_ctx.$slots, "end")], 16)], 16, _hoisted_1$e);
}
__name(render$9, "render$9");
script$a.render = render$9;
const _withScopeId$4 = /* @__PURE__ */ __name((n) => (pushScopeId("data-v-1b0a8fe3"), n = n(), popScopeId(), n), "_withScopeId$4");
const _hoisted_1$d = { class: "comfy-vue-side-bar-container" };
const _hoisted_2$8 = { class: "comfy-vue-side-bar-header-span" };
const _hoisted_3$4 = { class: "comfy-vue-side-bar-body" };
const _sfc_main$c = /* @__PURE__ */ defineComponent({
  __name: "SidebarTabTemplate",
  props: {
    title: {
      type: String,
      required: true
    }
  },
  setup(__props) {
    const props = __props;
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$d, [
        createVNode(unref(script$a), { class: "comfy-vue-side-bar-header" }, {
          start: withCtx(() => [
            createBaseVNode("span", _hoisted_2$8, toDisplayString$1(props.title.toUpperCase()), 1)
          ]),
          end: withCtx(() => [
            renderSlot(_ctx.$slots, "tool-buttons", {}, void 0, true)
          ]),
          _: 3
        }),
        createBaseVNode("div", _hoisted_3$4, [
          renderSlot(_ctx.$slots, "body", {}, void 0, true)
        ])
      ]);
    };
  }
});
const SidebarTabTemplate = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["__scopeId", "data-v-1b0a8fe3"]]);
const _withScopeId$3 = /* @__PURE__ */ __name((n) => (pushScopeId("data-v-3cc33869"), n = n(), popScopeId(), n), "_withScopeId$3");
const _hoisted_1$c = { class: "queue-grid" };
const _hoisted_2$7 = { key: 1 };
const _hoisted_3$3 = { key: 2 };
const IMAGE_FIT = "Comfy.Queue.ImageFit";
const ITEMS_PER_PAGE = 8;
const SCROLL_THRESHOLD = 100;
const _sfc_main$b = /* @__PURE__ */ defineComponent({
  __name: "QueueSidebarTab",
  setup(__props) {
    const confirm2 = useConfirm();
    const toast = useToast();
    const queueStore = useQueueStore();
    const settingStore = useSettingStore();
    const { t } = useI18n();
    const isExpanded = ref(false);
    const visibleTasks = ref([]);
    const scrollContainer = ref(null);
    const loadMoreTrigger = ref(null);
    const galleryActiveIndex = ref(-1);
    const folderTask = ref(null);
    const isInFolderView = computed(() => folderTask.value !== null);
    const imageFit = computed(() => settingStore.get(IMAGE_FIT));
    const allTasks = computed(
      () => isInFolderView.value ? folderTask.value ? folderTask.value.flatten() : [] : isExpanded.value ? queueStore.flatTasks : queueStore.tasks
    );
    const allGalleryItems = computed(
      () => allTasks.value.flatMap((task) => {
        const previewOutput = task.previewOutput;
        return previewOutput ? [previewOutput] : [];
      })
    );
    const loadMoreItems = /* @__PURE__ */ __name(() => {
      const currentLength = visibleTasks.value.length;
      const newTasks = allTasks.value.slice(
        currentLength,
        currentLength + ITEMS_PER_PAGE
      );
      visibleTasks.value.push(...newTasks);
    }, "loadMoreItems");
    const checkAndLoadMore = /* @__PURE__ */ __name(() => {
      if (!scrollContainer.value) return;
      const { scrollHeight: scrollHeight2, scrollTop: scrollTop2, clientHeight } = scrollContainer.value;
      if (scrollHeight2 - scrollTop2 - clientHeight < SCROLL_THRESHOLD) {
        loadMoreItems();
      }
    }, "checkAndLoadMore");
    useInfiniteScroll(
      scrollContainer,
      () => {
        if (visibleTasks.value.length < allTasks.value.length) {
          loadMoreItems();
        }
      },
      { distance: SCROLL_THRESHOLD }
    );
    useResizeObserver(scrollContainer, () => {
      nextTick(() => {
        checkAndLoadMore();
      });
    });
    const updateVisibleTasks = /* @__PURE__ */ __name(() => {
      visibleTasks.value = allTasks.value.slice(0, ITEMS_PER_PAGE);
    }, "updateVisibleTasks");
    const toggleExpanded = /* @__PURE__ */ __name(() => {
      isExpanded.value = !isExpanded.value;
      updateVisibleTasks();
    }, "toggleExpanded");
    const removeTask = /* @__PURE__ */ __name((task) => {
      if (task.isRunning) {
        api.interrupt();
      }
      queueStore.delete(task);
    }, "removeTask");
    const removeAllTasks = /* @__PURE__ */ __name(async () => {
      await queueStore.clear();
    }, "removeAllTasks");
    const confirmRemoveAll = /* @__PURE__ */ __name((event2) => {
      confirm2.require({
        target: event2.currentTarget,
        message: "Do you want to delete all tasks?",
        icon: "pi pi-info-circle",
        rejectProps: {
          label: "Cancel",
          severity: "secondary",
          outlined: true
        },
        acceptProps: {
          label: "Delete",
          severity: "danger"
        },
        accept: /* @__PURE__ */ __name(async () => {
          await removeAllTasks();
          toast.add({
            severity: "info",
            summary: "Confirmed",
            detail: "Tasks deleted",
            life: 3e3
          });
        }, "accept")
      });
    }, "confirmRemoveAll");
    const onStatus = /* @__PURE__ */ __name(async () => {
      await queueStore.update();
      updateVisibleTasks();
    }, "onStatus");
    const menu = ref(null);
    const menuTargetTask = ref(null);
    const menuTargetNode = ref(null);
    const menuItems = computed(() => [
      {
        label: t("delete"),
        icon: "pi pi-trash",
        command: /* @__PURE__ */ __name(() => menuTargetTask.value && removeTask(menuTargetTask.value), "command"),
        disabled: isExpanded.value || isInFolderView.value
      },
      {
        label: t("loadWorkflow"),
        icon: "pi pi-file-export",
        command: /* @__PURE__ */ __name(() => menuTargetTask.value?.loadWorkflow(), "command")
      },
      {
        label: t("goToNode"),
        icon: "pi pi-arrow-circle-right",
        command: /* @__PURE__ */ __name(() => app$1.goToNode(menuTargetNode.value?.id), "command"),
        visible: !!menuTargetNode.value
      }
    ]);
    const handleContextMenu = /* @__PURE__ */ __name(({
      task,
      event: event2,
      node: node3
    }) => {
      menuTargetTask.value = task;
      menuTargetNode.value = node3;
      menu.value?.show(event2);
    }, "handleContextMenu");
    const handlePreview = /* @__PURE__ */ __name((task) => {
      galleryActiveIndex.value = allGalleryItems.value.findIndex(
        (item2) => item2.url === task.previewOutput?.url
      );
    }, "handlePreview");
    const enterFolderView = /* @__PURE__ */ __name((task) => {
      folderTask.value = task;
      updateVisibleTasks();
    }, "enterFolderView");
    const exitFolderView = /* @__PURE__ */ __name(() => {
      folderTask.value = null;
      updateVisibleTasks();
    }, "exitFolderView");
    const toggleImageFit = /* @__PURE__ */ __name(() => {
      settingStore.set(IMAGE_FIT, imageFit.value === "cover" ? "contain" : "cover");
    }, "toggleImageFit");
    onMounted(() => {
      api.addEventListener("status", onStatus);
      queueStore.update();
    });
    onUnmounted(() => {
      api.removeEventListener("status", onStatus);
    });
    watch(
      allTasks,
      (newTasks) => {
        if (visibleTasks.value.length === 0 || visibleTasks.value.length > newTasks.length) {
          updateVisibleTasks();
        }
        nextTick(() => {
          checkAndLoadMore();
        });
      },
      { immediate: true }
    );
    return (_ctx, _cache) => {
      const _directive_tooltip = resolveDirective("tooltip");
      return openBlock(), createElementBlock(Fragment, null, [
        createVNode(SidebarTabTemplate, {
          title: _ctx.$t("sideToolbar.queue")
        }, {
          "tool-buttons": withCtx(() => [
            withDirectives(createVNode(unref(script$J), {
              icon: imageFit.value === "cover" ? "pi pi-arrow-down-left-and-arrow-up-right-to-center" : "pi pi-arrow-up-right-and-arrow-down-left-from-center",
              text: "",
              severity: "secondary",
              onClick: toggleImageFit,
              class: "toggle-expanded-button"
            }, null, 8, ["icon"]), [
              [_directive_tooltip, _ctx.$t(`sideToolbar.queueTab.${imageFit.value}ImagePreview`)]
            ]),
            isInFolderView.value ? withDirectives((openBlock(), createBlock(unref(script$J), {
              key: 0,
              icon: "pi pi-arrow-left",
              text: "",
              severity: "secondary",
              onClick: exitFolderView,
              class: "back-button"
            }, null, 512)), [
              [_directive_tooltip, _ctx.$t("sideToolbar.queueTab.backToAllTasks")]
            ]) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              withDirectives(createVNode(unref(script$J), {
                icon: isExpanded.value ? "pi pi-images" : "pi pi-image",
                text: "",
                severity: "secondary",
                onClick: toggleExpanded,
                class: "toggle-expanded-button"
              }, null, 8, ["icon"]), [
                [_directive_tooltip, _ctx.$t("sideToolbar.queueTab.showFlatList")]
              ]),
              createVNode(unref(script$J), {
                icon: "pi pi-trash",
                text: "",
                severity: "primary",
                onClick: _cache[0] || (_cache[0] = ($event) => confirmRemoveAll($event)),
                class: "clear-all-button"
              })
            ], 64))
          ]),
          body: withCtx(() => [
            visibleTasks.value.length > 0 ? (openBlock(), createElementBlock("div", {
              key: 0,
              ref_key: "scrollContainer",
              ref: scrollContainer,
              class: "scroll-container"
            }, [
              createBaseVNode("div", _hoisted_1$c, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(visibleTasks.value, (task) => {
                  return openBlock(), createBlock(TaskItem, {
                    key: task.key,
                    task,
                    isFlatTask: isExpanded.value || isInFolderView.value,
                    onContextmenu: handleContextMenu,
                    onPreview: handlePreview,
                    onTaskOutputLengthClicked: _cache[1] || (_cache[1] = ($event) => enterFolderView($event))
                  }, null, 8, ["task", "isFlatTask"]);
                }), 128))
              ]),
              createBaseVNode("div", {
                ref_key: "loadMoreTrigger",
                ref: loadMoreTrigger,
                style: { "height": "1px" }
              }, null, 512)
            ], 512)) : unref(queueStore).isLoading ? (openBlock(), createElementBlock("div", _hoisted_2$7, [
              createVNode(unref(script$V), { style: { "width": "50px", "left": "50%", "transform": "translateX(-50%)" } })
            ])) : (openBlock(), createElementBlock("div", _hoisted_3$3, [
              createVNode(NoResultsPlaceholder, {
                icon: "pi pi-info-circle",
                title: _ctx.$t("noTasksFound"),
                message: _ctx.$t("noTasksFoundMessage")
              }, null, 8, ["title", "message"])
            ]))
          ]),
          _: 1
        }, 8, ["title"]),
        createVNode(unref(script$h)),
        createVNode(unref(script$f), {
          ref_key: "menu",
          ref: menu,
          model: menuItems.value
        }, null, 8, ["model"]),
        createVNode(_sfc_main$d, {
          activeIndex: galleryActiveIndex.value,
          "onUpdate:activeIndex": _cache[2] || (_cache[2] = ($event) => galleryActiveIndex.value = $event),
          allGalleryItems: allGalleryItems.value
        }, null, 8, ["activeIndex", "allGalleryItems"])
      ], 64);
    };
  }
});
const QueueSidebarTab = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["__scopeId", "data-v-3cc33869"]]);
var theme$4 = /* @__PURE__ */ __name(function theme33(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-popover {\n    margin-top: ".concat(dt3("popover.gutter"), ";\n    background: ").concat(dt3("popover.background"), ";\n    color: ").concat(dt3("popover.color"), ";\n    border: 1px solid ").concat(dt3("popover.border.color"), ";\n    border-radius: ").concat(dt3("popover.border.radius"), ";\n    box-shadow: ").concat(dt3("popover.shadow"), ";\n}\n\n.p-popover-content {\n    padding: ").concat(dt3("popover.content.padding"), ";\n}\n\n.p-popover-flipped {\n    margin-top: calc(").concat(dt3("popover.gutter"), " * -1);\n    margin-bottom: ").concat(dt3("popover.gutter"), ";\n}\n\n.p-popover-enter-from {\n    opacity: 0;\n    transform: scaleY(0.8);\n}\n\n.p-popover-leave-to {\n    opacity: 0;\n}\n\n.p-popover-enter-active {\n    transition: transform 0.12s cubic-bezier(0, 0, 0.2, 1), opacity 0.12s cubic-bezier(0, 0, 0.2, 1);\n}\n\n.p-popover-leave-active {\n    transition: opacity 0.1s linear;\n}\n\n.p-popover:after,\n.p-popover:before {\n    bottom: 100%;\n    left: ").concat(dt3("popover.arrow.offset"), ';\n    content: " ";\n    height: 0;\n    width: 0;\n    position: absolute;\n    pointer-events: none;\n}\n\n.p-popover:after {\n    border-width: calc(').concat(dt3("popover.gutter"), " - 2px);\n    margin-left: calc(-1 * (").concat(dt3("popover.gutter"), " - 2px));\n    border-style: solid;\n    border-color: transparent;\n    border-bottom-color: ").concat(dt3("popover.background"), ";\n}\n\n.p-popover:before {\n    border-width: ").concat(dt3("popover.gutter"), ";\n    margin-left: calc(-1 * ").concat(dt3("popover.gutter"), ");\n    border-style: solid;\n    border-color: transparent;\n    border-bottom-color: ").concat(dt3("popover.border.color"), ";\n}\n\n.p-popover-flipped:after,\n.p-popover-flipped:before {\n    bottom: auto;\n    top: 100%;\n}\n\n.p-popover.p-popover-flipped:after {\n    border-bottom-color: transparent;\n    border-top-color: ").concat(dt3("popover.background"), ";\n}\n\n.p-popover.p-popover-flipped:before {\n    border-bottom-color: transparent;\n    border-top-color: ").concat(dt3("popover.border.color"), ";\n}\n");
}, "theme");
var classes$4 = {
  root: "p-popover p-component",
  content: "p-popover-content"
};
var PopoverStyle = BaseStyle.extend({
  name: "popover",
  theme: theme$4,
  classes: classes$4
});
var script$1$4 = {
  name: "BasePopover",
  "extends": script$X,
  props: {
    dismissable: {
      type: Boolean,
      "default": true
    },
    appendTo: {
      type: [String, Object],
      "default": "body"
    },
    baseZIndex: {
      type: Number,
      "default": 0
    },
    autoZIndex: {
      type: Boolean,
      "default": true
    },
    breakpoints: {
      type: Object,
      "default": null
    },
    closeOnEscape: {
      type: Boolean,
      "default": true
    }
  },
  style: PopoverStyle,
  provide: /* @__PURE__ */ __name(function provide36() {
    return {
      $pcPopover: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$9 = {
  name: "Popover",
  "extends": script$1$4,
  inheritAttrs: false,
  emits: ["show", "hide"],
  data: /* @__PURE__ */ __name(function data19() {
    return {
      visible: false
    };
  }, "data"),
  watch: {
    dismissable: {
      immediate: true,
      handler: /* @__PURE__ */ __name(function handler4(newValue) {
        if (newValue) {
          this.bindOutsideClickListener();
        } else {
          this.unbindOutsideClickListener();
        }
      }, "handler")
    }
  },
  selfClick: false,
  target: null,
  eventTarget: null,
  outsideClickListener: null,
  scrollHandler: null,
  resizeListener: null,
  container: null,
  styleElement: null,
  overlayEventListener: null,
  documentKeydownListener: null,
  beforeUnmount: /* @__PURE__ */ __name(function beforeUnmount13() {
    if (this.dismissable) {
      this.unbindOutsideClickListener();
    }
    if (this.scrollHandler) {
      this.scrollHandler.destroy();
      this.scrollHandler = null;
    }
    this.destroyStyle();
    this.unbindResizeListener();
    this.target = null;
    if (this.container && this.autoZIndex) {
      ZIndex.clear(this.container);
    }
    if (this.overlayEventListener) {
      OverlayEventBus.off("overlay-click", this.overlayEventListener);
      this.overlayEventListener = null;
    }
    this.container = null;
  }, "beforeUnmount"),
  mounted: /* @__PURE__ */ __name(function mounted18() {
    if (this.breakpoints) {
      this.createStyle();
    }
  }, "mounted"),
  methods: {
    toggle: /* @__PURE__ */ __name(function toggle2(event2, target) {
      if (this.visible) this.hide();
      else this.show(event2, target);
    }, "toggle"),
    show: /* @__PURE__ */ __name(function show5(event2, target) {
      this.visible = true;
      this.eventTarget = event2.currentTarget;
      this.target = target || event2.currentTarget;
    }, "show"),
    hide: /* @__PURE__ */ __name(function hide5() {
      this.visible = false;
    }, "hide"),
    onContentClick: /* @__PURE__ */ __name(function onContentClick() {
      this.selfClick = true;
    }, "onContentClick"),
    onEnter: /* @__PURE__ */ __name(function onEnter6(el) {
      var _this = this;
      this.container.setAttribute(this.attributeSelector, "");
      addStyle(el, {
        position: "absolute",
        top: "0",
        left: "0"
      });
      this.alignOverlay();
      if (this.dismissable) {
        this.bindOutsideClickListener();
      }
      this.bindScrollListener();
      this.bindResizeListener();
      if (this.autoZIndex) {
        ZIndex.set("overlay", el, this.baseZIndex + this.$primevue.config.zIndex.overlay);
      }
      this.overlayEventListener = function(e) {
        if (_this.container.contains(e.target)) {
          _this.selfClick = true;
        }
      };
      this.focus();
      OverlayEventBus.on("overlay-click", this.overlayEventListener);
      this.$emit("show");
      if (this.closeOnEscape) {
        this.bindDocumentKeyDownListener();
      }
    }, "onEnter"),
    onLeave: /* @__PURE__ */ __name(function onLeave4() {
      this.unbindOutsideClickListener();
      this.unbindScrollListener();
      this.unbindResizeListener();
      this.unbindDocumentKeyDownListener();
      OverlayEventBus.off("overlay-click", this.overlayEventListener);
      this.overlayEventListener = null;
      this.$emit("hide");
    }, "onLeave"),
    onAfterLeave: /* @__PURE__ */ __name(function onAfterLeave5(el) {
      if (this.autoZIndex) {
        ZIndex.clear(el);
      }
    }, "onAfterLeave"),
    alignOverlay: /* @__PURE__ */ __name(function alignOverlay5() {
      absolutePosition(this.container, this.target, false);
      var containerOffset = getOffset(this.container);
      var targetOffset = getOffset(this.target);
      var arrowLeft = 0;
      if (containerOffset.left < targetOffset.left) {
        arrowLeft = targetOffset.left - containerOffset.left;
      }
      this.container.style.setProperty($dt("popover.arrow.left").name, "".concat(arrowLeft, "px"));
      if (containerOffset.top < targetOffset.top) {
        this.container.setAttribute("data-p-popover-flipped", "true");
        !this.isUnstyled && addClass(this.container, "p-popover-flipped");
      }
    }, "alignOverlay"),
    onContentKeydown: /* @__PURE__ */ __name(function onContentKeydown(event2) {
      if (event2.code === "Escape" && this.closeOnEscape) {
        this.hide();
        focus(this.target);
      }
    }, "onContentKeydown"),
    onButtonKeydown: /* @__PURE__ */ __name(function onButtonKeydown(event2) {
      switch (event2.code) {
        case "ArrowDown":
        case "ArrowUp":
        case "ArrowLeft":
        case "ArrowRight":
          event2.preventDefault();
      }
    }, "onButtonKeydown"),
    focus: /* @__PURE__ */ __name(function focus4() {
      var focusTarget = this.container.querySelector("[autofocus]");
      if (focusTarget) {
        focusTarget.focus();
      }
    }, "focus"),
    onKeyDown: /* @__PURE__ */ __name(function onKeyDown8(event2) {
      if (event2.code === "Escape" && this.closeOnEscape) {
        this.visible = false;
      }
    }, "onKeyDown"),
    bindDocumentKeyDownListener: /* @__PURE__ */ __name(function bindDocumentKeyDownListener2() {
      if (!this.documentKeydownListener) {
        this.documentKeydownListener = this.onKeyDown.bind(this);
        window.document.addEventListener("keydown", this.documentKeydownListener);
      }
    }, "bindDocumentKeyDownListener"),
    unbindDocumentKeyDownListener: /* @__PURE__ */ __name(function unbindDocumentKeyDownListener2() {
      if (this.documentKeydownListener) {
        window.document.removeEventListener("keydown", this.documentKeydownListener);
        this.documentKeydownListener = null;
      }
    }, "unbindDocumentKeyDownListener"),
    bindOutsideClickListener: /* @__PURE__ */ __name(function bindOutsideClickListener5() {
      var _this2 = this;
      if (!this.outsideClickListener && isClient$1()) {
        this.outsideClickListener = function(event2) {
          if (_this2.visible && !_this2.selfClick && !_this2.isTargetClicked(event2)) {
            _this2.visible = false;
          }
          _this2.selfClick = false;
        };
        document.addEventListener("click", this.outsideClickListener);
      }
    }, "bindOutsideClickListener"),
    unbindOutsideClickListener: /* @__PURE__ */ __name(function unbindOutsideClickListener5() {
      if (this.outsideClickListener) {
        document.removeEventListener("click", this.outsideClickListener);
        this.outsideClickListener = null;
        this.selfClick = false;
      }
    }, "unbindOutsideClickListener"),
    bindScrollListener: /* @__PURE__ */ __name(function bindScrollListener5() {
      var _this3 = this;
      if (!this.scrollHandler) {
        this.scrollHandler = new ConnectedOverlayScrollHandler(this.target, function() {
          if (_this3.visible) {
            _this3.visible = false;
          }
        });
      }
      this.scrollHandler.bindScrollListener();
    }, "bindScrollListener"),
    unbindScrollListener: /* @__PURE__ */ __name(function unbindScrollListener5() {
      if (this.scrollHandler) {
        this.scrollHandler.unbindScrollListener();
      }
    }, "unbindScrollListener"),
    bindResizeListener: /* @__PURE__ */ __name(function bindResizeListener6() {
      var _this4 = this;
      if (!this.resizeListener) {
        this.resizeListener = function() {
          if (_this4.visible && !isTouchDevice()) {
            _this4.visible = false;
          }
        };
        window.addEventListener("resize", this.resizeListener);
      }
    }, "bindResizeListener"),
    unbindResizeListener: /* @__PURE__ */ __name(function unbindResizeListener6() {
      if (this.resizeListener) {
        window.removeEventListener("resize", this.resizeListener);
        this.resizeListener = null;
      }
    }, "unbindResizeListener"),
    isTargetClicked: /* @__PURE__ */ __name(function isTargetClicked2(event2) {
      return this.eventTarget && (this.eventTarget === event2.target || this.eventTarget.contains(event2.target));
    }, "isTargetClicked"),
    containerRef: /* @__PURE__ */ __name(function containerRef5(el) {
      this.container = el;
    }, "containerRef"),
    createStyle: /* @__PURE__ */ __name(function createStyle3() {
      if (!this.styleElement && !this.isUnstyled) {
        var _this$$primevue;
        this.styleElement = document.createElement("style");
        this.styleElement.type = "text/css";
        setAttribute(this.styleElement, "nonce", (_this$$primevue = this.$primevue) === null || _this$$primevue === void 0 || (_this$$primevue = _this$$primevue.config) === null || _this$$primevue === void 0 || (_this$$primevue = _this$$primevue.csp) === null || _this$$primevue === void 0 ? void 0 : _this$$primevue.nonce);
        document.head.appendChild(this.styleElement);
        var innerHTML = "";
        for (var breakpoint in this.breakpoints) {
          innerHTML += "\n                        @media screen and (max-width: ".concat(breakpoint, ") {\n                            .p-popover[").concat(this.attributeSelector, "] {\n                                width: ").concat(this.breakpoints[breakpoint], " !important;\n                            }\n                        }\n                    ");
        }
        this.styleElement.innerHTML = innerHTML;
      }
    }, "createStyle"),
    destroyStyle: /* @__PURE__ */ __name(function destroyStyle2() {
      if (this.styleElement) {
        document.head.removeChild(this.styleElement);
        this.styleElement = null;
      }
    }, "destroyStyle"),
    onOverlayClick: /* @__PURE__ */ __name(function onOverlayClick4(event2) {
      OverlayEventBus.emit("overlay-click", {
        originalEvent: event2,
        target: this.target
      });
    }, "onOverlayClick")
  },
  computed: {
    attributeSelector: /* @__PURE__ */ __name(function attributeSelector2() {
      return UniqueComponentId();
    }, "attributeSelector")
  },
  directives: {
    focustrap: FocusTrap,
    ripple: Ripple
  },
  components: {
    Portal: script$z
  }
};
var _hoisted_1$b = ["aria-modal"];
function render$8(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_Portal = resolveComponent("Portal");
  var _directive_focustrap = resolveDirective("focustrap");
  return openBlock(), createBlock(_component_Portal, {
    appendTo: _ctx.appendTo
  }, {
    "default": withCtx(function() {
      return [createVNode(Transition, mergeProps({
        name: "p-popover",
        onEnter: $options.onEnter,
        onLeave: $options.onLeave,
        onAfterLeave: $options.onAfterLeave
      }, _ctx.ptm("transition")), {
        "default": withCtx(function() {
          return [$data.visible ? withDirectives((openBlock(), createElementBlock("div", mergeProps({
            key: 0,
            ref: $options.containerRef,
            role: "dialog",
            "aria-modal": $data.visible,
            onClick: _cache[3] || (_cache[3] = function() {
              return $options.onOverlayClick && $options.onOverlayClick.apply($options, arguments);
            }),
            "class": _ctx.cx("root")
          }, _ctx.ptmi("root")), [_ctx.$slots.container ? renderSlot(_ctx.$slots, "container", {
            key: 0,
            closeCallback: $options.hide,
            keydownCallback: /* @__PURE__ */ __name(function keydownCallback(event2) {
              return $options.onButtonKeydown(event2);
            }, "keydownCallback")
          }) : (openBlock(), createElementBlock("div", mergeProps({
            key: 1,
            "class": _ctx.cx("content"),
            onClick: _cache[0] || (_cache[0] = function() {
              return $options.onContentClick && $options.onContentClick.apply($options, arguments);
            }),
            onMousedown: _cache[1] || (_cache[1] = function() {
              return $options.onContentClick && $options.onContentClick.apply($options, arguments);
            }),
            onKeydown: _cache[2] || (_cache[2] = function() {
              return $options.onContentKeydown && $options.onContentKeydown.apply($options, arguments);
            })
          }, _ctx.ptm("content")), [renderSlot(_ctx.$slots, "default")], 16))], 16, _hoisted_1$b)), [[_directive_focustrap]]) : createCommentVNode("", true)];
        }),
        _: 3
      }, 16, ["onEnter", "onLeave", "onAfterLeave"])];
    }),
    _: 3
  }, 8, ["appendTo"]);
}
__name(render$8, "render$8");
script$9.render = render$8;
var theme$3 = /* @__PURE__ */ __name(function theme34(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-tree {\n    background: ".concat(dt3("tree.background"), ";\n    color: ").concat(dt3("tree.color"), ";\n    padding: ").concat(dt3("tree.padding"), ";\n}\n\n.p-tree-root-children,\n.p-tree-node-children {\n    display: flex;\n    list-style-type: none;\n    flex-direction: column;\n    margin: 0;\n    gap: ").concat(dt3("tree.gap"), ";\n}\n\n.p-tree-root-children {\n    padding: ").concat(dt3("tree.gap"), " 0 0 0;\n}\n\n.p-tree-node-children {\n    padding: ").concat(dt3("tree.gap"), " 0 0 ").concat(dt3("tree.indent"), ";\n}\n\n.p-tree-node {\n    padding: 0;\n    outline: 0 none;\n}\n\n.p-tree-node-content {\n    border-radius: ").concat(dt3("tree.node.border.radius"), ";\n    padding: ").concat(dt3("tree.node.padding"), ";\n    display: flex;\n    align-items: center;\n    outline-color: transparent;\n    color: ").concat(dt3("tree.node.color"), ";\n    gap: ").concat(dt3("tree.node.gap"), ";\n    transition: background ").concat(dt3("tree.transition.duration"), ", color ").concat(dt3("tree.transition.duration"), ", outline-color ").concat(dt3("tree.transition.duration"), ", box-shadow ").concat(dt3("tree.transition.duration"), ";\n}\n\n.p-tree-node:focus-visible > .p-tree-node-content {\n    box-shadow: ").concat(dt3("tree.node.focus.ring.shadow"), ";\n    outline: ").concat(dt3("tree.node.focus.ring.width"), " ").concat(dt3("tree.node.focus.ring.style"), " ").concat(dt3("tree.node.focus.ring.color"), ";\n    outline-offset: ").concat(dt3("tree.node.focus.ring.offset"), ";\n}\n\n.p-tree-node-content.p-tree-node-selectable:not(.p-tree-node-selected):hover {\n    background: ").concat(dt3("tree.node.hover.background"), ";\n    color: ").concat(dt3("tree.node.hover.color"), ";\n}\n\n.p-tree-node-content.p-tree-node-selectable:not(.p-tree-node-selected):hover .p-tree-node-icon {\n    color: ").concat(dt3("tree.node.icon.hover.color"), ";\n}\n\n.p-tree-node-content.p-tree-node-selected {\n    background: ").concat(dt3("tree.node.selected.background"), ";\n    color: ").concat(dt3("tree.node.selected.color"), ";\n}\n\n.p-tree-node-content.p-tree-node-selected .p-tree-node-toggle-button {\n    color: inherit;\n}\n\n.p-tree-node-toggle-button {\n    cursor: pointer;\n    user-select: none;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    overflow: hidden;\n    position: relative;\n    flex-shrink: 0;\n    width: ").concat(dt3("tree.node.toggle.button.size"), ";\n    height: ").concat(dt3("tree.node.toggle.button.size"), ";\n    color: ").concat(dt3("tree.node.toggle.button.color"), ";\n    border: 0 none;\n    background: transparent;\n    border-radius: ").concat(dt3("tree.node.toggle.button.border.radius"), ";\n    transition: background ").concat(dt3("tree.transition.duration"), ", color ").concat(dt3("tree.transition.duration"), ", border-color ").concat(dt3("tree.transition.duration"), ", outline-color ").concat(dt3("tree.transition.duration"), ", box-shadow ").concat(dt3("tree.transition.duration"), ";\n    outline-color: transparent;\n    padding: 0;\n}\n\n.p-tree-node-toggle-button:enabled:hover {\n    background: ").concat(dt3("tree.node.toggle.button.hover.background"), ";\n    color: ").concat(dt3("tree.node.toggle.button.hover.color"), ";\n}\n\n.p-tree-node-content.p-tree-node-selected .p-tree-node-toggle-button:hover {\n    background: ").concat(dt3("tree.node.toggle.button.selected.hover.background"), ";\n    color: ").concat(dt3("tree.node.toggle.button.selected.hover.color"), ";\n}\n\n.p-tree-root {\n    overflow: auto;\n}\n\n.p-tree-node-selectable {\n    cursor: pointer;\n    user-select: none;\n}\n\n.p-tree-node-leaf > .p-tree-node-content .p-tree-node-toggle-button {\n    visibility: hidden;\n}\n\n.p-tree-node-icon {\n    color: ").concat(dt3("tree.node.icon.color"), ";\n    transition: color ").concat(dt3("tree.transition.duration"), ";\n}\n\n.p-tree-node-content.p-tree-node-selected .p-tree-node-icon {\n    color: ").concat(dt3("tree.node.icon.selected.color"), ";\n}\n\n.p-tree-filter-input {\n    width: 100%;\n}\n\n.p-tree-loading {\n    position: relative;\n    height: 100%;\n}\n\n.p-tree-loading-icon {\n    font-size: ").concat(dt3("tree.loading.icon.size"), ";\n    width: ").concat(dt3("tree.loading.icon.size"), ";\n    height: ").concat(dt3("tree.loading.icon.size"), ";\n}\n\n.p-tree .p-tree-mask {\n    position: absolute;\n    z-index: 1;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.p-tree-flex-scrollable {\n    display: flex;\n    flex: 1;\n    height: 100%;\n    flex-direction: column;\n}\n\n.p-tree-flex-scrollable .p-tree-root {\n    flex: 1;\n}\n");
}, "theme");
var classes$3 = {
  root: /* @__PURE__ */ __name(function root22(_ref2) {
    var props = _ref2.props;
    return ["p-tree p-component", {
      "p-tree-selectable": props.selectionMode != null,
      "p-tree-loading": props.loading,
      "p-tree-flex-scrollable": props.scrollHeight === "flex"
    }];
  }, "root"),
  mask: "p-tree-mask p-overlay-mask",
  loadingIcon: "p-tree-loading-icon",
  pcFilterInput: "p-tree-filter-input",
  wrapper: "p-tree-root",
  //TODO: discuss
  rootChildren: "p-tree-root-children",
  node: /* @__PURE__ */ __name(function node2(_ref3) {
    var instance = _ref3.instance;
    return ["p-tree-node", {
      "p-tree-node-leaf": instance.leaf
    }];
  }, "node"),
  nodeContent: /* @__PURE__ */ __name(function nodeContent(_ref4) {
    var instance = _ref4.instance;
    return ["p-tree-node-content", instance.node.styleClass, {
      "p-tree-node-selectable": instance.selectable,
      "p-tree-node-selected": instance.checkboxMode && instance.$parentInstance.highlightOnSelect ? instance.checked : instance.selected
    }];
  }, "nodeContent"),
  nodeToggleButton: "p-tree-node-toggle-button",
  nodeToggleIcon: "p-tree-node-toggle-icon",
  nodeCheckbox: "p-tree-node-checkbox",
  nodeIcon: "p-tree-node-icon",
  nodeLabel: "p-tree-node-label",
  nodeChildren: "p-tree-node-children"
};
var TreeStyle = BaseStyle.extend({
  name: "tree",
  theme: theme$3,
  classes: classes$3
});
var script$8 = {
  name: "MinusIcon",
  "extends": script$U
};
var _hoisted_1$a = /* @__PURE__ */ createBaseVNode("path", {
  d: "M13.2222 7.77778H0.777778C0.571498 7.77778 0.373667 7.69584 0.227806 7.54998C0.0819442 7.40412 0 7.20629 0 7.00001C0 6.79373 0.0819442 6.5959 0.227806 6.45003C0.373667 6.30417 0.571498 6.22223 0.777778 6.22223H13.2222C13.4285 6.22223 13.6263 6.30417 13.7722 6.45003C13.9181 6.5959 14 6.79373 14 7.00001C14 7.20629 13.9181 7.40412 13.7722 7.54998C13.6263 7.69584 13.4285 7.77778 13.2222 7.77778Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$6 = [_hoisted_1$a];
function render$7(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$6, 16);
}
__name(render$7, "render$7");
script$8.render = render$7;
var theme$2 = /* @__PURE__ */ __name(function theme35(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-checkbox {\n    position: relative;\n    display: inline-flex;\n    user-select: none;\n    vertical-align: bottom;\n    width: ".concat(dt3("checkbox.width"), ";\n    height: ").concat(dt3("checkbox.height"), ";\n}\n\n.p-checkbox-input {\n    cursor: pointer;\n    appearance: none;\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    padding: 0;\n    margin: 0;\n    opacity: 0;\n    z-index: 1;\n    outline: 0 none;\n    border: 1px solid transparent;\n    border-radius: ").concat(dt3("checkbox.border.radius"), ";\n}\n\n.p-checkbox-box {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    border-radius: ").concat(dt3("checkbox.border.radius"), ";\n    border: 1px solid ").concat(dt3("checkbox.border.color"), ";\n    background: ").concat(dt3("checkbox.background"), ";\n    width: ").concat(dt3("checkbox.width"), ";\n    height: ").concat(dt3("checkbox.height"), ";\n    transition: background ").concat(dt3("checkbox.transition.duration"), ", color ").concat(dt3("checkbox.transition.duration"), ", border-color ").concat(dt3("checkbox.transition.duration"), ", box-shadow ").concat(dt3("checkbox.transition.duration"), ", outline-color ").concat(dt3("checkbox.transition.duration"), ";\n    outline-color: transparent;\n    box-shadow: ").concat(dt3("checkbox.shadow"), ";\n}\n\n.p-checkbox-icon {\n    transition-duration: ").concat(dt3("checkbox.transition.duration"), ";\n    color: ").concat(dt3("checkbox.icon.color"), ";\n    font-size: ").concat(dt3("checkbox.icon.size"), ";\n    width: ").concat(dt3("checkbox.icon.size"), ";\n    height: ").concat(dt3("checkbox.icon.size"), ";\n}\n\n.p-checkbox:not(.p-disabled):has(.p-checkbox-input:hover) .p-checkbox-box {\n    border-color: ").concat(dt3("checkbox.hover.border.color"), ";\n}\n\n.p-checkbox-checked .p-checkbox-box {\n    border-color: ").concat(dt3("checkbox.checked.border.color"), ";\n    background: ").concat(dt3("checkbox.checked.background"), ";\n}\n\n.p-checkbox-checked .p-checkbox-icon {\n    color: ").concat(dt3("checkbox.icon.checked.color"), ";\n}\n\n.p-checkbox-checked:not(.p-disabled):has(.p-checkbox-input:hover) .p-checkbox-box {\n    background: ").concat(dt3("checkbox.checked.hover.background"), ";\n    border-color: ").concat(dt3("checkbox.checked.hover.border.color"), ";\n}\n\n.p-checkbox-checked:not(.p-disabled):has(.p-checkbox-input:hover) .p-checkbox-icon {\n    color: ").concat(dt3("checkbox.icon.checked.hover.color"), ";\n}\n\n.p-checkbox:not(.p-disabled):has(.p-checkbox-input:focus-visible) .p-checkbox-box {\n    border-color: ").concat(dt3("checkbox.focus.border.color"), ";\n    box-shadow: ").concat(dt3("checkbox.focus.ring.shadow"), ";\n    outline: ").concat(dt3("checkbox.focus.ring.width"), " ").concat(dt3("checkbox.focus.ring.style"), " ").concat(dt3("checkbox.focus.ring.color"), ";\n    outline-offset: ").concat(dt3("checkbox.focus.ring.offset"), ";\n}\n\n.p-checkbox-checked:not(.p-disabled):has(.p-checkbox-input:focus-visible) .p-checkbox-box {\n    border-color: ").concat(dt3("checkbox.checked.focus.border.color"), ";\n}\n\n.p-checkbox.p-invalid > .p-checkbox-box {\n    border-color: ").concat(dt3("checkbox.invalid.border.color"), ";\n}\n\n.p-checkbox.p-variant-filled .p-checkbox-box {\n    background: ").concat(dt3("checkbox.filled.background"), ";\n}\n\n.p-checkbox-checked.p-variant-filled .p-checkbox-box {\n    background: ").concat(dt3("checkbox.checked.background"), ";\n}\n\n.p-checkbox-checked.p-variant-filled:not(.p-disabled):has(.p-checkbox-input:hover) .p-checkbox-box {\n    background: ").concat(dt3("checkbox.checked.hover.background"), ";\n}\n\n.p-checkbox.p-disabled {\n    opacity: 1;\n}\n\n.p-checkbox.p-disabled .p-checkbox-box {\n    background: ").concat(dt3("checkbox.disabled.background"), ";\n    border-color: ").concat(dt3("checkbox.checked.disabled.border.color"), ";\n}\n\n.p-checkbox.p-disabled .p-checkbox-box .p-checkbox-icon {\n    color: ").concat(dt3("checkbox.icon.disabled.color"), ";\n}\n");
}, "theme");
var classes$2 = {
  root: /* @__PURE__ */ __name(function root23(_ref2) {
    var instance = _ref2.instance, props = _ref2.props;
    return ["p-checkbox p-component", {
      "p-checkbox-checked": instance.checked,
      "p-disabled": props.disabled,
      "p-invalid": props.invalid,
      "p-variant-filled": props.variant ? props.variant === "filled" : instance.$primevue.config.inputStyle === "filled" || instance.$primevue.config.inputVariant === "filled"
    }];
  }, "root"),
  box: "p-checkbox-box",
  input: "p-checkbox-input",
  icon: "p-checkbox-icon"
};
var CheckboxStyle = BaseStyle.extend({
  name: "checkbox",
  theme: theme$2,
  classes: classes$2
});
var script$1$3 = {
  name: "BaseCheckbox",
  "extends": script$X,
  props: {
    value: null,
    modelValue: null,
    binary: Boolean,
    name: {
      type: String,
      "default": null
    },
    indeterminate: {
      type: Boolean,
      "default": false
    },
    trueValue: {
      type: null,
      "default": true
    },
    falseValue: {
      type: null,
      "default": false
    },
    variant: {
      type: String,
      "default": null
    },
    invalid: {
      type: Boolean,
      "default": false
    },
    disabled: {
      type: Boolean,
      "default": false
    },
    readonly: {
      type: Boolean,
      "default": false
    },
    required: {
      type: Boolean,
      "default": false
    },
    tabindex: {
      type: Number,
      "default": null
    },
    inputId: {
      type: String,
      "default": null
    },
    inputClass: {
      type: [String, Object],
      "default": null
    },
    inputStyle: {
      type: Object,
      "default": null
    },
    ariaLabelledby: {
      type: String,
      "default": null
    },
    ariaLabel: {
      type: String,
      "default": null
    }
  },
  style: CheckboxStyle,
  provide: /* @__PURE__ */ __name(function provide37() {
    return {
      $pcCheckbox: this,
      $parentInstance: this
    };
  }, "provide")
};
function _toConsumableArray$3(r) {
  return _arrayWithoutHoles$3(r) || _iterableToArray$3(r) || _unsupportedIterableToArray$3(r) || _nonIterableSpread$3();
}
__name(_toConsumableArray$3, "_toConsumableArray$3");
function _nonIterableSpread$3() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableSpread$3, "_nonIterableSpread$3");
function _unsupportedIterableToArray$3(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$3(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$3(r, a) : void 0;
  }
}
__name(_unsupportedIterableToArray$3, "_unsupportedIterableToArray$3");
function _iterableToArray$3(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
__name(_iterableToArray$3, "_iterableToArray$3");
function _arrayWithoutHoles$3(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$3(r);
}
__name(_arrayWithoutHoles$3, "_arrayWithoutHoles$3");
function _arrayLikeToArray$3(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
__name(_arrayLikeToArray$3, "_arrayLikeToArray$3");
var script$7 = {
  name: "Checkbox",
  "extends": script$1$3,
  inheritAttrs: false,
  emits: ["update:modelValue", "change", "focus", "blur", "update:indeterminate"],
  data: /* @__PURE__ */ __name(function data20() {
    return {
      d_indeterminate: this.indeterminate
    };
  }, "data"),
  watch: {
    indeterminate: /* @__PURE__ */ __name(function indeterminate(newValue) {
      this.d_indeterminate = newValue;
    }, "indeterminate")
  },
  methods: {
    getPTOptions: /* @__PURE__ */ __name(function getPTOptions12(key) {
      var _ptm = key === "root" ? this.ptmi : this.ptm;
      return _ptm(key, {
        context: {
          checked: this.checked,
          disabled: this.disabled
        }
      });
    }, "getPTOptions"),
    onChange: /* @__PURE__ */ __name(function onChange4(event2) {
      var _this = this;
      if (!this.disabled && !this.readonly) {
        var newModelValue;
        if (this.binary) {
          newModelValue = this.d_indeterminate ? this.trueValue : this.checked ? this.falseValue : this.trueValue;
        } else {
          if (this.checked || this.d_indeterminate) newModelValue = this.modelValue.filter(function(val) {
            return !equals(val, _this.value);
          });
          else newModelValue = this.modelValue ? [].concat(_toConsumableArray$3(this.modelValue), [this.value]) : [this.value];
        }
        if (this.d_indeterminate) {
          this.d_indeterminate = false;
          this.$emit("update:indeterminate", this.d_indeterminate);
        }
        this.$emit("update:modelValue", newModelValue);
        this.$emit("change", event2);
      }
    }, "onChange"),
    onFocus: /* @__PURE__ */ __name(function onFocus7(event2) {
      this.$emit("focus", event2);
    }, "onFocus"),
    onBlur: /* @__PURE__ */ __name(function onBlur7(event2) {
      this.$emit("blur", event2);
    }, "onBlur")
  },
  computed: {
    checked: /* @__PURE__ */ __name(function checked2() {
      return this.d_indeterminate ? false : this.binary ? this.modelValue === this.trueValue : contains(this.value, this.modelValue);
    }, "checked")
  },
  components: {
    CheckIcon: script$S,
    MinusIcon: script$8
  }
};
var _hoisted_1$9 = ["data-p-checked", "data-p-indeterminate", "data-p-disabled"];
var _hoisted_2$5 = ["id", "value", "name", "checked", "tabindex", "disabled", "readonly", "required", "aria-labelledby", "aria-label", "aria-invalid", "aria-checked"];
function render$6(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_CheckIcon = resolveComponent("CheckIcon");
  var _component_MinusIcon = resolveComponent("MinusIcon");
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("root")
  }, $options.getPTOptions("root"), {
    "data-p-checked": $options.checked,
    "data-p-indeterminate": $data.d_indeterminate || void 0,
    "data-p-disabled": _ctx.disabled
  }), [createBaseVNode("input", mergeProps({
    id: _ctx.inputId,
    type: "checkbox",
    "class": [_ctx.cx("input"), _ctx.inputClass],
    style: _ctx.inputStyle,
    value: _ctx.value,
    name: _ctx.name,
    checked: $options.checked,
    tabindex: _ctx.tabindex,
    disabled: _ctx.disabled,
    readonly: _ctx.readonly,
    required: _ctx.required,
    "aria-labelledby": _ctx.ariaLabelledby,
    "aria-label": _ctx.ariaLabel,
    "aria-invalid": _ctx.invalid || void 0,
    "aria-checked": $data.d_indeterminate ? "mixed" : void 0,
    onFocus: _cache[0] || (_cache[0] = function() {
      return $options.onFocus && $options.onFocus.apply($options, arguments);
    }),
    onBlur: _cache[1] || (_cache[1] = function() {
      return $options.onBlur && $options.onBlur.apply($options, arguments);
    }),
    onChange: _cache[2] || (_cache[2] = function() {
      return $options.onChange && $options.onChange.apply($options, arguments);
    })
  }, $options.getPTOptions("input")), null, 16, _hoisted_2$5), createBaseVNode("div", mergeProps({
    "class": _ctx.cx("box")
  }, $options.getPTOptions("box")), [renderSlot(_ctx.$slots, "icon", {
    checked: $options.checked,
    indeterminate: $data.d_indeterminate,
    "class": normalizeClass(_ctx.cx("icon"))
  }, function() {
    return [$options.checked ? (openBlock(), createBlock(_component_CheckIcon, mergeProps({
      key: 0,
      "class": _ctx.cx("icon")
    }, $options.getPTOptions("icon")), null, 16, ["class"])) : $data.d_indeterminate ? (openBlock(), createBlock(_component_MinusIcon, mergeProps({
      key: 1,
      "class": _ctx.cx("icon")
    }, $options.getPTOptions("icon")), null, 16, ["class"])) : createCommentVNode("", true)];
  })], 16)], 16, _hoisted_1$9);
}
__name(render$6, "render$6");
script$7.render = render$6;
var script$2$1 = {
  name: "BaseTree",
  "extends": script$X,
  props: {
    value: {
      type: null,
      "default": null
    },
    expandedKeys: {
      type: null,
      "default": null
    },
    selectionKeys: {
      type: null,
      "default": null
    },
    selectionMode: {
      type: String,
      "default": null
    },
    metaKeySelection: {
      type: Boolean,
      "default": false
    },
    loading: {
      type: Boolean,
      "default": false
    },
    loadingIcon: {
      type: String,
      "default": void 0
    },
    loadingMode: {
      type: String,
      "default": "mask"
    },
    filter: {
      type: Boolean,
      "default": false
    },
    filterBy: {
      type: String,
      "default": "label"
    },
    filterMode: {
      type: String,
      "default": "lenient"
    },
    filterPlaceholder: {
      type: String,
      "default": null
    },
    filterLocale: {
      type: String,
      "default": void 0
    },
    highlightOnSelect: {
      type: Boolean,
      "default": false
    },
    scrollHeight: {
      type: String,
      "default": null
    },
    level: {
      type: Number,
      "default": 0
    },
    ariaLabelledby: {
      type: String,
      "default": null
    },
    ariaLabel: {
      type: String,
      "default": null
    }
  },
  style: TreeStyle,
  provide: /* @__PURE__ */ __name(function provide38() {
    return {
      $pcTree: this,
      $parentInstance: this
    };
  }, "provide")
};
function _typeof$1$1(o) {
  "@babel/helpers - typeof";
  return _typeof$1$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$1$1(o);
}
__name(_typeof$1$1, "_typeof$1$1");
function _createForOfIteratorHelper$1(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (!t) {
    if (Array.isArray(r) || (t = _unsupportedIterableToArray$1(r)) || e) {
      t && (r = t);
      var _n = 0, F = /* @__PURE__ */ __name(function F2() {
      }, "F");
      return { s: F, n: /* @__PURE__ */ __name(function n() {
        return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
      }, "n"), e: /* @__PURE__ */ __name(function e2(r2) {
        throw r2;
      }, "e"), f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o, a = true, u = false;
  return { s: /* @__PURE__ */ __name(function s() {
    t = t.call(r);
  }, "s"), n: /* @__PURE__ */ __name(function n() {
    var r2 = t.next();
    return a = r2.done, r2;
  }, "n"), e: /* @__PURE__ */ __name(function e2(r2) {
    u = true, o = r2;
  }, "e"), f: /* @__PURE__ */ __name(function f() {
    try {
      a || null == t["return"] || t["return"]();
    } finally {
      if (u) throw o;
    }
  }, "f") };
}
__name(_createForOfIteratorHelper$1, "_createForOfIteratorHelper$1");
function ownKeys$1$1(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
__name(ownKeys$1$1, "ownKeys$1$1");
function _objectSpread$1$1(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$1$1(Object(t), true).forEach(function(r2) {
      _defineProperty$1$1(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1$1(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
__name(_objectSpread$1$1, "_objectSpread$1$1");
function _defineProperty$1$1(e, r, t) {
  return (r = _toPropertyKey$1$1(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty$1$1, "_defineProperty$1$1");
function _toPropertyKey$1$1(t) {
  var i2 = _toPrimitive$1$1(t, "string");
  return "symbol" == _typeof$1$1(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$1$1, "_toPropertyKey$1$1");
function _toPrimitive$1$1(t, r) {
  if ("object" != _typeof$1$1(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$1$1(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive$1$1, "_toPrimitive$1$1");
function _toConsumableArray$1(r) {
  return _arrayWithoutHoles$1(r) || _iterableToArray$1(r) || _unsupportedIterableToArray$1(r) || _nonIterableSpread$1();
}
__name(_toConsumableArray$1, "_toConsumableArray$1");
function _nonIterableSpread$1() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableSpread$1, "_nonIterableSpread$1");
function _unsupportedIterableToArray$1(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$1(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$1(r, a) : void 0;
  }
}
__name(_unsupportedIterableToArray$1, "_unsupportedIterableToArray$1");
function _iterableToArray$1(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
__name(_iterableToArray$1, "_iterableToArray$1");
function _arrayWithoutHoles$1(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$1(r);
}
__name(_arrayWithoutHoles$1, "_arrayWithoutHoles$1");
function _arrayLikeToArray$1(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
__name(_arrayLikeToArray$1, "_arrayLikeToArray$1");
var script$1$2 = {
  name: "TreeNode",
  hostName: "Tree",
  "extends": script$X,
  emits: ["node-toggle", "node-click", "checkbox-change"],
  props: {
    node: {
      type: null,
      "default": null
    },
    expandedKeys: {
      type: null,
      "default": null
    },
    loadingMode: {
      type: String,
      "default": "mask"
    },
    selectionKeys: {
      type: null,
      "default": null
    },
    selectionMode: {
      type: String,
      "default": null
    },
    templates: {
      type: null,
      "default": null
    },
    level: {
      type: Number,
      "default": null
    },
    index: null
  },
  nodeTouched: false,
  toggleClicked: false,
  mounted: /* @__PURE__ */ __name(function mounted19() {
    this.setAllNodesTabIndexes();
  }, "mounted"),
  methods: {
    toggle: /* @__PURE__ */ __name(function toggle3() {
      this.$emit("node-toggle", this.node);
      this.toggleClicked = true;
    }, "toggle"),
    label: /* @__PURE__ */ __name(function label4(node3) {
      return typeof node3.label === "function" ? node3.label() : node3.label;
    }, "label"),
    onChildNodeToggle: /* @__PURE__ */ __name(function onChildNodeToggle(node3) {
      this.$emit("node-toggle", node3);
    }, "onChildNodeToggle"),
    getPTOptions: /* @__PURE__ */ __name(function getPTOptions13(key) {
      return this.ptm(key, {
        context: {
          index: this.index,
          expanded: this.expanded,
          selected: this.selected,
          checked: this.checked,
          leaf: this.leaf
        }
      });
    }, "getPTOptions"),
    onClick: /* @__PURE__ */ __name(function onClick2(event2) {
      if (this.toggleClicked || getAttribute(event2.target, '[data-pc-section="nodetogglebutton"]') || getAttribute(event2.target.parentElement, '[data-pc-section="nodetogglebutton"]')) {
        this.toggleClicked = false;
        return;
      }
      if (this.isCheckboxSelectionMode()) {
        this.toggleCheckbox();
      } else {
        this.$emit("node-click", {
          originalEvent: event2,
          nodeTouched: this.nodeTouched,
          node: this.node
        });
      }
      this.nodeTouched = false;
    }, "onClick"),
    onChildNodeClick: /* @__PURE__ */ __name(function onChildNodeClick(event2) {
      this.$emit("node-click", event2);
    }, "onChildNodeClick"),
    onTouchEnd: /* @__PURE__ */ __name(function onTouchEnd2() {
      this.nodeTouched = true;
    }, "onTouchEnd"),
    onKeyDown: /* @__PURE__ */ __name(function onKeyDown9(event2) {
      if (!this.isSameNode(event2)) return;
      switch (event2.code) {
        case "Tab":
          this.onTabKey(event2);
          break;
        case "ArrowDown":
          this.onArrowDown(event2);
          break;
        case "ArrowUp":
          this.onArrowUp(event2);
          break;
        case "ArrowRight":
          this.onArrowRight(event2);
          break;
        case "ArrowLeft":
          this.onArrowLeft(event2);
          break;
        case "Enter":
        case "NumpadEnter":
        case "Space":
          this.onEnterKey(event2);
          break;
      }
    }, "onKeyDown"),
    onArrowDown: /* @__PURE__ */ __name(function onArrowDown(event2) {
      var nodeElement = event2.target.getAttribute("data-pc-section") === "nodetogglebutton" ? event2.target.closest('[role="treeitem"]') : event2.target;
      var listElement = nodeElement.children[1];
      if (listElement) {
        this.focusRowChange(nodeElement, listElement.children[0]);
      } else {
        if (nodeElement.nextElementSibling) {
          this.focusRowChange(nodeElement, nodeElement.nextElementSibling);
        } else {
          var nextSiblingAncestor = this.findNextSiblingOfAncestor(nodeElement);
          if (nextSiblingAncestor) {
            this.focusRowChange(nodeElement, nextSiblingAncestor);
          }
        }
      }
      event2.preventDefault();
    }, "onArrowDown"),
    onArrowUp: /* @__PURE__ */ __name(function onArrowUp(event2) {
      var nodeElement = event2.target;
      if (nodeElement.previousElementSibling) {
        this.focusRowChange(nodeElement, nodeElement.previousElementSibling, this.findLastVisibleDescendant(nodeElement.previousElementSibling));
      } else {
        var parentNodeElement = this.getParentNodeElement(nodeElement);
        if (parentNodeElement) {
          this.focusRowChange(nodeElement, parentNodeElement);
        }
      }
      event2.preventDefault();
    }, "onArrowUp"),
    onArrowRight: /* @__PURE__ */ __name(function onArrowRight(event2) {
      var _this = this;
      if (this.leaf || this.expanded) return;
      event2.currentTarget.tabIndex = -1;
      this.$emit("node-toggle", this.node);
      this.$nextTick(function() {
        _this.onArrowDown(event2);
      });
    }, "onArrowRight"),
    onArrowLeft: /* @__PURE__ */ __name(function onArrowLeft(event2) {
      var togglerElement = findSingle(event2.currentTarget, '[data-pc-section="nodetogglebutton"]');
      if (this.level === 0 && !this.expanded) {
        return false;
      }
      if (this.expanded && !this.leaf) {
        togglerElement.click();
        return false;
      }
      var target = this.findBeforeClickableNode(event2.currentTarget);
      if (target) {
        this.focusRowChange(event2.currentTarget, target);
      }
    }, "onArrowLeft"),
    onEnterKey: /* @__PURE__ */ __name(function onEnterKey5(event2) {
      this.setTabIndexForSelectionMode(event2, this.nodeTouched);
      this.onClick(event2);
      event2.preventDefault();
    }, "onEnterKey"),
    onTabKey: /* @__PURE__ */ __name(function onTabKey6() {
      this.setAllNodesTabIndexes();
    }, "onTabKey"),
    setAllNodesTabIndexes: /* @__PURE__ */ __name(function setAllNodesTabIndexes() {
      var nodes = find(this.$refs.currentNode.closest('[data-pc-section="rootchildren"]'), '[role="treeitem"]');
      var hasSelectedNode = _toConsumableArray$1(nodes).some(function(node3) {
        return node3.getAttribute("aria-selected") === "true" || node3.getAttribute("aria-checked") === "true";
      });
      _toConsumableArray$1(nodes).forEach(function(node3) {
        node3.tabIndex = -1;
      });
      if (hasSelectedNode) {
        var selectedNodes = _toConsumableArray$1(nodes).filter(function(node3) {
          return node3.getAttribute("aria-selected") === "true" || node3.getAttribute("aria-checked") === "true";
        });
        selectedNodes[0].tabIndex = 0;
        return;
      }
      _toConsumableArray$1(nodes)[0].tabIndex = 0;
    }, "setAllNodesTabIndexes"),
    setTabIndexForSelectionMode: /* @__PURE__ */ __name(function setTabIndexForSelectionMode(event2, nodeTouched) {
      if (this.selectionMode !== null) {
        var elements = _toConsumableArray$1(find(this.$refs.currentNode.parentElement, '[role="treeitem"]'));
        event2.currentTarget.tabIndex = nodeTouched === false ? -1 : 0;
        if (elements.every(function(element) {
          return element.tabIndex === -1;
        })) {
          elements[0].tabIndex = 0;
        }
      }
    }, "setTabIndexForSelectionMode"),
    focusRowChange: /* @__PURE__ */ __name(function focusRowChange(firstFocusableRow, currentFocusedRow, lastVisibleDescendant) {
      firstFocusableRow.tabIndex = "-1";
      currentFocusedRow.tabIndex = "0";
      this.focusNode(lastVisibleDescendant || currentFocusedRow);
    }, "focusRowChange"),
    findBeforeClickableNode: /* @__PURE__ */ __name(function findBeforeClickableNode(node3) {
      var parentListElement = node3.closest("ul").closest("li");
      if (parentListElement) {
        var prevNodeButton = findSingle(parentListElement, "button");
        if (prevNodeButton && prevNodeButton.style.visibility !== "hidden") {
          return parentListElement;
        }
        return this.findBeforeClickableNode(node3.previousElementSibling);
      }
      return null;
    }, "findBeforeClickableNode"),
    toggleCheckbox: /* @__PURE__ */ __name(function toggleCheckbox() {
      var _selectionKeys = this.selectionKeys ? _objectSpread$1$1({}, this.selectionKeys) : {};
      var _check = !this.checked;
      this.propagateDown(this.node, _check, _selectionKeys);
      this.$emit("checkbox-change", {
        node: this.node,
        check: _check,
        selectionKeys: _selectionKeys
      });
    }, "toggleCheckbox"),
    propagateDown: /* @__PURE__ */ __name(function propagateDown(node3, check, selectionKeys) {
      if (check) selectionKeys[node3.key] = {
        checked: true,
        partialChecked: false
      };
      else delete selectionKeys[node3.key];
      if (node3.children && node3.children.length) {
        var _iterator = _createForOfIteratorHelper$1(node3.children), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var child = _step.value;
            this.propagateDown(child, check, selectionKeys);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    }, "propagateDown"),
    propagateUp: /* @__PURE__ */ __name(function propagateUp(event2) {
      var check = event2.check;
      var _selectionKeys = _objectSpread$1$1({}, event2.selectionKeys);
      var checkedChildCount = 0;
      var childPartialSelected = false;
      var _iterator2 = _createForOfIteratorHelper$1(this.node.children), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var child = _step2.value;
          if (_selectionKeys[child.key] && _selectionKeys[child.key].checked) checkedChildCount++;
          else if (_selectionKeys[child.key] && _selectionKeys[child.key].partialChecked) childPartialSelected = true;
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      if (check && checkedChildCount === this.node.children.length) {
        _selectionKeys[this.node.key] = {
          checked: true,
          partialChecked: false
        };
      } else {
        if (!check) {
          delete _selectionKeys[this.node.key];
        }
        if (childPartialSelected || checkedChildCount > 0 && checkedChildCount !== this.node.children.length) _selectionKeys[this.node.key] = {
          checked: false,
          partialChecked: true
        };
        else delete _selectionKeys[this.node.key];
      }
      this.$emit("checkbox-change", {
        node: event2.node,
        check: event2.check,
        selectionKeys: _selectionKeys
      });
    }, "propagateUp"),
    onChildCheckboxChange: /* @__PURE__ */ __name(function onChildCheckboxChange(event2) {
      this.$emit("checkbox-change", event2);
    }, "onChildCheckboxChange"),
    findNextSiblingOfAncestor: /* @__PURE__ */ __name(function findNextSiblingOfAncestor(nodeElement) {
      var parentNodeElement = this.getParentNodeElement(nodeElement);
      if (parentNodeElement) {
        if (parentNodeElement.nextElementSibling) return parentNodeElement.nextElementSibling;
        else return this.findNextSiblingOfAncestor(parentNodeElement);
      } else {
        return null;
      }
    }, "findNextSiblingOfAncestor"),
    findLastVisibleDescendant: /* @__PURE__ */ __name(function findLastVisibleDescendant(nodeElement) {
      var childrenListElement = nodeElement.children[1];
      if (childrenListElement) {
        var lastChildElement = childrenListElement.children[childrenListElement.children.length - 1];
        return this.findLastVisibleDescendant(lastChildElement);
      } else {
        return nodeElement;
      }
    }, "findLastVisibleDescendant"),
    getParentNodeElement: /* @__PURE__ */ __name(function getParentNodeElement(nodeElement) {
      var parentNodeElement = nodeElement.parentElement.parentElement;
      return getAttribute(parentNodeElement, "role") === "treeitem" ? parentNodeElement : null;
    }, "getParentNodeElement"),
    focusNode: /* @__PURE__ */ __name(function focusNode(element) {
      element.focus();
    }, "focusNode"),
    isCheckboxSelectionMode: /* @__PURE__ */ __name(function isCheckboxSelectionMode() {
      return this.selectionMode === "checkbox";
    }, "isCheckboxSelectionMode"),
    isSameNode: /* @__PURE__ */ __name(function isSameNode(event2) {
      return event2.currentTarget && (event2.currentTarget.isSameNode(event2.target) || event2.currentTarget.isSameNode(event2.target.closest('[role="treeitem"]')));
    }, "isSameNode")
  },
  computed: {
    hasChildren: /* @__PURE__ */ __name(function hasChildren() {
      return this.node.children && this.node.children.length > 0;
    }, "hasChildren"),
    expanded: /* @__PURE__ */ __name(function expanded() {
      return this.expandedKeys && this.expandedKeys[this.node.key] === true;
    }, "expanded"),
    leaf: /* @__PURE__ */ __name(function leaf() {
      return this.node.leaf === false ? false : !(this.node.children && this.node.children.length);
    }, "leaf"),
    selectable: /* @__PURE__ */ __name(function selectable() {
      return this.node.selectable === false ? false : this.selectionMode != null;
    }, "selectable"),
    selected: /* @__PURE__ */ __name(function selected() {
      return this.selectionMode && this.selectionKeys ? this.selectionKeys[this.node.key] === true : false;
    }, "selected"),
    checkboxMode: /* @__PURE__ */ __name(function checkboxMode() {
      return this.selectionMode === "checkbox" && this.node.selectable !== false;
    }, "checkboxMode"),
    checked: /* @__PURE__ */ __name(function checked3() {
      return this.selectionKeys ? this.selectionKeys[this.node.key] && this.selectionKeys[this.node.key].checked : false;
    }, "checked"),
    partialChecked: /* @__PURE__ */ __name(function partialChecked() {
      return this.selectionKeys ? this.selectionKeys[this.node.key] && this.selectionKeys[this.node.key].partialChecked : false;
    }, "partialChecked"),
    ariaChecked: /* @__PURE__ */ __name(function ariaChecked() {
      return this.selectionMode === "single" || this.selectionMode === "multiple" ? this.selected : void 0;
    }, "ariaChecked"),
    ariaSelected: /* @__PURE__ */ __name(function ariaSelected() {
      return this.checkboxMode ? this.checked : void 0;
    }, "ariaSelected")
  },
  components: {
    Checkbox: script$7,
    ChevronDownIcon: script$B,
    ChevronRightIcon: script$d,
    CheckIcon: script$S,
    MinusIcon: script$8,
    SpinnerIcon: script$N
  },
  directives: {
    ripple: Ripple
  }
};
var _hoisted_1$1$1 = ["aria-label", "aria-selected", "aria-expanded", "aria-setsize", "aria-posinset", "aria-level", "aria-checked", "tabindex"];
var _hoisted_2$4 = ["data-p-selected", "data-p-selectable"];
function render$1$1(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_SpinnerIcon = resolveComponent("SpinnerIcon");
  var _component_Checkbox = resolveComponent("Checkbox");
  var _component_TreeNode = resolveComponent("TreeNode", true);
  var _directive_ripple = resolveDirective("ripple");
  return openBlock(), createElementBlock("li", mergeProps({
    ref: "currentNode",
    "class": _ctx.cx("node"),
    role: "treeitem",
    "aria-label": $options.label($props.node),
    "aria-selected": $options.ariaSelected,
    "aria-expanded": $options.expanded,
    "aria-setsize": $props.node.children ? $props.node.children.length : 0,
    "aria-posinset": $props.index + 1,
    "aria-level": $props.level,
    "aria-checked": $options.ariaChecked,
    tabindex: $props.index === 0 ? 0 : -1,
    onKeydown: _cache[4] || (_cache[4] = function() {
      return $options.onKeyDown && $options.onKeyDown.apply($options, arguments);
    })
  }, $props.level === 1 ? $options.getPTOptions("node") : _ctx.ptm("nodeChildren")), [createBaseVNode("div", mergeProps({
    "class": _ctx.cx("nodeContent"),
    onClick: _cache[2] || (_cache[2] = function() {
      return $options.onClick && $options.onClick.apply($options, arguments);
    }),
    onTouchend: _cache[3] || (_cache[3] = function() {
      return $options.onTouchEnd && $options.onTouchEnd.apply($options, arguments);
    }),
    style: $props.node.style
  }, $options.getPTOptions("nodeContent"), {
    "data-p-selected": $options.checkboxMode ? $options.checked : $options.selected,
    "data-p-selectable": $options.selectable
  }), [withDirectives((openBlock(), createElementBlock("button", mergeProps({
    type: "button",
    "class": _ctx.cx("nodeToggleButton"),
    onClick: _cache[0] || (_cache[0] = function() {
      return $options.toggle && $options.toggle.apply($options, arguments);
    }),
    tabindex: "-1",
    "aria-hidden": "true"
  }, $options.getPTOptions("nodeToggleButton")), [$props.node.loading && $props.loadingMode === "icon" ? (openBlock(), createElementBlock(Fragment, {
    key: 0
  }, [$props.templates["nodetoggleicon"] || $props.templates["nodetogglericon"] ? (openBlock(), createBlock(resolveDynamicComponent($props.templates["nodetoggleicon"] || $props.templates["nodetogglericon"]), {
    key: 0,
    "class": normalizeClass(_ctx.cx("nodeToggleIcon"))
  }, null, 8, ["class"])) : (openBlock(), createBlock(_component_SpinnerIcon, mergeProps({
    key: 1,
    spin: "",
    "class": _ctx.cx("nodetogglericon")
  }, _ctx.ptm("nodeToggleIcon")), null, 16, ["class"]))], 64)) : (openBlock(), createElementBlock(Fragment, {
    key: 1
  }, [$props.templates["nodetoggleicon"] || $props.templates["togglericon"] ? (openBlock(), createBlock(resolveDynamicComponent($props.templates["nodetoggleicon"] || $props.templates["togglericon"]), {
    key: 0,
    node: $props.node,
    expanded: $options.expanded,
    "class": normalizeClass(_ctx.cx("nodeToggleIcon"))
  }, null, 8, ["node", "expanded", "class"])) : $options.expanded ? (openBlock(), createBlock(resolveDynamicComponent($props.node.expandedIcon ? "span" : "ChevronDownIcon"), mergeProps({
    key: 1,
    "class": _ctx.cx("nodeToggleIcon")
  }, $options.getPTOptions("nodeToggleIcon")), null, 16, ["class"])) : (openBlock(), createBlock(resolveDynamicComponent($props.node.collapsedIcon ? "span" : "ChevronRightIcon"), mergeProps({
    key: 2,
    "class": _ctx.cx("nodeToggleIcon")
  }, $options.getPTOptions("nodeToggleIcon")), null, 16, ["class"]))], 64))], 16)), [[_directive_ripple]]), $options.checkboxMode ? (openBlock(), createBlock(_component_Checkbox, {
    key: 0,
    modelValue: $options.checked,
    binary: true,
    indeterminate: $options.partialChecked,
    "class": normalizeClass(_ctx.cx("nodeCheckbox")),
    tabindex: -1,
    unstyled: _ctx.unstyled,
    pt: $options.getPTOptions("nodeCheckbox"),
    "data-p-partialchecked": $options.partialChecked
  }, {
    icon: withCtx(function(slotProps) {
      return [$props.templates["checkboxicon"] ? (openBlock(), createBlock(resolveDynamicComponent($props.templates["checkboxicon"]), {
        key: 0,
        checked: slotProps.checked,
        partialChecked: $options.partialChecked,
        "class": normalizeClass(slotProps["class"])
      }, null, 8, ["checked", "partialChecked", "class"])) : createCommentVNode("", true)];
    }),
    _: 1
  }, 8, ["modelValue", "indeterminate", "class", "unstyled", "pt", "data-p-partialchecked"])) : createCommentVNode("", true), $props.templates["nodeicon"] ? (openBlock(), createBlock(resolveDynamicComponent($props.templates["nodeicon"]), mergeProps({
    key: 1,
    node: $props.node,
    "class": [_ctx.cx("nodeIcon")]
  }, $options.getPTOptions("nodeIcon")), null, 16, ["node", "class"])) : (openBlock(), createElementBlock("span", mergeProps({
    key: 2,
    "class": [_ctx.cx("nodeIcon"), $props.node.icon]
  }, $options.getPTOptions("nodeIcon")), null, 16)), createBaseVNode("span", mergeProps({
    "class": _ctx.cx("nodeLabel")
  }, $options.getPTOptions("nodeLabel"), {
    onKeydown: _cache[1] || (_cache[1] = withModifiers(function() {
    }, ["stop"]))
  }), [$props.templates[$props.node.type] || $props.templates["default"] ? (openBlock(), createBlock(resolveDynamicComponent($props.templates[$props.node.type] || $props.templates["default"]), {
    key: 0,
    node: $props.node,
    selected: $options.checkboxMode ? $options.checked : $options.selected
  }, null, 8, ["node", "selected"])) : (openBlock(), createElementBlock(Fragment, {
    key: 1
  }, [createTextVNode(toDisplayString$1($options.label($props.node)), 1)], 64))], 16)], 16, _hoisted_2$4), $options.hasChildren && $options.expanded ? (openBlock(), createElementBlock("ul", mergeProps({
    key: 0,
    "class": _ctx.cx("nodeChildren"),
    role: "group"
  }, _ctx.ptm("nodeChildren")), [(openBlock(true), createElementBlock(Fragment, null, renderList($props.node.children, function(childNode) {
    return openBlock(), createBlock(_component_TreeNode, {
      key: childNode.key,
      node: childNode,
      templates: $props.templates,
      level: $props.level + 1,
      loadingMode: $props.loadingMode,
      expandedKeys: $props.expandedKeys,
      onNodeToggle: $options.onChildNodeToggle,
      onNodeClick: $options.onChildNodeClick,
      selectionMode: $props.selectionMode,
      selectionKeys: $props.selectionKeys,
      onCheckboxChange: $options.propagateUp,
      unstyled: _ctx.unstyled,
      pt: _ctx.pt
    }, null, 8, ["node", "templates", "level", "loadingMode", "expandedKeys", "onNodeToggle", "onNodeClick", "selectionMode", "selectionKeys", "onCheckboxChange", "unstyled", "pt"]);
  }), 128))], 16)) : createCommentVNode("", true)], 16, _hoisted_1$1$1);
}
__name(render$1$1, "render$1$1");
script$1$2.render = render$1$1;
function _typeof$3(o) {
  "@babel/helpers - typeof";
  return _typeof$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$3(o);
}
__name(_typeof$3, "_typeof$3");
function _createForOfIteratorHelper(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (!t) {
    if (Array.isArray(r) || (t = _unsupportedIterableToArray$2(r)) || e) {
      t && (r = t);
      var _n = 0, F = /* @__PURE__ */ __name(function F2() {
      }, "F");
      return { s: F, n: /* @__PURE__ */ __name(function n() {
        return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
      }, "n"), e: /* @__PURE__ */ __name(function e2(r2) {
        throw r2;
      }, "e"), f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o, a = true, u = false;
  return { s: /* @__PURE__ */ __name(function s() {
    t = t.call(r);
  }, "s"), n: /* @__PURE__ */ __name(function n() {
    var r2 = t.next();
    return a = r2.done, r2;
  }, "n"), e: /* @__PURE__ */ __name(function e2(r2) {
    u = true, o = r2;
  }, "e"), f: /* @__PURE__ */ __name(function f() {
    try {
      a || null == t["return"] || t["return"]();
    } finally {
      if (u) throw o;
    }
  }, "f") };
}
__name(_createForOfIteratorHelper, "_createForOfIteratorHelper");
function _toConsumableArray$2(r) {
  return _arrayWithoutHoles$2(r) || _iterableToArray$2(r) || _unsupportedIterableToArray$2(r) || _nonIterableSpread$2();
}
__name(_toConsumableArray$2, "_toConsumableArray$2");
function _nonIterableSpread$2() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableSpread$2, "_nonIterableSpread$2");
function _unsupportedIterableToArray$2(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$2(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$2(r, a) : void 0;
  }
}
__name(_unsupportedIterableToArray$2, "_unsupportedIterableToArray$2");
function _iterableToArray$2(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
__name(_iterableToArray$2, "_iterableToArray$2");
function _arrayWithoutHoles$2(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$2(r);
}
__name(_arrayWithoutHoles$2, "_arrayWithoutHoles$2");
function _arrayLikeToArray$2(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
__name(_arrayLikeToArray$2, "_arrayLikeToArray$2");
function ownKeys$2(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
__name(ownKeys$2, "ownKeys$2");
function _objectSpread$2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$2(Object(t), true).forEach(function(r2) {
      _defineProperty$3(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$2(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
__name(_objectSpread$2, "_objectSpread$2");
function _defineProperty$3(e, r, t) {
  return (r = _toPropertyKey$3(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty$3, "_defineProperty$3");
function _toPropertyKey$3(t) {
  var i2 = _toPrimitive$3(t, "string");
  return "symbol" == _typeof$3(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$3, "_toPropertyKey$3");
function _toPrimitive$3(t, r) {
  if ("object" != _typeof$3(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$3(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive$3, "_toPrimitive$3");
var script$6 = {
  name: "Tree",
  "extends": script$2$1,
  inheritAttrs: false,
  emits: ["node-expand", "node-collapse", "update:expandedKeys", "update:selectionKeys", "node-select", "node-unselect", "filter"],
  data: /* @__PURE__ */ __name(function data21() {
    return {
      d_expandedKeys: this.expandedKeys || {},
      filterValue: null
    };
  }, "data"),
  watch: {
    expandedKeys: /* @__PURE__ */ __name(function expandedKeys(newValue) {
      this.d_expandedKeys = newValue;
    }, "expandedKeys")
  },
  methods: {
    onNodeToggle: /* @__PURE__ */ __name(function onNodeToggle(node3) {
      var key = node3.key;
      if (this.d_expandedKeys[key]) {
        delete this.d_expandedKeys[key];
        this.$emit("node-collapse", node3);
      } else {
        this.d_expandedKeys[key] = true;
        this.$emit("node-expand", node3);
      }
      this.d_expandedKeys = _objectSpread$2({}, this.d_expandedKeys);
      this.$emit("update:expandedKeys", this.d_expandedKeys);
    }, "onNodeToggle"),
    onNodeClick: /* @__PURE__ */ __name(function onNodeClick(event2) {
      if (this.selectionMode != null && event2.node.selectable !== false) {
        var metaSelection = event2.nodeTouched ? false : this.metaKeySelection;
        var _selectionKeys = metaSelection ? this.handleSelectionWithMetaKey(event2) : this.handleSelectionWithoutMetaKey(event2);
        this.$emit("update:selectionKeys", _selectionKeys);
      }
    }, "onNodeClick"),
    onCheckboxChange: /* @__PURE__ */ __name(function onCheckboxChange(event2) {
      this.$emit("update:selectionKeys", event2.selectionKeys);
      if (event2.check) this.$emit("node-select", event2.node);
      else this.$emit("node-unselect", event2.node);
    }, "onCheckboxChange"),
    handleSelectionWithMetaKey: /* @__PURE__ */ __name(function handleSelectionWithMetaKey(event2) {
      var originalEvent = event2.originalEvent;
      var node3 = event2.node;
      var metaKey = originalEvent.metaKey || originalEvent.ctrlKey;
      var selected2 = this.isNodeSelected(node3);
      var _selectionKeys;
      if (selected2 && metaKey) {
        if (this.isSingleSelectionMode()) {
          _selectionKeys = {};
        } else {
          _selectionKeys = _objectSpread$2({}, this.selectionKeys);
          delete _selectionKeys[node3.key];
        }
        this.$emit("node-unselect", node3);
      } else {
        if (this.isSingleSelectionMode()) {
          _selectionKeys = {};
        } else if (this.isMultipleSelectionMode()) {
          _selectionKeys = !metaKey ? {} : this.selectionKeys ? _objectSpread$2({}, this.selectionKeys) : {};
        }
        _selectionKeys[node3.key] = true;
        this.$emit("node-select", node3);
      }
      return _selectionKeys;
    }, "handleSelectionWithMetaKey"),
    handleSelectionWithoutMetaKey: /* @__PURE__ */ __name(function handleSelectionWithoutMetaKey(event2) {
      var node3 = event2.node;
      var selected2 = this.isNodeSelected(node3);
      var _selectionKeys;
      if (this.isSingleSelectionMode()) {
        if (selected2) {
          _selectionKeys = {};
          this.$emit("node-unselect", node3);
        } else {
          _selectionKeys = {};
          _selectionKeys[node3.key] = true;
          this.$emit("node-select", node3);
        }
      } else {
        if (selected2) {
          _selectionKeys = _objectSpread$2({}, this.selectionKeys);
          delete _selectionKeys[node3.key];
          this.$emit("node-unselect", node3);
        } else {
          _selectionKeys = this.selectionKeys ? _objectSpread$2({}, this.selectionKeys) : {};
          _selectionKeys[node3.key] = true;
          this.$emit("node-select", node3);
        }
      }
      return _selectionKeys;
    }, "handleSelectionWithoutMetaKey"),
    isSingleSelectionMode: /* @__PURE__ */ __name(function isSingleSelectionMode() {
      return this.selectionMode === "single";
    }, "isSingleSelectionMode"),
    isMultipleSelectionMode: /* @__PURE__ */ __name(function isMultipleSelectionMode() {
      return this.selectionMode === "multiple";
    }, "isMultipleSelectionMode"),
    isNodeSelected: /* @__PURE__ */ __name(function isNodeSelected(node3) {
      return this.selectionMode && this.selectionKeys ? this.selectionKeys[node3.key] === true : false;
    }, "isNodeSelected"),
    isChecked: /* @__PURE__ */ __name(function isChecked(node3) {
      return this.selectionKeys ? this.selectionKeys[node3.key] && this.selectionKeys[node3.key].checked : false;
    }, "isChecked"),
    isNodeLeaf: /* @__PURE__ */ __name(function isNodeLeaf(node3) {
      return node3.leaf === false ? false : !(node3.children && node3.children.length);
    }, "isNodeLeaf"),
    onFilterKeydown: /* @__PURE__ */ __name(function onFilterKeydown(event2) {
      if (event2.code === "Enter" || event2.code === "NumpadEnter") {
        event2.preventDefault();
      }
      this.$emit("filter", {
        originalEvent: event2,
        value: event2.target.value
      });
    }, "onFilterKeydown"),
    findFilteredNodes: /* @__PURE__ */ __name(function findFilteredNodes(node3, paramsWithoutNode) {
      if (node3) {
        var matched = false;
        if (node3.children) {
          var childNodes = _toConsumableArray$2(node3.children);
          node3.children = [];
          var _iterator = _createForOfIteratorHelper(childNodes), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var childNode = _step.value;
              var copyChildNode = _objectSpread$2({}, childNode);
              if (this.isFilterMatched(copyChildNode, paramsWithoutNode)) {
                matched = true;
                node3.children.push(copyChildNode);
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
        if (matched) {
          return true;
        }
      }
    }, "findFilteredNodes"),
    isFilterMatched: /* @__PURE__ */ __name(function isFilterMatched(node3, _ref) {
      var searchFields3 = _ref.searchFields, filterText = _ref.filterText, strict = _ref.strict;
      var matched = false;
      var _iterator2 = _createForOfIteratorHelper(searchFields3), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var field = _step2.value;
          var fieldValue = String(resolveFieldData(node3, field)).toLocaleLowerCase(this.filterLocale);
          if (fieldValue.indexOf(filterText) > -1) {
            matched = true;
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      if (!matched || strict && !this.isNodeLeaf(node3)) {
        matched = this.findFilteredNodes(node3, {
          searchFields: searchFields3,
          filterText,
          strict
        }) || matched;
      }
      return matched;
    }, "isFilterMatched")
  },
  computed: {
    filteredValue: /* @__PURE__ */ __name(function filteredValue() {
      var filteredNodes = [];
      var searchFields3 = this.filterBy.split(",");
      var filterText = this.filterValue.trim().toLocaleLowerCase(this.filterLocale);
      var strict = this.filterMode === "strict";
      var _iterator3 = _createForOfIteratorHelper(this.value), _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
          var node3 = _step3.value;
          var _node = _objectSpread$2({}, node3);
          var paramsWithoutNode = {
            searchFields: searchFields3,
            filterText,
            strict
          };
          if (strict && (this.findFilteredNodes(_node, paramsWithoutNode) || this.isFilterMatched(_node, paramsWithoutNode)) || !strict && (this.isFilterMatched(_node, paramsWithoutNode) || this.findFilteredNodes(_node, paramsWithoutNode))) {
            filteredNodes.push(_node);
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      return filteredNodes;
    }, "filteredValue"),
    valueToRender: /* @__PURE__ */ __name(function valueToRender() {
      if (this.filterValue && this.filterValue.trim().length > 0) return this.filteredValue;
      else return this.value;
    }, "valueToRender")
  },
  components: {
    TreeNode: script$1$2,
    InputText: script$O,
    InputIcon: script$P,
    IconField: script$Q,
    SearchIcon: script$R,
    SpinnerIcon: script$N
  }
};
var _hoisted_1$8 = ["aria-labelledby", "aria-label"];
function render$5(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_SpinnerIcon = resolveComponent("SpinnerIcon");
  var _component_InputText = resolveComponent("InputText");
  var _component_SearchIcon = resolveComponent("SearchIcon");
  var _component_InputIcon = resolveComponent("InputIcon");
  var _component_IconField = resolveComponent("IconField");
  var _component_TreeNode = resolveComponent("TreeNode");
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("root")
  }, _ctx.ptmi("root")), [_ctx.loading && _ctx.loadingMode === "mask" ? (openBlock(), createElementBlock("div", mergeProps({
    key: 0,
    "class": _ctx.cx("mask")
  }, _ctx.ptm("mask")), [renderSlot(_ctx.$slots, "loadingicon", {
    "class": normalizeClass(_ctx.cx("loadingIcon"))
  }, function() {
    return [_ctx.loadingIcon ? (openBlock(), createElementBlock("i", mergeProps({
      key: 0,
      "class": [_ctx.cx("loadingIcon"), "pi-spin", _ctx.loadingIcon]
    }, _ctx.ptm("loadingIcon")), null, 16)) : (openBlock(), createBlock(_component_SpinnerIcon, mergeProps({
      key: 1,
      spin: "",
      "class": _ctx.cx("loadingIcon")
    }, _ctx.ptm("loadingIcon")), null, 16, ["class"]))];
  })], 16)) : createCommentVNode("", true), _ctx.filter ? (openBlock(), createBlock(_component_IconField, mergeProps({
    key: 1,
    unstyled: _ctx.unstyled
  }, _ctx.ptm("pcFilterContainer")), {
    "default": withCtx(function() {
      return [createVNode(_component_InputText, mergeProps({
        modelValue: $data.filterValue,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = function($event) {
          return $data.filterValue = $event;
        }),
        autocomplete: "off",
        "class": _ctx.cx("pcFilterInput"),
        placeholder: _ctx.filterPlaceholder,
        unstyled: _ctx.unstyled,
        onKeydown: $options.onFilterKeydown
      }, _ctx.ptm("pcFilterInput")), null, 16, ["modelValue", "class", "placeholder", "unstyled", "onKeydown"]), createVNode(_component_InputIcon, mergeProps({
        unstyled: _ctx.unstyled
      }, _ctx.ptm("pcFilterIconContainer")), {
        "default": withCtx(function() {
          return [renderSlot(_ctx.$slots, _ctx.$slots.filtericon ? "filtericon" : "searchicon", {
            "class": normalizeClass(_ctx.cx("filterIcon"))
          }, function() {
            return [createVNode(_component_SearchIcon, mergeProps({
              "class": _ctx.cx("filterIcon")
            }, _ctx.ptm("filterIcon")), null, 16, ["class"])];
          })];
        }),
        _: 3
      }, 16, ["unstyled"])];
    }),
    _: 3
  }, 16, ["unstyled"])) : createCommentVNode("", true), createBaseVNode("div", mergeProps({
    "class": _ctx.cx("wrapper"),
    style: {
      maxHeight: _ctx.scrollHeight
    }
  }, _ctx.ptm("wrapper")), [createBaseVNode("ul", mergeProps({
    "class": _ctx.cx("rootChildren"),
    role: "tree",
    "aria-labelledby": _ctx.ariaLabelledby,
    "aria-label": _ctx.ariaLabel
  }, _ctx.ptm("rootChildren")), [(openBlock(true), createElementBlock(Fragment, null, renderList($options.valueToRender, function(node3, index2) {
    return openBlock(), createBlock(_component_TreeNode, {
      key: node3.key,
      node: node3,
      templates: _ctx.$slots,
      level: _ctx.level + 1,
      index: index2,
      expandedKeys: $data.d_expandedKeys,
      onNodeToggle: $options.onNodeToggle,
      onNodeClick: $options.onNodeClick,
      selectionMode: _ctx.selectionMode,
      selectionKeys: _ctx.selectionKeys,
      onCheckboxChange: $options.onCheckboxChange,
      loadingMode: _ctx.loadingMode,
      unstyled: _ctx.unstyled,
      pt: _ctx.pt
    }, null, 8, ["node", "templates", "level", "index", "expandedKeys", "onNodeToggle", "onNodeClick", "selectionMode", "selectionKeys", "onCheckboxChange", "loadingMode", "unstyled", "pt"]);
  }), 128))], 16, _hoisted_1$8)], 16)], 16);
}
__name(render$5, "render$5");
script$6.render = render$5;
const _withScopeId$2 = /* @__PURE__ */ __name((n) => (pushScopeId("data-v-d4b7b060"), n = n(), popScopeId(), n), "_withScopeId$2");
const _hoisted_1$7 = { class: "node-content" };
const _hoisted_2$3 = { class: "node-label" };
const _hoisted_3$2 = { class: "node-actions" };
const _sfc_main$a = /* @__PURE__ */ defineComponent({
  __name: "TreeExplorerTreeNode",
  props: {
    node: {}
  },
  emits: ["itemDropped", "dragStart", "dragEnd"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const labelEditable = computed(() => !!props.node.handleRename);
    const renameEditingNode = inject("renameEditingNode");
    const isEditing = computed(
      () => labelEditable.value && renameEditingNode.value?.key === props.node.key
    );
    const handleRename = /* @__PURE__ */ __name((newName) => {
      props.node.handleRename(props.node, newName);
      renameEditingNode.value = null;
    }, "handleRename");
    const container = ref(null);
    const canDrop = ref(false);
    const treeNodeElement = ref(null);
    let dropTargetCleanup = /* @__PURE__ */ __name(() => {
    }, "dropTargetCleanup");
    let draggableCleanup = /* @__PURE__ */ __name(() => {
    }, "draggableCleanup");
    onMounted(() => {
      treeNodeElement.value = container.value?.closest(
        ".p-tree-node-content"
      );
      if (props.node.droppable) {
        dropTargetCleanup = dropTargetForElements({
          element: treeNodeElement.value,
          onDrop: /* @__PURE__ */ __name((event2) => {
            const dndData = event2.source.data;
            if (dndData.type === "tree-explorer-node") {
              props.node.handleDrop?.(props.node, dndData);
              canDrop.value = false;
              emit2("itemDropped", props.node, dndData.data);
            }
          }, "onDrop"),
          onDragEnter: /* @__PURE__ */ __name((event2) => {
            const dndData = event2.source.data;
            if (dndData.type === "tree-explorer-node") {
              canDrop.value = true;
            }
          }, "onDragEnter"),
          onDragLeave: /* @__PURE__ */ __name(() => {
            canDrop.value = false;
          }, "onDragLeave")
        });
      }
      if (props.node.draggable) {
        draggableCleanup = draggable({
          element: treeNodeElement.value,
          getInitialData() {
            return {
              type: "tree-explorer-node",
              data: props.node
            };
          },
          onDragStart: /* @__PURE__ */ __name(() => emit2("dragStart", props.node), "onDragStart"),
          onDrop: /* @__PURE__ */ __name(() => emit2("dragEnd", props.node), "onDrop")
        });
      }
    });
    onUnmounted(() => {
      dropTargetCleanup();
      draggableCleanup();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([
          "tree-node",
          {
            "can-drop": canDrop.value,
            "tree-folder": !props.node.leaf,
            "tree-leaf": props.node.leaf
          }
        ]),
        ref_key: "container",
        ref: container
      }, [
        createBaseVNode("div", _hoisted_1$7, [
          createBaseVNode("span", _hoisted_2$3, [
            renderSlot(_ctx.$slots, "before-label", {
              node: props.node
            }, void 0, true),
            createVNode(EditableText, {
              modelValue: _ctx.node.label,
              isEditing: isEditing.value,
              onEdit: handleRename
            }, null, 8, ["modelValue", "isEditing"]),
            renderSlot(_ctx.$slots, "after-label", {
              node: props.node
            }, void 0, true)
          ]),
          !props.node.leaf ? (openBlock(), createBlock(unref(script$K), {
            key: 0,
            value: props.node.totalLeaves,
            severity: "secondary",
            class: "leaf-count-badge"
          }, null, 8, ["value"])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_3$2, [
          renderSlot(_ctx.$slots, "actions", {
            node: props.node
          }, void 0, true)
        ])
      ], 2);
    };
  }
});
const TreeExplorerTreeNode = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["__scopeId", "data-v-d4b7b060"]]);
const _sfc_main$9 = /* @__PURE__ */ defineComponent({
  __name: "TreeExplorer",
  props: /* @__PURE__ */ mergeModels({
    roots: {},
    class: {},
    extraMenuItems: { type: [Array, Function] }
  }, {
    "expandedKeys": {},
    "expandedKeysModifiers": {}
  }),
  emits: /* @__PURE__ */ mergeModels(["nodeClick", "nodeDelete", "contextMenu"], ["update:expandedKeys"]),
  setup(__props, { expose: __expose, emit: __emit }) {
    const expandedKeys2 = useModel(__props, "expandedKeys");
    provide("expandedKeys", expandedKeys2);
    const props = __props;
    const emit2 = __emit;
    const renderedRoots = computed(() => {
      return props.roots.map(fillNodeInfo);
    });
    const getTreeNodeIcon = /* @__PURE__ */ __name((node3) => {
      if (node3.getIcon) {
        const icon2 = node3.getIcon(node3);
        if (icon2) {
          return icon2;
        }
      } else if (node3.icon) {
        return node3.icon;
      }
      if (node3.leaf) {
        return "pi pi-file";
      }
      const isExpanded = expandedKeys2.value[node3.key];
      return isExpanded ? "pi pi-folder-open" : "pi pi-folder";
    }, "getTreeNodeIcon");
    const fillNodeInfo = /* @__PURE__ */ __name((node3) => {
      const children = node3.children?.map(fillNodeInfo);
      return {
        ...node3,
        icon: getTreeNodeIcon(node3),
        children,
        type: node3.leaf ? "node" : "folder",
        totalLeaves: node3.leaf ? 1 : children.reduce((acc, child) => acc + child.totalLeaves, 0)
      };
    }, "fillNodeInfo");
    const onNodeContentClick = /* @__PURE__ */ __name((e, node3) => {
      emit2("nodeClick", node3, e);
    }, "onNodeContentClick");
    const menu = ref(null);
    const menuTargetNode = ref(null);
    provide("menuTargetNode", menuTargetNode);
    const renameEditingNode = ref(null);
    provide("renameEditingNode", renameEditingNode);
    const { t } = useI18n();
    const renameCommand = /* @__PURE__ */ __name((node3) => {
      renameEditingNode.value = node3;
    }, "renameCommand");
    const deleteCommand = /* @__PURE__ */ __name((node3) => {
      node3.handleDelete?.(node3);
      emit2("nodeDelete", node3);
    }, "deleteCommand");
    const menuItems = computed(() => [
      {
        label: t("rename"),
        icon: "pi pi-file-edit",
        command: /* @__PURE__ */ __name(() => renameCommand(menuTargetNode.value), "command"),
        visible: menuTargetNode.value?.handleRename !== void 0
      },
      {
        label: t("delete"),
        icon: "pi pi-trash",
        command: /* @__PURE__ */ __name(() => deleteCommand(menuTargetNode.value), "command"),
        visible: menuTargetNode.value?.handleDelete !== void 0
      },
      ...props.extraMenuItems ? typeof props.extraMenuItems === "function" ? props.extraMenuItems(menuTargetNode.value) : props.extraMenuItems : []
    ]);
    const handleContextMenu = /* @__PURE__ */ __name((node3, e) => {
      menuTargetNode.value = node3;
      emit2("contextMenu", node3, e);
      if (menuItems.value.filter((item2) => item2.visible).length > 0) {
        menu.value?.show(e);
      }
    }, "handleContextMenu");
    __expose({
      renameCommand,
      deleteCommand
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        createVNode(unref(script$6), {
          class: normalizeClass(["tree-explorer", props.class]),
          expandedKeys: expandedKeys2.value,
          "onUpdate:expandedKeys": _cache[0] || (_cache[0] = ($event) => expandedKeys2.value = $event),
          value: renderedRoots.value,
          selectionMode: "single",
          pt: {
            nodeLabel: "tree-explorer-node-label",
            nodeContent: /* @__PURE__ */ __name(({ props: props2 }) => ({
              onClick: /* @__PURE__ */ __name((e) => onNodeContentClick(e, props2.node), "onClick"),
              onContextmenu: /* @__PURE__ */ __name((e) => handleContextMenu(props2.node, e), "onContextmenu")
            }), "nodeContent"),
            nodeToggleButton: /* @__PURE__ */ __name(() => ({
              onClick: /* @__PURE__ */ __name((e) => {
                e.stopImmediatePropagation();
              }, "onClick")
            }), "nodeToggleButton")
          }
        }, {
          folder: withCtx(({ node: node3 }) => [
            renderSlot(_ctx.$slots, "folder", { node: node3 }, () => [
              createVNode(TreeExplorerTreeNode, { node: node3 }, null, 8, ["node"])
            ], true)
          ]),
          node: withCtx(({ node: node3 }) => [
            renderSlot(_ctx.$slots, "node", { node: node3 }, () => [
              createVNode(TreeExplorerTreeNode, { node: node3 }, null, 8, ["node"])
            ], true)
          ]),
          _: 3
        }, 8, ["class", "expandedKeys", "value", "pt"]),
        createVNode(unref(script$f), {
          ref_key: "menu",
          ref: menu,
          model: menuItems.value
        }, null, 8, ["model"])
      ], 64);
    };
  }
});
const TreeExplorer = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["__scopeId", "data-v-9d3310b9"]]);
const _sfc_main$8 = /* @__PURE__ */ defineComponent({
  __name: "NodeTreeLeaf",
  props: {
    node: {}
  },
  emits: ["toggle-bookmark"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const nodeDef = computed(() => props.node.data);
    const nodeBookmarkStore = useNodeBookmarkStore();
    const isBookmarked = computed(
      () => nodeBookmarkStore.isBookmarked(nodeDef.value)
    );
    const settingStore = useSettingStore();
    const sidebarLocation = computed(
      () => settingStore.get("Comfy.Sidebar.Location")
    );
    const emit2 = __emit;
    const toggleBookmark = /* @__PURE__ */ __name(() => {
      nodeBookmarkStore.toggleBookmark(nodeDef.value);
    }, "toggleBookmark");
    const previewRef = ref(null);
    const nodePreviewStyle = ref({
      position: "absolute",
      top: "0px",
      left: "0px"
    });
    const handleNodeHover = /* @__PURE__ */ __name(async () => {
      const hoverTarget = nodeContentElement.value;
      const targetRect = hoverTarget.getBoundingClientRect();
      const previewHeight = previewRef.value?.$el.offsetHeight || 0;
      const availableSpaceBelow = window.innerHeight - targetRect.bottom;
      nodePreviewStyle.value.top = previewHeight > availableSpaceBelow ? `${Math.max(0, targetRect.top - (previewHeight - availableSpaceBelow) - 20)}px` : `${targetRect.top - 40}px`;
      if (sidebarLocation.value === "left") {
        nodePreviewStyle.value.left = `${targetRect.right}px`;
      } else {
        nodePreviewStyle.value.left = `${targetRect.left - 400}px`;
      }
    }, "handleNodeHover");
    const container = ref(null);
    const nodeContentElement = ref(null);
    const isHovered = ref(false);
    const handleMouseEnter = /* @__PURE__ */ __name(async () => {
      isHovered.value = true;
      await nextTick();
      handleNodeHover();
    }, "handleMouseEnter");
    const handleMouseLeave = /* @__PURE__ */ __name(() => {
      isHovered.value = false;
    }, "handleMouseLeave");
    onMounted(() => {
      nodeContentElement.value = container.value?.closest(".p-tree-node-content");
      nodeContentElement.value?.addEventListener("mouseenter", handleMouseEnter);
      nodeContentElement.value?.addEventListener("mouseleave", handleMouseLeave);
    });
    onUnmounted(() => {
      nodeContentElement.value?.removeEventListener("mouseenter", handleMouseEnter);
      nodeContentElement.value?.removeEventListener("mouseleave", handleMouseLeave);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "container",
        ref: container,
        class: "node-lib-node-container"
      }, [
        createVNode(TreeExplorerTreeNode, { node: _ctx.node }, {
          "before-label": withCtx(() => [
            nodeDef.value.experimental ? (openBlock(), createBlock(unref(script$w), {
              key: 0,
              value: _ctx.$t("experimental"),
              severity: "primary"
            }, null, 8, ["value"])) : createCommentVNode("", true),
            nodeDef.value.deprecated ? (openBlock(), createBlock(unref(script$w), {
              key: 1,
              value: _ctx.$t("deprecated"),
              severity: "danger"
            }, null, 8, ["value"])) : createCommentVNode("", true)
          ]),
          actions: withCtx(() => [
            createVNode(unref(script$J), {
              class: "bookmark-button",
              size: "small",
              icon: isBookmarked.value ? "pi pi-bookmark-fill" : "pi pi-bookmark",
              text: "",
              severity: "secondary",
              onClick: withModifiers(toggleBookmark, ["stop"])
            }, null, 8, ["icon"])
          ]),
          _: 1
        }, 8, ["node"]),
        isHovered.value ? (openBlock(), createBlock(Teleport, {
          key: 0,
          to: "#node-library-node-preview-container"
        }, [
          createBaseVNode("div", {
            class: "node-lib-node-preview",
            style: normalizeStyle(nodePreviewStyle.value)
          }, [
            createVNode(NodePreview, {
              ref_key: "previewRef",
              ref: previewRef,
              nodeDef: nodeDef.value
            }, null, 8, ["nodeDef"])
          ], 4)
        ])) : createCommentVNode("", true)
      ], 512);
    };
  }
});
const NodeTreeLeaf = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["__scopeId", "data-v-3238e135"]]);
const _sfc_main$7 = /* @__PURE__ */ defineComponent({
  __name: "NodeTreeFolder",
  props: {
    node: {}
  },
  setup(__props) {
    const props = __props;
    const nodeBookmarkStore = useNodeBookmarkStore();
    const customization = computed(() => {
      return nodeBookmarkStore.bookmarksCustomization[props.node.data.nodePath];
    });
    const treeNodeElement = ref(null);
    const iconElement = ref(null);
    let stopWatchCustomization = null;
    const container = ref(null);
    onMounted(() => {
      treeNodeElement.value = container.value?.closest(
        ".p-tree-node-content"
      );
      iconElement.value = treeNodeElement.value.querySelector(
        ":scope > .p-tree-node-icon"
      );
      updateIconColor();
      stopWatchCustomization = watch(customization, updateIconColor, { deep: true });
    });
    const updateIconColor = /* @__PURE__ */ __name(() => {
      if (iconElement.value && customization.value) {
        iconElement.value.style.color = customization.value.color;
      }
    }, "updateIconColor");
    onUnmounted(() => {
      if (stopWatchCustomization) {
        stopWatchCustomization();
      }
    });
    const expandedKeys2 = inject("expandedKeys");
    const handleItemDrop = /* @__PURE__ */ __name((node3) => {
      expandedKeys2.value[node3.key] = true;
    }, "handleItemDrop");
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "container",
        ref: container,
        class: "node-lib-node-container"
      }, [
        createVNode(TreeExplorerTreeNode, {
          node: _ctx.node,
          onItemDropped: handleItemDrop
        }, null, 8, ["node"])
      ], 512);
    };
  }
});
var theme$1 = /* @__PURE__ */ __name(function theme36(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-colorpicker {\n    display: inline-block;\n    position: relative;\n}\n\n.p-colorpicker-dragging {\n    cursor: pointer;\n}\n\n.p-colorpicker-preview {\n    width: ".concat(dt3("colorpicker.preview.width"), ";\n    height: ").concat(dt3("colorpicker.preview.height"), ";\n    padding: 0;\n    border: 0 none;\n    border-radius: ").concat(dt3("colorpicker.preview.border.radius"), ";\n    transition: background ").concat(dt3("colorpicker.transition.duration"), ", color ").concat(dt3("colorpicker.transition.duration"), ", border-color ").concat(dt3("colorpicker.transition.duration"), ", outline-color ").concat(dt3("colorpicker.transition.duration"), ", box-shadow ").concat(dt3("colorpicker.transition.duration"), ";\n    outline-color: transparent;\n    cursor: pointer;\n}\n\n.p-colorpicker-preview:enabled:focus-visible {\n    border-color: ").concat(dt3("colorpicker.preview.focus.border.color"), ";\n    box-shadow: ").concat(dt3("colorpicker.preview.focus.ring.shadow"), ";\n    outline: ").concat(dt3("colorpicker.preview.focus.ring.width"), " ").concat(dt3("colorpicker.preview.focus.ring.style"), " ").concat(dt3("colorpicker.preview.focus.ring.color"), ";\n    outline-offset: ").concat(dt3("colorpicker.preview.focus.ring.offset"), ";\n}\n\n.p-colorpicker-panel {\n    background: ").concat(dt3("colorpicker.panel.background"), ";\n    border: 1px solid ").concat(dt3("colorpicker.panel.border.color"), ";\n    border-radius: ").concat(dt3("colorpicker.panel.border.radius"), ";\n    box-shadow: ").concat(dt3("colorpicker.panel.shadow"), ";\n    width: 193px;\n    height: 166px;\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n\n.p-colorpicker-panel-inline {\n    box-shadow: none;\n    position: static;\n}\n\n.p-colorpicker-content {\n    position: relative;\n}\n\n.p-colorpicker-color-selector {\n    width: 150px;\n    height: 150px;\n    top: 8px;\n    left: 8px;\n    position: absolute;\n}\n\n.p-colorpicker-color-background {\n    width: 100%;\n    height: 100%;\n    background: linear-gradient(to top, #000 0%, rgba(0, 0, 0, 0) 100%), linear-gradient(to right, #fff 0%, rgba(255, 255, 255, 0) 100%);\n}\n\n.p-colorpicker-color-handle {\n    position: absolute;\n    top: 0px;\n    left: 150px;\n    border-radius: 100%;\n    width: 10px;\n    height: 10px;\n    border-width: 1px;\n    border-style: solid;\n    margin: -5px 0 0 -5px;\n    cursor: pointer;\n    opacity: 0.85;\n    border-color: ").concat(dt3("colorpicker.handle.color"), ";\n}\n\n.p-colorpicker-hue {\n    width: 17px;\n    height: 150px;\n    top: 8px;\n    left: 167px;\n    position: absolute;\n    opacity: 0.85;\n    background: linear-gradient(0deg,\n        red 0,\n        #ff0 17%,\n        #0f0 33%,\n        #0ff 50%,\n        #00f 67%,\n        #f0f 83%,\n        red);\n}\n\n.p-colorpicker-hue-handle {\n    position: absolute;\n    top: 150px;\n    left: 0px;\n    width: 21px;\n    margin-left: -2px;\n    margin-top: -5px;\n    height: 10px;\n    border-width: 2px;\n    border-style: solid;\n    opacity: 0.85;\n    cursor: pointer;\n    border-color: ").concat(dt3("colorpicker.handle.color"), ";\n}\n");
}, "theme");
var classes$1 = {
  root: "p-colorpicker p-component",
  preview: /* @__PURE__ */ __name(function preview(_ref2) {
    var props = _ref2.props;
    return ["p-colorpicker-preview", {
      "p-disabled": props.disabled
    }];
  }, "preview"),
  panel: /* @__PURE__ */ __name(function panel2(_ref3) {
    var props = _ref3.props;
    return ["p-colorpicker-panel", {
      "p-colorpicker-panel-inline": props.inline,
      "p-disabled": props.disabled
    }];
  }, "panel"),
  colorSelector: "p-colorpicker-color-selector",
  colorBackground: "p-colorpicker-color-background",
  colorHandle: "p-colorpicker-color-handle",
  hue: "p-colorpicker-hue",
  hueHandle: "p-colorpicker-hue-handle"
};
var ColorPickerStyle = BaseStyle.extend({
  name: "colorpicker",
  theme: theme$1,
  classes: classes$1
});
var script$1$1 = {
  name: "BaseColorPicker",
  "extends": script$X,
  props: {
    modelValue: {
      type: null,
      "default": null
    },
    defaultColor: {
      type: null,
      "default": "ff0000"
    },
    inline: {
      type: Boolean,
      "default": false
    },
    format: {
      type: String,
      "default": "hex"
    },
    disabled: {
      type: Boolean,
      "default": false
    },
    tabindex: {
      type: String,
      "default": null
    },
    autoZIndex: {
      type: Boolean,
      "default": true
    },
    baseZIndex: {
      type: Number,
      "default": 0
    },
    appendTo: {
      type: [String, Object],
      "default": "body"
    },
    panelClass: null
  },
  style: ColorPickerStyle,
  provide: /* @__PURE__ */ __name(function provide39() {
    return {
      $pcColorPicker: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$5 = {
  name: "ColorPicker",
  "extends": script$1$1,
  inheritAttrs: false,
  emits: ["update:modelValue", "change", "show", "hide"],
  data: /* @__PURE__ */ __name(function data22() {
    return {
      overlayVisible: false
    };
  }, "data"),
  hsbValue: null,
  outsideClickListener: null,
  documentMouseMoveListener: null,
  documentMouseUpListener: null,
  scrollHandler: null,
  resizeListener: null,
  hueDragging: null,
  colorDragging: null,
  selfUpdate: null,
  picker: null,
  colorSelector: null,
  colorHandle: null,
  hueView: null,
  hueHandle: null,
  watch: {
    modelValue: {
      immediate: true,
      handler: /* @__PURE__ */ __name(function handler5(newValue) {
        this.hsbValue = this.toHSB(newValue);
        if (this.selfUpdate) this.selfUpdate = false;
        else this.updateUI();
      }, "handler")
    }
  },
  beforeUnmount: /* @__PURE__ */ __name(function beforeUnmount14() {
    this.unbindOutsideClickListener();
    this.unbindDragListeners();
    this.unbindResizeListener();
    if (this.scrollHandler) {
      this.scrollHandler.destroy();
      this.scrollHandler = null;
    }
    if (this.picker && this.autoZIndex) {
      ZIndex.clear(this.picker);
    }
    this.clearRefs();
  }, "beforeUnmount"),
  mounted: /* @__PURE__ */ __name(function mounted20() {
    this.updateUI();
  }, "mounted"),
  methods: {
    pickColor: /* @__PURE__ */ __name(function pickColor(event2) {
      var rect = this.colorSelector.getBoundingClientRect();
      var top = rect.top + (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0);
      var left = rect.left + document.body.scrollLeft;
      var saturation = Math.floor(100 * Math.max(0, Math.min(150, (event2.pageX || event2.changedTouches[0].pageX) - left)) / 150);
      var brightness = Math.floor(100 * (150 - Math.max(0, Math.min(150, (event2.pageY || event2.changedTouches[0].pageY) - top))) / 150);
      this.hsbValue = this.validateHSB({
        h: this.hsbValue.h,
        s: saturation,
        b: brightness
      });
      this.selfUpdate = true;
      this.updateColorHandle();
      this.updateInput();
      this.updateModel(event2);
    }, "pickColor"),
    pickHue: /* @__PURE__ */ __name(function pickHue(event2) {
      var top = this.hueView.getBoundingClientRect().top + (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0);
      this.hsbValue = this.validateHSB({
        h: Math.floor(360 * (150 - Math.max(0, Math.min(150, (event2.pageY || event2.changedTouches[0].pageY) - top))) / 150),
        s: 100,
        b: 100
      });
      this.selfUpdate = true;
      this.updateColorSelector();
      this.updateHue();
      this.updateModel(event2);
      this.updateInput();
    }, "pickHue"),
    updateModel: /* @__PURE__ */ __name(function updateModel6(event2) {
      var value3 = this.modelValue;
      switch (this.format) {
        case "hex":
          value3 = this.HSBtoHEX(this.hsbValue);
          break;
        case "rgb":
          value3 = this.HSBtoRGB(this.hsbValue);
          break;
        case "hsb":
          value3 = this.hsbValue;
          break;
      }
      this.$emit("update:modelValue", value3);
      this.$emit("change", {
        event: event2,
        value: value3
      });
    }, "updateModel"),
    updateColorSelector: /* @__PURE__ */ __name(function updateColorSelector() {
      if (this.colorSelector) {
        var hsbValue = this.validateHSB({
          h: this.hsbValue.h,
          s: 100,
          b: 100
        });
        this.colorSelector.style.backgroundColor = "#" + this.HSBtoHEX(hsbValue);
      }
    }, "updateColorSelector"),
    updateColorHandle: /* @__PURE__ */ __name(function updateColorHandle() {
      if (this.colorHandle) {
        this.colorHandle.style.left = Math.floor(150 * this.hsbValue.s / 100) + "px";
        this.colorHandle.style.top = Math.floor(150 * (100 - this.hsbValue.b) / 100) + "px";
      }
    }, "updateColorHandle"),
    updateHue: /* @__PURE__ */ __name(function updateHue() {
      if (this.hueHandle) {
        this.hueHandle.style.top = Math.floor(150 - 150 * this.hsbValue.h / 360) + "px";
      }
    }, "updateHue"),
    updateInput: /* @__PURE__ */ __name(function updateInput2() {
      if (this.$refs.input) {
        this.$refs.input.style.backgroundColor = "#" + this.HSBtoHEX(this.hsbValue);
      }
    }, "updateInput"),
    updateUI: /* @__PURE__ */ __name(function updateUI() {
      this.updateHue();
      this.updateColorHandle();
      this.updateInput();
      this.updateColorSelector();
    }, "updateUI"),
    validateHSB: /* @__PURE__ */ __name(function validateHSB(hsb) {
      return {
        h: Math.min(360, Math.max(0, hsb.h)),
        s: Math.min(100, Math.max(0, hsb.s)),
        b: Math.min(100, Math.max(0, hsb.b))
      };
    }, "validateHSB"),
    validateRGB: /* @__PURE__ */ __name(function validateRGB(rgb) {
      return {
        r: Math.min(255, Math.max(0, rgb.r)),
        g: Math.min(255, Math.max(0, rgb.g)),
        b: Math.min(255, Math.max(0, rgb.b))
      };
    }, "validateRGB"),
    validateHEX: /* @__PURE__ */ __name(function validateHEX(hex) {
      var len = 6 - hex.length;
      if (len > 0) {
        var o = [];
        for (var i2 = 0; i2 < len; i2++) {
          o.push("0");
        }
        o.push(hex);
        hex = o.join("");
      }
      return hex;
    }, "validateHEX"),
    HEXtoRGB: /* @__PURE__ */ __name(function HEXtoRGB(hex) {
      var hexValue = parseInt(hex.indexOf("#") > -1 ? hex.substring(1) : hex, 16);
      return {
        r: hexValue >> 16,
        g: (hexValue & 65280) >> 8,
        b: hexValue & 255
      };
    }, "HEXtoRGB"),
    HEXtoHSB: /* @__PURE__ */ __name(function HEXtoHSB(hex) {
      return this.RGBtoHSB(this.HEXtoRGB(hex));
    }, "HEXtoHSB"),
    RGBtoHSB: /* @__PURE__ */ __name(function RGBtoHSB(rgb) {
      var hsb = {
        h: 0,
        s: 0,
        b: 0
      };
      var min = Math.min(rgb.r, rgb.g, rgb.b);
      var max = Math.max(rgb.r, rgb.g, rgb.b);
      var delta2 = max - min;
      hsb.b = max;
      hsb.s = max !== 0 ? 255 * delta2 / max : 0;
      if (hsb.s !== 0) {
        if (rgb.r === max) {
          hsb.h = (rgb.g - rgb.b) / delta2;
        } else if (rgb.g === max) {
          hsb.h = 2 + (rgb.b - rgb.r) / delta2;
        } else {
          hsb.h = 4 + (rgb.r - rgb.g) / delta2;
        }
      } else {
        hsb.h = -1;
      }
      hsb.h *= 60;
      if (hsb.h < 0) {
        hsb.h += 360;
      }
      hsb.s *= 100 / 255;
      hsb.b *= 100 / 255;
      return hsb;
    }, "RGBtoHSB"),
    HSBtoRGB: /* @__PURE__ */ __name(function HSBtoRGB(hsb) {
      var rgb = {
        r: null,
        g: null,
        b: null
      };
      var h2 = Math.round(hsb.h);
      var s = Math.round(hsb.s * 255 / 100);
      var v2 = Math.round(hsb.b * 255 / 100);
      if (s === 0) {
        rgb = {
          r: v2,
          g: v2,
          b: v2
        };
      } else {
        var t1 = v2;
        var t2 = (255 - s) * v2 / 255;
        var t3 = (t1 - t2) * (h2 % 60) / 60;
        if (h2 === 360) h2 = 0;
        if (h2 < 60) {
          rgb.r = t1;
          rgb.b = t2;
          rgb.g = t2 + t3;
        } else if (h2 < 120) {
          rgb.g = t1;
          rgb.b = t2;
          rgb.r = t1 - t3;
        } else if (h2 < 180) {
          rgb.g = t1;
          rgb.r = t2;
          rgb.b = t2 + t3;
        } else if (h2 < 240) {
          rgb.b = t1;
          rgb.r = t2;
          rgb.g = t1 - t3;
        } else if (h2 < 300) {
          rgb.b = t1;
          rgb.g = t2;
          rgb.r = t2 + t3;
        } else if (h2 < 360) {
          rgb.r = t1;
          rgb.g = t2;
          rgb.b = t1 - t3;
        } else {
          rgb.r = 0;
          rgb.g = 0;
          rgb.b = 0;
        }
      }
      return {
        r: Math.round(rgb.r),
        g: Math.round(rgb.g),
        b: Math.round(rgb.b)
      };
    }, "HSBtoRGB"),
    RGBtoHEX: /* @__PURE__ */ __name(function RGBtoHEX(rgb) {
      var hex = [rgb.r.toString(16), rgb.g.toString(16), rgb.b.toString(16)];
      for (var key in hex) {
        if (hex[key].length === 1) {
          hex[key] = "0" + hex[key];
        }
      }
      return hex.join("");
    }, "RGBtoHEX"),
    HSBtoHEX: /* @__PURE__ */ __name(function HSBtoHEX(hsb) {
      return this.RGBtoHEX(this.HSBtoRGB(hsb));
    }, "HSBtoHEX"),
    toHSB: /* @__PURE__ */ __name(function toHSB(value3) {
      var hsb;
      if (value3) {
        switch (this.format) {
          case "hex":
            hsb = this.HEXtoHSB(value3);
            break;
          case "rgb":
            hsb = this.RGBtoHSB(value3);
            break;
          case "hsb":
            hsb = value3;
            break;
        }
      } else {
        hsb = this.HEXtoHSB(this.defaultColor);
      }
      return hsb;
    }, "toHSB"),
    onOverlayEnter: /* @__PURE__ */ __name(function onOverlayEnter3(el) {
      this.updateUI();
      this.alignOverlay();
      this.bindOutsideClickListener();
      this.bindScrollListener();
      this.bindResizeListener();
      if (this.autoZIndex) {
        ZIndex.set("overlay", el, this.baseZIndex, this.$primevue.config.zIndex.overlay);
      }
      this.$emit("show");
    }, "onOverlayEnter"),
    onOverlayLeave: /* @__PURE__ */ __name(function onOverlayLeave3() {
      this.unbindOutsideClickListener();
      this.unbindScrollListener();
      this.unbindResizeListener();
      this.clearRefs();
      this.$emit("hide");
    }, "onOverlayLeave"),
    onOverlayAfterLeave: /* @__PURE__ */ __name(function onOverlayAfterLeave3(el) {
      if (this.autoZIndex) {
        ZIndex.clear(el);
      }
    }, "onOverlayAfterLeave"),
    alignOverlay: /* @__PURE__ */ __name(function alignOverlay6() {
      if (this.appendTo === "self") relativePosition(this.picker, this.$refs.input);
      else absolutePosition(this.picker, this.$refs.input);
    }, "alignOverlay"),
    onInputClick: /* @__PURE__ */ __name(function onInputClick2() {
      if (this.disabled) {
        return;
      }
      this.overlayVisible = !this.overlayVisible;
    }, "onInputClick"),
    onInputKeydown: /* @__PURE__ */ __name(function onInputKeydown(event2) {
      switch (event2.code) {
        case "Space":
          this.overlayVisible = !this.overlayVisible;
          event2.preventDefault();
          break;
        case "Escape":
        case "Tab":
          this.overlayVisible = false;
          break;
      }
    }, "onInputKeydown"),
    onColorMousedown: /* @__PURE__ */ __name(function onColorMousedown(event2) {
      if (this.disabled) {
        return;
      }
      this.bindDragListeners();
      this.onColorDragStart(event2);
    }, "onColorMousedown"),
    onColorDragStart: /* @__PURE__ */ __name(function onColorDragStart(event2) {
      if (this.disabled) {
        return;
      }
      this.colorDragging = true;
      this.pickColor(event2);
      this.$el.setAttribute("p-colorpicker-dragging", "true");
      !this.isUnstyled && addClass(this.$el, "p-colorpicker-dragging");
      event2.preventDefault();
    }, "onColorDragStart"),
    onDrag: /* @__PURE__ */ __name(function onDrag2(event2) {
      if (this.colorDragging) {
        this.pickColor(event2);
        event2.preventDefault();
      }
      if (this.hueDragging) {
        this.pickHue(event2);
        event2.preventDefault();
      }
    }, "onDrag"),
    onDragEnd: /* @__PURE__ */ __name(function onDragEnd2() {
      this.colorDragging = false;
      this.hueDragging = false;
      this.$el.setAttribute("p-colorpicker-dragging", "false");
      !this.isUnstyled && removeClass(this.$el, "p-colorpicker-dragging");
      this.unbindDragListeners();
    }, "onDragEnd"),
    onHueMousedown: /* @__PURE__ */ __name(function onHueMousedown(event2) {
      if (this.disabled) {
        return;
      }
      this.bindDragListeners();
      this.onHueDragStart(event2);
    }, "onHueMousedown"),
    onHueDragStart: /* @__PURE__ */ __name(function onHueDragStart(event2) {
      if (this.disabled) {
        return;
      }
      this.hueDragging = true;
      this.pickHue(event2);
      !this.isUnstyled && addClass(this.$el, "p-colorpicker-dragging");
    }, "onHueDragStart"),
    isInputClicked: /* @__PURE__ */ __name(function isInputClicked2(event2) {
      return this.$refs.input && this.$refs.input.isSameNode(event2.target);
    }, "isInputClicked"),
    bindDragListeners: /* @__PURE__ */ __name(function bindDragListeners2() {
      this.bindDocumentMouseMoveListener();
      this.bindDocumentMouseUpListener();
    }, "bindDragListeners"),
    unbindDragListeners: /* @__PURE__ */ __name(function unbindDragListeners2() {
      this.unbindDocumentMouseMoveListener();
      this.unbindDocumentMouseUpListener();
    }, "unbindDragListeners"),
    bindOutsideClickListener: /* @__PURE__ */ __name(function bindOutsideClickListener6() {
      var _this = this;
      if (!this.outsideClickListener) {
        this.outsideClickListener = function(event2) {
          if (_this.overlayVisible && _this.picker && !_this.picker.contains(event2.target) && !_this.isInputClicked(event2)) {
            _this.overlayVisible = false;
          }
        };
        document.addEventListener("click", this.outsideClickListener);
      }
    }, "bindOutsideClickListener"),
    unbindOutsideClickListener: /* @__PURE__ */ __name(function unbindOutsideClickListener6() {
      if (this.outsideClickListener) {
        document.removeEventListener("click", this.outsideClickListener);
        this.outsideClickListener = null;
      }
    }, "unbindOutsideClickListener"),
    bindScrollListener: /* @__PURE__ */ __name(function bindScrollListener6() {
      var _this2 = this;
      if (!this.scrollHandler) {
        this.scrollHandler = new ConnectedOverlayScrollHandler(this.$refs.container, function() {
          if (_this2.overlayVisible) {
            _this2.overlayVisible = false;
          }
        });
      }
      this.scrollHandler.bindScrollListener();
    }, "bindScrollListener"),
    unbindScrollListener: /* @__PURE__ */ __name(function unbindScrollListener6() {
      if (this.scrollHandler) {
        this.scrollHandler.unbindScrollListener();
      }
    }, "unbindScrollListener"),
    bindResizeListener: /* @__PURE__ */ __name(function bindResizeListener7() {
      var _this3 = this;
      if (!this.resizeListener) {
        this.resizeListener = function() {
          if (_this3.overlayVisible && !isTouchDevice()) {
            _this3.overlayVisible = false;
          }
        };
        window.addEventListener("resize", this.resizeListener);
      }
    }, "bindResizeListener"),
    unbindResizeListener: /* @__PURE__ */ __name(function unbindResizeListener7() {
      if (this.resizeListener) {
        window.removeEventListener("resize", this.resizeListener);
        this.resizeListener = null;
      }
    }, "unbindResizeListener"),
    bindDocumentMouseMoveListener: /* @__PURE__ */ __name(function bindDocumentMouseMoveListener() {
      if (!this.documentMouseMoveListener) {
        this.documentMouseMoveListener = this.onDrag.bind(this);
        document.addEventListener("mousemove", this.documentMouseMoveListener);
      }
    }, "bindDocumentMouseMoveListener"),
    unbindDocumentMouseMoveListener: /* @__PURE__ */ __name(function unbindDocumentMouseMoveListener() {
      if (this.documentMouseMoveListener) {
        document.removeEventListener("mousemove", this.documentMouseMoveListener);
        this.documentMouseMoveListener = null;
      }
    }, "unbindDocumentMouseMoveListener"),
    bindDocumentMouseUpListener: /* @__PURE__ */ __name(function bindDocumentMouseUpListener() {
      if (!this.documentMouseUpListener) {
        this.documentMouseUpListener = this.onDragEnd.bind(this);
        document.addEventListener("mouseup", this.documentMouseUpListener);
      }
    }, "bindDocumentMouseUpListener"),
    unbindDocumentMouseUpListener: /* @__PURE__ */ __name(function unbindDocumentMouseUpListener() {
      if (this.documentMouseUpListener) {
        document.removeEventListener("mouseup", this.documentMouseUpListener);
        this.documentMouseUpListener = null;
      }
    }, "unbindDocumentMouseUpListener"),
    pickerRef: /* @__PURE__ */ __name(function pickerRef(el) {
      this.picker = el;
    }, "pickerRef"),
    colorSelectorRef: /* @__PURE__ */ __name(function colorSelectorRef(el) {
      this.colorSelector = el;
    }, "colorSelectorRef"),
    colorHandleRef: /* @__PURE__ */ __name(function colorHandleRef(el) {
      this.colorHandle = el;
    }, "colorHandleRef"),
    hueViewRef: /* @__PURE__ */ __name(function hueViewRef(el) {
      this.hueView = el;
    }, "hueViewRef"),
    hueHandleRef: /* @__PURE__ */ __name(function hueHandleRef(el) {
      this.hueHandle = el;
    }, "hueHandleRef"),
    clearRefs: /* @__PURE__ */ __name(function clearRefs() {
      this.picker = null;
      this.colorSelector = null;
      this.colorHandle = null;
      this.hueView = null;
      this.hueHandle = null;
    }, "clearRefs"),
    onOverlayClick: /* @__PURE__ */ __name(function onOverlayClick5(event2) {
      OverlayEventBus.emit("overlay-click", {
        originalEvent: event2,
        target: this.$el
      });
    }, "onOverlayClick")
  },
  components: {
    Portal: script$z
  }
};
var _hoisted_1$6 = ["tabindex", "disabled"];
function render$4(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_Portal = resolveComponent("Portal");
  return openBlock(), createElementBlock("div", mergeProps({
    ref: "container",
    "class": _ctx.cx("root")
  }, _ctx.ptmi("root")), [!_ctx.inline ? (openBlock(), createElementBlock("input", mergeProps({
    key: 0,
    ref: "input",
    type: "text",
    "class": _ctx.cx("preview"),
    readonly: "readonly",
    tabindex: _ctx.tabindex,
    disabled: _ctx.disabled,
    onClick: _cache[0] || (_cache[0] = function() {
      return $options.onInputClick && $options.onInputClick.apply($options, arguments);
    }),
    onKeydown: _cache[1] || (_cache[1] = function() {
      return $options.onInputKeydown && $options.onInputKeydown.apply($options, arguments);
    })
  }, _ctx.ptm("preview")), null, 16, _hoisted_1$6)) : createCommentVNode("", true), createVNode(_component_Portal, {
    appendTo: _ctx.appendTo,
    disabled: _ctx.inline
  }, {
    "default": withCtx(function() {
      return [createVNode(Transition, mergeProps({
        name: "p-connected-overlay",
        onEnter: $options.onOverlayEnter,
        onLeave: $options.onOverlayLeave,
        onAfterLeave: $options.onOverlayAfterLeave
      }, _ctx.ptm("transition")), {
        "default": withCtx(function() {
          return [(_ctx.inline ? true : $data.overlayVisible) ? (openBlock(), createElementBlock("div", mergeProps({
            key: 0,
            ref: $options.pickerRef,
            "class": [_ctx.cx("panel"), _ctx.panelClass],
            onClick: _cache[10] || (_cache[10] = function() {
              return $options.onOverlayClick && $options.onOverlayClick.apply($options, arguments);
            })
          }, _ctx.ptm("panel")), [createBaseVNode("div", mergeProps({
            "class": _ctx.cx("content")
          }, _ctx.ptm("content")), [createBaseVNode("div", mergeProps({
            ref: $options.colorSelectorRef,
            "class": _ctx.cx("colorSelector"),
            onMousedown: _cache[2] || (_cache[2] = function($event) {
              return $options.onColorMousedown($event);
            }),
            onTouchstart: _cache[3] || (_cache[3] = function($event) {
              return $options.onColorDragStart($event);
            }),
            onTouchmove: _cache[4] || (_cache[4] = function($event) {
              return $options.onDrag($event);
            }),
            onTouchend: _cache[5] || (_cache[5] = function($event) {
              return $options.onDragEnd();
            })
          }, _ctx.ptm("colorSelector")), [createBaseVNode("div", mergeProps({
            "class": _ctx.cx("colorBackground")
          }, _ctx.ptm("colorBackground")), [createBaseVNode("div", mergeProps({
            ref: $options.colorHandleRef,
            "class": _ctx.cx("colorHandle")
          }, _ctx.ptm("colorHandle")), null, 16)], 16)], 16), createBaseVNode("div", mergeProps({
            ref: $options.hueViewRef,
            "class": _ctx.cx("hue"),
            onMousedown: _cache[6] || (_cache[6] = function($event) {
              return $options.onHueMousedown($event);
            }),
            onTouchstart: _cache[7] || (_cache[7] = function($event) {
              return $options.onHueDragStart($event);
            }),
            onTouchmove: _cache[8] || (_cache[8] = function($event) {
              return $options.onDrag($event);
            }),
            onTouchend: _cache[9] || (_cache[9] = function($event) {
              return $options.onDragEnd();
            })
          }, _ctx.ptm("hue")), [createBaseVNode("div", mergeProps({
            ref: $options.hueHandleRef,
            "class": _ctx.cx("hueHandle")
          }, _ctx.ptm("hueHandle")), null, 16)], 16)], 16)], 16)) : createCommentVNode("", true)];
        }),
        _: 1
      }, 16, ["onEnter", "onLeave", "onAfterLeave"])];
    }),
    _: 1
  }, 8, ["appendTo", "disabled"])], 16);
}
__name(render$4, "render$4");
script$5.render = render$4;
const _withScopeId$1 = /* @__PURE__ */ __name((n) => (pushScopeId("data-v-91077f2a"), n = n(), popScopeId(), n), "_withScopeId$1");
const _hoisted_1$5 = { class: "p-fluid" };
const _hoisted_2$2 = { class: "field icon-field" };
const _hoisted_3$1 = { for: "icon" };
const _hoisted_4$1 = { class: "field color-field" };
const _hoisted_5 = { for: "color" };
const _hoisted_6 = { class: "color-picker-container" };
const _hoisted_7 = {
  key: 1,
  class: "pi pi-palette",
  style: { fontSize: "1.2rem" }
};
const _sfc_main$6 = /* @__PURE__ */ defineComponent({
  __name: "CustomizationDialog",
  props: {
    modelValue: { type: Boolean },
    initialIcon: {},
    initialColor: {}
  },
  emits: ["update:modelValue", "confirm"],
  setup(__props, { emit: __emit }) {
    const { t } = useI18n();
    const props = __props;
    const emit2 = __emit;
    const visible = computed({
      get: /* @__PURE__ */ __name(() => props.modelValue, "get"),
      set: /* @__PURE__ */ __name((value3) => emit2("update:modelValue", value3), "set")
    });
    const nodeBookmarkStore = useNodeBookmarkStore();
    const iconOptions = [
      { name: t("bookmark"), value: nodeBookmarkStore.defaultBookmarkIcon },
      { name: t("folder"), value: "pi-folder" },
      { name: t("star"), value: "pi-star" },
      { name: t("heart"), value: "pi-heart" },
      { name: t("file"), value: "pi-file" },
      { name: t("inbox"), value: "pi-inbox" },
      { name: t("box"), value: "pi-box" },
      { name: t("briefcase"), value: "pi-briefcase" }
    ];
    const colorOptions = [
      { name: t("default"), value: nodeBookmarkStore.defaultBookmarkColor },
      { name: t("blue"), value: "#007bff" },
      { name: t("green"), value: "#28a745" },
      { name: t("red"), value: "#dc3545" },
      { name: t("pink"), value: "#e83e8c" },
      { name: t("yellow"), value: "#ffc107" },
      { name: t("custom"), value: "custom" }
    ];
    const defaultIcon = iconOptions.find(
      (option4) => option4.value === nodeBookmarkStore.defaultBookmarkIcon
    );
    const defaultColor = colorOptions.find(
      (option4) => option4.value === nodeBookmarkStore.defaultBookmarkColor
    );
    const selectedIcon = ref(defaultIcon);
    const selectedColor = ref(defaultColor);
    const finalColor = computed(
      () => selectedColor.value.value === "custom" ? `#${customColor.value}` : selectedColor.value.value
    );
    const customColor = ref("000000");
    const closeDialog = /* @__PURE__ */ __name(() => {
      visible.value = false;
    }, "closeDialog");
    const confirmCustomization = /* @__PURE__ */ __name(() => {
      emit2("confirm", selectedIcon.value.value, finalColor.value);
      closeDialog();
    }, "confirmCustomization");
    const resetCustomization = /* @__PURE__ */ __name(() => {
      selectedIcon.value = iconOptions.find((option4) => option4.value === props.initialIcon) || defaultIcon;
      const colorOption = colorOptions.find(
        (option4) => option4.value === props.initialColor
      );
      if (!props.initialColor) {
        selectedColor.value = defaultColor;
      } else if (!colorOption) {
        customColor.value = props.initialColor.replace("#", "");
        selectedColor.value = { name: "Custom", value: "custom" };
      } else {
        selectedColor.value = colorOption;
      }
    }, "resetCustomization");
    watch(
      () => props.modelValue,
      (newValue) => {
        if (newValue) {
          resetCustomization();
        }
      },
      { immediate: true }
    );
    return (_ctx, _cache) => {
      const _directive_tooltip = resolveDirective("tooltip");
      return openBlock(), createBlock(unref(script$k), {
        visible: visible.value,
        "onUpdate:visible": _cache[3] || (_cache[3] = ($event) => visible.value = $event),
        header: _ctx.$t("customizeFolder")
      }, {
        footer: withCtx(() => [
          createVNode(unref(script$J), {
            label: _ctx.$t("reset"),
            icon: "pi pi-refresh",
            onClick: resetCustomization,
            class: "p-button-text"
          }, null, 8, ["label"]),
          createVNode(unref(script$J), {
            label: _ctx.$t("confirm"),
            icon: "pi pi-check",
            onClick: confirmCustomization,
            autofocus: ""
          }, null, 8, ["label"])
        ]),
        default: withCtx(() => [
          createBaseVNode("div", _hoisted_1$5, [
            createBaseVNode("div", _hoisted_2$2, [
              createBaseVNode("label", _hoisted_3$1, toDisplayString$1(_ctx.$t("icon")), 1),
              createVNode(unref(script$i), {
                modelValue: selectedIcon.value,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => selectedIcon.value = $event),
                options: iconOptions,
                optionLabel: "name",
                dataKey: "value"
              }, {
                option: withCtx((slotProps) => [
                  createBaseVNode("i", {
                    class: normalizeClass(["pi", slotProps.option.value, "mr-2"]),
                    style: normalizeStyle({ color: finalColor.value })
                  }, null, 6)
                ]),
                _: 1
              }, 8, ["modelValue"])
            ]),
            createVNode(unref(script$F)),
            createBaseVNode("div", _hoisted_4$1, [
              createBaseVNode("label", _hoisted_5, toDisplayString$1(_ctx.$t("color")), 1),
              createBaseVNode("div", _hoisted_6, [
                createVNode(unref(script$i), {
                  modelValue: selectedColor.value,
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => selectedColor.value = $event),
                  options: colorOptions,
                  optionLabel: "name",
                  dataKey: "value"
                }, {
                  option: withCtx((slotProps) => [
                    slotProps.option.value !== "custom" ? (openBlock(), createElementBlock("div", {
                      key: 0,
                      style: normalizeStyle({
                        width: "20px",
                        height: "20px",
                        backgroundColor: slotProps.option.value,
                        borderRadius: "50%"
                      })
                    }, null, 4)) : withDirectives((openBlock(), createElementBlock("i", _hoisted_7, null, 512)), [
                      [_directive_tooltip, _ctx.$t("customColor")]
                    ])
                  ]),
                  _: 1
                }, 8, ["modelValue"]),
                selectedColor.value.value === "custom" ? (openBlock(), createBlock(unref(script$5), {
                  key: 0,
                  modelValue: customColor.value,
                  "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => customColor.value = $event)
                }, null, 8, ["modelValue"])) : createCommentVNode("", true)
              ])
            ])
          ])
        ]),
        _: 1
      }, 8, ["visible", "header"]);
    };
  }
});
const FolderCustomizationDialog = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["__scopeId", "data-v-91077f2a"]]);
function useTreeExpansion() {
  const expandedKeys2 = ref({});
  const toggleNode = /* @__PURE__ */ __name((node3) => {
    if (node3.key && typeof node3.key === "string") {
      if (node3.key in expandedKeys2.value) {
        delete expandedKeys2.value[node3.key];
      } else {
        expandedKeys2.value[node3.key] = true;
      }
    }
  }, "toggleNode");
  const toggleNodeRecursive = /* @__PURE__ */ __name((node3) => {
    if (node3.key && typeof node3.key === "string") {
      if (node3.key in expandedKeys2.value) {
        collapseNode(node3);
      } else {
        expandNode(node3);
      }
    }
  }, "toggleNodeRecursive");
  const expandNode = /* @__PURE__ */ __name((node3) => {
    if (node3.key && typeof node3.key === "string" && node3.children && node3.children.length) {
      expandedKeys2.value[node3.key] = true;
      for (const child of node3.children) {
        expandNode(child);
      }
    }
  }, "expandNode");
  const collapseNode = /* @__PURE__ */ __name((node3) => {
    if (node3.key && typeof node3.key === "string" && node3.children && node3.children.length) {
      delete expandedKeys2.value[node3.key];
      for (const child of node3.children) {
        collapseNode(child);
      }
    }
  }, "collapseNode");
  const toggleNodeOnEvent = /* @__PURE__ */ __name((e, node3) => {
    if (e.ctrlKey) {
      toggleNodeRecursive(node3);
    } else {
      toggleNode(node3);
    }
  }, "toggleNodeOnEvent");
  return {
    expandedKeys: expandedKeys2,
    toggleNode,
    toggleNodeRecursive,
    expandNode,
    collapseNode,
    toggleNodeOnEvent
  };
}
__name(useTreeExpansion, "useTreeExpansion");
const _sfc_main$5 = /* @__PURE__ */ defineComponent({
  __name: "NodeBookmarkTreeExplorer",
  props: {
    filteredNodeDefs: {}
  },
  setup(__props, { expose: __expose }) {
    const props = __props;
    const { expandedKeys: expandedKeys2, expandNode, toggleNodeOnEvent } = useTreeExpansion();
    const handleNodeClick = /* @__PURE__ */ __name((node3, e) => {
      if (node3.leaf) {
        app$1.addNodeOnGraph(node3.data, { pos: app$1.getCanvasCenter() });
      } else {
        toggleNodeOnEvent(e, node3);
      }
    }, "handleNodeClick");
    const nodeBookmarkStore = useNodeBookmarkStore();
    const bookmarkedRoot = computed(() => {
      const filterTree = /* @__PURE__ */ __name((node3) => {
        if (node3.leaf) {
          return props.filteredNodeDefs.some((def2) => def2.name === node3.data.name) ? node3 : null;
        }
        const filteredChildren = node3.children?.map(filterTree).filter((child) => child !== null);
        if (filteredChildren && filteredChildren.length > 0) {
          return {
            ...node3,
            children: filteredChildren
          };
        }
        return null;
      }, "filterTree");
      return props.filteredNodeDefs.length ? filterTree(nodeBookmarkStore.bookmarkedRoot) || {
        key: "root",
        label: "Root",
        children: []
      } : nodeBookmarkStore.bookmarkedRoot;
    });
    watch(
      () => props.filteredNodeDefs,
      (newValue) => {
        if (newValue.length) {
          nextTick(() => expandNode(bookmarkedRoot.value));
        }
      }
    );
    const renderedBookmarkedRoot = computed(
      () => {
        const fillNodeInfo = /* @__PURE__ */ __name((node3) => {
          const children = node3.children?.map(fillNodeInfo);
          const sortedChildren = children?.sort((a, b) => {
            if (a.leaf === b.leaf) {
              return a.label.localeCompare(b.label);
            }
            return a.leaf ? 1 : -1;
          });
          return {
            key: node3.key,
            label: node3.leaf ? node3.data.display_name : node3.label,
            leaf: node3.leaf,
            data: node3.data,
            getIcon: /* @__PURE__ */ __name((node22) => {
              if (node22.leaf) {
                return "pi pi-circle-fill";
              }
              const customization = nodeBookmarkStore.bookmarksCustomization[node22.data.nodePath];
              return customization?.icon ? "pi " + customization.icon : "pi pi-bookmark-fill";
            }, "getIcon"),
            children: sortedChildren,
            draggable: node3.leaf,
            droppable: !node3.leaf,
            handleDrop: /* @__PURE__ */ __name((node22, data24) => {
              const nodeDefToAdd = data24.data.data;
              if (nodeBookmarkStore.isBookmarked(nodeDefToAdd)) {
                nodeBookmarkStore.toggleBookmark(nodeDefToAdd);
              }
              const folderNodeDef = node22.data;
              const nodePath = folderNodeDef.category + "/" + nodeDefToAdd.name;
              nodeBookmarkStore.addBookmark(nodePath);
            }, "handleDrop"),
            ...node3.leaf ? {} : {
              handleRename,
              handleDelete: /* @__PURE__ */ __name((node22) => {
                nodeBookmarkStore.deleteBookmarkFolder(node22.data);
              }, "handleDelete")
            }
          };
        }, "fillNodeInfo");
        return fillNodeInfo(bookmarkedRoot.value);
      }
    );
    const treeExplorerRef = ref(null);
    const addNewBookmarkFolder = /* @__PURE__ */ __name((parent) => {
      const newFolderKey = "root/" + nodeBookmarkStore.addNewBookmarkFolder(parent?.data).slice(0, -1);
      nextTick(() => {
        treeExplorerRef.value?.renameCommand(
          findNodeByKey(
            renderedBookmarkedRoot.value,
            newFolderKey
          )
        );
        if (parent) {
          expandedKeys2.value[parent.key] = true;
        }
      });
    }, "addNewBookmarkFolder");
    __expose({
      addNewBookmarkFolder
    });
    const toast = useToast();
    const { t } = useI18n();
    const handleRename = /* @__PURE__ */ __name((node3, newName) => {
      if (node3.data && node3.data.isDummyFolder) {
        try {
          nodeBookmarkStore.renameBookmarkFolder(node3.data, newName);
        } catch (e) {
          toast.add({
            severity: "error",
            summary: t("error"),
            detail: e.message,
            life: 3e3
          });
        }
      }
    }, "handleRename");
    const showCustomizationDialog = ref(false);
    const initialIcon = ref(nodeBookmarkStore.defaultBookmarkIcon);
    const initialColor = ref(nodeBookmarkStore.defaultBookmarkColor);
    const customizationTargetNodePath = ref("");
    const updateCustomization = /* @__PURE__ */ __name((icon2, color) => {
      if (customizationTargetNodePath.value) {
        nodeBookmarkStore.updateBookmarkCustomization(
          customizationTargetNodePath.value,
          { icon: icon2, color }
        );
      }
    }, "updateCustomization");
    const extraMenuItems = computed(
      () => (menuTargetNode) => [
        {
          label: t("newFolder"),
          icon: "pi pi-folder-plus",
          command: /* @__PURE__ */ __name(() => {
            addNewBookmarkFolder(menuTargetNode);
          }, "command"),
          visible: !menuTargetNode?.leaf
        },
        {
          label: t("customize"),
          icon: "pi pi-palette",
          command: /* @__PURE__ */ __name(() => {
            const customization = nodeBookmarkStore.bookmarksCustomization[menuTargetNode.data.nodePath];
            initialIcon.value = customization?.icon || nodeBookmarkStore.defaultBookmarkIcon;
            initialColor.value = customization?.color || nodeBookmarkStore.defaultBookmarkColor;
            showCustomizationDialog.value = true;
            customizationTargetNodePath.value = menuTargetNode.data.nodePath;
          }, "command"),
          visible: !menuTargetNode?.leaf
        }
      ]
    );
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        createVNode(TreeExplorer, {
          class: "node-lib-bookmark-tree-explorer",
          ref_key: "treeExplorerRef",
          ref: treeExplorerRef,
          roots: renderedBookmarkedRoot.value.children,
          expandedKeys: unref(expandedKeys2),
          extraMenuItems: extraMenuItems.value,
          onNodeClick: handleNodeClick
        }, {
          folder: withCtx(({ node: node3 }) => [
            createVNode(_sfc_main$7, { node: node3 }, null, 8, ["node"])
          ]),
          node: withCtx(({ node: node3 }) => [
            createVNode(NodeTreeLeaf, { node: node3 }, null, 8, ["node"])
          ]),
          _: 1
        }, 8, ["roots", "expandedKeys", "extraMenuItems"]),
        createVNode(FolderCustomizationDialog, {
          modelValue: showCustomizationDialog.value,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => showCustomizationDialog.value = $event),
          onConfirm: updateCustomization,
          initialIcon: initialIcon.value,
          initialColor: initialColor.value
        }, null, 8, ["modelValue", "initialIcon", "initialColor"])
      ], 64);
    };
  }
});
const _withScopeId = /* @__PURE__ */ __name((n) => (pushScopeId("data-v-85688f44"), n = n(), popScopeId(), n), "_withScopeId");
const _hoisted_1$4 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("div", { id: "node-library-node-preview-container" }, null, -1));
const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  __name: "NodeLibrarySidebarTab",
  setup(__props) {
    const nodeDefStore = useNodeDefStore();
    const nodeBookmarkStore = useNodeBookmarkStore();
    const { expandedKeys: expandedKeys2, expandNode, toggleNodeOnEvent } = useTreeExpansion();
    const nodeBookmarkTreeExplorerRef = ref(null);
    const searchFilter = ref(null);
    const alphabeticalSort = ref(false);
    const searchQuery = ref("");
    const root26 = computed(() => {
      const root27 = filteredRoot.value || nodeDefStore.nodeTree;
      return alphabeticalSort.value ? sortedTree(root27) : root27;
    });
    const renderedRoot = computed(() => {
      const fillNodeInfo = /* @__PURE__ */ __name((node3) => {
        const children = node3.children?.map(fillNodeInfo);
        return {
          key: node3.key,
          label: node3.leaf ? node3.data.display_name : node3.label,
          leaf: node3.leaf,
          data: node3.data,
          getIcon: /* @__PURE__ */ __name((node22) => {
            if (node22.leaf) {
              return "pi pi-circle-fill";
            }
          }, "getIcon"),
          children,
          draggable: node3.leaf
        };
      }, "fillNodeInfo");
      return fillNodeInfo(root26.value);
    });
    const filteredNodeDefs = ref([]);
    const filteredRoot = computed(() => {
      if (!filteredNodeDefs.value.length) {
        return null;
      }
      return buildNodeDefTree(filteredNodeDefs.value);
    });
    const filters = ref([]);
    const handleSearch = /* @__PURE__ */ __name((query) => {
      if (query.length === 0 && !filters.value.length) {
        filteredNodeDefs.value = [];
        expandedKeys2.value = {};
        return;
      }
      const f = filters.value.map((f2) => f2.filter);
      filteredNodeDefs.value = nodeDefStore.nodeSearchService.searchNode(
        query,
        f,
        {
          limit: 64
        },
        {
          matchWildcards: false
        }
      );
      nextTick(() => {
        expandNode(filteredRoot.value);
      });
    }, "handleSearch");
    const handleNodeClick = /* @__PURE__ */ __name((node3, e) => {
      if (node3.leaf) {
        app$1.addNodeOnGraph(node3.data, { pos: app$1.getCanvasCenter() });
      } else {
        toggleNodeOnEvent(e, node3);
      }
    }, "handleNodeClick");
    const onAddFilter = /* @__PURE__ */ __name((filterAndValue) => {
      filters.value.push({
        filter: filterAndValue,
        badge: filterAndValue[0].invokeSequence.toUpperCase(),
        badgeClass: filterAndValue[0].invokeSequence + "-badge",
        text: filterAndValue[1],
        id: +/* @__PURE__ */ new Date()
      });
      handleSearch(searchQuery.value);
    }, "onAddFilter");
    const onRemoveFilter = /* @__PURE__ */ __name((filterAndValue) => {
      const index2 = filters.value.findIndex((f) => f === filterAndValue);
      if (index2 !== -1) {
        filters.value.splice(index2, 1);
      }
      handleSearch(searchQuery.value);
    }, "onRemoveFilter");
    return (_ctx, _cache) => {
      const _directive_tooltip = resolveDirective("tooltip");
      return openBlock(), createElementBlock(Fragment, null, [
        createVNode(SidebarTabTemplate, {
          title: _ctx.$t("sideToolbar.nodeLibrary")
        }, {
          "tool-buttons": withCtx(() => [
            withDirectives(createVNode(unref(script$J), {
              class: "new-folder-button",
              icon: "pi pi-folder-plus",
              text: "",
              severity: "secondary",
              onClick: _cache[0] || (_cache[0] = ($event) => nodeBookmarkTreeExplorerRef.value?.addNewBookmarkFolder())
            }, null, 512), [
              [_directive_tooltip, _ctx.$t("newFolder")]
            ]),
            withDirectives(createVNode(unref(script$J), {
              class: "sort-button",
              icon: alphabeticalSort.value ? "pi pi-sort-alpha-down" : "pi pi-sort-alt",
              text: "",
              severity: "secondary",
              onClick: _cache[1] || (_cache[1] = ($event) => alphabeticalSort.value = !alphabeticalSort.value)
            }, null, 8, ["icon"]), [
              [_directive_tooltip, _ctx.$t("sideToolbar.nodeLibraryTab.sortOrder")]
            ])
          ]),
          body: withCtx(() => [
            createVNode(SearchBox, {
              class: "node-lib-search-box",
              modelValue: searchQuery.value,
              "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => searchQuery.value = $event),
              onSearch: handleSearch,
              onShowFilter: _cache[3] || (_cache[3] = ($event) => searchFilter.value.toggle($event)),
              onRemoveFilter,
              placeholder: _ctx.$t("searchNodes") + "...",
              "filter-icon": "pi pi-filter",
              filters: filters.value
            }, null, 8, ["modelValue", "placeholder", "filters"]),
            createVNode(unref(script$9), {
              ref_key: "searchFilter",
              ref: searchFilter,
              class: "node-lib-filter-popup"
            }, {
              default: withCtx(() => [
                createVNode(NodeSearchFilter, { onAddFilter })
              ]),
              _: 1
            }, 512),
            createVNode(_sfc_main$5, {
              ref_key: "nodeBookmarkTreeExplorerRef",
              ref: nodeBookmarkTreeExplorerRef,
              "filtered-node-defs": filteredNodeDefs.value
            }, null, 8, ["filtered-node-defs"]),
            unref(nodeBookmarkStore).bookmarks.length > 0 ? (openBlock(), createBlock(unref(script$F), {
              key: 0,
              type: "dashed"
            })) : createCommentVNode("", true),
            createVNode(TreeExplorer, {
              class: "node-lib-tree-explorer",
              roots: renderedRoot.value.children,
              expandedKeys: unref(expandedKeys2),
              "onUpdate:expandedKeys": _cache[4] || (_cache[4] = ($event) => isRef(expandedKeys2) ? expandedKeys2.value = $event : null),
              onNodeClick: handleNodeClick
            }, {
              node: withCtx(({ node: node3 }) => [
                createVNode(NodeTreeLeaf, { node: node3 }, null, 8, ["node"])
              ]),
              _: 1
            }, 8, ["roots", "expandedKeys"])
          ]),
          _: 1
        }, 8, ["title"]),
        _hoisted_1$4
      ], 64);
    };
  }
});
const NodeLibrarySidebarTab = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["__scopeId", "data-v-85688f44"]]);
const _hoisted_1$3 = { key: 1 };
const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  __name: "GlobalDialog",
  setup(__props) {
    const dialogStore = useDialogStore();
    const maximizable = computed(() => dialogStore.props.maximizable ?? false);
    const maximized = ref(false);
    const onMaximize = /* @__PURE__ */ __name(() => {
      maximized.value = true;
    }, "onMaximize");
    const onUnmaximize = /* @__PURE__ */ __name(() => {
      maximized.value = false;
    }, "onUnmaximize");
    const contentProps = computed(() => ({
      ...dialogStore.props,
      maximized: maximized.value
    }));
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(script$k), {
        visible: unref(dialogStore).isVisible,
        "onUpdate:visible": _cache[0] || (_cache[0] = ($event) => unref(dialogStore).isVisible = $event),
        modal: "",
        closable: "",
        closeOnEscape: "",
        dismissableMask: "",
        maximizable: maximizable.value,
        maximized: maximized.value,
        onHide: unref(dialogStore).closeDialog,
        onMaximize,
        onUnmaximize
      }, {
        header: withCtx(() => [
          unref(dialogStore).headerComponent ? (openBlock(), createBlock(resolveDynamicComponent(unref(dialogStore).headerComponent), { key: 0 })) : (openBlock(), createElementBlock("h3", _hoisted_1$3, toDisplayString$1(unref(dialogStore).title || " "), 1))
        ]),
        default: withCtx(() => [
          (openBlock(), createBlock(resolveDynamicComponent(unref(dialogStore).component), normalizeProps(guardReactiveProps(contentProps.value)), null, 16))
        ]),
        _: 1
      }, 8, ["visible", "maximizable", "maximized", "onHide"]);
    };
  }
});
function _typeof$2(o) {
  "@babel/helpers - typeof";
  return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$2(o);
}
__name(_typeof$2, "_typeof$2");
function _defineProperty$2(e, r, t) {
  return (r = _toPropertyKey$2(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty$2, "_defineProperty$2");
function _toPropertyKey$2(t) {
  var i2 = _toPrimitive$2(t, "string");
  return "symbol" == _typeof$2(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$2, "_toPropertyKey$2");
function _toPrimitive$2(t, r) {
  if ("object" != _typeof$2(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$2(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive$2, "_toPrimitive$2");
var theme = /* @__PURE__ */ __name(function theme37(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-toast {\n    width: ".concat(dt3("toast.width"), ";\n    white-space: pre-line;\n    word-break: break-word;\n}\n\n.p-toast-message {\n    margin: 0 0 1rem 0;\n}\n\n.p-toast-message-icon {\n    flex-shrink: 0;\n    font-size: ").concat(dt3("toast.icon.size"), ";\n    width: ").concat(dt3("toast.icon.size"), ";\n    height: ").concat(dt3("toast.icon.size"), ";\n}\n\n.p-toast-message-content {\n    display: flex;\n    align-items: flex-start;\n    padding: ").concat(dt3("toast.content.padding"), ";\n    gap: ").concat(dt3("toast.content.gap"), ";\n}\n\n.p-toast-message-text {\n    flex: 1 1 auto;\n    display: flex;\n    flex-direction: column;\n    gap: ").concat(dt3("toast.text.gap"), ";\n}\n\n.p-toast-summary {\n    font-weight: ").concat(dt3("toast.summary.font.weight"), ";\n    font-size: ").concat(dt3("toast.summary.font.size"), ";\n}\n\n.p-toast-detail {\n    font-weight: ").concat(dt3("toast.detail.font.weight"), ";\n    font-size: ").concat(dt3("toast.detail.font.size"), ";\n}\n\n.p-toast-close-button {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    overflow: hidden;\n    position: relative;\n    cursor: pointer;\n    background: transparent;\n    transition: background ").concat(dt3("toast.transition.duration"), ", color ").concat(dt3("toast.transition.duration"), ", outline-color ").concat(dt3("toast.transition.duration"), ", box-shadow ").concat(dt3("toast.transition.duration"), ";\n    outline-color: transparent;\n    color: inherit;\n    width: ").concat(dt3("toast.close.button.width"), ";\n    height: ").concat(dt3("toast.close.button.height"), ";\n    border-radius: ").concat(dt3("toast.close.button.border.radius"), ";\n    margin: -25% 0 0 0;\n    right: -25%;\n    padding: 0;\n    border: none;\n    user-select: none;\n}\n\n.p-toast-message-info,\n.p-toast-message-success,\n.p-toast-message-warn,\n.p-toast-message-error,\n.p-toast-message-secondary,\n.p-toast-message-contrast {\n    border-width: ").concat(dt3("toast.border.width"), ";\n    border-style: solid;\n    backdrop-filter: blur(").concat(dt3("toast.blur"), ");\n    border-radius: ").concat(dt3("toast.border.radius"), ";\n}\n\n.p-toast-close-icon {\n    font-size: ").concat(dt3("toast.close.icon.size"), ";\n    width: ").concat(dt3("toast.close.icon.size"), ";\n    height: ").concat(dt3("toast.close.icon.size"), ";\n}\n\n.p-toast-close-button:focus-visible {\n    outline-width: ").concat(dt3("focus.ring.width"), ";\n    outline-style: ").concat(dt3("focus.ring.style"), ";\n    outline-offset: ").concat(dt3("focus.ring.offset"), ";\n}\n\n.p-toast-message-info {\n    background: ").concat(dt3("toast.info.background"), ";\n    border-color: ").concat(dt3("toast.info.border.color"), ";\n    color: ").concat(dt3("toast.info.color"), ";\n    box-shadow: ").concat(dt3("toast.info.shadow"), ";\n}\n\n.p-toast-message-info .p-toast-detail {\n    color: ").concat(dt3("toast.info.detail.color"), ";\n}\n\n.p-toast-message-info .p-toast-close-button:focus-visible {\n    outline-color: ").concat(dt3("toast.info.close.button.focus.ring.color"), ";\n    box-shadow: ").concat(dt3("toast.info.close.button.focus.ring.shadow"), ";\n}\n\n.p-toast-message-info .p-toast-close-button:hover {\n    background: ").concat(dt3("toast.info.close.button.hover.background"), ";\n}\n\n.p-toast-message-success {\n    background: ").concat(dt3("toast.success.background"), ";\n    border-color: ").concat(dt3("toast.success.border.color"), ";\n    color: ").concat(dt3("toast.success.color"), ";\n    box-shadow: ").concat(dt3("toast.success.shadow"), ";\n}\n\n.p-toast-message-success .p-toast-detail {\n    color: ").concat(dt3("toast.success.detail.color"), ";\n}\n\n.p-toast-message-success .p-toast-close-button:focus-visible {\n    outline-color: ").concat(dt3("toast.success.close.button.focus.ring.color"), ";\n    box-shadow: ").concat(dt3("toast.success.close.button.focus.ring.shadow"), ";\n}\n\n.p-toast-message-success .p-toast-close-button:hover {\n    background: ").concat(dt3("toast.success.close.button.hover.background"), ";\n}\n\n.p-toast-message-warn {\n    background: ").concat(dt3("toast.warn.background"), ";\n    border-color: ").concat(dt3("toast.warn.border.color"), ";\n    color: ").concat(dt3("toast.warn.color"), ";\n    box-shadow: ").concat(dt3("toast.warn.shadow"), ";\n}\n\n.p-toast-message-warn .p-toast-detail {\n    color: ").concat(dt3("toast.warn.detail.color"), ";\n}\n\n.p-toast-message-warn .p-toast-close-button:focus-visible {\n    outline-color: ").concat(dt3("toast.warn.close.button.focus.ring.color"), ";\n    box-shadow: ").concat(dt3("toast.warn.close.button.focus.ring.shadow"), ";\n}\n\n.p-toast-message-warn .p-toast-close-button:hover {\n    background: ").concat(dt3("toast.warn.close.button.hover.background"), ";\n}\n\n.p-toast-message-error {\n    background: ").concat(dt3("toast.error.background"), ";\n    border-color: ").concat(dt3("toast.error.border.color"), ";\n    color: ").concat(dt3("toast.error.color"), ";\n    box-shadow: ").concat(dt3("toast.error.shadow"), ";\n}\n\n.p-toast-message-error .p-toast-detail {\n    color: ").concat(dt3("toast.error.detail.color"), ";\n}\n\n.p-toast-message-error .p-toast-close-button:focus-visible {\n    outline-color: ").concat(dt3("toast.error.close.button.focus.ring.color"), ";\n    box-shadow: ").concat(dt3("toast.error.close.button.focus.ring.shadow"), ";\n}\n\n.p-toast-message-error .p-toast-close-button:hover {\n    background: ").concat(dt3("toast.error.close.button.hover.background"), ";\n}\n\n.p-toast-message-secondary {\n    background: ").concat(dt3("toast.secondary.background"), ";\n    border-color: ").concat(dt3("toast.secondary.border.color"), ";\n    color: ").concat(dt3("toast.secondary.color"), ";\n    box-shadow: ").concat(dt3("toast.secondary.shadow"), ";\n}\n\n.p-toast-message-secondary .p-toast-detail {\n    color: ").concat(dt3("toast.secondary.detail.color"), ";\n}\n\n.p-toast-message-secondary .p-toast-close-button:focus-visible {\n    outline-color: ").concat(dt3("toast.secondary.close.button.focus.ring.color"), ";\n    box-shadow: ").concat(dt3("toast.secondary.close.button.focus.ring.shadow"), ";\n}\n\n.p-toast-message-secondary .p-toast-close-button:hover {\n    background: ").concat(dt3("toast.secondary.close.button.hover.background"), ";\n}\n\n.p-toast-message-contrast {\n    background: ").concat(dt3("toast.contrast.background"), ";\n    border-color: ").concat(dt3("toast.contrast.border.color"), ";\n    color: ").concat(dt3("toast.contrast.color"), ";\n    box-shadow: ").concat(dt3("toast.contrast.shadow"), ";\n}\n\n.p-toast-message-contrast .p-toast-detail {\n    color: ").concat(dt3("toast.contrast.detail.color"), ";\n}\n\n.p-toast-message-contrast .p-toast-close-button:focus-visible {\n    outline-color: ").concat(dt3("toast.contrast.close.button.focus.ring.color"), ";\n    box-shadow: ").concat(dt3("toast.contrast.close.button.focus.ring.shadow"), ";\n}\n\n.p-toast-message-contrast .p-toast-close-button:hover {\n    background: ").concat(dt3("toast.contrast.close.button.hover.background"), ";\n}\n\n.p-toast-top-center {\n    transform: translateX(-50%);\n}\n\n.p-toast-bottom-center {\n    transform: translateX(-50%);\n}\n\n.p-toast-center {\n    min-width: 20vw;\n    transform: translate(-50%, -50%);\n}\n\n.p-toast-message-enter-from {\n    opacity: 0;\n    transform: translateY(50%);\n}\n\n.p-toast-message-leave-from {\n    max-height: 1000px;\n}\n\n.p-toast .p-toast-message.p-toast-message-leave-to {\n    max-height: 0;\n    opacity: 0;\n    margin-bottom: 0;\n    overflow: hidden;\n}\n\n.p-toast-message-enter-active {\n    transition: transform 0.3s, opacity 0.3s;\n}\n\n.p-toast-message-leave-active {\n    transition: max-height 0.45s cubic-bezier(0, 1, 0, 1), opacity 0.3s, margin-bottom 0.3s;\n}\n");
}, "theme");
var inlineStyles = {
  root: /* @__PURE__ */ __name(function root24(_ref2) {
    var position2 = _ref2.position;
    return {
      position: "fixed",
      top: position2 === "top-right" || position2 === "top-left" || position2 === "top-center" ? "20px" : position2 === "center" ? "50%" : null,
      right: (position2 === "top-right" || position2 === "bottom-right") && "20px",
      bottom: (position2 === "bottom-left" || position2 === "bottom-right" || position2 === "bottom-center") && "20px",
      left: position2 === "top-left" || position2 === "bottom-left" ? "20px" : position2 === "center" || position2 === "top-center" || position2 === "bottom-center" ? "50%" : null
    };
  }, "root")
};
var classes = {
  root: /* @__PURE__ */ __name(function root25(_ref3) {
    var props = _ref3.props;
    return ["p-toast p-component p-toast-" + props.position];
  }, "root"),
  message: /* @__PURE__ */ __name(function message2(_ref4) {
    var props = _ref4.props;
    return ["p-toast-message", {
      "p-toast-message-info": props.message.severity === "info" || props.message.severity === void 0,
      "p-toast-message-warn": props.message.severity === "warn",
      "p-toast-message-error": props.message.severity === "error",
      "p-toast-message-success": props.message.severity === "success",
      "p-toast-message-secondary": props.message.severity === "secondary",
      "p-toast-message-contrast": props.message.severity === "contrast"
    }];
  }, "message"),
  messageContent: "p-toast-message-content",
  messageIcon: /* @__PURE__ */ __name(function messageIcon(_ref5) {
    var props = _ref5.props;
    return ["p-toast-message-icon", _defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2({}, props.infoIcon, props.message.severity === "info"), props.warnIcon, props.message.severity === "warn"), props.errorIcon, props.message.severity === "error"), props.successIcon, props.message.severity === "success")];
  }, "messageIcon"),
  messageText: "p-toast-message-text",
  summary: "p-toast-summary",
  detail: "p-toast-detail",
  closeButton: "p-toast-close-button",
  closeIcon: "p-toast-close-icon"
};
var ToastStyle = BaseStyle.extend({
  name: "toast",
  theme,
  classes,
  inlineStyles
});
var script$4 = {
  name: "ExclamationTriangleIcon",
  "extends": script$U
};
var _hoisted_1$2 = /* @__PURE__ */ createBaseVNode("path", {
  d: "M13.4018 13.1893H0.598161C0.49329 13.189 0.390283 13.1615 0.299143 13.1097C0.208003 13.0578 0.131826 12.9832 0.0780112 12.8932C0.0268539 12.8015 0 12.6982 0 12.5931C0 12.4881 0.0268539 12.3848 0.0780112 12.293L6.47985 1.08982C6.53679 1.00399 6.61408 0.933574 6.70484 0.884867C6.7956 0.836159 6.897 0.810669 7 0.810669C7.103 0.810669 7.2044 0.836159 7.29516 0.884867C7.38592 0.933574 7.46321 1.00399 7.52015 1.08982L13.922 12.293C13.9731 12.3848 14 12.4881 14 12.5931C14 12.6982 13.9731 12.8015 13.922 12.8932C13.8682 12.9832 13.792 13.0578 13.7009 13.1097C13.6097 13.1615 13.5067 13.189 13.4018 13.1893ZM1.63046 11.989H12.3695L7 2.59425L1.63046 11.989Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$1 = /* @__PURE__ */ createBaseVNode("path", {
  d: "M6.99996 8.78801C6.84143 8.78594 6.68997 8.72204 6.57787 8.60993C6.46576 8.49782 6.40186 8.34637 6.39979 8.18784V5.38703C6.39979 5.22786 6.46302 5.0752 6.57557 4.96265C6.68813 4.85009 6.84078 4.78686 6.99996 4.78686C7.15914 4.78686 7.31179 4.85009 7.42435 4.96265C7.5369 5.0752 7.60013 5.22786 7.60013 5.38703V8.18784C7.59806 8.34637 7.53416 8.49782 7.42205 8.60993C7.30995 8.72204 7.15849 8.78594 6.99996 8.78801Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_3 = /* @__PURE__ */ createBaseVNode("path", {
  d: "M6.99996 11.1887C6.84143 11.1866 6.68997 11.1227 6.57787 11.0106C6.46576 10.8985 6.40186 10.7471 6.39979 10.5885V10.1884C6.39979 10.0292 6.46302 9.87658 6.57557 9.76403C6.68813 9.65147 6.84078 9.58824 6.99996 9.58824C7.15914 9.58824 7.31179 9.65147 7.42435 9.76403C7.5369 9.87658 7.60013 10.0292 7.60013 10.1884V10.5885C7.59806 10.7471 7.53416 10.8985 7.42205 11.0106C7.30995 11.1227 7.15849 11.1866 6.99996 11.1887Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_4 = [_hoisted_1$2, _hoisted_2$1, _hoisted_3];
function render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_4, 16);
}
__name(render$3, "render$3");
script$4.render = render$3;
var script$3 = {
  name: "InfoCircleIcon",
  "extends": script$U
};
var _hoisted_1$1 = /* @__PURE__ */ createBaseVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M3.11101 12.8203C4.26215 13.5895 5.61553 14 7 14C8.85652 14 10.637 13.2625 11.9497 11.9497C13.2625 10.637 14 8.85652 14 7C14 5.61553 13.5895 4.26215 12.8203 3.11101C12.0511 1.95987 10.9579 1.06266 9.67879 0.532846C8.3997 0.00303296 6.99224 -0.13559 5.63437 0.134506C4.2765 0.404603 3.02922 1.07129 2.05026 2.05026C1.07129 3.02922 0.404603 4.2765 0.134506 5.63437C-0.13559 6.99224 0.00303296 8.3997 0.532846 9.67879C1.06266 10.9579 1.95987 12.0511 3.11101 12.8203ZM3.75918 2.14976C4.71846 1.50879 5.84628 1.16667 7 1.16667C8.5471 1.16667 10.0308 1.78125 11.1248 2.87521C12.2188 3.96918 12.8333 5.45291 12.8333 7C12.8333 8.15373 12.4912 9.28154 11.8502 10.2408C11.2093 11.2001 10.2982 11.9478 9.23232 12.3893C8.16642 12.8308 6.99353 12.9463 5.86198 12.7212C4.73042 12.4962 3.69102 11.9406 2.87521 11.1248C2.05941 10.309 1.50384 9.26958 1.27876 8.13803C1.05367 7.00647 1.16919 5.83358 1.61071 4.76768C2.05222 3.70178 2.79989 2.79074 3.75918 2.14976ZM7.00002 4.8611C6.84594 4.85908 6.69873 4.79698 6.58977 4.68801C6.48081 4.57905 6.4187 4.43185 6.41669 4.27776V3.88888C6.41669 3.73417 6.47815 3.58579 6.58754 3.4764C6.69694 3.367 6.84531 3.30554 7.00002 3.30554C7.15473 3.30554 7.3031 3.367 7.4125 3.4764C7.52189 3.58579 7.58335 3.73417 7.58335 3.88888V4.27776C7.58134 4.43185 7.51923 4.57905 7.41027 4.68801C7.30131 4.79698 7.1541 4.85908 7.00002 4.8611ZM7.00002 10.6945C6.84594 10.6925 6.69873 10.6304 6.58977 10.5214C6.48081 10.4124 6.4187 10.2652 6.41669 10.1111V6.22225C6.41669 6.06754 6.47815 5.91917 6.58754 5.80977C6.69694 5.70037 6.84531 5.63892 7.00002 5.63892C7.15473 5.63892 7.3031 5.70037 7.4125 5.80977C7.52189 5.91917 7.58335 6.06754 7.58335 6.22225V10.1111C7.58134 10.2652 7.51923 10.4124 7.41027 10.5214C7.30131 10.6304 7.1541 10.6925 7.00002 10.6945Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2 = [_hoisted_1$1];
function render$2(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2, 16);
}
__name(render$2, "render$2");
script$3.render = render$2;
var script$2 = {
  name: "BaseToast",
  "extends": script$X,
  props: {
    group: {
      type: String,
      "default": null
    },
    position: {
      type: String,
      "default": "top-right"
    },
    autoZIndex: {
      type: Boolean,
      "default": true
    },
    baseZIndex: {
      type: Number,
      "default": 0
    },
    breakpoints: {
      type: Object,
      "default": null
    },
    closeIcon: {
      type: String,
      "default": void 0
    },
    infoIcon: {
      type: String,
      "default": void 0
    },
    warnIcon: {
      type: String,
      "default": void 0
    },
    errorIcon: {
      type: String,
      "default": void 0
    },
    successIcon: {
      type: String,
      "default": void 0
    },
    closeButtonProps: {
      type: null,
      "default": null
    }
  },
  style: ToastStyle,
  provide: /* @__PURE__ */ __name(function provide40() {
    return {
      $pcToast: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$1 = {
  name: "ToastMessage",
  hostName: "Toast",
  "extends": script$X,
  emits: ["close"],
  closeTimeout: null,
  props: {
    message: {
      type: null,
      "default": null
    },
    templates: {
      type: Object,
      "default": null
    },
    closeIcon: {
      type: String,
      "default": null
    },
    infoIcon: {
      type: String,
      "default": null
    },
    warnIcon: {
      type: String,
      "default": null
    },
    errorIcon: {
      type: String,
      "default": null
    },
    successIcon: {
      type: String,
      "default": null
    },
    closeButtonProps: {
      type: null,
      "default": null
    }
  },
  mounted: /* @__PURE__ */ __name(function mounted21() {
    var _this = this;
    if (this.message.life) {
      this.closeTimeout = setTimeout(function() {
        _this.close({
          message: _this.message,
          type: "life-end"
        });
      }, this.message.life);
    }
  }, "mounted"),
  beforeUnmount: /* @__PURE__ */ __name(function beforeUnmount15() {
    this.clearCloseTimeout();
  }, "beforeUnmount"),
  methods: {
    close: /* @__PURE__ */ __name(function close3(params) {
      this.$emit("close", params);
    }, "close"),
    onCloseClick: /* @__PURE__ */ __name(function onCloseClick() {
      this.clearCloseTimeout();
      this.close({
        message: this.message,
        type: "close"
      });
    }, "onCloseClick"),
    clearCloseTimeout: /* @__PURE__ */ __name(function clearCloseTimeout() {
      if (this.closeTimeout) {
        clearTimeout(this.closeTimeout);
        this.closeTimeout = null;
      }
    }, "clearCloseTimeout")
  },
  computed: {
    iconComponent: /* @__PURE__ */ __name(function iconComponent() {
      return {
        info: !this.infoIcon && script$3,
        success: !this.successIcon && script$S,
        warn: !this.warnIcon && script$4,
        error: !this.errorIcon && script$u
      }[this.message.severity];
    }, "iconComponent"),
    closeAriaLabel: /* @__PURE__ */ __name(function closeAriaLabel3() {
      return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.close : void 0;
    }, "closeAriaLabel")
  },
  components: {
    TimesIcon: script$A,
    InfoCircleIcon: script$3,
    CheckIcon: script$S,
    ExclamationTriangleIcon: script$4,
    TimesCircleIcon: script$u
  },
  directives: {
    ripple: Ripple
  }
};
function _typeof$1(o) {
  "@babel/helpers - typeof";
  return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$1(o);
}
__name(_typeof$1, "_typeof$1");
function ownKeys$1(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
__name(ownKeys$1, "ownKeys$1");
function _objectSpread$1(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$1(Object(t), true).forEach(function(r2) {
      _defineProperty$1(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
__name(_objectSpread$1, "_objectSpread$1");
function _defineProperty$1(e, r, t) {
  return (r = _toPropertyKey$1(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty$1, "_defineProperty$1");
function _toPropertyKey$1(t) {
  var i2 = _toPrimitive$1(t, "string");
  return "symbol" == _typeof$1(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$1, "_toPropertyKey$1");
function _toPrimitive$1(t, r) {
  if ("object" != _typeof$1(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$1(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive$1, "_toPrimitive$1");
var _hoisted_1 = ["aria-label"];
function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  var _directive_ripple = resolveDirective("ripple");
  return openBlock(), createElementBlock("div", mergeProps({
    "class": [_ctx.cx("message"), $props.message.styleClass],
    role: "alert",
    "aria-live": "assertive",
    "aria-atomic": "true"
  }, _ctx.ptm("message")), [$props.templates.container ? (openBlock(), createBlock(resolveDynamicComponent($props.templates.container), {
    key: 0,
    message: $props.message,
    closeCallback: $options.onCloseClick
  }, null, 8, ["message", "closeCallback"])) : (openBlock(), createElementBlock("div", mergeProps({
    key: 1,
    "class": [_ctx.cx("messageContent"), $props.message.contentStyleClass]
  }, _ctx.ptm("messageContent")), [!$props.templates.message ? (openBlock(), createElementBlock(Fragment, {
    key: 0
  }, [(openBlock(), createBlock(resolveDynamicComponent($props.templates.messageicon ? $props.templates.messageicon : $props.templates.icon ? $props.templates.icon : $options.iconComponent && $options.iconComponent.name ? $options.iconComponent : "span"), mergeProps({
    "class": _ctx.cx("messageIcon")
  }, _ctx.ptm("messageIcon")), null, 16, ["class"])), createBaseVNode("div", mergeProps({
    "class": _ctx.cx("messageText")
  }, _ctx.ptm("messageText")), [createBaseVNode("span", mergeProps({
    "class": _ctx.cx("summary")
  }, _ctx.ptm("summary")), toDisplayString$1($props.message.summary), 17), createBaseVNode("div", mergeProps({
    "class": _ctx.cx("detail")
  }, _ctx.ptm("detail")), toDisplayString$1($props.message.detail), 17)], 16)], 64)) : (openBlock(), createBlock(resolveDynamicComponent($props.templates.message), {
    key: 1,
    message: $props.message
  }, null, 8, ["message"])), $props.message.closable !== false ? (openBlock(), createElementBlock("div", normalizeProps(mergeProps({
    key: 2
  }, _ctx.ptm("buttonContainer"))), [withDirectives((openBlock(), createElementBlock("button", mergeProps({
    "class": _ctx.cx("closeButton"),
    type: "button",
    "aria-label": $options.closeAriaLabel,
    onClick: _cache[0] || (_cache[0] = function() {
      return $options.onCloseClick && $options.onCloseClick.apply($options, arguments);
    }),
    autofocus: ""
  }, _objectSpread$1(_objectSpread$1({}, $props.closeButtonProps), _ctx.ptm("closeButton"))), [(openBlock(), createBlock(resolveDynamicComponent($props.templates.closeicon || "TimesIcon"), mergeProps({
    "class": [_ctx.cx("closeIcon"), $props.closeIcon]
  }, _ctx.ptm("closeIcon")), null, 16, ["class"]))], 16, _hoisted_1)), [[_directive_ripple]])], 16)) : createCommentVNode("", true)], 16))], 16);
}
__name(render$1, "render$1");
script$1.render = render$1;
function _toConsumableArray(r) {
  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
}
__name(_toConsumableArray, "_toConsumableArray");
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableSpread, "_nonIterableSpread");
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}
__name(_unsupportedIterableToArray, "_unsupportedIterableToArray");
function _iterableToArray(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
__name(_iterableToArray, "_iterableToArray");
function _arrayWithoutHoles(r) {
  if (Array.isArray(r)) return _arrayLikeToArray(r);
}
__name(_arrayWithoutHoles, "_arrayWithoutHoles");
function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
__name(_arrayLikeToArray, "_arrayLikeToArray");
var messageIdx = 0;
var script = {
  name: "Toast",
  "extends": script$2,
  inheritAttrs: false,
  emits: ["close", "life-end"],
  data: /* @__PURE__ */ __name(function data23() {
    return {
      messages: []
    };
  }, "data"),
  styleElement: null,
  mounted: /* @__PURE__ */ __name(function mounted22() {
    ToastEventBus.on("add", this.onAdd);
    ToastEventBus.on("remove", this.onRemove);
    ToastEventBus.on("remove-group", this.onRemoveGroup);
    ToastEventBus.on("remove-all-groups", this.onRemoveAllGroups);
    if (this.breakpoints) {
      this.createStyle();
    }
  }, "mounted"),
  beforeUnmount: /* @__PURE__ */ __name(function beforeUnmount16() {
    this.destroyStyle();
    if (this.$refs.container && this.autoZIndex) {
      ZIndex.clear(this.$refs.container);
    }
    ToastEventBus.off("add", this.onAdd);
    ToastEventBus.off("remove", this.onRemove);
    ToastEventBus.off("remove-group", this.onRemoveGroup);
    ToastEventBus.off("remove-all-groups", this.onRemoveAllGroups);
  }, "beforeUnmount"),
  methods: {
    add: /* @__PURE__ */ __name(function add2(message3) {
      if (message3.id == null) {
        message3.id = messageIdx++;
      }
      this.messages = [].concat(_toConsumableArray(this.messages), [message3]);
    }, "add"),
    remove: /* @__PURE__ */ __name(function remove4(params) {
      var index2 = this.messages.findIndex(function(m) {
        return m.id === params.message.id;
      });
      if (index2 !== -1) {
        this.messages.splice(index2, 1);
        this.$emit(params.type, {
          message: params.message
        });
      }
    }, "remove"),
    onAdd: /* @__PURE__ */ __name(function onAdd(message3) {
      if (this.group == message3.group) {
        this.add(message3);
      }
    }, "onAdd"),
    onRemove: /* @__PURE__ */ __name(function onRemove(message3) {
      this.remove({
        message: message3,
        type: "close"
      });
    }, "onRemove"),
    onRemoveGroup: /* @__PURE__ */ __name(function onRemoveGroup(group) {
      if (this.group === group) {
        this.messages = [];
      }
    }, "onRemoveGroup"),
    onRemoveAllGroups: /* @__PURE__ */ __name(function onRemoveAllGroups() {
      this.messages = [];
    }, "onRemoveAllGroups"),
    onEnter: /* @__PURE__ */ __name(function onEnter7() {
      this.$refs.container.setAttribute(this.attributeSelector, "");
      if (this.autoZIndex) {
        ZIndex.set("modal", this.$refs.container, this.baseZIndex || this.$primevue.config.zIndex.modal);
      }
    }, "onEnter"),
    onLeave: /* @__PURE__ */ __name(function onLeave5() {
      var _this = this;
      if (this.$refs.container && this.autoZIndex && isEmpty(this.messages)) {
        setTimeout(function() {
          ZIndex.clear(_this.$refs.container);
        }, 200);
      }
    }, "onLeave"),
    createStyle: /* @__PURE__ */ __name(function createStyle4() {
      if (!this.styleElement && !this.isUnstyled) {
        var _this$$primevue;
        this.styleElement = document.createElement("style");
        this.styleElement.type = "text/css";
        setAttribute(this.styleElement, "nonce", (_this$$primevue = this.$primevue) === null || _this$$primevue === void 0 || (_this$$primevue = _this$$primevue.config) === null || _this$$primevue === void 0 || (_this$$primevue = _this$$primevue.csp) === null || _this$$primevue === void 0 ? void 0 : _this$$primevue.nonce);
        document.head.appendChild(this.styleElement);
        var innerHTML = "";
        for (var breakpoint in this.breakpoints) {
          var breakpointStyle = "";
          for (var styleProp in this.breakpoints[breakpoint]) {
            breakpointStyle += styleProp + ":" + this.breakpoints[breakpoint][styleProp] + "!important;";
          }
          innerHTML += "\n                        @media screen and (max-width: ".concat(breakpoint, ") {\n                            .p-toast[").concat(this.attributeSelector, "] {\n                                ").concat(breakpointStyle, "\n                            }\n                        }\n                    ");
        }
        this.styleElement.innerHTML = innerHTML;
      }
    }, "createStyle"),
    destroyStyle: /* @__PURE__ */ __name(function destroyStyle3() {
      if (this.styleElement) {
        document.head.removeChild(this.styleElement);
        this.styleElement = null;
      }
    }, "destroyStyle")
  },
  computed: {
    attributeSelector: /* @__PURE__ */ __name(function attributeSelector3() {
      return UniqueComponentId();
    }, "attributeSelector")
  },
  components: {
    ToastMessage: script$1,
    Portal: script$z
  }
};
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}
__name(_typeof, "_typeof");
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
__name(ownKeys, "ownKeys");
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
__name(_objectSpread, "_objectSpread");
function _defineProperty(e, r, t) {
  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty, "_defineProperty");
function _toPropertyKey(t) {
  var i2 = _toPrimitive(t, "string");
  return "symbol" == _typeof(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey, "_toPropertyKey");
function _toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive, "_toPrimitive");
function render(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_ToastMessage = resolveComponent("ToastMessage");
  var _component_Portal = resolveComponent("Portal");
  return openBlock(), createBlock(_component_Portal, null, {
    "default": withCtx(function() {
      return [createBaseVNode("div", mergeProps({
        ref: "container",
        "class": _ctx.cx("root"),
        style: _ctx.sx("root", true, {
          position: _ctx.position
        })
      }, _ctx.ptmi("root")), [createVNode(TransitionGroup, mergeProps({
        name: "p-toast-message",
        tag: "div",
        onEnter: $options.onEnter,
        onLeave: $options.onLeave
      }, _objectSpread({}, _ctx.ptm("transition"))), {
        "default": withCtx(function() {
          return [(openBlock(true), createElementBlock(Fragment, null, renderList($data.messages, function(msg) {
            return openBlock(), createBlock(_component_ToastMessage, {
              key: msg.id,
              message: msg,
              templates: _ctx.$slots,
              closeIcon: _ctx.closeIcon,
              infoIcon: _ctx.infoIcon,
              warnIcon: _ctx.warnIcon,
              errorIcon: _ctx.errorIcon,
              successIcon: _ctx.successIcon,
              closeButtonProps: _ctx.closeButtonProps,
              onClose: _cache[0] || (_cache[0] = function($event) {
                return $options.remove($event);
              }),
              pt: _ctx.pt
            }, null, 8, ["message", "templates", "closeIcon", "infoIcon", "warnIcon", "errorIcon", "successIcon", "closeButtonProps", "pt"]);
          }), 128))];
        }),
        _: 1
      }, 16, ["onEnter", "onLeave"])], 16)];
    }),
    _: 1
  });
}
__name(render, "render");
script.render = render;
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  __name: "GlobalToast",
  setup(__props) {
    const toast = useToast();
    const toastStore = useToastStore();
    const settingStore = useSettingStore();
    watch(
      () => toastStore.messagesToAdd,
      (newMessages) => {
        if (newMessages.length === 0) {
          return;
        }
        newMessages.forEach((message3) => {
          toast.add(message3);
        });
        toastStore.messagesToAdd = [];
      },
      { deep: true }
    );
    watch(
      () => toastStore.messagesToRemove,
      (messagesToRemove) => {
        if (messagesToRemove.length === 0) {
          return;
        }
        messagesToRemove.forEach((message3) => {
          toast.remove(message3);
        });
        toastStore.messagesToRemove = [];
      },
      { deep: true }
    );
    watch(
      () => toastStore.removeAllRequested,
      (requested) => {
        if (requested) {
          toast.removeAllGroups();
          toastStore.removeAllRequested = false;
        }
      }
    );
    function updateToastPosition() {
      const styleElement = document.getElementById("dynamic-toast-style") || createStyleElement();
      const rect = document.querySelector(".graph-canvas-container").getBoundingClientRect();
      styleElement.textContent = `
    .p-toast.p-component.p-toast-top-right {
      top: ${rect.top + 20}px !important;
      right: ${window.innerWidth - (rect.left + rect.width) + 20}px !important;
    }
  `;
    }
    __name(updateToastPosition, "updateToastPosition");
    function createStyleElement() {
      const style = document.createElement("style");
      style.id = "dynamic-toast-style";
      document.head.appendChild(style);
      return style;
    }
    __name(createStyleElement, "createStyleElement");
    watch(
      () => settingStore.get("Comfy.UseNewMenu"),
      () => nextTick(updateToastPosition),
      { immediate: true }
    );
    watch(
      () => settingStore.get("Comfy.Sidebar.Location"),
      () => nextTick(updateToastPosition),
      { immediate: true }
    );
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(script));
    };
  }
});
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  __name: "UnloadWindowConfirmDialog",
  setup(__props) {
    const settingStore = useSettingStore();
    const handleBeforeUnload = /* @__PURE__ */ __name((event2) => {
      if (settingStore.get("Comfy.Window.UnloadConfirmation")) {
        event2.preventDefault();
        return true;
      }
      return void 0;
    }, "handleBeforeUnload");
    onMounted(() => {
      window.addEventListener("beforeunload", handleBeforeUnload);
    });
    onUnmounted(() => {
      window.removeEventListener("beforeunload", handleBeforeUnload);
    });
    return () => {
    };
  }
});
const messages = {
  en: {
    add: "Add",
    confirm: "Confirm",
    reset: "Reset",
    customizeFolder: "Customize Folder",
    icon: "Icon",
    color: "Color",
    bookmark: "Bookmark",
    folder: "Folder",
    star: "Star",
    heart: "Heart",
    file: "File",
    inbox: "Inbox",
    box: "Box",
    briefcase: "Briefcase",
    error: "Error",
    findIssues: "Find Issues",
    copyToClipboard: "Copy to Clipboard",
    openNewIssue: "Open New Issue",
    showReport: "Show Report",
    imageFailedToLoad: "Image failed to load",
    reconnecting: "Reconnecting",
    reconnected: "Reconnected",
    delete: "Delete",
    rename: "Rename",
    customize: "Customize",
    experimental: "BETA",
    deprecated: "DEPR",
    loadWorkflow: "Load Workflow",
    goToNode: "Go to Node",
    settings: "Settings",
    searchSettings: "Search Settings",
    searchNodes: "Search Nodes",
    noResultsFound: "No Results Found",
    searchFailedMessage: "We couldn't find any settings matching your search. Try adjusting your search terms.",
    noTasksFound: "No Tasks Found",
    noTasksFoundMessage: "There are no tasks in the queue.",
    newFolder: "New Folder",
    sideToolbar: {
      themeToggle: "Toggle Theme",
      queue: "Queue",
      nodeLibrary: "Node Library",
      nodeLibraryTab: {
        sortOrder: "Sort Order"
      },
      queueTab: {
        showFlatList: "Show Flat List",
        backToAllTasks: "Back to All Tasks",
        containImagePreview: "Fill Image Preview",
        coverImagePreview: "Fit Image Preview"
      }
    }
  },
  zh: {
    customizeFolder: "",
    icon: "",
    color: "",
    bookmark: "",
    folder: "",
    star: "",
    heart: "",
    file: "",
    inbox: "",
    box: "",
    briefcase: "",
    error: "",
    showReport: "",
    imageFailedToLoad: "",
    reconnecting: "",
    reconnected: "",
    delete: "",
    rename: "",
    customize: "",
    loadWorkflow: "",
    settings: "",
    searchSettings: "",
    searchNodes: "",
    noResultsFound: "",
    noTasksFound: "",
    noTasksFoundMessage: "",
    searchFailedMessage: "",
    newFolder: "",
    sideToolbar: {
      themeToggle: "",
      queue: "",
      nodeLibrary: "",
      nodeLibraryTab: {
        sortOrder: ""
      },
      queueTab: {
        showFlatList: "",
        backToAllTasks: ""
      }
    }
  }
  // TODO: Add more languages
};
const i18n = createI18n({
  // Must set `false`, as Vue I18n Legacy API is for Vue 2
  legacy: false,
  locale: navigator.language.split("-")[0] || "en",
  fallbackLocale: "en",
  messages
});
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "App",
  setup(__props) {
    const isLoading = computed(() => useWorkspaceStore().spinner);
    const theme38 = computed(
      () => useSettingStore().get("Comfy.ColorPalette")
    );
    watch(
      theme38,
      (newTheme) => {
        const DARK_THEME_CLASS = "dark-theme";
        const isDarkTheme = newTheme !== "light";
        if (isDarkTheme) {
          document.body.classList.add(DARK_THEME_CLASS);
        } else {
          document.body.classList.remove(DARK_THEME_CLASS);
        }
      },
      { immediate: true }
    );
    watchEffect(() => {
      const fontSize = useSettingStore().get("Comfy.TextareaWidget.FontSize");
      document.documentElement.style.setProperty(
        "--comfy-textarea-font-size",
        `${fontSize}px`
      );
    });
    watchEffect(() => {
      const padding = useSettingStore().get("Comfy.TreeExplorer.ItemPadding");
      document.documentElement.style.setProperty(
        "--comfy-tree-explorer-item-padding",
        `${padding}px`
      );
    });
    watchEffect(() => {
      const locale2 = useSettingStore().get("Comfy.Locale");
      if (locale2) {
        i18n.global.locale.value = locale2;
      }
    });
    const { t } = useI18n();
    const init2 = /* @__PURE__ */ __name(() => {
      useSettingStore().addSettings(app$1.ui.settings);
      app$1.extensionManager = useWorkspaceStore();
      app$1.extensionManager.registerSidebarTab({
        id: "queue",
        icon: "pi pi-history",
        iconBadge: /* @__PURE__ */ __name(() => {
          const value3 = useQueuePendingTaskCountStore().count.toString();
          return value3 === "0" ? null : value3;
        }, "iconBadge"),
        title: t("sideToolbar.queue"),
        tooltip: t("sideToolbar.queue"),
        component: markRaw(QueueSidebarTab),
        type: "vue"
      });
      app$1.extensionManager.registerSidebarTab({
        id: "node-library",
        icon: "pi pi-book",
        title: t("sideToolbar.nodeLibrary"),
        tooltip: t("sideToolbar.nodeLibrary"),
        component: markRaw(NodeLibrarySidebarTab),
        type: "vue"
      });
    }, "init");
    const queuePendingTaskCountStore = useQueuePendingTaskCountStore();
    const onStatus = /* @__PURE__ */ __name((e) => queuePendingTaskCountStore.update(e), "onStatus");
    const toast = useToast();
    const reconnectingMessage = {
      severity: "error",
      summary: t("reconnecting")
    };
    const onReconnecting = /* @__PURE__ */ __name(() => {
      toast.remove(reconnectingMessage);
      toast.add(reconnectingMessage);
    }, "onReconnecting");
    const onReconnected = /* @__PURE__ */ __name(() => {
      toast.remove(reconnectingMessage);
      toast.add({
        severity: "success",
        summary: t("reconnected"),
        life: 2e3
      });
    }, "onReconnected");
    onMounted(() => {
      api.addEventListener("status", onStatus);
      api.addEventListener("reconnecting", onReconnecting);
      api.addEventListener("reconnected", onReconnected);
      try {
        init2();
      } catch (e) {
        console.error("Failed to init Vue app", e);
      }
    });
    onUnmounted(() => {
      api.removeEventListener("status", onStatus);
      api.removeEventListener("reconnecting", onReconnecting);
      api.removeEventListener("reconnected", onReconnected);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        isLoading.value ? (openBlock(), createBlock(unref(script$V), {
          key: 0,
          class: "spinner"
        })) : createCommentVNode("", true),
        createVNode(unref(script$W), {
          "full-screen": "",
          blocked: isLoading.value
        }, null, 8, ["blocked"]),
        createVNode(_sfc_main$3),
        createVNode(_sfc_main$2),
        createVNode(_sfc_main$1),
        createVNode(_sfc_main$h)
      ], 64);
    };
  }
});
const App = /* @__PURE__ */ _export_sfc(_sfc_main, [["__scopeId", "data-v-75e4840f"]]);
const ComfyUIPreset = definePreset(index$1, {
  semantic: {
    primary: index$1["primitive"].blue
  }
});
const app = createApp(App);
const pinia = createPinia();
app.directive("tooltip", Tooltip);
app.use(PrimeVue, {
  theme: {
    preset: ComfyUIPreset,
    options: {
      prefix: "p",
      cssLayer: false,
      // This is a workaround for the issue with the dark mode selector
      // https://github.com/primefaces/primevue/issues/5515
      darkModeSelector: ".dark-theme, :root:has(.dark-theme)"
    }
  }
}).use(ConfirmationService).use(ToastService).use(pinia).use(i18n).mount("#vue-app");
export {
  $el as $,
  ComfyDialog as C,
  DraggableList as D,
  LGraphCanvas as L,
  ComfyApp as a,
  app$1 as b,
  LiteGraph as c,
  LGraphNode as d,
  applyTextReplacements as e,
  ComfyWidgets as f,
  addValueControlWidgets as g,
  api as h,
  LGraphGroup as i,
  createSpinner as j,
  useToastStore as u
};
//# sourceMappingURL=index-Dfv2aLsq.js.map
